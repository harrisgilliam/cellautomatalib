#include <CAM/CAM.h>
#include <CAM/CAM_err.h>
#include <CAM/CAM_mem.h>
#include <CAM/CAM_pipecomm.h>
#include <CAM/CAM_TclTk.h>
#include "cam_tcltk.h"

/*
 * Information used for argv parsing.
 */

static Tk_ConfigSpec configSpecs[] = {
  {TK_CONFIG_ACTIVE_CURSOR, "-cursor", "cursor", "Cursor",
     "top_left_arrow", Tk_Offset(XCam, cur), TK_CONFIG_NULL_OK},
  {TK_CONFIG_PIXELS, "-height", "height", "Height",
     "512", Tk_Offset(XCam, height), 0},
  {TK_CONFIG_PIXELS, "-width", "width", "Width",
     "512", Tk_Offset(XCam, width), 0},
  {TK_CONFIG_END, (char *) NULL, (char *) NULL, (char *) NULL,
     (char *) NULL, 0, 0}
};

static unsigned char *NullCmmd(char *appdata, unsigned char *o,
			       unsigned char *b)
{
  XCAM xc = (XCAM) appdata;
  T_ENTER("NullCmmd");

  T_LEAVE;
  SETRETV(xc, 0, 0);
  PIPERET(xc);
}


static Cmdt ctbl[] = {
  { "quit", FreeAndExit },
  { "shmi", SetupSHMI },
  { "shmc", SetupSHMC },
  { "keri", SetupKERI },
  { "kerc", SetupKERC },
  { "glbx", SetGLBX },
  { "glby", SetGLBY },
  { "aply", XCAMApply },
  { "free", XCAMFree },
  { "null", NullCmmd },
  { "", NULL }
};

static int refresh = FALSE;


int XCAM_fatal[2] = {-1, -1};
int XCAM_infd = -1, XCAM_outfd = -1;
int XCAM_camfd = -1;

/* 
 * Implements a XCAM widget.  Used to display images generated by CAM8.
 * Has commands for dumping the contents to a file in xwd format.
 *
 * Copyright Harris L. Gilliam, Information Mechanics, MIT LCS 1994
 * 
 * This software may be copied and distributed freely for non-commercial use
 * providing it is distributed in its entirety, including this copyright
 * notice and all documentation.  Any improvements upon this code are welcome
 * and should be emailed to myself (gilliam@im.lcs.mit.edu) or Norman Margolus
 * (nhm@im.lcs.mit.edu).
 */

/***************************************************************************/
/*			  Utility Procedures                               */
/***************************************************************************/

static void pipedeath(sig, func)
     int sig;
     void (*func)();
{
  CAM_Msg(CAMerr, "tkXCAM", "connection lost\n");
  exit(0);
}

static int Image_Size(image)
     XImage *image;
{
    if (image->format != ZPixmap)
      return(image->bytes_per_line * image->height * image->depth);

    return(image->bytes_per_line * image->height);
}

static void Get_XColors(xc, colors)
     XCAM xc;
     XColor *colors;
{
  register int i;


#ifdef CORRECTCMAP
  if (xc->v->class == DirectColor || xc->v->class == TrueColor) {
    Pixel red, green, blue, red1, green1, blue1;
    
    red = green = blue = 0;
    red1 = lowbit(xc->v->red_mask);
    green1 = lowbit(xc->v->green_mask);
    blue1 = lowbit(xc->v->blue_mask);

    for (i = 0; i < ncolors; i++) {
      colors[i].pixel = red|green|blue;
      colors[i].pad = 0;
      red += red1;
      if (red > xc->v->red_mask)
	red = 0;
	green += green1;
      if (green > xc->v->green_mask)
	green = 0;
      blue += blue1;
      if (blue > xc->v->blue_mask)
	blue = 0;
    }
  }

  else
#endif
    
    {
      for (i = 0; i < 256; i++) {
	colors[i].pixel = i;
	colors[i].pad = 0;
      }
    }

  XQueryColors(xc->dpy, xc->cmap, colors, 256);
}

static _swapshort (bp, n)
     register char *bp;
     register unsigned n;
{
  register char c;
  register char *ep = bp + n;

  while (bp < ep) {
    c = *bp;
    *bp = *(bp + 1);
    bp++;
    *bp++ = c;
  }
}

static _swaplong (bp, n)
     register char *bp;
     register unsigned n;
{
  register char c;
  register char *ep = bp + n;
  register char *sp;
  
  while (bp < ep) {
    sp = bp + 3;
    c = *sp;
    *sp = *bp;
    *bp++ = c;
    sp = bp + 1;
    c = *sp;
    *sp = *bp;
    *bp++ = c;
    bp += 2;
  }
}
  
static int desc_idx(XCAM xc, char *b)
{
  int d = *((int *) b);

  if (d > DESCTBLSZ)
    return(-1);

  if (xc->dtbl[d].Apply == NULL)
    return(-1);

  return(d);
}

static void CopyColormap(XCAM xc, Colormap s, Colormap d)
{
  register int i;
  XColor p[256];

  for(i = 0; i < 256; i++) {
    p[i].pixel = i;
    p[i].pad = 0;
  }

  XQueryColors(xc->dpy, s, p, 256);
  XStoreColors(xc->dpy, d, p, 256);
}

static int FindClosestColor(XCAM xc, Colormap cm, unsigned short r,
			    unsigned short b, unsigned short g)
{
  register int i;
  XColor p[256];
  int rv;
  unsigned short dist, mindist;

  for(i = 0; i < 256; i++) {
    p[i].pixel = i;
    p[i].pad = 0;
  }

  XQueryColors(xc->dpy, cm, p, 256);

  mindist = abs(p[0].red - r) + abs(p[0].green - g) + abs(p[0].blue - b);
  rv = 0;

  for(i = 1; i < 256; i++) {

    dist = abs(p[i].red - r) + abs(p[i].green - g) + abs(p[i].blue - b);
    if (dist < mindist) {

      mindist = dist;
      rv = i;
    }
  }

  return(rv);
}

static void CaptureFrame(XCAM xc, XCAM_DESC ds)
{
  XColor cm[256];
  T_ENTER("void CaptureFrame");

  Get_XColors(xc, cm);

  switch(xc->capture) {

  case TO_FILES: {

    char cmd[128];
    int x, y;
    unsigned char r, g, b, p, *d;
    XColor cm[256];
    FILE *f;

    sprintf(cmd, xc->fcmd, xc->fcnt);
  
    if ((f = popen(cmd, "w")) == NULL) {
      CAM_Msg(CAMerr, "tkXCAM", "Can't pipe to capture command: %s\n", cmd);
      CAM_Msg(CAMerr, NULL, "Capture aborted\n");
      xc->ftot = xc->fcnt = 0;
      free(xc->fcmd);
      xc->fcmd = NULL;
      xc->capture = FALSE;
    }

    else {

      Get_XColors(xc, cm);
      d = ds->obj.i->data;

      ppm_writeppminit(f, xc->glbx, xc->glby, 255, 0);

      for(y = 0; y < xc->glby; y++)
	for(x = 0; x < xc->glbx; x++) {
	  
	  p = d[x + y * xc->glbx];
	  r = cm[p].red / 257;
	  g = cm[p].green / 257;
	  b = cm[p].blue / 257;

	  fwrite(&r, sizeof(unsigned char), 1, f);
	  fwrite(&g, sizeof(unsigned char), 1, f);
	  fwrite(&b, sizeof(unsigned char), 1, f);
	}
 
      pclose(f);
      xc->fcnt++;

      if ((xc->ftot != UNLIMITED) && (xc->fcnt) == xc->ftot) {
	xc->ftot = xc->fcnt = 0;
	free(xc->fcmd);
	xc->fcmd = NULL;
	xc->capture = FALSE;
      }
    }

    break;
  }


  case START_STREAM: {

    /*******************************************************************/
    /* Need to send command to mpeg_encode process to start the stream */
    /*******************************************************************/

    xc->capture = CONTINUE_STREAM;
    break;
  }


  case CONTINUE_STREAM: {

    /**********************************************************************/
    /* Need to send command to mpeg_encode process to continue the stream */
    /**********************************************************************/

    xc->fcnt++;

    if ((xc->ftot != UNLIMITED) && (xc->fcnt == xc->ftot))
      xc->capture = FINISH_STREAM;

    break;
  }

  case FINISH_STREAM: {

    /********************************************************************/
    /* Need to send command to mpeg_encode process to finish the stream */
    /********************************************************************/


    xc->capture = FALSE;
    break;
  }
  }
  T_LEAVE;
}

/**************************************************************************/
/**************************************************************************/

int CAM_XCmd(clientData, interp, argc, argv)
     ClientData clientData;	/* Main window associated with
				 * interpreter. */
     Tcl_Interp *interp;	/* Current interpreter. */
     int argc;			/* Number of arguments. */
     char **argv;		/* Argument strings. */
{
  Tk_Window main = (Tk_Window) clientData;
  Tk_Window tkwin;
  XCAM xc;
  XColor p[256];
  long i;
#ifdef XSHM
  char dn[128], hn[128];
  long int a1 = 0, a2 = 0;
  struct hostent *htmp;
#endif
  char fifoname[32];
  FILE *tf;
  T_ENTER("CAM_XCmd");

  /* Try to die gracefully on broken pipe */
  signal(SIGPIPE, pipedeath);

  if (argc < 2) {
    Tcl_AppendResult(interp, "wrong # args:  should be \"",
		     argv[0], " pathName ?options?\"", (char *) NULL);
    T_LEAVE;
    return TCL_ERROR;
  }
  
  tkwin = Tk_CreateWindowFromPath(interp, main, argv[1], (char *) NULL);
  Tk_MakeWindowExist(tkwin);
  if (tkwin == NULL) {
    T_LEAVE;
    return TCL_ERROR;
  }
  Tk_SetClass(tkwin, "XCAM");
  
  /*
   * Allocate and initialize the widget record.
   */
  
  xc = (XCAM) ckalloc(sizeof(XCam));
  xc->tkwin = tkwin;
  xc->ti = interp;
  xc->dpy = Tk_Display(tkwin);
  xc->s = Tk_ScreenNumber(tkwin);
  xc->w = Tk_WindowId(tkwin);
  xc->v = Tk_Visual(tkwin);
  xc->cmap = XCreateColormap(xc->dpy, xc->w, xc->v, AllocAll);
  xc->pcmap = Tk_Colormap(Tk_Parent(tkwin));
  xc->cur = None;
  xc->gc = Tk_GetGC(tkwin, 0, 0);
  xc->width = 0;
  xc->height = 0;
  xc->black = FindClosestColor(xc, xc->pcmap, 0, 0, 0);
  bzero(xc->dtbl, sizeof(XCam_Desc) * DESCTBLSZ);
  xc->glbx = 512;
  xc->glby = 512;
  xc->locx = 0;
  xc->locy = 0;
  xc->lid = -1;
  xc->lcu = -1;
  xc->pmode = CAM_PIPEALL;
  xc->capture = FALSE;
  xc->ftot = 0;
  xc->fcnt = 0;
  xc->fcmd = NULL;
  xc->forth_fifo = NULL;
  xc->retv[0] = 0;
  xc->retv[1] = 0;

  CAM_SetPipeCmdTable(ctbl);
  CAM_SetPipeMode(CAM_PIPEALL);

#ifdef XSHM
  xc->xshmok = XShmQueryExtension(xc->dpy);
  strcpy(dn, DisplayString(xc->dpy));
  if (dn[0] != ':') {

    for(i = 0; i < 128; i++) {
      
      if (dn[i] != ':')
	continue;
      else {
	bzero(dn + i, 128 - i); 
	break;
      }
    }
    
    gethostname(hn, 128);
    
    htmp = gethostbyname(hn);
    if (htmp != NULL)
      bcopy(htmp->h_addr_list[0], &a1, htmp->h_length);

    htmp = gethostbyname(dn);
    if (htmp != NULL)
      bcopy(htmp->h_addr_list[0], &a2, htmp->h_length);

    if ((a1 == 0) || (a2 == 0)) {
      CAM_Msg(CAMerr, "tkXCAM", "\nCan't determine if X Shared Memory is okay\n");
      CAM_Msg(CAMerr, NULL, "Assuming it is not\n");
      xc->xshmok = False;
    }

    if (a1 != a2) {
      xc->xshmok = False;
      xc->CompType = XShmGetEventBase(xc->dpy) + ShmCompletion;
    }
  }
#endif

  CopyColormap(xc, xc->pcmap, xc->cmap);

  Tk_SetWindowColormap(tkwin, xc->cmap);

  Tk_SetWindowBackground(tkwin, xc->black);

  Tk_CreateEventHandler(tkwin,
			ExposureMask|StructureNotifyMask|ColormapChangeMask|
			PointerMotionMask,
			XCAMEventProc, (ClientData) xc);

  if ( ((tf = fopen("/tmp/fifoname", "r")) != NULL) &&
       (fscanf(tf, "%s", fifoname) == 1) && (fclose(tf) == 0) &&
       ((xc->forth_fifo = fopen(fifoname, "w")) != NULL) ) {

    Tk_CreateEventHandler(tkwin, KeyPressMask, XCAMKeyProc, (ClientData) xc);
  }    
    
  Tk_CreateFileHandler(XCAM_infd, TK_READABLE, InputFDProc, (ClientData) xc);

  Tcl_CreateCommand(interp, Tk_PathName(xc->tkwin), XCAMWidgetCmd,
		    (ClientData) xc, (void (*)()) NULL);
  
  if (ConfigureXCAM(interp, xc, argc-2, argv+2, 0)
      != TCL_OK) {
    Tk_DestroyWindow(xc->tkwin);
    T_LEAVE;
    return TCL_ERROR;
  }
  
  interp->result = Tk_PathName(xc->tkwin);
  T_LEAVE;
  return TCL_OK;
}

static int XCAMWidgetCmd(clientData, interp, argc, argv)
     ClientData clientData;	/* Information about XCAM widget. */
     Tcl_Interp *interp;	/* Current interpreter. */
     int argc;			/* Number of arguments. */
     const char **argv;		/* Argument strings. */
{
  XCAM xc = (XCAM) clientData;
  int result = TCL_OK;
  int length;
  char c;
  
  if (argc < 2) {
    Tcl_AppendResult(interp, "wrong # args: should be \"",
		     argv[0], " option ?arg arg ...?\"", (char *) NULL);
    return TCL_ERROR;
  }
  
  Tk_Preserve((ClientData) xc);
  c = argv[1][0];
  length = strlen(argv[1]);

  if (strncmp(argv[1], "configure", length) == 0) {
    switch(argc) {

    case 2: {
      result = Tk_ConfigureInfo(interp, xc->tkwin, configSpecs, (char *) xc,
				(char *) NULL, 0);
      break;
    }

    case 3: {
      result = Tk_ConfigureInfo(interp, xc->tkwin, configSpecs, (char *) xc,
				argv[2], 0);
      break;
    }

    default: {    
      result = ConfigureXCAM(interp, xc, argc-2, argv+2, 0);
    }
    }
  }

  else if (strncmp(argv[1], "pipe", length) == 0)
    result = PipeImag(interp, xc, argc-2, argv+2);

  else if (strncmp(argv[1], "wimag", length) == 0)
    result = WriteImag(interp, xc, argc-2, argv+2);

  else if (strncmp(argv[1], "wcmap", length) == 0)
    result = WriteCmap(interp, xc, argc-2, argv+2);

  else if (strncmp(argv[1], "resize", length) == 0)
    result = ResizeWindow(interp, xc, argc-2, argv+2);

  else if (strncmp(argv[1], "ignore", length) == 0)
    CAM_SetPipeMode(xc->pmode = CAM_PIPENONE);

  else if (strncmp(argv[1], "pause", length) == 0)
    CAM_SetPipeMode(xc->pmode = CAM_PIPEPAUSE);

  else if (strncmp(argv[1], "cont", length) == 0)
    CAM_SetPipeMode(xc->pmode = CAM_PIPEALL);

  else if (strncmp(argv[1], "menucmap", length) == 0)
    Tk_SetWindowColormap(Tk_NameToWindow(xc->ti, ".", xc->tkwin), xc->pcmap);

  else if (strncmp(argv[1], "imagcmap", length) == 0)
    Tk_SetWindowColormap(Tk_NameToWindow(xc->ti, ".", xc->tkwin), xc->cmap);

  else if (strncmp(argv[1], "capture", length) == 0)
    result = ToggleCaptureFrames(interp, xc, argc-2, argv+2);

  else {
    Tcl_AppendResult(interp, "bad option \"", argv[1],
		     "\":  must be configure, position, or size",(char *) NULL);
    goto error;
  }

  Tk_Release((ClientData) xc);
  return result;
  
 error:
  Tk_Release((ClientData) xc);
  return TCL_ERROR;
}

static int ConfigureXCAM(interp, xc, argc, argv, flags)
     Tcl_Interp *interp;			/* Used for error reporting. */
     XCAM xc;			/* Information about widget. */
     int argc;				/* Number of valid entries in argv. */
     const char **argv;			/* Arguments. */
     int flags;				/* Flags to pass to
					 * Tk_ConfigureWidget. */
{
  if (Tk_ConfigureWidget(interp, xc->tkwin, configSpecs, argc, argv,
			 (char *) xc, flags) != TCL_OK) {
    return TCL_ERROR;
  }
  
  /*
   * Register the desired geometry for the window.  Then arrange for
   * the window to be redisplayed.
   */
  
  Tk_GeometryRequest(xc->tkwin, xc->width, xc->height);

  return TCL_OK;
}

/****************************************************************************/
/****************************************************************************/

static int PipeImag(interp, xc, argc, argv)
     Tcl_Interp *interp;		/* Used for error reporting. */
     XCAM xc;                          /* Information about widget. */
     int argc;				/* Number of valid entries in argv. */
     char **argv;			/* Arguments. */
{
  FILE *fp;
  register int i;
  int win_name_size;
  int header_size;
  unsigned int buffer_size;
  unsigned long swaptest = 1;
  char *win_name;
  XColor colors[256];
  Bool got_win_name;
  XImage *image;
  Window dummywin;
  XWDFileHeader header;
  
    


  if (argc < 1) {
    Tcl_SetResult(interp, "need_args", TCL_STATIC);
    return TCL_OK;
  }

  if (xc->lid == -1) {
    Tcl_SetResult(interp, "no_image", TCL_STATIC);
    return TCL_OK;
  }

  if ((fp = popen(argv[0], "w")) == NULL) {
    Tcl_SetResult(interp, "command_failed", TCL_STATIC);
    return TCL_OK;
  }


  XFetchName(xc->dpy, xc->w, &win_name);
  if (!win_name || !win_name[0]) {
    win_name = "xwdump";
    got_win_name = False;
  } else {
    got_win_name = True;
  }

  /* sizeof(char) is included for the null string terminator. */
  win_name_size = strlen(win_name) + sizeof(char);

  image = xc->dtbl[xc->lid].obj.i;

  /*
   * Determine the pixmap size.
   */
  buffer_size = Image_Size(image);

  Get_XColors(xc, colors);

  /*
   * Calculate header size.
   */
  header_size = sizeof(header) + win_name_size;

  /*
   * Write out header information.
   */
  header.header_size = (CARD32) header_size;
  header.file_version = (CARD32) XWD_FILE_VERSION;
  header.pixmap_format = (CARD32) ZPixmap;
  header.pixmap_depth = (CARD32) image->depth;
  header.pixmap_width = (CARD32) image->width;
  header.pixmap_height = (CARD32) image->height;
  header.xoffset = (CARD32) image->xoffset;
  header.byte_order = (CARD32) image->byte_order;
  header.bitmap_unit = (CARD32) image->bitmap_unit;
  header.bitmap_bit_order = (CARD32) image->bitmap_bit_order;
  header.bitmap_pad = (CARD32) image->bitmap_pad;
  header.bits_per_pixel = (CARD32) image->bits_per_pixel;
  header.bytes_per_line = (CARD32) image->bytes_per_line;
  header.visual_class = (CARD32) xc->v->class;
  header.red_mask = (CARD32) xc->v->red_mask;
  header.green_mask = (CARD32) xc->v->green_mask;
  header.blue_mask = (CARD32) xc->v->blue_mask;
  header.bits_per_rgb = (CARD32) xc->v->bits_per_rgb;
  header.colormap_entries = (CARD32) xc->v->map_entries;
  header.ncolors = 256;
  header.window_width = (CARD32) image->width;
  header.window_height = (CARD32) image->height;
  header.window_x = 0;
  header.window_y = 0;
  header.window_bdrwidth = (CARD32) 0;
  
  if (*(char *) &swaptest) {
    _swaplong((char *) &header, sizeof(header));
    for (i = 0; i < 256; i++) {
      _swaplong((char *) &(colors[i].pixel), sizeof(long));
      _swapshort((char *) &(colors[i].red), 3 * sizeof(short));
    }
  }

  (void) fwrite((char *)&header, sizeof(header), 1, fp);
  (void) fwrite(win_name, win_name_size, 1, fp);
  
  /*
   * Write out the color maps, if any
   */
  
  (void) fwrite((char *) colors, sizeof(XColor), 256, fp);

  /*
   * Write out the buffer.
   *
   *    This copying of the bit stream (data) to a file is to be replaced
   *  by an Xlib call which hasn't been written yet.  It is not clear
   *  what other functions of xwd will be taken over by this (as yet)
   *  non-existant X function.
   */
  (void) fwrite(image->data, (int) buffer_size, 1, fp);

  /*
   * Free window name string.
   */
  if (got_win_name) XFree(win_name);

  fflush(fp);
  pclose(fp);

  Tcl_SetResult(interp, "complete", TCL_STATIC);
  return TCL_OK;
}

static int WriteImag(interp, xc, argc, argv)
     Tcl_Interp *interp;		/* Used for error reporting. */
     XCAM xc;                          /* Information about widget. */
     int argc;				/* Number of valid entries in argv. */
     char **argv;			/* Arguments. */
{
  int f;
  register int nb;


  if (argc < 1) {
    Tcl_SetResult(interp, "need_args", TCL_STATIC);
    return TCL_OK;
  }

  if (xc->lid == -1) {
    Tcl_SetResult(interp, "no_image", TCL_STATIC);
    return TCL_OK;
  }

  if ((f = open(argv[0], O_CREAT|O_WRONLY, 0744)) == -1) {
    Tcl_SetResult(interp, "cannot_open", TCL_STATIC);
    return TCL_OK;
  }

  nb = xc->dtbl[xc->lid].obj.i->width * xc->dtbl[xc->lid].obj.i->height;

  if (CAM_WriteBytes(f, xc->dtbl[xc->lid].obj.i->data, nb) != nb) {
    Tcl_SetResult(interp, "write_failed", TCL_STATIC);
    return TCL_OK;
  }

  close(f);

  Tcl_SetResult(interp, "complete", TCL_STATIC);
  return TCL_OK;
}

static int WriteCmap(interp, xc, argc, argv)
     Tcl_Interp *interp;		/* Used for error reporting. */
     XCAM xc;                          /* Information about widget. */
     int argc;				/* Number of valid entries in argv. */
     char **argv;			/* Arguments. */
{
  int f;
  register int i;
  CamCm cm;
  XColor p[256];


  if (argc < 1) {
    Tcl_SetResult(interp, "need_args", TCL_STATIC);
    return TCL_OK;
  }

  if ((f = open(argv[0], O_CREAT|O_WRONLY, 0744)) == -1) {
    Tcl_SetResult(interp, "cannot_open", TCL_STATIC);
    return TCL_OK;
  }

  Get_XColors(xc, p);

  for (i = 0; i < 256; i++) {

    cm.p = p[i].pixel;
    cm.r = p[i].red / 257;
    cm.g = p[i].green / 257;
    cm.b = p[i].blue / 257;

    if (CAM_WriteBytes(f, (char *) &cm, sizeof(CamCm)) != sizeof(CamCm)) {
      Tcl_SetResult(interp, "write_failed", TCL_STATIC);
      return TCL_OK;
    }
  }

  close(f);
  Tcl_SetResult(interp, "complete", TCL_STATIC);
  return TCL_OK;
}

static int ResizeWindow(interp, xc, argc, argv)
     Tcl_Interp *interp;		/* Used for error reporting. */
     XCAM xc;                          /* Information about widget. */
     int argc;				/* Number of valid entries in argv. */
     char **argv;			/* Arguments. */
{
  int x, y, mw, mh;
  Tk_Window root, topbar;

  root = Tk_NameToWindow(xc->ti, ".", xc->tkwin);
  topbar = Tk_NameToWindow(xc->ti, ".topbar", xc->tkwin);

  if (argc < 1) {

    mw = xc->glbx;
    mh = Tk_Height(topbar) + xc->glby;

    /* Resize to global X and Y settings */
    Tk_ResizeWindow(root, mw, mh);

    Tcl_SetResult(interp, "complete", TCL_STATIC);
    return TCL_OK;
  }

  else {

    /* Dimensions specified */

    if (argc < 2) {
      Tcl_SetResult(interp, "need_args", TCL_STATIC);
      return TCL_OK;
    }

    x = atoi(argv[0]);
    y = atoi(argv[1]);

    if ((x > 0) && (y > 0)) {

      Tk_ResizeWindow(xc->tkwin, x, y);

      Tcl_SetResult(interp, "complete", TCL_STATIC);
      return TCL_OK;
    }

    else {

      Tcl_SetResult(interp, "command_failed", TCL_STATIC);
      return TCL_OK;
    }
  }
}

static int ToggleCaptureFrames(interp, xc, argc, argv)
     Tcl_Interp *interp;		/* Used for error reporting. */
     XCAM xc;                          /* Information about widget. */
     int argc;				/* Number of valid entries in argv. */
     char **argv;			/* Arguments. */
{

  if (argc < 2) {
      Tcl_SetResult(interp, "need_args", TCL_STATIC);
      return TCL_OK;
    }

  switch(xc->capture) {

  case TO_FILES: {

    xc->fcnt = xc->ftot = 0;
    free(xc->fcmd);
    xc->fcmd = NULL;
    xc->capture = FALSE;
    break;
  }

  case FALSE: {

    xc->capture = TO_FILES;
    xc->ftot = atoi(argv[0]);
    xc->fcmd = strdup(argv[1]);
    xc->fcnt = 0;
    break;
  }
  }

  Tcl_SetResult(interp, "ok", TCL_STATIC);
  return TCL_OK;
}

/****************************************************************************/
/****************************************************************************/

static void InputFDProc(clientData, mask)
     ClientData clientData;
     int mask;
{
  int rv;
  XCAM xc = (XCAM) clientData;

  if ((rv = CAM_ParsePipeMesg(XCAM_infd, XCAM_outfd, (char *) xc)) < CAM_PIPEALL)
    sendmesg(XCAM_outfd, rv);

  (void) Tcl_Eval(xc->ti, "update idletasks");
}

static void XCAMEventProc(clientData, eventPtr)
     ClientData clientData;	/* Information about window. */
     XEvent *eventPtr;		/* Information about event. */
{
  static int argc = 1;
  XCAM xc = (XCAM) clientData;
  
  switch(eventPtr->type) {

  case Expose: {
    if (eventPtr->xexpose.count == 0) {
      if (xc->lid == -1)
	XClearWindow(xc->dpy, xc->w);
      else {
	refresh = TRUE;
	if (xc->dtbl[xc->lid].Apply(xc, &(xc->dtbl[xc->lid])) != 0)
	  xc->lid = -1;
      }
    }
    break;
  }

  case ConfigureNotify: {

    Tk_MapWindow(xc->tkwin);
    break;
  }

  case DestroyNotify: {
    Tcl_DeleteCommand(xc->ti, Tk_PathName(xc->tkwin));
    xc->tkwin = NULL;

    Tk_EventuallyFree((ClientData) xc, DestroyXCAM);
    break;
  }

  case ColormapNotify: {
    if ((eventPtr->xcolormap.new == True) ||
	(eventPtr->xcolormap.state == ColormapInstalled)) {

      xc->black = FindClosestColor(xc, eventPtr->xcolormap.colormap, 0, 0, 0);
      Tk_SetWindowBackground(xc->tkwin, xc->black);
    }
    break;
  }

  }
}

static void XCAMKeyProc(clientData, eventPtr)
     ClientData clientData;	/* Information about window. */
     XEvent *eventPtr;		/* Information about event. */
{
  static char buf[16];
  static int len, i;
  static KeySym ks;
  XCAM xc = (XCAM) clientData;
  

  if (xc->forth_fifo != NULL) {

    switch(eventPtr->type) {

    case KeyPress: {
      if (XCAM_infd != fileno(stdin))
	CAM_SendKeyString((XKeyEvent *) eventPtr, xc->forth_fifo);
      break;
    }
    }

  }
}

static void DestroyXCAM(clientData)
     char * clientData;	/* Info about XCAM widget. */
{
  XCAM xc = (XCAM) clientData;
  
  Tk_FreeOptions(configSpecs, (char *) xc, xc->dpy, 0);
  Tk_FreeGC(xc->dpy, xc->gc);
  ckfree((char *) xc);
}

/****************************************************************************/
/*		    Begining of Command Table Procedures	            */
/****************************************************************************/

static unsigned char *SetupSHMI(char *appdata, unsigned char *o, unsigned char *b)
{
  XCAM xc = (XCAM) appdata;
  register int i;
  register XCAM_DESC p;
  register XCAM_DESC dtbl = xc->dtbl;
  int nd;
  caddr_t ptr;
  T_ENTER("SetupSHMI");

  FindNxt(xc, nd);
  
  if (nd >= 0)
    p = &(dtbl[nd]);

  else {
    T_LEAVE;
    SETRETV(xc, -1000, -1);
    PIPERET(xc);
  }

  p->shm.id = *((int *) b);

  for(i = 0; i < nd; i++)
    if (dtbl[i].shm.id == p->shm.id)
      p->shm.cnt = dtbl[i].shm.cnt + 1;
  
#ifdef XSHM
  if (xc->xshmok) {
    p->shm.info.shmid = p->shm.id;
    p->type = XSHMIMAG;
    p->obj.i = XShmCreateImage(xc->dpy, xc->v, 8, ZPixmap, 0,
				       &(p->shm.info), xc->glbx, xc->glby);
  }

  else
#endif
    {
    normximage:
      p->type = SHMIMAG;
      p->obj.i = XCreateImage(xc->dpy, xc->v, 8, ZPixmap, 0, NULL,
				       xc->glbx, xc->glby, 8, 0);
    }

  if ((ptr = (caddr_t) shmat(p->shm.id, 0, SHM_RDONLY)) == (caddr_t) -1) {

    CAM_Msg(CAMerr, "tkXCAM", "Error trying to attach to shmid %d\n", p->shm.id);

    XDestroyImage(p->obj.i);
    T_LEAVE;
    SETRETV(xc, -1000, -1);
    PIPERET(xc);
  }

  p->obj.i->data = (char *) (ptr + HEADER_LENGTH);

#ifdef XSHM
  if (xc->xshmok) {
    p->shm.info.shmaddr = p->obj.i->data;
    p->shm.info.readOnly = True;
    p->Apply = DispXSHMImage;

    if (XShmAttach(xc->dpy, &(p->shm.info)) == False) {
      CAM_Msg(CAMerr, "tkXCAM", "X Shared Memory Extension error...\n");
      CAM_Msg(CAMerr, NULL, "Using normal XLIB calls.\n");
      xc->xshmok = False;
      XDestroyImage(p->obj.i);
      shmdt(p->shm.info.shmaddr);
      goto normximage;
    }
  }

  else
#endif

    p->Apply = DispXImage;

  T_LEAVE;
  SETRETV(xc, 0, nd);
  PIPERET(xc);
}

static unsigned char *SetupSHMC(char *appdata, unsigned char *o, unsigned char *b)
{
  XCAM xc = (XCAM) appdata;
  register int i;
  register XCAM_DESC p;
  register XCAM_DESC dtbl = xc->dtbl;
  int nd;
  caddr_t ptr;
  T_ENTER("SetupSHMC");


  FindNxt(xc, nd);
  
  if (nd >= 0)
    p = &(dtbl[nd]);

  else {
    T_LEAVE;
    SETRETV(xc, -1000, -1);
    PIPERET(xc);
  }


  p->shm.id = *((int *) b);
  p->type = SHMCMAP;
  
  for(i = 0; i < nd; i++)
    if (dtbl[i].shm.id == p->shm.id)
      p->shm.cnt = dtbl[i].shm.cnt + 1;

  if ((ptr = (caddr_t) shmat(p->shm.id, 0, SHM_RDONLY)) == (caddr_t) -1) {

    CAM_Msg(CAMerr, "tkXCAM", "Error trying to attach to shmid %d\n", p->shm.id);
    T_LEAVE;
    SETRETV(xc, -1000, -1);
    PIPERET(xc);
  }

  p->obj.c = (CAMCM) (ptr + HEADER_LENGTH);
  p->Apply = AllocCmap;

  T_LEAVE;
  SETRETV(xc, 0, nd);
  PIPERET(xc);
}

static unsigned char *SetupKERI(char *appdata, unsigned char *o, unsigned char *b)
{
  XCAM xc = (XCAM) appdata;
  register int i;
  register XCAM_DESC p;
  register XCAM_DESC dtbl = xc->dtbl;
  int nd;
  char *ip = *((char **) b);
  T_ENTER("SetupKERI");

  FindNxt(xc, nd);
  
  if (nd >= 0)
    p = &(dtbl[nd]);

  else {
    T_LEAVE;
    SETRETV(xc, -1000, -1);
    PIPERET(xc);
  }

  ip = mmap(0, xc->glbx * xc->glby + HEADER_LENGTH,
	    PROT_READ, MAP_SHARED, XCAM_camfd, ip);

  if (ip == (char *) -1) {
    T_LEAVE;
    SETRETV(xc, -1000, -1);
    PIPERET(xc);
  }

  p->type = IMAG;
  p->obj.i = XCreateImage(xc->dpy, xc->v, 8, ZPixmap, 0,
			  (ip + HEADER_LENGTH),
			  xc->glbx, xc->glby, 8, 0);
  p->Apply = DispXImage;

  T_LEAVE;
  SETRETV(xc, 0, nd);
  PIPERET(xc);
}

static unsigned char *SetupKERC(char *appdata, unsigned char *o, unsigned char *b)
{
  XCAM xc = (XCAM) appdata;
  register int i;
  register XCAM_DESC p;
  register XCAM_DESC dtbl = xc->dtbl;
  int nd;
  char *cp = *((char **) b);
  T_ENTER("SetupKERC");

  FindNxt(xc, nd);
  
  if (nd >= 0)
    p = &(dtbl[nd]);

  else {
    T_LEAVE;
    SETRETV(xc, -1000, -1);
    PIPERET(xc);
  }

  cp = mmap(0, 256 * sizeof(CamCm) + HEADER_LENGTH,
	    PROT_READ, MAP_SHARED, XCAM_camfd, cp);

  if (cp == (char *) -1) {
    T_LEAVE;
    CAM_Perror(CAMerr, NULL);
    SETRETV(xc, -1000, -1);
    PIPERET(xc);
  }

  p->type = CMAP;
  p->obj.c = (CAMCM) (cp + HEADER_LENGTH);
  p->Apply = AllocCmap;

  T_LEAVE;
  SETRETV(xc, 0, nd);
  PIPERET(xc);
}

static unsigned char *SetGLBX(char *appdata, unsigned char *o, unsigned char *b)
{
  XCAM xc = (XCAM) appdata;
  int x = *((int *) b);
  T_ENTER("SetGLBX");

  if (x < 0) {
    T_LEAVE;
    SETRETV(xc, -1000, -1);
    PIPERET(xc);
  }
  else {
    xc->glbx = x;
    T_LEAVE;
    SETRETV(xc, 0, 0);
    PIPERET(xc);
  }
}

static unsigned char *SetGLBY(char *appdata, unsigned char *o, unsigned char *b)
{
  XCAM xc = (XCAM) appdata;
  int y = *((int *) b);
  T_ENTER("SetGLBY");

  if (y < 0) {
    T_LEAVE;
    SETRETV(xc, -1000, -1);
    PIPERET(xc);
  }
  else {
    xc->glby = y;
    T_LEAVE;
    SETRETV(xc, 0, 0);
    PIPERET(xc);
  }
}

static unsigned char *XCAMApply(char *appdata, unsigned char *o, unsigned char *b)
{
  XCAM xc = (XCAM) appdata;
  int d;
  T_ENTER("XCAMApply");

  if ((d = desc_idx(xc, b)) == -1) {
    T_LEAVE;
    SETRETV(xc, d, d);
    PIPERET(xc);
  }

  if ((xc->dtbl[d].type == IMAG) || (xc->dtbl[d].type == SHMIMAG) ||
      (xc->dtbl[d].type == XSHMIMAG)) {

    /* if we are not displaying from the same buffer then clear screen */
    if (xc->lid != d)
      XClearWindow(xc->dpy, xc->w);

    xc->lid = d;
  }

  if ((xc->dtbl[d].type == CMAP) || (xc->dtbl[d].type == SHMCMAP))
    xc->lcu = d;
   
  xc->dtbl[d].Apply(xc, &(xc->dtbl[d]));
  T_LEAVE;
  PIPERET(xc);
}

static unsigned char *XCAMFree(char *appdata, unsigned char *o, unsigned char *b)
{
  XCAM xc = (XCAM) appdata;
  int d;
  T_ENTER("XCAMFree");

  if ((d = desc_idx(xc, b)) == -1) {
    T_LEAVE;
    SETRETV(xc, d, d);
    PIPERET(xc);
  }

  if (d == xc->lid) {
    xc->lid = -1;
    XClearWindow(xc->dpy, xc->w);
  }

  else if (d == xc->lcu) {
    xc->lcu = -1;
    CopyColormap(xc, xc->pcmap, xc->cmap);
  }


  if (xc->dtbl[d].type == IMAG)
    munmap(xc->dtbl[d].obj.i->data,
	   xc->dtbl[d].obj.i->width * xc->dtbl[d].obj.i->height);

  else if (xc->dtbl[d].type == CMAP)
    munmap(xc->dtbl[d].obj.c, 256 * sizeof(CamCm));


#ifdef XSHM
  if ((xc->xshmok) && (xc->dtbl[d].type == XSHMIMAG))
    XShmDetach(xc->dpy, &(xc->dtbl[d].shm.info));    
#endif

  if ((xc->dtbl[d].type < 'a') && (xc->dtbl[d].shm.cnt == 0))
    shmdt(xc->dtbl[d].shm.id);

  bzero(&(xc->dtbl[d]), sizeof(XCam_Desc));

  T_LEAVE;
  SETRETV(xc, 0, 0);
  PIPERET(xc);
}

static unsigned char *FreeAndExit(char *appdata, unsigned char *o, unsigned char *b)
{
  XCAM xc = (XCAM) appdata;
  int i;
  T_ENTER("FreeAndExit");

  for(i = 0; i < DESCTBLSZ; i++)
    if (xc->dtbl[i].type != 0)
      XCAMFree((char *) xc, 0, (unsigned char *) &i);

  if (xc->forth_fifo)
    fclose(xc->forth_fifo);

  Tk_DestroyWindow(Tk_NameToWindow(xc->ti, ".", xc->tkwin));

  T_LEAVE;
  SETRETV(xc, 0, 0);
  PIPERET(xc);
}

/****************************************************************************/
/*		     Begining of XCAM operations                            */
/****************************************************************************/

static int AllocCmap(XCAM xc, XCAM_DESC ds)
{
  register int i;
  XColor xcolor[256];
  T_ENTER("int AllocCmap");

  for (i=0; i<256; i++) {

    xcolor[i].flags = DoRed | DoGreen | DoBlue;
/*  xcolor[i].pixel = (unsigned long) ds->obj.c[i].p; */
    xcolor[i].pixel = (unsigned long) i;
    xcolor[i].red = ds->obj.c[i].r * 257;
    xcolor[i].green = ds->obj.c[i].g * 257;
    xcolor[i].blue = ds->obj.c[i].b * 257;
  }

  if(XStoreColors(xc->dpy, xc->cmap, xcolor, 256) == 0) {
    CAM_Msg(CAMerr, "tkXCAM", "Cannot store colors in private colormap!!\n");
    FATALERROR(xc);
    FreeAndExit((char *) xc, 0, 0);
  }

#ifdef DEBUG
  DUMPCMAP("Image", xc->cmap, xc->dpy);
#endif

  T_LEAVE;
  SETRETV(xc, 0, 0);
  XCAMRET(xc);
}

static int DispXImage(XCAM xc, XCAM_DESC ds)
{
  XPutImage(xc->dpy, xc->w,xc->gc, ds->obj.i, 0, 0, 0, 0, ds->obj.i->width,
	    ds->obj.i->height); 
  XSync(xc->dpy, 0);

  if (xc->capture && !refresh)
    CaptureFrame(xc, ds);

  refresh = FALSE;

  SETRETV(xc, 0, 0);
  XCAMRET(xc);
}

static int DispXSHMImage(XCAM xc, XCAM_DESC ds)
{
#ifdef XSHM
  if (xc->xshmok) {

    XShmPutImage(xc->dpy, xc->w, xc->gc, ds->obj.i, 0, 0, 0, 0,
		 ds->obj.i->width, ds->obj.i->height, True);
    XSync(xc->dpy, 0);
  }

  else
#endif

    {

      XPutImage(xc->dpy, xc->w, xc->gc, ds->obj.i, 0, 0, 0, 0,
		ds->obj.i->width, ds->obj.i->height);
      XSync(xc->dpy, 0);
      ds->Apply = DispXImage;
    }

  if (xc->capture && !refresh)
    CaptureFrame(xc, ds);

  refresh = FALSE;

  SETRETV(xc, 0, 0);
  XCAMRET(xc);
}
