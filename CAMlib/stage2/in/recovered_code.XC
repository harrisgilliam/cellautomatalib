



#ifndef _CAM8INTERFACE_H_
#define _CAM8INTERFACE_H_
#include <CaLib++.H>
#include "std++.H"
/*****************************************************************************/
/********************************* DEFINES ***********************************/
/*****************************************************************************/
#define RESET_CAM_MASK		0x80000000					 /* These are bits of the control or */
#define READ_CAM_MASK		0x40000000					 /* first long word of every step    */
#define IMMEDIATE_DATA_MASK	0x20000000					 /* instruction 		     */
#define BYTE_MODE_MASK		0x10000000
#define HOST_JUMP_MASK		0x00008000
#define HOST_WAIT_MASK		0x00004000
#define SOFT_INT_MASK		0x00002000
#define WAIT_EOS_MASK		0x00001000
#define REGISTER_ADDR_MASK	0x0000003F
/* NLP/NLP */
#define CAM_INTERFACE_HALTED    0x00000008 /* Interface Halted?            */
#define CAM_WAIT_FOR_HOST       0x00000004 /* CAM waiting for host? status */
#define CAM_EXCEPTION_STATUS    0x00000002 /* Interface Exception status   */
#define CAM_NLP_WRITTEN         0x00000001 /* CAM NLP written? status      */
/* ISR/RER */
#define CAM_INT_PENDING_STATUS  0x0000001F /* Status of all Interrupt Bits */
#define CAM_NEWLIST_INT_STATUS  0x00000010 /* Status new-list interrupt    */
#define CAM_TIMEOUT_INT_STATUS  0x00000008 /* Status timeout interrupt     */
#define CAM_SBUS_INT_STATUS     0x00000004 /* Status Sbus interrupt        */
#define CAM_CAM_INT_STATUS      0x00000002 /* Status CAM interrupt         */
#define CAM_SOFT_INT_STATUS     0x00000001 /* Status interrupt             */
#define CAM_RESET_INTERFACE     0x80000000 /* Reset the interface          */
#define CAM_HALT_INTERFACE      0x00008000 /* Halt the interface           */
#define CAM_CLEAR_EXCEPTION     0x00004000 /* Clear exceptions (enable     */
					   /* exceptions caused by timeout)*/
#define CAM_ENABLE_TIMEOUT_EXC  0x00004000 /* enable exceptions caused     */
					   /* by timeout (clear exceptions)*/
#define CAM_RESUME_AFTER_ERR    0x00002000 /* Resume after error ack       */
					   /* (enable exceptions by CAM    */
					   /* interrupt)                   */
#define CAM_ENABLE_CAMINT_EXC   0x00002000 /* enable exceptions by CAM     */
					   /* interrupt (resume after      */
					   /* error ack)                   */
#define CAM_ENABLE_NEWLIST_INT  0x00001000 /* Enable new-list interrupt    */
#define CAM_ENABLE_TIMEOUT_INT  0x00000800 /* Enable timeout interrupt     */
#define CAM_ENABLE_SBUS_INT     0x00000400 /* Enable Sbus interrupt        */
#define CAM_ENABLE_CAM_INT      0x00000200 /* Enable CAM interrupt         */
#define CAM_ENABLE_SOFT_INT     0x00000100 /* Enable soft interrupt        */
#define CAM_DISABLE_TIMEOUT_EXC 0x00000040 /* Disable new-list interrupt   */
#define CAM_DISABLE_CAMINT_EXC  0x00000020 /* Disable timeout interrupt    */
#define CAM_DISABLE_NEWLIST_INT 0x00000010 /* Disable new-list interrupt   */
#define CAM_DISABLE_TIMEOUT_INT 0x00000008 /* Disable timeout interrupt    */
#define CAM_DISABLE_SBUS_INT    0x00000004 /* Disable Sbus interrupt       */
#define CAM_DISABLE_CAM_INT     0x00000002 /* Disable CAM interrupt        */
#define CAM_DISABLE_SOFT_INT    0x00000001 /* Disable soft interrupt       */
/* CIP/DSL */
#define CAM_TRANSFER_WAITING   0x00000008  /* Is CAM waiting to transfer?  */
#define CAM_DONE_STATUS        0x00000004  /* CAM Done status              */
#define CAM_PARTIAL_WRITE      0x00000002  /* Partial write after Sbus err?*/
#define CAM_FSM_SUSPENDED      0x00000001  /* Is Sbus FSM suspended?       */
/* PIP/DBL */
#define CAM_INTRFC_RESET_PNDNG 0x00000008  /* Interface reset pending?     */
#define CAM_SS2                0x00000004  /* CAM SS2 mode set?            */
#define CAM_SCANNING_STATUS    0x00000002  /* CAM scanning status          */
#define CAM_INTERRUPT_STATUS   0x00000001  /* CAM interrupt status         */
#ifdef __cplusplus
/*****************************************************************************/
/******************************** TEMPLATES **********************************/
/*****************************************************************************/
/*****************************************************************************/
/*************************** CLASSES & TYPEDEFS ******************************/
/*****************************************************************************/
class Cam8Interface {
public:
  Cam8Interface(void);
  DECL_COPYCONST(Cam8Interface);
  virtual ~Cam8Interface(void);
  DECL_OPEQ(Cam8Interface);
  DECL_BZERO(Cam8Interface);
  DECL_BCOPY(Cam8Interface);
  DECL_BCMP(Cam8Interface);
  void InitInterface(Cam8Sim *);
  void ResetInterface(void);
  void Generate_Interrupt(int) throws Cam8SimInterrupt;
  virtual LONG32 * GetNextSteplist(void);
/*****************************************************************************/
/********************************* INLINES ***********************************/
/*****************************************************************************/
#endif
/*****************************************************************************/
/******************************* PROTOTYPES **********************************/
/*****************************************************************************/
/*****************************************************************************/
/********************************* GLOBALS ***********************************/
/*****************************************************************************/
#endif

---------------------------------------------------------------------------

Stage 3 amounts to the underpinings of a CA compiler that is targeted
to a virtual cellular automata machine.  Many of the classes that
support abstractions for CA and CAMs can compliment the intermediate
language of such a compiler.
The virtual CAM in optimal cases turns out to actually be CAM8.  Other
times it may be camsim (which is cam8sim without the 16 bit cell
limitation).  The CA compiler will produce an intermediate language
which can easily be converted to run on this virtual CAM.  Minimally
VCAM has the features:
   Can layout the space in bitslices.
   Can layout the space in words.
   Can do neighborhoods using the CAM8 mentality of copy&kick.
   Can do neighborhoods by directly addressing memory.
   Can do rule updating using a LUT.
   Can do rule updating using a procedure.
Loosely speaking the features fall into categories:
   How to layout the CA space in memory (bitslice or words).
   How to do data movement (copy&kick or direct addressing).
   How to update a cell (LUT or procedure).
All of these features can be mixed and matched to implement the given
CA.  The CA compiler frontend and intermediate instruction generator
will not need to care about which features are used.  The VCAM is a
machine that has ALL features simultaneously, in other words it
defines the set of possible features.  In real life every target
architecture must have at least one feature from each category to be a
valid target.  Each backend will know which features its target
architecture has and will convert the intermediate language into
native code for its target.
The stage3 library should be designed and coded so that it can be used
in the backend of the CA compiler.  The abstractions represented in
the intermediate language can probably become abstract classes in the
stage3 library.
Basic Cellular Automata Machine Operations
------------------------------------------
new_experiment				Free all currently allocate
					resources.  Reset the machine
					and initialize it to its
					startup state.
define_space				Define dimensionality and size
					of the CA space.
download				Copy data from the CA space to
					the host.
upload					Copy data from the host to the
					CA space.
define_field				Define a field within the cell
					state.  Can be specified in
					terms of bits or a data type.
kick					Define the data movement for
					a particular field.  Various
					lattice arrangements can be
					implemented in this way.
scan					Update a space using a rule.

---------------------------------------------------------------------------

Stage 3 amounts to the underpinings of a CA compiler that is targeted
to a virtual cellular automata machine.  Many of the classes that
support abstractions for CA and CAMs can compliment the intermediate
language of such a compiler.
The virtual CAM in optimal cases turns out to actually be CAM8.  Other
times it may be camsim (which is cam8sim without the 16 bit cell
limitation).  The CA compiler will produce an intermediate language
which can easily be converted to run on this virtual CAM.  Minimally
VCAM has the features:
   Can layout the space in bitslices.
   Can layout the space in words.
   Can do neighborhoods using the CAM8 mentality of copy&kick.
   Can do neighborhoods by directly addressing memory.
   Can do rule updating using a LUT.
   Can do rule updating using a procedure.
Loosely speaking the features fall into categories:
   How to layout the CA space in memory (bitslice or words).
   How to do data movement (copy&kick or direct addressing).
   How to update a cell (LUT or procedure).
All of these features can be mixed and matched to implement the given
CA.  The CA compiler frontend and intermediate instruction generator
will not need to care about which features are used.  The VCAM is a
machine that has ALL features simultaneously, in other words it
defines the set of possible features.  In real life every target
architecture must have at least one feature from each category to be a
valid target.  Each backend will know which features its target
architecture has and will convert the intermediate language into
native code for its target.
The stage3 library should be designed and coded so that it can be used
in the backend of the CA compiler.  The abstractions represented in
the intermediate language can probably become abstract classes in the
stage3 library.

---------------------------------------------------------------------------



#include <CAM/CALib++.H>
#include <CAM/CamStream++.H>
#include <CAM/CamError++.H>
#include <CAM/CamTrace++.H>
#include <CAM/CAM8SimJIT++.H>
#include <CAM/CAM8SimRegMgr++.H>
#include <CAM/CAM8SimSPARCRegMgr++.H>
#include "std++.H"
REGISTER GetReg(INT16 nVar, CODEHANDLE hcodCurrent, BOOL bLoad)
     REGISTER reg;
     CODEPTR pcodNext;
     pcodNext = *hcodCurrent;
     
     if (SymbolTable[nVar].regLoc != 0) {					 /* if nVar is already in a register */
	  return (SymbolTable[nVar].regLoc);					 /* 	return the register 	     */
     }
     if (NumFreeRegs() != 0) {						 	 /* else if there is a free register */
	  reg = GetFreeReg();							 /* 	get free register 	     */
     } else {
	  reg = GetSpillable();							 /* else get a spillable register    */
#ifdef _INSTRUMENTATION_
	  fprintf(stderr, "Spilling Register : Variable %x : Priority %x\n",
		  	  rCurrWindow[reg].nVar,
		  	  rCurrWindow[reg].nPriority);
#endif	  
#ifdef DEBUG
	  fprintf(DEBUGFILE, "Spilling Register : Variable %s : Priority %x\n",
		  	  SYMBOLS[rCurrWindow[reg].nVar],
		  	  rCurrWindow[reg].nPriority);
#endif
	  SymbolTable[rCurrWindow[reg].nVar].regLoc = 0;			 /* 	Unmark old var's reg alias   */
	  EMIT(STW_REG_IMM(REG_DS, rCurrWindow[reg].nHeapOffset, reg));		 /* 	spill the register 	     */
     }
     
     SymbolTable[nVar].regLoc = reg;						 /* Update SymbolTable	    	     */
     rCurrWindow[reg].nVar = nVar;						 /* and Current Reg Window recs      */
     rCurrWindow[reg].nHeapOffset = SymbolTable[nVar].nHeapOffset;		 
     rCurrWindow[reg].nPriority = SymbolTable[nVar].nPriority;
     if (rCurrWindow[reg].nPriority != VOLATILE) {				 /* if nVar is not a VOLATILE        */
	  if (bLoad) {
	       EMIT(LDW_REG_IMM(REG_DS, rCurrWindow[reg].nHeapOffset, reg));	 /*    load it into reg	  	     */
	  }
	  InsertSpillable(reg);							 /*    and mark it as spillable	     */
     }
     *hcodCurrent = pcodNext;							 /* Update caller's code handle      */
#ifdef DEBUG
     fprintf(DEBUGFILE, "%s is in register %s\n", SYMBOLS[nVar],
	     REGISTERS[reg]);
     fflush(stderr);
#endif
     return (reg);
     
void FlushReg(REGISTER rFlush, CODEHANDLE hcodCurrent)
     CODEPTR 	pcodNext = *hcodCurrent;
     if (rCurrWindow[rFlush].nPriority != VOLATILE) {
	  EMIT(STW_REG_IMM(REG_DS, rCurrWindow[rFlush].nHeapOffset, rFlush));	 /* Store rFlush back to heap 	     */
	  *hcodCurrent = pcodNext;
     }
     SymbolTable[rCurrWindow[rFlush].nVar].regLoc = 0;
     FreeReg(rFlush);
void PushRegWindow()
     short i, j;
     SaveRegState();								 /* Save state of registers 	     */
     ResetFreeQue();
     ResetSpillQue();
     for (i = REG_L0; i <= REG_L7; i++) {					 /* Free all the new Local Registers */
	  SymbolTable[rCurrWindow[i].nVar].regLoc = 0;				 /* if nVar == 0, who cares? 	     */
	  FreeReg(i);
     }
     for (i = REG_O0, j = REG_I0; i <= REG_O5; i++, j++) {
	  SymbolTable[rCurrWindow[j].nVar].regLoc = 0;				 /* Vars in previous in register     */
										 /* become inaccessible 	     */
	  rCurrWindow[j] = rCurrWindow[i];					 /* Out registers become in regs     */
	  if (rCurrWindow[j].nVar != 0) {					 /* Update SymbolTable regLoc entries*/
	       SymbolTable[rCurrWindow[j].nVar].regLoc = j;			 /* for symbols in new In Registers  */
	       if (rCurrWindow[j].nPriority != VOLATILE) {			 /* if the var is also spillable,    */
		    InsertSpillable(j);						 /*    mark it as such 		     */
	       }
	  } else {								 /* If no symbol in new In Register, */
	       FreeReg(j);							 /* mark it as free 		     */
	  }
     }
     for (i = REG_O0; i <= REG_O5; i++) {					 /* Free all the new Out Registers,  */
	  SymbolTable[rCurrWindow[i].nVar].regLoc = 0;				 /* except SP and DS  		     */
	  FreeReg(i);
     }
     
     for (i = REG_G1; i <= REG_G6; i++) {					 /* Since we reset the free and spil */
	  if (rCurrWindow[i].nVar == 0) {					 /* queues, add unused global regs   */
	       FreeReg(i);							 /* to the appropriate queues 	     */
	  } else {
	       if (rCurrWindow[i].nPriority != VOLATILE) {
		    InsertSpillable(i);
	       }
	  }
     }
     
struct tag_regRec {
     REGENTRY rWindow[MREGS];
     struct tag_regRec *precPrev;
typedef struct tag_regRec REGREC;
REGREC *precTOS = NULL;
void PopRegWindow(CODEHANDLE hcodCurrent)					 /* Reverse the action of PushRegWi. */
{										 /* This window's local and out regs */
     short i, j;								 /* will go out of scope, so store   */
     CODEPTR pcodNext = *hcodCurrent;						 /* any vars in there back to heap   */
										 /* In regs of this window become out*/
     ResetFreeQue();								 /* regs of prev window 	     */
     ResetSpillQue();
     /* The following loop restores the local registers to the state of the  */
     /* parent's local registers. All vars in current local registers are    */
     /* stored back to heap, and their symbol table entries updated	     */
     for (i = REG_L0; i <= REG_L7; i++) {					 /* Restore local regs to state of   */
	  if (rCurrWindow[i].nVar != 0) {					 /* previous window 		     */
	       SymbolTable[rCurrWindow[i].nVar].regLoc = 0;
	       if (rCurrWindow[i].nPriority != VOLATILE) {			 /* if this window was using reg,    */
		    EMIT(STW_REG_IMM(REG_DS,					 /* update heap 		     */
				     rCurrWindow[i].nHeapOffset, i));
	       }
	  }
	  rCurrWindow[i] = precTOS->rWindow[i];					 /* Now, restore to state of prev    */
	  if (rCurrWindow[i].nVar != 0) {					 /* window 			     */
	       SymbolTable[rCurrWindow[i].nVar].regLoc = i;
	       if (rCurrWindow[i].nPriority != VOLATILE) {
		    InsertSpillable(i);
	       }
	  } else {
	       FreeReg(i);
	  }
     }
     /* The following loop stores all vars in OUT registers back to heap     */
     /* and updates their symbol table entries. At the end of this loop, all */
     /* OUT registers are marked as empty. 				     */
     for (i = REG_O0; i <= REG_O5; i++) {					 /* Store vars in OUT regs to heap   */
	  if (rCurrWindow[i].nVar != 0) {
	       SymbolTable[rCurrWindow[i].nVar].regLoc = 0;
	       if (rCurrWindow[i].nPriority != VOLATILE) {			 /* if this window was using reg,    */
		    EMIT(STW_REG_IMM(REG_DS,					 /* update heap 		     */
				     rCurrWindow[i].nHeapOffset, i));
	       }
	       rCurrWindow[i].nVar = 0;
	       rCurrWindow[i].nPriority = 0;
	       rCurrWindow[i].nHeapOffset = 0;
	  }
     }
     /* The following loop does two things: one, it restores the OUT reg     */
     /* to the parent's state; two, it leaves the IN registers empty. Since  */
     /* popping a reg window means that the current IN registers become the  */
     /* OUT registers, this loop must do both things simultaneously. Effect  */
     /* is that any vars in IN registers which are in the parent's OUT reg   */
     /* are simply marked to be in the OUT registers. Any vars in IN reg     */
     /* which are not in the the parent's OUT reg, are restored back to heap.*/
     /* At the end of this loop, the OUT regs are back to their parent's     */
     /* state, and all the IN regs are empty, either spilled or marked to    */
     /* to the OUT regs							     */
     for (i = REG_I0, j = REG_O0; i <= REG_I5; i++, j++) {
	  if (rCurrWindow[i].nVar == precTOS->rWindow[j].nVar) {		 /* if var in IN register was inh-   */
	       rCurrWindow[j] = rCurrWindow[i];					 /* erited from parent's OUT reg,    */
	       if (rCurrWindow[j].nPriority != VOLATILE) {			 /* restore it to out reg 	     */
		    InsertSpillable(j);
	       }
	       SymbolTable[rCurrWindow[j].nVar].regLoc = j;
	  } else {								 /* var not inherited from parent    */
	       if (rCurrWindow[i].nPriority != VOLATILE) {			 /* if var not volatile		     */
		    EMIT(STW_REG_IMM(REG_DS,					 /*    restore to heap 		     */
				     rCurrWindow[i].nHeapOffset, i));
	       }
	       SymbolTable[rCurrWindow[i].nVar].regLoc = 0;			 /* update symbol table 	     */
	       rCurrWindow[j] = precTOS->rWindow[j];				 /* restore parent's var 	     */
	       if (rCurrWindow[j].nVar != 0) {					 /* if parent had a var in reg 	     */
		    SymbolTable[rCurrWindow[i].nVar].regLoc = i;		 /*    update symbol table 	     */
		    if (rCurrWindow[i].nPriority != VOLATILE) {			 /*    and spill que 		     */
			 InsertSpillable(j);
		    }
	       } else {								 /* else parent had no var in reg    */
		    FreeReg(j);							 /*    so free it 		     */
	       }
	  }
	  rCurrWindow[i].nVar = 0;
	  rCurrWindow[i].nPriority = 0;
	  rCurrWindow[i].nHeapOffset = 0;
     }
     /* The following loop restores the IN regs to the state of the parents  */
     /* It assumes that all the IN regs are currently marked empty.	     */
     for (i = REG_I0; i <= REG_I5; i++) {					 /* Restore in registers to that of  */
	  rCurrWindow[i] = precTOS->rWindow[i];					 /* parent 			     */
	  if (rCurrWindow[i].nVar == 0) {
	       FreeReg(i);
	  } else {
	       if (rCurrWindow[i].nPriority != VOLATILE) {
		    InsertSpillable(i);
	       }
	       SymbolTable[rCurrWindow[i].nVar].regLoc = i;
	  }
     }
     
     for (i = REG_G1; i <= REG_G6; i++) {					 /* Since we reset the free and spil */
	  if (rCurrWindow[i].nVar == 0) {					 /* queues, add unused global regs   */
	       FreeReg(i);							 /* to the appropriate queues 	     */
	  } else {
	       if (rCurrWindow[i].nPriority != VOLATILE) {
		    InsertSpillable(i);
	       }
	  }
     }
     
     RestoreRegState(CURRENT_HANDLE);						 /* now, restore register state      */
     *hcodCurrent = pcodNext;
     
void SaveRegState()								 /* Take a snapshot of register      */
{										 /* contents. 			     */
     REGREC *precNew;
     precNew = (REGREC *) MALLOC(sizeof(REGREC), "SaveRegState");
     memcpy((char *)precNew, (char *)rCurrWindow, sizeof(REGREC));		 /* Ok, so this is a litte flaky     */
     precNew->precPrev = precTOS;
     precTOS = precNew;
void RestoreRegState(CODEHANDLE hcodCurrent)					 /* Restore state to snapshot. Only  */
{										 /* non-volatile priority registers  */
     CODEPTR pcodNext = *hcodCurrent;						 /* are guaranteed to be restored.   */
     short i;
     REGREC *precOld;
     /************************************************************************/
     /* First, save all the registers which have different variables than    */
     /* the parent.							     */
     /************************************************************************/
     
     for (i = REG_G1; i <= REG_I5; i++) {
	  if (rCurrWindow[i].nVar == 0) {
	       continue;
	  } else if (rCurrWindow[i].nVar != precTOS->rWindow[i].nVar) {
	       FlushReg(i, CURRENT_HANDLE);
	  }
     }
     /************************************************************************/
     /* Now, go through each register, and for all those registers which are */
     /* not in the same state as the parent, refresh the register	     */
     /************************************************************************/
     
     for (i = REG_G1; i <= REG_I5; i++) {
	  if (precTOS->rWindow[i].nVar == 0) {
	       continue;
	  } else if (    (precTOS->rWindow[i].nVar != rCurrWindow[i].nVar)
		      && (precTOS->rWindow[i].nPriority != VOLATILE)) {
	       EMIT( LDW_REG_IMM(REG_DS, precTOS->rWindow[i].nHeapOffset, i) );
	       rCurrWindow[i] = precTOS->rWindow[i];
	       SymbolTable[rCurrWindow[i].nVar].regLoc = i;
	  }
     }
	       
     /************************************************************************/
     /* Now, we need to refresh the state of the free and spill ques.	     */
     /************************************************************************/
     
     ResetFreeQue();
     ResetSpillQue();
     for (i = REG_L0; i <= REG_L7; i++) {
	  if (rCurrWindow[i].nVar == 0) {
	       FreeReg(i);
	  } else if (rCurrWindow[i].nPriority != VOLATILE) {
	       InsertSpillable(i);
	  }
     }
     for (i = REG_O0; i <= REG_O5; i++) {
	  if (rCurrWindow[i].nVar == 0) {
	       FreeReg(i);
	  } else if (rCurrWindow[i].nPriority != VOLATILE) {
	       InsertSpillable(i);
	  }
     }
     for (i = REG_I0; i <= REG_I5; i++) {
	  if (rCurrWindow[i].nVar == 0) {
	       FreeReg(i);
	  } else if (rCurrWindow[i].nPriority != VOLATILE) {
	       InsertSpillable(i);
	  }
     }
     for (i = REG_G1; i <= REG_G6; i++) {
	  if (rCurrWindow[i].nVar == 0) {
	       FreeReg(i);
	  } else if (rCurrWindow[i].nPriority != VOLATILE) {
	       InsertSpillable(i);
	  }
     }
     *hcodCurrent = pcodNext;
     precOld = precTOS;
     precTOS = precTOS->precPrev;
     FREE(precOld, "RestoreRegState");
}			 
void InitRegMgr()
     short i;
     REGENTRY rentNull = {0, 0, 0};
     REGREC *precOld;
     for (i = 0; i < MREGS; i++) {						 /* Mark all register entries as     */
	  rCurrWindow[i] = rentNull;						 /* NULL 			     */
     }
     while (precTOS) {								 /* Free up stack of saved states    */
	  precOld = precTOS;
	  precTOS = precTOS->precPrev;
	  FREE(precOld, "InitRegMgr");
     }
     ResetFreeQue();
     ResetSpillQue();
     for (i = REG_L0; i <= REG_L7; i++) {
	  FreeReg(i);
     }
     for (i = REG_O0; i <= REG_O5; i++) {
	  FreeReg(i);
     }
     for (i = REG_I0; i <= REG_I5; i++) {
	  FreeReg(i);
     }
     for (i = REG_G1; i <= REG_G6; i++) {					 /* Free up all registers except     */
	  FreeReg(i);								 /* FP, RA, DS, and SP 		     */
     }
     
/*****************************************************************************/
/*                                                                           */
/* Routines to manipulate free registers				     */
/*                                                                           */
/*****************************************************************************/
BYTE NumFreeRegs()
     return (NumQueElements(rqueFree));
REGISTER GetFreeReg()
     return (GetQueElement(&rqueFree));
void FreeReg(REGISTER reg)
     AddQueElement(&rqueFree, reg);
     rCurrWindow[reg].nVar = 0;
     rCurrWindow[reg].nPriority = VOLATILE;
     rCurrWindow[reg].nHeapOffset = 0;
void ResetFreeQue()
     ResetQue(&rqueFree);
/*****************************************************************************/
/*                                                                           */
/* Routines to manipulate spillable registers.				     */
/*                                                                           */
/*****************************************************************************/
REGISTER GetSpillable()
     if (NumQueElements(rqueSpillable[TEMP-1]) != 0) {				 /* Check for spillable register in  */
	  return (GetQueElement(&rqueSpillable[TEMP-1]));			 /* TEMP priority que, then LOOP_CTR,*/
     } else if (NumQueElements(rqueSpillable[LOOP_CTR-1]) != 0) {		 /* and last in GLOBAL priority que  */
	  return (GetQueElement(&rqueSpillable[LOOP_CTR-1]));
     } else if (NumQueElements(rqueSpillable[GLOBAL-1]) != 0) {
	  return (GetQueElement(&rqueSpillable[GLOBAL-1]));
     } else {
	  return (0);
     }
	   
void InsertSpillable(REGISTER reg)
     short nPriority = rCurrWindow[reg].nPriority - 1;
     
     AddQueElement(&rqueSpillable[nPriority], reg);
void ResetSpillQue()
     short i;
     
     for (i = 0; i < 4; i++) {
	  ResetQue(&rqueSpillable[i]);
     }
/*****************************************************************************/
/*                                                                           */
/* Implementation of queues of registers. Lists of Free registers and 	     */
/* registers containing different priority variables are organized as queues */
/*                                                                           */
/*****************************************************************************/
BYTE NumQueElements(REGQUE rque)
     return (rque.bNumElements);
REGISTER GetQueElement(REGQUE *prque)
     REGISTER reg;
     
     if (prque->bNumElements != 0) {
	  reg = prque->rRegQue[prque->bTail];
	  prque->bTail = (prque->bTail + 1) % MREGS;
	  prque->bNumElements--;
     } else {
	  reg = 0;
     }
     return (reg);
void AddQueElement(REGQUE *prque, REGISTER reg)
#ifdef _CAUTIOUS_
     if (prque->bNumElements < MREGS) {
#endif	  
	  prque->bNumElements++;
	  prque->rRegQue[prque->bHead] = reg;
	  prque->bHead = (prque->bHead + 1) % MREGS;
#ifdef _CAUTIOUS_	  
     } else {
	  CRITICAL_ERROR("Queue Overflow", "AddQueElement");
     }
#endif     
void ResetQue(REGQUE *prque)
     prque->bNumElements = 0;
     prque->bHead = 0;
     prque->bTail = 0;

---------------------------------------------------------------------------

#ifndef _CAM8SIMSPARCREGMGR_H_
#define _CAM8SIMSPARCREGMGR_H_
#include <CAM/CALib++.H>
#include <CAM/CAM8SimRegMgr++.H>
#include "std++.H"
/*****************************************************************************/
/********************************* DEFINES ***********************************/
/*****************************************************************************/
#define MREGS	32
/*****************************************************************************/
/*                                                                           */
/* macros for convenient addressing of SPARC registers			     */
/*                                                                           */
/*****************************************************************************/
#define REG_G0	0L
#define REG_G1	1L
#define REG_G2	2L
#define REG_G3	3L
#define REG_G4	4L
#define REG_G5	5L
#define REG_G6	6L
#define REG_G7	7L
#define REG_O0	8L
#define REG_O1	9L
#define REG_O2	10L
#define REG_O3	11L
#define REG_O4	12L
#define REG_O5	13L
#define REG_O6	14L
#define REG_O7	15L
#define REG_L0	16L
#define REG_L1	17L
#define REG_L2	18L
#define REG_L3	19L
#define REG_L4	20L
#define REG_L5	21L
#define REG_L6	22L
#define REG_L7	23L
#define REG_I0	24L
#define REG_I1	25L
#define REG_I2	26L
#define REG_I3	27L
#define REG_I4	28L
#define REG_I5	29L
#define REG_I6	30L
#define REG_I7	31L
#define REG_SP	14L								 /* Stack Pointer 		     */
#define REG_TP	15L								 /* The Temp register 		     */
#define REG_DS	07L								 /* pointer to Heap base	     */
#define REG_FP	30L								 /* Frame Pointer 		     */
#define REG_RA	31L								 /* Return Address 		     */
#ifdef __cplusplus
/*****************************************************************************/
/******************************** TEMPLATES **********************************/
/*****************************************************************************/
/*****************************************************************************/
/*************************** CLASSES & TYPEDEFS ******************************/
/*****************************************************************************/
typedef struct tag_regEntry {						 /* Describes register contents      */
  INT16	nVar;								 /*    Name (index) of variable      */
  INT16	nPriority;							 /*    Priority of variable 	     */
  INT16	nHeapOffset;							 /*    Offset into heap of variable  */
} REGENTRY;
     
typedef struct tag_regQue {
  REGISTER rRegQue[MREGS];
  BYTE bHead;
  BYTE bTail;
  BYTE bNumElements;
} REGQUE;
class CAM8SimSPARCRegMgr : public CAM8SimRegMgr {
public:
  REGENTRY rCurrWindow[MREGS];
  REGQUE rqueFree;
  REGQUE rqueSpillable[4];							 /* Que of spillable registers, one  */
										 /* que per priority 		     */
#ifdef DEBUG
  static char REGISTERS[32][64] = {
    "G0", "G1", "G2", "G3", "G4", "G5", "G6", "G7",
    "O0", "O1", "O2", "O3", "O4", "O5", "O6", "O7",
    "L0", "L1", "L2", "L3", "L4", "L5", "L6", "L7",
    "I0", "I1", "I2", "I3", "I4", "I5", "I6", "I7",
  };
  char SYMBOLS[SymbolTableSize][64];
#endif
  void InsertSpillable(REGISTER reg);
  void ResetSpillQue(void);
  void PushRegWindow(void);
  void PopRegWindow(CODEHANDLE hcodCurrent);
  void FreeReg(REGISTER reg);
  void ResetFreeQue(void);
  void AddQueElement(REGQUE *prque, REGISTER reg);
  void ResetQue(REGQUE *prque);
  BYTE NumFreeRegs(void);
  BYTE NumQueElements(REGQUE rque);
  REGISTER GetFreeReg(void);
  REGISTER GetSpillable(void);
REGISTER GetQueElement(REGQUE *prque);
/*****************************************************************************/
/********************************* INLINES ***********************************/
/*****************************************************************************/
#endif
/*****************************************************************************/
/******************************* PROTOTYPES **********************************/
/*****************************************************************************/
/*****************************************************************************/
/********************************* GLOBALS ***********************************/
/*****************************************************************************/
#endif

---------------------------------------------------------------------------

#include <CAM/CALib++.H>
#include <CAM/CamStream++.H>
#include <CAM/CamError++.H>
#include <CAM/CamTrace++.H>
#include <CAM/CAM8SimJIT++.H>
#include <CAM/CAM8SimSPARCJIT++.H>
#include "std++.H"
CAM8SimSPARCJIT::CAM8SimSPARCJIT(CAM8SimRegMgr *rm)
  regmgr = rm;
  hcodTarget = NULL;						 /* Handle to Target Code Location   */
  pcodNext = NULL;						 /* Pointer to location of next inst */
  lblNext = 0;							 /* Next Label 			     */
  pblkTOS = NULL;
CAM8SimSPARCJIT::~CAM8SimSPARCJIT(void)
/*****************************************************************************/
/*                                                                           */
/* Routines to start and end code blocks, and emit instructions into code    */
/* blocks.								     */
/*                                                                           */
/*****************************************************************************/
void NewBlock(CODEHANDLE hcodDest)
     void pushblk(void);
     
     pushblk();									 /* save code block state 	     */
     hcodTarget = hcodDest;							 /* point to new code block 	     */
     pcodNext = *hcodDest;
     lblNext = 0;
/*****************************************************************************/
/*                                                                           */
/* Translate an intermediate instruction into target code. 		     */
/*                                                                           */
/*****************************************************************************/
void Emit(INT16 opcode,
	  BYTE op1Type, LONG32 op1,
	  BYTE op2Type, LONG32 op2,
	  BYTE destType, LONG32 dest)
     char *szFuncName = "Emit";
     
#ifdef DEBUG
     DASMADDR = pcodNext;
#endif
     if (opcode & NATIVE_OP) {							 /* NATIVE INSTRUCTION 		     */
	  REGISTER rs1, rs2, rd;						 
	  switch (op1Type) {							 /* Figure out rs1 		     */
	     case NULL_OP:
	       rs1 = REG_G0;
	       break;
	     case REG_OP:
	       rs1 = (REGISTER) op1;
	       break;
	     case VAR_OP:
	       rs1 = GetReg(op1, CURRENT_HANDLE, TRUE);
	       break;
	     default:
	       CRITICAL_ERROR("Invalid argument for rs1", szFuncName);
	       break;
	  }
	  switch (destType) {							 /* Figure out the dest register     */
	     case NULL_OP:
	       rs1 = REG_G0;
	       break;
	     case REG_OP:
	       rd = (REGISTER) dest;
	       break;
	     case VAR_OP:
	       rd = GetReg(dest, CURRENT_HANDLE, FALSE);
	       break;
	     default:
	       CRITICAL_ERROR("Invalid argument for rd", szFuncName);
	       break;
	  }
	  switch (op2Type) {							 /* Figure out rs2. This is done     */
	     case REG_OP:							 /* last because rs2 might be a      */
	       rs2 = (REGISTER) op2;						 /* constant > 13 bits, and we might */
	       break;								 /* have to preload it into the dest */
	     case VAR_OP:
	       rs2 = GetReg(op2, CURRENT_HANDLE, TRUE);
	       break;
	     case CONST_OP:
	       if (((signed long) op2) > 4095 ||				 /* if op2 will not fit in 13 bits   */
		   ((signed long) op2) < -4096) {
		    EMIT( SETHI(HI22(op2), rd) );
		    EMIT( OR_REG_IMM(rd, LOW10(op2), rd) );
		    op2Type = REG_OP;
		    rs2 = rd;
	       }
	       break;
	       
	     default:
	       CRITICAL_ERROR("Invalid argument for rs2", szFuncName);
	       break;
	  }
	  opcode = opcode & NATIVE_OP_MASK;					 /* extract the target's native op-  */
										 /* code... 			     */
	  if (op2Type == CONST_OP) {
	       *pcodNext++ = FMT3_INST(0x02L, opcode, rs1, IMMEDIATE, op2, rd);	 /* and emit the instruction 	     */
	  } else {
	       *pcodNext++ = FMT3_INST(0x02L, opcode, rs1, REG_SOURCE, rs2, rd);
	  }									 /* -------------------------------- */
     } else if (opcode & LD_ST_OP) {						 /* LOAD-STORE INSTRUCTION 	     */
	  REGISTER rs1, rs2, rd;
	  switch (opcode) {
	     case LDW_MEM:							 /* bring op1 into a register 	     */
	       if (op1Type == VAR_OP) {
		    rs1 = GetReg(op1, CURRENT_HANDLE, TRUE);
	       } else {
		    CRITICAL_ERROR("Invalid LDW_MEM argument",
				   szFuncName);
	       }
	       break;
	     case LDUB_IND:
	     case LDHW_IND:
	     case LDW_IND:							 /* load indirect : dest <- [op1+op2]*/
	       if (op1Type == VAR_OP) {
		    rs1 = GetReg(op1, CURRENT_HANDLE, TRUE);
	       } else if (op1Type == REG_OP) {
		    rs1 = (REGISTER) op1;
	       } else {
		    CRITICAL_ERROR("Invalid LDW_IND argument 1",
				   szFuncName);
	       }
	       if (op2Type == VAR_OP) {
		    rs2 = GetReg(op2, CURRENT_HANDLE, TRUE);
	       } else if (op2Type == REG_OP) {
		    rs2 = (REGISTER) op2;
	       } else if (op2Type == CONST_OP) {
		    /* do nothing */
	       } else {
		    CRITICAL_ERROR("Invalid LDW_IND argument 2",
				   szFuncName);
	       }
		    
	       if (destType == VAR_OP) {
		    rd = GetReg(dest, CURRENT_HANDLE, FALSE);
	       } else if (op2Type == REG_OP) {
		    rd = (REGISTER) dest;
	       } else {
		    CRITICAL_ERROR("Invalid LDW_IND argument",
				   szFuncName);
	       }
	       
	       if (opcode == LDW_IND) {
		    (op2Type == CONST_OP) ? (EMIT( LDW_REG_IMM(rs1, op2, rd) )) :
		      (EMIT( LDW_REG_REG(rs1, rs2, rd)));
	       } else if (opcode == LDHW_IND) {
		    (op2Type == CONST_OP) ? (EMIT( LDHW_REG_IMM(rs1, op2, rd) )) :
		      (EMIT( LDHW_REG_REG(rs1, rs2, rd)));	
	       } else {
		    (op2Type == CONST_OP) ? (EMIT( LDUB_REG_IMM(rs1, op2, rd) )) :
		      (EMIT( LDUB_REG_REG(rs1, rs2, rd) ));
	       }
	       break;
	       
	     case STW_MEM:							 /* flush op1 to memory 	     */
	       if (op1Type == VAR_OP) {
		    rs1 = GetReg(op1, CURRENT_HANDLE, TRUE);			 /* 	hopefully, op1 is already    */
		    FlushReg(rs1, CURRENT_HANDLE);				 /* 	in a register!		     */
	       } else {
		    CRITICAL_ERROR("Invalid STW_MEM argument",
				   szFuncName);
	       }
	       break;
	     case STUB_IND:
	     case STHW_IND:
	     case STW_IND:							 /* store indirect: [op1+op2] <- dest*/
	       if (op1Type == VAR_OP) {						 /* 	get op1 - var or reg 	     */
		    rs1 = GetReg(op1, CURRENT_HANDLE, TRUE);
	       } else if (op1Type == REG_OP) {
		    rs1 = (REGISTER) op1;
	       } else {
		    CRITICAL_ERROR("Invalid STW_IND argument",
				   szFuncName);
	       }
	       if (op2Type == VAR_OP) {						 /* 	get op2 - var, reg, or const */
		    rs2 = GetReg(op2, CURRENT_HANDLE, TRUE);
	       } else if (op2Type == REG_OP) {
		    rs2 = (REGISTER) op2;
	       } else if (op2Type == CONST_OP) {
		    /* do nothing */
	       } else {
		    CRITICAL_ERROR("Invalid LDW_IND argument 2",
				   szFuncName);
	       }
		    
	       if (destType == VAR_OP) {					 /* 	get dest - var or reg 	     */
		    rd = GetReg(dest, CURRENT_HANDLE, TRUE);
	       } else if (op2Type == REG_OP) {
		    rd = (REGISTER) dest;
	       } else {
		    CRITICAL_ERROR("Invalid STW_IND argument",
				   szFuncName);
	       }
	       if (opcode == STW_IND) {
		    (op2Type == CONST_OP) ? (EMIT( STW_REG_IMM(rs1, op2, rd))) :
		      (EMIT( STW_REG_REG(rs1, rs2, rd)));
	       } else if (opcode == STHW_IND) {
		    (op2Type == CONST_OP) ? (EMIT( STHW_REG_IMM(rs1, op2, rd))) :
		      (EMIT( STHW_REG_REG(rs1, rs2, rd)));
	       } else {
		    (op2Type == CONST_OP) ? (EMIT( STUB_REG_IMM(rs1, op2, rd))) :
		      (EMIT( STUB_REG_REG(rs1, rs2, rd)));
	       }
	       break;
	       
	     default:
	       CRITICAL_ERROR("Unknown Load Store operation",
			      szFuncName);
	       break;
	  }									 /* -------------------------------- */
     } else if (opcode & BRANCH_OP) {						 /* BRANCH INSTRUCTION 		     */
	  LABELREC	*plblrecBranch;
	  LONG32	lDisp;
	  opcode &= NATIVE_OP_MASK;						 /* extract the native branch code   */
	  if (op1Type == LABEL_OP) {
	       if ((plblrecBranch = FindLabel((CODELABEL) op1)) != NULL) {	 /* if label was encountered before  */
		    CODEPTR pcodBranchLoc = GetLabelAddress(plblrecBranch);	 /*     Get address of branch loc    */
		    if (!pcodBranchLoc) {					 /* 	if label's addrss is unknown */
			 AddLabelRef(plblrecBranch, CURRENT_LOC);		 /* 	   add a ref record. 	     */
			 lDisp = 0;						 /* 	   dummy disp 		     */
		    } else {							 /*     else label's addr is known   */
			 lDisp = pcodBranchLoc - CURRENT_LOC;			 /*        calculate displacement    */
		    }
		    EMIT( BRANCH_INST(0, opcode, lDisp) );			 /* 	Emit branch instruction      */
	       } else {								 /* Label was not encountered before */
		    plblrecBranch = AddLabel((CODELABEL) op1, 0, FALSE);	 /* 	So create new record 	     */
		    AddLabelRef(plblrecBranch, CURRENT_LOC);			 /* 	add a ref record to it 	     */
		    EMIT( BRANCH_INST(0, opcode, 0) );				 /* 	emit filler branch instr     */
	       }
	  } else {
	       CRITICAL_ERROR("Branch to a non-label", szFuncName);
	  }									 /* -------------------------------- */
     } else {									 /* PSEUDO INSTRUCTION 		     */
	  switch (opcode) {
	     case INSTR:							 /* op1 is a valid sparc instruction */
	       EMIT( op1 );							 /* 	simply insert it 	     */
	       break;								 /* 	useful to fill delay slots   */
	       
	     case ENTER_PROC:							 /* procedure entry prologue 	     */
	       PushRegWindow();							 /*     Inform register manager of   */
	       if (op1Type == CONST_OP) {					 /*     new register window 	     */
		    EMIT( SAVE_REG_IMM(REG_SP, -112-8-op1, REG_SP) );		 /* 	-112 is gcc's local frame    */
	       } else {								 /*     and we need 2 words to save  */
		    EMIT( SAVE_REG_IMM(REG_SP, -112-8, REG_SP) );		 /* 	our own fp and return addr   */
	       }								 /*     registers. 		     */
	       EMIT( STW_REG_IMM(REG_SP, 72, REG_G7) );				 /* 	sp+8 = our fp register       */
	       EMIT( STW_REG_IMM(REG_SP, 68, REG_RA) );				 /* 	sp+4 = our return address    */
	       EMIT( SETHI(HI22(pcHeap), REG_DS) );				 /* 	make ds point to heap base   */
	       if ( LOW10(pcHeap) != 0) {
		    EMIT( OR_REG_IMM(REG_DS, LOW10(pcHeap), REG_DS) );
	       }
	       break;
	       
	     case RETURN_PROC:							 /* return from procedure 	     */
	       PopRegWindow(CURRENT_HANDLE);					 /* 	restore reg. window 	     */
	       EMIT( LDW_REG_IMM(REG_SP, 72, REG_G7) );				 /* 	restore saved fp register    */
	       EMIT( LDW_REG_IMM(REG_SP, 68, REG_RA) );				 /* 	restore our return address   */
	       EMIT( RET );							 /* 	return from procedure	     */
	       EMIT( RESTORE );							 /* 	and restore the reg window   */
	       break;
	       
	     case CALL_PROC:							 /* call a procedure 		     */
	       if (op1Type == ADDR_OP) {
		    op1 -= (LONG32) pcodNext;
		    EMIT( CALL(op1) );						 /* 	call procedure at addr op1   */
	       } else {
		    CRITICAL_ERROR("Invalid procedure call", szFuncName);
	       }
	       break;
	     case ENTER_LEAF:							 /* leaf procedure entry 	     */
	       SaveRegState();							 /*     Save all the live registers  */
	       break;
	     case RETURN_LEAF:							 /* return from leaf procedure 	     */
	       RestoreRegState(CURRENT_HANDLE);					 /*  	Restore live registers	     */
	       EMIT( RETL );							 /*     return to caller 	     */
	       EMIT( NOP );							 /* 	delay slot 		     */
	       break;
	       
	     case CALL_LEAF:							 /* call a leaf procedure 	     */
	       if (op1Type == ADDR_OP) {
		    EMIT( SETHI(HI22(op1), REG_RA) );
		    EMIT( CALL_REG_IMM(REG_RA, LOW10(op1)) );
	       } else {
		    CRITICAL_ERROR("Invalid leaf procedure call",
				   szFuncName);
	       }
	       break;
	     case CALL_LEAF_IND: {
		  REGISTER rs1, rs2, rd;
		  
		  if (op1Type == VAR_OP) {
		       rs1 = GetReg(op1, CURRENT_HANDLE, TRUE);
		  } else {
		       CRITICAL_ERROR("Invalid op1 : indirect leaf procedure call",
				      szFuncName);
		  }
		  if (op2Type == CONST_OP) {
		       /* do nothing */
		  } else if (op2Type != NULL_OP) {
		       CRITICAL_ERROR("Invalid op2 : indirect leaf procedure call",
		       		      szFuncName);
		  } 
		  
		  EMIT( CALL_REG_IMM(rs1, op2) );
	       }
	       break;
		       
		       
	     case ENTER_BASICBLK:
	       SaveRegState();
	       break;
	     case RETURN_BASICBLK:
	       RestoreRegState(CURRENT_HANDLE);
	       break;
	       
	     case ADD_LABEL:							 /* define a label 		     */
	       if (op1Type == LABEL_OP) {
		    LABELREC *plblrec;
		    
		    if ((plblrec = FindLabel((CODELABEL) op1)) == NULL) {	 /* 	if first time seeing label   */
			 AddLabel((CODELABEL) op1, CURRENT_LOC, TRUE);		 /* 	   add a new label record    */
		    } else {							 /* 	else  			     */
			 ResolveRefs(plblrec, CURRENT_LOC);			 /* 	   resolve all refs to label */
		    }
	       } else {
		    CRITICAL_ERROR("Invalid operand to ADD_LABEL",		
				   szFuncName);
	       }
	       break;
	     case NO_OP:
	       EMIT( NOP );
	       break;
	       
	     default:
	       CRITICAL_ERROR("Unknown pseudo-op", szFuncName);
	       break;
     }
CODELABEL NewLabel()
     return (lblNext++);
void EndBlock()
     void popblk(void);
     FreeLabels();								 /* Free up all label records 	     */
     *pcodNext = 0L;								 
     *hcodTarget = pcodNext;							 /* Update caller's code handle      */
     popblk();									 /* Restore previous block state     */
/*****************************************************************************/
/*                                                                           */
/* Utilities for managing labels and references to labels.		     */
/*                                                                           */
/*****************************************************************************/
LABELREC *AddLabel(CODELABEL lblName, CODEPTR pcodLabelLoc, BOOL bValid)
     LABELREC	*plblrecNew;
     plblrecNew = (LABELREC *) MALLOC(sizeof(LABELREC), "AddLabel");
     plblrecNew->lblName = lblName;
     if ((plblrecNew->bValid = bValid) == TRUE) {
	  plblrecNew->lAddress = pcodLabelLoc;
     }
     plblrecNew->precNext = plblrecFirst;
     plblrecNew->prefFirst = NULL;
     plblrecFirst = plblrecNew;
     return (plblrecNew);
LABELREC *FindLabel(CODELABEL lblName)
     LABELREC *plblrecNext;
     for (plblrecNext = plblrecFirst;
	  (plblrecNext != NULL) && (plblrecNext->lblName != lblName);
	  plblrecNext = plblrecNext->precNext);
     return (plblrecNext);
CODEPTR GetLabelAddress(LABELREC *plblrec)
     if (plblrec->bValid) {
	  return (plblrec->lAddress);
     } else {
	  return (NULL);
     }
void AddLabelRef(LABELREC *plblrec, CODEPTR lAddress)
     LABELREF *prefNew;
     prefNew = (LABELREF *) MALLOC(sizeof(LABELREF), "AddLabelRef");
     prefNew->pcodRefLoc = lAddress;
     prefNew->prefNext = plblrec->prefFirst;
     plblrec->prefFirst = prefNew;
void ResolveRefs(LABELREC *plblrec, CODEPTR lAddress)
     if (plblrec->bValid == TRUE) {
	  WARNING("Possible redefinition of label", "ResolveRefs");
     } else {
	  LABELREF *prefNext;
	  CODEPTR pcodRefLoc;
	  LONG32 lDisp;
	  plblrec->bValid = TRUE;						 /* update label record for future   */
	  plblrec->lAddress = lAddress;						 /* reference resolutions 	     */
	  do {									 /* Now, update all references.      */
	       prefNext = plblrec->prefFirst;					 /* Assume at least one reference!   */
	       pcodRefLoc = prefNext->pcodRefLoc;				 
	       lDisp = lAddress - pcodRefLoc;					 /* calculate displacement 	     */
	       lDisp &= 0x3FFFFF;						 /* least sig 22 bits only 	     */
	       *pcodRefLoc |= lDisp;						 /* and patch the refering instruct  */
	       plblrec->prefFirst = prefNext->prefNext;
	       FREE(prefNext, "ResolveRefs");					 /* release the reference record     */
	  } while (plblrec->prefFirst != NULL);
     }
     
void FreeLabels()
     LABELREC *plblrec;
     while (plblrecFirst != NULL) {
	  plblrec = plblrecFirst;
	  plblrecFirst = plblrec->precNext;
	  FREE(plblrec, "FreeLabels");
     }
void PrintAsm(CODEPTR pcodSource, FILE *fOut)
  CODEPTR pcod;
  unsigned short op;
  for (pcod = pcodSource; *pcod != 0; pcod++) {
    
    fprintf(fOut, "0x%x: ", pcod);
    
    op = (*pcod >> 30) & 0x3L;
    switch (op) {
    case 0:
      Fmt2Instr(*pcod, fOut);
      break;
      
    case 1:
      Fmt1Instr(*pcod, fOut);
      break;
      
    case 2:
    case 3:
      Fmt3Instr(*pcod, fOut);
      break;
    }
/*****************************************************************************/
/*                                                                           */
/* Simple stack manager for pushing and pop-ing code block states.	     */
/*                                                                           */
/*****************************************************************************/
void pushblk()
     CODEBLK *pNew;
     pNew = MALLOC(sizeof(CODEBLK), "icode : pushblk");
     pNew->hcodTarget = hcodTarget;
     pNew->pcodNext = pcodNext;
     pNew->lblNext = lblNext;
     pNew->plblrecFirst = plblrecFirst;
     
     pNew->pblkPrev = pblkTOS;
     pblkTOS = pNew;
     plblrecFirst = NULL;
void popblk()
     CODEBLK *pblkOld;
     if (!pblkTOS) {
	  CRITICAL_ERROR("I-Code Block stack underflow", "popblk");
     }
     hcodTarget = pblkTOS->hcodTarget;
     pcodNext = pblkTOS->pcodNext;
     lblNext = pblkTOS->lblNext;
     plblrecFirst = pblkTOS->plblrecFirst;
     pblkOld = pblkTOS;
     pblkTOS = pblkTOS->pblkPrev;
     FREE(pblkOld, "popblk");
void Fmt1Instr(INSTRUCTION instr, FILE *fOut)
  fprintf(fOut, "CALL \t%x\n", (instr & 0x3FFFFFFFL));
void Fmt2Instr(INSTRUCTION instr, FILE *fOut)
  unsigned short op2, cc, rd;
  signed long disp;
  op2 = (instr >> 22) & 0x7L;
  if (op2 == 4) {								 /* SETHI 			     */
    unsigned long hi22;
    hi22 = (instr << 10);
    rd = (instr >> 25) & 0x1FL;
    fprintf(fOut,"SETHI \t%s, \t%x (%x)\n", szRegName[rd],
	    (instr & 0x003FFFFFL), hi22);
  } else if (op2 == 2) {							 /* BRANCH 			     */
    cc = (instr >> 25) & 0xFL;
    if (instr & 0x00200000L) {
      disp = instr | 0xFFC00000L;
    } else {
      disp = instr & 0x1FFFFF;
    }
    fprintf(fOut,"BR%s \t%d\n", szCCName[cc], disp);
  } else {
    fprintf(fOut,"UNIMP BR : %x\n", instr);
void Fmt3Instr(INSTRUCTION instr, FILE *fOut)
  unsigned short majorOp, opcode, imm, rs1, rs2, rd;
  signed long lConst;
  majorOp = (instr >> 30) & 0x3L;
  opcode = (instr >> 19) & 0x3FL;
  rd = (instr >> 25) & 0x1FL;
  rs1 = (instr >> 14) & 0x1FL;
  rs2 = instr & 0x1FL;
  imm = (instr >> 13) & 0x1L;
  if (imm) {
    if (instr & 0x00001000L) {
      lConst = (instr | 0xFFFFF000L);
    } else {
      lConst = (instr & 0xFFFL);
    }
  if (majorOp == 3) {							 /* LOAD-STORE 			     */
    switch (opcode) {
    case OP_LDW:
      fprintf(fOut,"LDW ");
      break;
    case OP_LDHW:
      fprintf(fOut,"LDHW ");
      break;
    case OP_LDUB:
      fprintf(fOut,"LDUB ");
      break;
    case OP_STW:
      fprintf(fOut,"STW ");
      break;
    case OP_STUB:
      fprintf(fOut,"STUB ");
      break;
      
    default:
      fprintf(fOut,"UNIMP LOAD-STORE : %x\n", instr);
      return;
      break;
    };
  } else {									 /* ARITHMETIC 			     */
    switch (opcode) {
    case OP_ADD:
      fprintf(fOut,"ADD ");
      break;
    case OP_ADDcc:
      fprintf(fOut,"ADDcc ");
      break;
    case OP_ADDX:
      fprintf(fOut,"ADDX ");
      break;
    case OP_ADDXcc:
      fprintf(fOut,"ADDXcc ");
      break;
      
    case OP_SUB:
      fprintf(fOut,"SUB ");
      break;
    case OP_SUBcc:
      fprintf(fOut,"SUBcc ");
      break;
    case OP_SUBX:
      fprintf(fOut,"SUBX ");
      break;
    case OP_SUBXcc:
      fprintf(fOut,"SUBXcc ");
      break;
      
    case OP_AND:							 /* LOGICAL 			     */
      fprintf(fOut,"AND ");
      break;
    case OP_ANDcc:
      fprintf(fOut,"ANDcc ");
      break;
    case OP_ANDN:
      fprintf(fOut,"ANDN ");
      break;
    case OP_ANDNcc:
      fprintf(fOut,"ANDNcc ");
      break;
      
    case OP_OR:
      fprintf(fOut,"OR ");
      break;
    case OP_ORcc:
      fprintf(fOut,"ORcc ");
      break;
    case OP_ORN:
      fprintf(fOut,"ORN ");
      break;
    case OP_ORNcc:
      fprintf(fOut,"ORNcc ");
      break;
      
    case OP_XOR:
      fprintf(fOut,"XOR ");
      break;
    case OP_XORcc:
      fprintf(fOut,"XORcc ");
      break;
    case OP_XNOR:
      fprintf(fOut,"XNOR ");
      break;
    case OP_XNORcc:
      fprintf(fOut,"XNORcc ");
      break;
      
      
    case OP_SLL:
      fprintf(fOut,"SLL ");
      break;
    case OP_SRL:
      fprintf(fOut,"SRL ");
      break;
    case OP_SRA:
      fprintf(fOut,"SRA ");
      break;
      
    case OP_JMPL:							 /* CONTROL TRANSFER 		     */
      fprintf(fOut,"JMPL ");
      break;
    case OP_SAVE:
      fprintf(fOut,"SAVE ");
      break;
    case OP_RESTORE:
      fprintf(fOut,"RESTOR");
      break;
      
    default:
      fprintf(fOut,"UNIMP LOGICAL-ARITH : %x\n", instr);
      return;
      break;
    };
  if (imm) {
    fprintf(fOut,"\t%s \t%d \t%s\n", szRegName[rs1], lConst, szRegName[rd]);
  } else {
    fprintf(fOut,"\t%s \t%s \t%s\n", szRegName[rs1], szRegName[rs2],
	    szRegName[rd]);

---------------------------------------------------------------------------

#ifndef _CAM8SIMSPARCJIT_H_
#define _CAM8SIMSPARCJIT_H_
#include <CAM/CALib++.H>
#include <CAM/CAM8SimSPARCRegMgr++.H>
#include "std++.H"
/*****************************************************************************/
/********************************* DEFINES ***********************************/
/*****************************************************************************/
#define OP_LDW		0x00L
#define OP_LDHW		0x02L
#define OP_LDUB		0x01L
#define OP_STW		0x04L
#define OP_STUB		0x05L
#define OP_STHW		0x06L
#define OP_ADD		0x00L
#define OP_ADDcc	0x10L
#define OP_ADDX		0x08L
#define OP_ADDXcc	0x18L
#define	OP_SUB		0x04L
#define OP_SUBcc	0x14L
#define OP_SUBX		0x0CL
#define OP_SUBXcc	0x1CL
#define OP_AND		0x01L
#define OP_ANDcc	0x11L
#define OP_ANDN		0x05L
#define OP_ANDNcc	0x15L
#define OP_OR		0x02L
#define OP_ORcc 	0x12L
#define OP_ORN		0x06L
#define OP_ORNcc	0x16L
#define OP_XOR		0x03L
#define OP_XORcc 	0x13L
#define OP_XNOR		0x07L
#define OP_XNORcc	0x17L
#define OP_SLL		0x25L
#define OP_SRL		0x26L
#define OP_SRA		0x27L
#define OP_SETHI	0x04L
#define OP_JMPL		0x38L
#define OP_SAVE		0x3CL
#define OP_RESTORE	0x3DL
#define IMMEDIATE	1
#define REG_SOURCE	0
#define FMT2_INST(op, opcode, k, rd) 	(((op) << 30) | \
					 ((opcode) << 22) | \
					 ((rd) << 25) | \
					 ((k) & 0x3fffffL))
#define FMT3_INST(op, opcode, rs1, i, rs2, rd) (((op) << 30) | \
						((rd) << 25) | \
						((opcode) << 19) | \
		       				((rs1) << 14) | \
						((i) << 13) | \
						((rs2) & 0x1FFFL))
#define SAVE_REG_IMM(rs1, k, rd)	(FMT3_INST(0x2L, OP_SAVE, (rs1), IMMEDIATE, (k), (rd)))
#define SAVE_REG_REG(rs1, rs2, rd)	(FMT3_INST(0x2L, OP_SAVE, (rs1), REG_SOURCE, (rs2), (rd)))
#define RESTORE				(FMT3_INST(0x2L, OP_RESTORE, REG_G0, REG_SOURCE, REG_G0, REG_G0))
#define RET				(FMT3_INST(0x2L, OP_JMPL, REG_I7, IMMEDIATE, 8, REG_G0))
#define RETL				(FMT3_INST(0x2L, OP_JMPL, REG_O7, IMMEDIATE, 8, REG_G0))
#define CALL_REG(r)			(FMT3_INST(0x2L, OP_JMPL, (r), IMMEDIATE, 0, REG_O7))
#define CALL_REG_IMM(r, k) 		(FMT3_INST(0x2L, OP_JMPL, (r), IMMEDIATE, (k), REG_O7))
#define CALL(disp)			((0x01 << 30) | (((unsigned long) (disp)) >> 2))
#define NOP				(FMT3_INST(0x2L, OP_OR, REG_G0, REG_SOURCE, REG_G0, REG_G0))
#define LDW_REG_IMM(rs1, k, rd) 	(FMT3_INST(0x3L, OP_LDW, rs1, IMMEDIATE, k, rd))
#define LDW_REG_REG(rs1, rs2, rd) 	(FMT3_INST(0x3L, OP_LDW, rs1, REG_SOURCE, rs2, rd))
#define LDHW_REG_IMM(rs1, k, rd) 	(FMT3_INST(0x3L, OP_LDHW, rs1, IMMEDIATE, k, rd))
#define LDHW_REG_REG(rs1, rs2, rd) 	(FMT3_INST(0x3L, OP_LDHW, rs1, REG_SOURCE, rs2, rd))
#define LDUB_REG_IMM(rs1, k, rd) 	(FMT3_INST(0x3L, OP_LDUB, rs1, IMMEDIATE, k, rd))
#define LDUB_REG_REG(rs1, rs2, rd) 	(FMT3_INST(0x3L, OP_LDUB, rs1, REG_SOURCE, rs2, rd))
#define STW_REG_IMM(rs1, k, rd) 	(FMT3_INST(0x3L, OP_STW, rs1, IMMEDIATE, k, rd))
#define STW_REG_REG(rs1, rs2, rd) 	(FMT3_INST(0x3L, OP_STW, rs1, REG_SOURCE, rs2, rd))
#define STHW_REG_IMM(rs1, k, rd) 	(FMT3_INST(0x3L, OP_STHW, rs1, IMMEDIATE, k, rd))
#define STHW_REG_REG(rs1, rs2, rd) 	(FMT3_INST(0x3L, OP_STHW, rs1, REG_SOURCE, rs2, rd))
#define STUB_REG_IMM(rs1, k, rd) 	(FMT3_INST(0x3L, OP_STUB, rs1, IMMEDIATE, k, rd))
#define STUB_REG_REG(rs1, rs2, rd) 	(FMT3_INST(0x3L, OP_STUB, rs1, REG_SOURCE, rs2, rd))
#define ADD_REG_IMM(rs1, k, rd) 	(FMT3_INST(0x2L, OP_ADD, rs1, IMMEDIATE, k, rd))
#define ADD_REG_REG(rs1, rs2, rd) 	(FMT3_INST(0x2L, OP_ADD, rs1, REG_SOURCE, rs2, rd))
#define ADDcc_REG_IMM(rs1, k, rd) 	(FMT3_INST(0x2L, OP_ADDcc, rs1, IMMEDIATE, k, rd))
#define ADDcc_REG_REG(rs1, rs2, rd) 	(FMT3_INST(0x2L, OP_ADDcc, rs1, REG_SOURCE, rs2, rd))
#define ADDX_REG_IMM(rs1, k, rd) 	(FMT3_INST(0x2L, OP_ADDX, rs1, IMMEDIATE, k, rd))
#define ADDX_REG_REG(rs1, rs2, rd) 	(FMT3_INST(0x2L, OP_ADDX, rs1, REG_SOURCE, rs2, rd))
#define ADDXcc_REG_IMM(rs1, k, rd) 	(FMT3_INST(0x2L, OP_ADDXcc, rs1, IMMEDIATE, k, rd))
#define ADDXcc_REG_REG(rs1, rs2, rd) 	(FMT3_INST(0x2L, OP_ADDXcc, rs1, REG_SOURCE, rs2, rd))
#define SUB_REG_IMM(rs1, k, rd) 	(FMT3_INST(0x2L, OP_SUB, rs1, IMMEDIATE, k, rd))
#define SUB_REG_REG(rs1, rs2, rd) 	(FMT3_INST(0x2L, OP_SUB, rs1, REG_SOURCE, rs2, rd))
#define SUBcc_REG_IMM(rs1, k, rd) 	(FMT3_INST(0x2L, OP_SUBcc, rs1, IMMEDIATE, k, rd))
#define SUBcc_REG_REG(rs1, rs2, rd) 	(FMT3_INST(0x2L, OP_SUBcc, rs1, REG_SOURCE, rs2, rd))
#define SUBX_REG_IMM(rs1, k, rd) 	(FMT3_INST(0x2L, OP_SUBX, rs1, IMMEDIATE, k, rd))
#define SUBX_REG_REG(rs1, rs2, rd) 	(FMT3_INST(0x2L, OP_SUBX, rs1, REG_SOURCE, rs2, rd))
#define SUBXcc_REG_IMM(rs1, k, rd) 	(FMT3_INST(0x2L, OP_SUBXcc, rs1, IMMEDIATE, k, rd))
#define SUBXcc_REG_REG(rs1, rs2, rd) 	(FMT3_INST(0x2L, OP_SUBXcc, rs1, REG_SOURCE, rs2, rd))
#define AND_REG_IMM(rs1, k, rd) 	(FMT3_INST(0x2L, OP_AND, rs1, IMMEDIATE, k, rd))
#define AND_REG_REG(rs1, rs2, rd) 	(FMT3_INST(0x2L, OP_AND, rs1, REG_SOURCE, rs2, rd))
#define OR_REG_IMM(rs1, k, rd) 		(FMT3_INST(0x2L, OP_OR, rs1, IMMEDIATE, k, rd))
#define OR_REG_REG(rs1, rs2, rd) 	(FMT3_INST(0x2L, OP_OR, rs1, REG_SOURCE, rs2, rd))
#define XOR_REG_IMM(rs1, k, rd) 	(FMT3_INST(0x2L, OP_XOR, rs1, IMMEDIATE, k, rd))
#define XOR_REG_REG(rs1, rs2, rd) 	(FMT3_INST(0x2L, OP_XOR, rs1, REG_SOURCE, rs2, rd))
#define XNOR_REG_IMM(rs1, k, rd) 	(FMT3_INST(0x2L, OP_XNOR, rs1, IMMEDIATE, k, rd))
#define XNOR_REG_REG(rs1, rs2, rd) 	(FMT3_INST(0x2L, OP_XNOR, rs1, REG_SOURCE, rs2, rd))
#define NOT_REG(r)			(XNOR_REG_REG(r, REG_G0, r))
#define SLL_REG_IMM(rs1, k, rd) 	(FMT3_INST(0x2L, OP_SLL, rs1, IMMEDIATE, k, rd))
#define SLL_REG_REG(rs1, rs2, rd) 	(FMT3_INST(0x2L, OP_SLL, rs1, REG_SOURCE, rs2, rd))
#define SRL_REG_IMM(rs1, k, rd) 	(FMT3_INST(0x2L, OP_SRL, rs1, IMMEDIATE, k, rd))
#define SRL_REG_REG(rs1, rs2, rd) 	(FMT3_INST(0x2L, OP_SRL, rs1, REG_SOURCE, rs2, rd))
#define HI22(k) 			((((unsigned long) (k)) >> 10) & 0x3fffffL)
#define LOW10(k) 			(((unsigned long) (k)) & 0x3ffL)
#define SETHI(k, rd) 			(FMT2_INST(0x0L, OP_SETHI, k, rd))
/******************************************************************************
 * The branch instructions.
 *****************************************************************************/
#define BRANCH_INST(annul, cond, disp)	(((annul) << 29) | ((cond) << 25) | (0x800000) | ((disp) & 0x3FFFFF))
#define BRA(disp)			(BRANCH_INST(0, 0x8, disp))
#define BRN(disp)			(BRANCH_INST(0, 0x0, disp))
#define BRNE(disp)			(BRANCH_INST(0, 0x9, disp))
#define BRE(disp)			(BRANCH_INST(0, 0x1, disp))
#define BRG(disp)			(BRANCH_INST(0, 0xA, disp))
#define BRLE(disp)			(BRANCH_INST(0, 0x2, disp))
#define BRGE(disp)			(BRANCH_INST(0, 0xB, disp))
#define BRL(disp)			(BRANCH_INST(0, 0x3, disp))
#define BRGU(disp)			(BRANCH_INST(0, 0xC, disp))
#define BRLEU(disp)			(BRANCH_INST(0, 0x4, disp))
#define BRCC(disp)			(BRANCH_INST(0, 0xD, disp))
#define BRCS(disp)			(BRANCH_INST(0, 0x5, disp))
#define BRPOS(disp)			(BRANCH_INST(0, 0xE, disp))
#define BRNEG(disp)			(BRANCH_INST(0, 0x6, disp))
#define BRVC(disp)			(BRANCH_INST(0, 0xF, disp))
#define BRVS(disp)			(BRANCH_INST(0, 0x7, disp))
#define BRNZ(disp)			(BRANCH_INST(0, 0x9, disp))
#define BRZ(disp)			(BRANCH_INST(0, 0x1, disp))
/*****************************************************************************/
/*                                                                           */
/* Macros to insert target instructions etc.				     */
/*                                                                           */
/*****************************************************************************/
#define EMIT(inst)			*pcodNext++ = (inst)
#define CURRENT_LOC			(pcodNext)
#define CURRENT_HANDLE			(&pcodNext)
#ifdef __cplusplus
/*****************************************************************************/
/******************************** TEMPLATES **********************************/
/*****************************************************************************/
/*****************************************************************************/
/*************************** CLASSES & TYPEDEFS ******************************/
/*****************************************************************************/
typedef struct tag_codeblk {
     CODEHANDLE hcodTarget;
     CODEPTR    pcodNext;
     CODELABEL	lblNext;
     LABELREC   *plblrecFirst;
     struct tag_codeblk *pblkPrev;
} CODEBLK;
typedef struct tag_lblref {
     CODEPTR	pcodRefLoc;
     struct tag_lblref *prefNext;
} LABELREF;									 /* record of a reference to a label */
typedef struct tag_lblrec {
     INT16	lblName;
     BYTE	bValid;
     CODEPTR	lAddress;
     struct tag_lblref *prefFirst;
     struct tag_lblrec *precNext;
} LABELREC;									 /* record of a label 		     */
typedef unsigned long INSTRUCTION;
class CAM8SimSPARCJIT : CAM8SimJIT {
public:
  static const char *szRegName[] = {
    "%g0", "%g1", "%g2", "%g3", "%g4", "%g5", "%g6", "%g7",
    "%o0", "%o1", "%o2", "%o3", "%o4", "%o5", "%sp", "%tp",
    "%l0", "%l1", "%l2", "%l3", "%l4", "%l5", "%l6", "%l7",
    "%i0", "%i1", "%i2", "%i3", "%i4", "%i5", "%ds", "%ra"
  };
  static const char *szCCName[] = {
    "NEVER", "EQ", "LE", "L", "LEU", "CS", "NEG", "VS",
    "ALWAYS", "NEQ", "G", "GE", "GU", "CC", "POS", "VC"
  };
  LABELREC *plblrecFirst;
  CODEHANDLE hcodTarget;							 /* Handle to Target Code Location   */
  CODEPTR pcodNext;								 /* Pointer to location of next inst */
  CODELABEL lblNext;								 /* Next Label 			     */
  CODEBLK *pblkTOS;
  void AddLabelRef(LABELREC *plblrec, CODEPTR lAddress) = 0;			 /* Add a reference to a label 	     */
  void ResolveRefs(LABELREC *plblrec, CODEPTR lAddress) = 0;			 /* Resolve all references to a labl */
  void FreeLabels(void) = 0;							 /* Free all storage used by labels  */
  CODELABEL NewLabel() = 0;
  CODEPTR GetLabelAddress(LABELREC *plblrec) = 0;				 /* Returns label's address 	     */
  LABELREC *AddLabel(CODELABEL lblName, CODEPTR pcodLabelLoc, BOOL bValid) = 0;	 /* Add a new label record 	     */
  LABELREC *FindLabel(CODELABEL lblName) = 0;					 /* Find a label 		     */
/*****************************************************************************/
/********************************* INLINES ***********************************/
/*****************************************************************************/
#endif
/*****************************************************************************/
/******************************* PROTOTYPES **********************************/
/*****************************************************************************/
/*****************************************************************************/
/********************************* GLOBALS ***********************************/
/*****************************************************************************/
#endif

---------------------------------------------------------------------------

#ifndef _CAM8SIMREGMGR_H_
#define _CAM8SIMREGMGR_H_
#include <CAM/CALib++.H>
#include <CAM/CAM8SimJIT++.H>
#include "std++.H"
/*****************************************************************************/
/********************************* DEFINES ***********************************/
/*****************************************************************************/
#ifdef __cplusplus
/*****************************************************************************/
/******************************** TEMPLATES **********************************/
/*****************************************************************************/
/*****************************************************************************/
/*************************** CLASSES & TYPEDEFS ******************************/
/*****************************************************************************/
typedef unsigned long REGISTER;
class CAM8SimRegMgr {
public:
  virtual void InitRegMgr(void) = 0;
  virtual REGISTER GetReg(INT16 nVar, CODEHANDLE hcodCurrent, BOOL bLoad) = 0;		 /* allocates a register for nVar    */
  virtual void FlushReg(REGISTER rFlush, CODEHANDLE hcodCurrent) = 0;			 /* flushes rFlush back to memory    */
  virtual void SaveRegState(void) = 0;							 /* record all the "live" registers  */
  virtual void RestoreRegState(CODEHANDLE hcodCurrent) = 0;				 /* returns all regs to state they   */
/*****************************************************************************/
/********************************* INLINES ***********************************/
/*****************************************************************************/
#endif
/*****************************************************************************/
/******************************* PROTOTYPES **********************************/
/*****************************************************************************/
/*****************************************************************************/
/********************************* GLOBALS ***********************************/
/*****************************************************************************/
#endif

---------------------------------------------------------------------------

#include <stdio.h>
#include <setjmp.h>
#include <sys/types.h>
#include <sys/ipc.h>
#include <sys/shm.h>
#include <sys/mman.h>
#include <CAM/CALib++.H>
#include <CAM/Pipecomm++.H>
#include <CAM/CAM8SimPipeInterface++.H>
static int qflag = 0;
static int retv[2];
CAM8SimPipeInterface::CAM8SimPipeInterface(void)
  MapCnt = 0;
  mlen = 0;
  *madr = NULL;
int CAM8SimPipeInterface::main(int argc, char *argv[])
  CAM8Sim cam8sim;
  ReadCmdLine(argc, argv);
  cam8sim.main(argc, argv, this);
  InitExitProcs();
  while (ReadInterfaceRegs() > -1) {}
  exit(0);
int CAM8SimPipeInterface::main(int argc, char *argv[], CAM8SimInterface *ifc)
  CAM8Sim cam8sim;
  ReadCmdLine(argc, argv);
  cam8sim.main(argc, argv, this);
  InitExitProcs();
  while (ReadInterfaceRegs() > -1) {}
  exit(0);
void CAM8SimPipeInterface::ReadCmdLine(int argc, char *argv[])
  register int i;
  for(i = 1; i < argc; i++) {
    if (strcmp(argv[i], "-fd") == 0) {
      sim_memfd = atoi(argv[i+1]);
      i++;
      continue;
    }
    if (strcmp(argv[i], "-in") == 0) {
      sim_infd = atoi(argv[i+1]);
      i++;
      continue;
    }
    if (strcmp(argv[i], "-out") == 0) {
      sim_outfd = atoi(argv[i+1]);
      i++;
      continue;
    }
    
void InitInterface(void)
  ResetInterface();
  CAM_SetPipeCmdTable(simcmds);
  CAM_SetPipeMode(CAM_PIPEALL|CAM_PIPESILENT|CAM_PIPEFDPLX);
int ReadInterfaceRegs(void)
  int rv;
  if ((rv = CAM_ParsePipeMesg(sim_infd, sim_outfd, NULL)) < CAM_PIPEALL) {	/* There has been a fatal error	     */
    retv[0] = FATAL;
    CAM_SendPipeMesg(sim_outfd, (char *) retv);
    fprintf(stderr, "CAM8SIM: Fatal error, exiting\n");
    return(-1);
  return(qflag);
/* PipeComm routines */
unsigned char *MAPADDR(char *appdata, unsigned char *o, unsigned char *d)
  retv[0] = NOERR;
  retv[1] = NOERR;
  madr = *((char **) d);
  return((unsigned char *) retv);
unsigned char *MAPLEN(char *appdata, unsigned char *o, unsigned char *d)
  retv[0] = NOERR;
  retv[1] = NOERR;
  mlen = *((int *) d);
  return((unsigned char *) retv);
unsigned char *MAPBUF(char *appdata, unsigned char *o, unsigned char *d)
  retv[0] = -3;
  retv[1] = NOERR;
  if (madr && mlen) {
    if ((retv[1] = (int) mmap(NULL, mlen, PROT_READ|PROT_WRITE, MAP_SHARED,
			 sim_memfd, (off_t) madr)) == -1)
      retv[0] = -2;
    else {
      MapTable[MapCnt].ker = madr;
      MapTable[MapCnt].len = mlen;
      MapTable[MapCnt++].ifc = (char *) retv[1];
      retv[0] = NOERR;
    }
  return((unsigned char *) retv);
unsigned char *SIMCIOMAP(char *appdata, unsigned char *o, unsigned char *d)
  int i;
  int off;
  char *ifc = *((char **) d);
  retv[0] = -5;
  for (i = 0; i < MapCnt; i++)
    if ((MapTable[i].ifc <= ifc) &&
	((MapTable[i].ifc + MapTable[i].len) > ifc)) {
      off = ifc - MapTable[i].ifc;
      retv[0] = NOERR;
      retv[1] = (int) MapTable[i].ker + off;
      break;
    }
  return((unsigned char *) retv);
unsigned char *READR0(char *appdata, unsigned char *o, unsigned char *d)
  retv[0] = NOERR;
  retv[1] = iregs.NLP;
  return((unsigned char *) retv);
unsigned char *READR1(char *appdata, unsigned char *o, unsigned char *d)
  retv[0] = NOERR;
  retv[1] = iregs.ISR;
  /* Turn off interrupt flags and unused bits, leave enables the same */
  iregs.ISR &= 0x00001F00;
  return((unsigned char *) retv);
unsigned char *READR2(char *appdata, unsigned char *o, unsigned char *d)
  retv[0] = NOERR;
  retv[1] = iregs.CIP;
  return((unsigned char *) retv);
unsigned char *READR3(char *appdata, unsigned char *o, unsigned char *d)
  retv[0] = NOERR;
  retv[1] = iregs.PIP;
  return((unsigned char *) retv);
unsigned char *WRITER0(char *appdata, unsigned char *o, unsigned char *d)
  LONG32 tmp = iregs.NLP & 0xF;
  if (setjmp(cam8sim_exception) == 0) {
    
    if (!(iregs.NLP & CAM_EXCEPTION_STATUS)) {
      iregs.NLP = tmp | (*((int *) d) & 0xFFFFFFF0);
      
      /* Step list has been scheduled... Execute it */
      SimStepList((LONG32 *) (iregs.NLP & 0xFFFFFFF0));
    }
  retv[0] = NOERR;
  return((unsigned char *) retv);
unsigned char *WRITER1(char *appdata, unsigned char *o, unsigned char *d)
  iregs.RER = *((int *) d);
  if (iregs.RER & CAM_RESET_INTERFACE) {
    ResetInterface();
  if (iregs.RER & CAM_HALT_INTERFACE)
    iregs.NLP |= CAM_INTERFACE_HALTED;
  if (iregs.RER & CAM_ENABLE_TIMEOUT_EXC)
    iregs.NLP &= ~(CAM_EXCEPTION_STATUS);
  /*  This is supposed to also resume after error ack, whatever that is
  if (iregs.RER & CAM_ENABLE_CAMINT_EXC)
  */
  if (iregs.RER & CAM_ENABLE_NEWLIST_INT)
    iregs.ISR |= CAM_ENABLE_NEWLIST_INT;
  if (iregs.RER & CAM_ENABLE_TIMEOUT_INT)
    iregs.ISR |= CAM_ENABLE_TIMEOUT_INT;
  if (iregs.RER & CAM_ENABLE_SBUS_INT)
    iregs.ISR |= CAM_ENABLE_SBUS_INT;
  if (iregs.RER & CAM_ENABLE_CAM_INT)
    iregs.ISR |= CAM_ENABLE_CAM_INT;
  if (iregs.RER & CAM_ENABLE_SOFT_INT)
    iregs.ISR |= CAM_ENABLE_SOFT_INT;
  if (iregs.RER & CAM_DISABLE_NEWLIST_INT)
    iregs.ISR &= ~(CAM_ENABLE_NEWLIST_INT);
  if (iregs.RER & CAM_DISABLE_TIMEOUT_INT)
    iregs.ISR &= ~(CAM_ENABLE_TIMEOUT_INT);
  if (iregs.RER & CAM_DISABLE_SBUS_INT)
    iregs.ISR &= ~(CAM_ENABLE_SBUS_INT);
  if (iregs.RER & CAM_DISABLE_CAM_INT)
    iregs.ISR &= ~(CAM_ENABLE_CAM_INT);
  if (iregs.RER & CAM_ENABLE_SOFT_INT)
    iregs.ISR |= CAM_ENABLE_SOFT_INT;
  retv[0] = NOERR;
  return((unsigned char *) retv);
unsigned char *WRITER2(char *appdata, unsigned char *o, unsigned char *d)
  iregs.DSL = *((int *) d);
  retv[0] = NOERR;
  return((unsigned char *) retv);
unsigned char *WRITER3(char *appdata, unsigned char *o, unsigned char *d)
  iregs.DBL = *((int *) d);
  retv[0] = NOERR;
  return((unsigned char *) retv);
unsigned char *QUIT(char *appdata, unsigned char *o, unsigned char *d)
  retv[0] = NOERR;
  qflag = -1;
  return((unsigned char *) retv);

---------------------------------------------------------------------------

#ifndef _CAM8SIMPIPEINTERFACE_H_
#define _CAM8SIMPIPEINTERFACE_H_
#include <CAM/CALib++.H>
#include <CAM/CAM8SimInterface++.H>
#include <CAM/CAM8Sim++.H>
#include "std++.H"
/*****************************************************************************/
/********************************* DEFINES ***********************************/
/*****************************************************************************/
#ifdef __cplusplus
/*****************************************************************************/
/******************************** TEMPLATES **********************************/
/*****************************************************************************/
/*****************************************************************************/
/*************************** CLASSES & TYPEDEFS ******************************/
/*****************************************************************************/
typedef struct {
  char *ker, *ifc;
  int len;
} MapEntry;
class CAM8SimPipeInterface : public CAM8SimInterface {
public:
  CAM8SimPipeInterface(void);
  DECL_COPYCONST(CAM8SimPipeInterface);
  virtual ~CAM8SimPipeInterface(void);
  DECL_OPEQ(CAM8SimPipeInterface);
  DECL_BZERO(CAM8SimPipeInterface);
  DECL_BCOPY(CAM8SimPipeInterface);
  DECL_BCMP(CAM8SimPipeInterface);
  virtual int main(int argc, char *argv[]);
  virtual void ReadInstr(INT16 *pnBuffer, LONG32 lInstr, LONG32 lData, LONG32 lLength);
  virtual int ReadInterfaceRegs(void);
protected:
  static Cmdt simcmds[] = {
    { "madr", MAPADDR },
    { "mlen", MAPLEN },
    { "mbuf", MAPBUF },
    { "ciom", SIMCIOMAP },
    { "rdR0", READR0 },
    { "rdR1", READR1 },
    { "rdR2", READR2 },
    { "rdR3", READR3 },
    { "wrR0", WRITER0 },
    { "wrR1", WRITER1 },
    { "wrR2", WRITER2 },
    { "wrR3", WRITER3 },
    { "quit", QUIT }
  };
  MapEntry MapTable[8192];
  int MapCnt;
  int mlen;
  char *madr;
  unsigned char *MAPADDR(char *, unsigned char *, unsigned char *);
  unsigned char *MAPLEN(char *, unsigned char *, unsigned char *);
  unsigned char *MAPBUF(char *, unsigned char *, unsigned char *);
  unsigned char *SIMCIOMAP(char *, unsigned char *, unsigned char *);
  unsigned char *READR0(char *, unsigned char *, unsigned char *);
  unsigned char *READR1(char *, unsigned char *, unsigned char *);
  unsigned char *READR2(char *, unsigned char *, unsigned char *);
  unsigned char *READR3(char *, unsigned char *, unsigned char *);
  unsigned char *WRITER0(char *, unsigned char *, unsigned char *);
  unsigned char *WRITER1(char *, unsigned char *, unsigned char *);
  unsigned char *WRITER2(char *, unsigned char *, unsigned char *);
  unsigned char *WRITER3(char *, unsigned char *, unsigned char *);
  unsigned char *QUIT(char *, unsigned char *, unsigned char *);
/*****************************************************************************/
/********************************* INLINES ***********************************/
/*****************************************************************************/
#endif
/*****************************************************************************/
/******************************* PROTOTYPES **********************************/
/*****************************************************************************/
/*****************************************************************************/
/********************************* GLOBALS ***********************************/
/*****************************************************************************/
#endif

---------------------------------------------------------------------------

#include <CAM/CALib++.H>
#include <CAM/CamStream++.H>
#include <CAM/CamError++.H>
#include <CAM/CamTrace++.H>
#include <CAM/CAM8SimSPARCJIT++.H>
#include <CAM/Cam8SimulatorModule++.H>
#include "std++.H"
Cam8SimulatorModule::Cam8SimulatorModule(void)
  bSourceRegChange = TRUE;
  bDestChange = TRUE;
  bForceGeneralScan = FALSE;
Cam8SimulatorModule::~Cam8SimulatorModule(void)
void CAM8SimModule::InitModule(void)
#ifndef INTERPRETER
  InitSymbolTable();
#endif INTERPRETER
  InitHeap();
#ifndef INTERPRETER
  InitSim();
#endif INTERPRETER
void vwecheck(INT16 *base, int reg_fld, int imm)
  register int i;
  int f = 0, o;
  Bt bt;
  bt = base_type[reg_fld];
  if (VWECHK) {
    UnpackStateInto(base, reg_fld, imm, (BYTE *) pbuf, bt.type);
    for (i = 0; i < CHIPS_PER_MOD; i++) {
      o = bt.type * i;
      if (VWE[i]) {
	if (bcmp(bt.base + o, ((BYTE *) pbuf) + o, bt.type) != 0) {
	  f = 1;
	  VWIF[i] = 1;
      }
      else
	bcopy(((BYTE *) pbuf) + o, bt.base + o, bt.type);
    }
  else
    UnpackState(base, reg_fld, imm);
void SimStepList(LONG32 *plFirstInstr)
  LONG32 *plCurr = NULL, *plNext = NULL;
  LONG32 lData = 0, lLength;
  short nRegister, i, imm = FALSE;
  BOOL bHostJump, bHostWait, bByteMode, bReadMode;
  BOOL bDone = FALSE;
  LONG32 pbuf[CHIPS_PER_MOD];
  bHostJump = bHostWait = FALSE;
  for (plCurr = plFirstInstr; !bDone; plCurr = plNext) {
    bHostJump = (*plCurr & HOST_JUMP_MASK) != 0;
    bHostWait = (*plCurr & HOST_WAIT_MASK) != 0;
    bDone = bHostJump || bHostWait;
    bByteMode = (*plCurr & BYTE_MODE_MASK) != 0;
    bReadMode = (*plCurr & READ_CAM_MASK) != 0;
    
    cam8sim_iregs.PIP = cam8sim_iregs.CIP;
    cam8sim_iregs.CIP = (LONG32) plNext;
    if (*plCurr & RESET_CAM_MASK) {
      memset ((char *) &CAM8State, 0, sizeof(CAM8State));
      LIOR = LUT1;
      LUT_ADDR = (LONG32) LUT0;
      bSourceRegChange = bDestChange = TRUE;
      
#ifdef DEBUG
      fprintf(DEBUGFILE, "CAM Reset\n");
      fflush(DEBUGFILE);
#endif
    }
    
    
    nRegister = *plCurr & REGISTER_ADDR_MASK;
    imm = (*plCurr & IMMEDIATE_DATA_MASK) != 0;
    lData = *(plCurr + 1);
    lLength = *(plCurr + 2);
    
    plNext = (LONG32 *) (*(plCurr + 3));
    
    if ((*plCurr & READ_CAM_MASK) && (*plCurr & IMMEDIATE_DATA_MASK)) {
#ifdef DEBUG
      fprintf(DEBUGFILE, "NOOP\n");
#endif
      continue;
    }
    
    
#ifdef DEBUG
    fprintf(DEBUGFILE, "REG = %d (%s), ", nRegister, REGNAMES[nRegister]);
    if (imm)
      fprintf(DEBUGFILE, "IMMEDIATE DATA, ");
    fprintf(DEBUGFILE, "BYTEMODE = %d, READMODE = %d\n", bByteMode, bReadMode);
    fflush(DEBUGFILE);
#endif
    
    if ((*plCurr & READ_CAM_MASK) != 0) {
      INT16 *pnBuffer;
      
      CAM8State.bReadMode = TRUE;
      bDestChange = TRUE;
      
      pnBuffer = (INT16 *) lData;
      
      SimReadInstr(pnBuffer, *plCurr, lData, lLength);
      
      continue;
    }
    
    
    switch (nRegister) {
      
    case RFINDEX(REG_MSR): {
      vwecheck((INT16 *) lData, RFINDEX(REG_MSR), imm);
      break;
    }      
      
      
    case RFINDEX(REG_RMR): {
      vwecheck((INT16 *) lData, RFINDEX(FLD_SSM), imm);
      vwecheck((INT16 *) lData, RFINDEX(FLD_RT), imm);
      vwecheck((INT16 *) lData, RFINDEX(FLD_ECT), imm);
      vwecheck((INT16 *) lData, RFINDEX(FLD_RPK), imm);
      vwecheck((INT16 *) lData, RFINDEX(FLD_ALT), imm);
      
#ifndef INTERPRETER
      for(i = 0; i < CHIPS_PER_MOD; i++) {
	if (ECT[i] == 1) {
          ECR[i] = EVENT_COUNT(i);
          EVENT_COUNT(i) = 0L;
        }
        if (RPK[i] == 1)
          DoKick(i);
      }
      
#else INTERPRETER
      for(i = 0; i < CHIPS_PER_MOD; i++) {
	if (ECT[i] == 1) {
          ECR[i] = EVENT_COUNT[i];
          EVENT_COUNT[i] = 0L;
        }
        if (RPK[i] == 1)
          DoKick(i);
      }
      
#endif INTERPRETER
      if (ALT[0] == 1) {
        INT16 *pnTemp;
        
        pnTemp = LIOR;
        LIOR = (INT16 *) LUT_ADDR;
        LUT_ADDR = (LONG32) pnTemp;
        
        for (i = 0; i < CHIPS_PER_MOD; i++)
	  ALS[i] ^= 1;
      }
      if (CAM8State.bReadMode != FALSE) {
	bDestChange = TRUE;
	CAM8State.bReadMode = FALSE;
      }
      if (SSM[0] != 0) {
	CAM8State.WhyScan = RFINDEX(REG_RMR);
#ifndef INTERPRETER
        SimCompScan();
        
#ifndef _DRYRUN_                 
#ifdef _INSTRUMENTATION_
	gettimeofday(&tvStart, &tzZone);
#endif
        SimExecScan();
#ifdef _INSTRUMENTATION_
	gettimeofday(&tvEnd, &tzZone);
      
	fprintf(stderr, "Regular Scan took %d usecs\n",
		(tvEnd.tv_sec - tvStart.tv_sec) * 1000000 +
		(tvEnd.tv_usec - tvStart.tv_usec));
#endif _INSTRUMENTATION_
#endif _DRYRUN_
#else INTERPRETER
	SimExecScan();
#endif INTERPRETER
      }
      
      break;
    }
      
      
    case RFINDEX(REG_KR): {
      vwecheck((INT16 *) lData, RFINDEX(FLD_KA), imm);
      vwecheck((INT16 *) lData, RFINDEX(FLD_XKS), imm);
      vwecheck((INT16 *) lData, RFINDEX(FLD_YKS), imm);
      vwecheck((INT16 *) lData, RFINDEX(FLD_ZKS), imm);
      vwecheck((INT16 *) lData, RFINDEX(FLD_XKMF), imm);
      vwecheck((INT16 *) lData, RFINDEX(FLD_YKMF), imm);
      vwecheck((INT16 *) lData, RFINDEX(FLD_ZKMF), imm);
      DoKick(-1);
      break;
    }
      
      
    case RFINDEX(REG_SABSR):
      {
	vwecheck((INT16 *) lData, RFINDEX(REG_SABSR), imm);
	break;
      }
    case RFINDEX(REG_LASR):
    case RFINDEX(REG_FOSR):
    case RFINDEX(REG_SDSR):
    case RFINDEX(REG_ECSR):
    case RFINDEX(REG_DSR): {
      vwecheck((INT16 *) lData, FLD_SELECT(nRegister), imm);
      vwecheck((INT16 *) lData, FLD_MAP(nRegister), imm);
      bSourceRegChange = TRUE;
      break;
    }
      
    case RFINDEX(REG_SSR): {
      vwecheck((INT16 *) lData, RFINDEX(REG_SSR), imm);
      
      break;
    }
      
      
    case RFINDEX(REG_ECR): {
      if (ECL[0] != lLength) {
	ConstantSetAll(RLIF, 1);
	Generate_Interrupt(CAM_CAM_INT_STATUS);
      }
      else {
	int i;
	UnpackBits((INT16 *) lData, 0, lLength, imm, (BYTE *) ECR, BIT32);
	for(i = 0; i < CHIPS_PER_MOD; i++)
#ifndef INTERPRETER
	  EVENT_COUNT(i) = ECR[i];
#else INTERPRETER
	  EVENT_COUNT[i] = ECR[i];
#endif INTERPRETER
      }
      break;
    }
      
      
    case RFINDEX(REG_LIR): {
      vwecheck((INT16 *) lData, RFINDEX(REG_LIR), imm);
      break;
    }
      
      
    case RFINDEX(REG_LIPR): {
      vwecheck((INT16 *) lData, RFINDEX(REG_LIPR), imm);
      
      break;
    }
      
      
    case RFINDEX(REG_LIOR): {
      INT16 nLUTEntry, nLUTNextIndex;
      INT16 *pnLUT, *pnSource;
      int i, j;
      INT16 nImmediate[2];
      
      if (imm) {
        nImmediate[0] = (INT16) lData >> 16;
        nImmediate[1] = (INT16) lData & 0xFF;
        pnSource = &nImmediate[0];
      }
      
      else
        pnSource = (INT16 *) lData;
      
      for (i = 0; i < lLength; i++) {
        nLUTNextIndex = 0;
        for (j = CHIPS_PER_MOD - 1; j >= 0; j--) {
          nLUTNextIndex <<= 1;
          if (LIPR[j] < 16)
            nLUTNextIndex |= ((LIR[j] >> LIPR[j]) & 0x1);
          else if (LIPR[j] == 31)
            nLUTNextIndex |= 0x1;
	  LIR[j]++;
        }
        pnLUT = LIOR + nLUTNextIndex;                 
        
        if (imm) {
          *pnLUT = *pnSource;
          pnSource = &nImmediate[i % 2];
        } 
        
        else {
          *pnLUT = *pnSource;
          pnSource++;
        }
      }
      
      break;
    }
      
      
    case RFINDEX(REG_SIR): {
      vwecheck((INT16 *) lData, RFINDEX(REG_SIR), imm);
      
      SCAN_INDEX_REG = SIR[0];
      
      break;
    }
      
      
    case RFINDEX(REG_SIPR): {
      int j;
      
      for(j = 0; j < SCAN_INDEX_LENGTH; j++)
        vwecheck((INT16 *) lData, RFINDEX(FLD_SSA(j)), imm);
      
      break;
    }
      
      
    case RFINDEX(REG_SIOR): {
      if ((CAM8State.bByteMode != bByteMode) || 
          (CAM8State.bImmediate != imm)) {
        CAM8State.bByteMode = bByteMode;
        CAM8State.bImmediate = imm;
        bSourceRegChange = TRUE;
      }
      
      if (imm) {
        SIOR = (BYTE *) &lData;
        TBUS_DATA = lData;
#ifndef INTERPRETER
	SIOREG = (LONG32) SIOR;
#endif INTERPRETER
      }
      
      else {
        SIOR = (BYTE *) lData;
	TBUS_ADDR = lData;
#ifndef INTERPRETER
	SIOREG = (LONG32) SIOR;
#endif INTERPRETER
      }
      
      if (CAM8State.bReadMode != FALSE) {
        bDestChange = TRUE;
        CAM8State.bReadMode = FALSE;
      }
      
      CAM8State.WhyScan = RFINDEX(REG_SIOR);
#ifndef INTERPRETER
      SimCompScan();
#ifndef _DRYRUN_                 
#ifdef _INSTRUMENTATION_
      gettimeofday(&tvStart, &tzZone);
#endif
      SimExecScan();
#ifdef _INSTRUMENTATION_
      gettimeofday(&tvEnd, &tzZone);
      
      fprintf(stderr, "Scan I/O Write took %d usecs\n",
	      (tvEnd.tv_sec - tvStart.tv_sec) * 1000000 +
	      (tvEnd.tv_usec - tvStart.tv_usec));
#endif _INSTRUMENTATION_
#endif _DRYRUN_
      
#else INTERPRETER
      
      SimExecScan();      
#endif INTERPRETER
      break;
    }
      
      
    case RFINDEX(REG_SFR): {
      vwecheck((INT16 *) lData, RFINDEX(FLD_SM), imm);
      vwecheck((INT16 *) lData, RFINDEX(FLD_ESC), imm);
      vwecheck((INT16 *) lData, RFINDEX(FLD_ESW), imm);
      vwecheck((INT16 *) lData, RFINDEX(FLD_EST), imm);
      vwecheck((INT16 *) lData, RFINDEX(FLD_SBRC), imm);
      vwecheck((INT16 *) lData, RFINDEX(FLD_RCL), imm);
      vwecheck((INT16 *) lData, RFINDEX(FLD_ECL), imm);
      vwecheck((INT16 *) lData, RFINDEX(FLD_STM), imm);
      
      break;
    }
      
      
    case RFINDEX(REG_OSR): {
      vwecheck((INT16 *) lData, nRegister, imm);
      break;
    }
      
      
    case RFINDEX(REG_DR): {
      vwecheck((INT16 *) lData, RFINDEX(FLD_DCM), imm);
      vwecheck((INT16 *) lData, RFINDEX(FLD_XDCP), imm);
      vwecheck((INT16 *) lData, RFINDEX(FLD_YDCP), imm);
      vwecheck((INT16 *) lData, RFINDEX(FLD_ZDCP), imm);
      UpdateDCMR();
      
      break;
    }
      
      
    case RFINDEX(REG_HER): {
      vwecheck((INT16 *) lData, RFINDEX(FLD_LPL), imm);
      vwecheck((INT16 *) lData, RFINDEX(FLD_FPL), imm);
      vwecheck((INT16 *) lData, RFINDEX(FLD_DCS), imm);
      vwecheck((INT16 *) lData, RFINDEX(FLD_TBD), imm);
      vwecheck((INT16 *) lData, RFINDEX(FLD_TMS), imm);
      vwecheck((INT16 *) lData, RFINDEX(FLD_NBF), imm);
      vwecheck((INT16 *) lData, RFINDEX(FLD_SRE), imm);
      vwecheck((INT16 *) lData, RFINDEX(FLD_ALS), imm);
       
      if (ALS[0] == 1) {
        LIOR = (INT16*) LUT0;
        LUT_ADDR = (LONG32) LUT1;
      } 
      
      else {
        LIOR = (INT16 *) LUT1;
        LUT_ADDR = (LONG32) LUT0;
      }
      
      bSourceRegChange = TRUE;
      
      break;
    }
      
      
    case RFINDEX(REG_MPCR): {
      vwecheck((INT16 *) lData, RFINDEX(FLD_MAFS), imm);
      vwecheck((INT16 *) lData, RFINDEX(FLD_MBFS), imm);
      break;
    }
      
      
    case RFINDEX(REG_GPCR): {
      vwecheck((INT16 *) lData, RFINDEX(FLD_XMPC), imm);
      vwecheck((INT16 *) lData, RFINDEX(FLD_XPPC), imm);
      vwecheck((INT16 *) lData, RFINDEX(FLD_YMPC), imm);
      vwecheck((INT16 *) lData, RFINDEX(FLD_YPPC), imm);
      vwecheck((INT16 *) lData, RFINDEX(FLD_ZMPC), imm);
      vwecheck((INT16 *) lData, RFINDEX(FLD_ZPPC), imm);
      break;
    }
      
      
    case RFINDEX(REG_MIDR): {
      vwecheck((INT16 *) lData, RFINDEX(REG_MIDR), imm);
      break;
    }
      
      
    case RFINDEX(REG_GIDR): {
      vwecheck((INT16 *) lData, RFINDEX(REG_GIDR), imm);
      break;
    }
      
      
    case RFINDEX(REG_IER): {
      vwecheck((INT16 *) lData, RFINDEX(FLD_BPIE), imm);
      vwecheck((INT16 *) lData, RFINDEX(FLD_BCIE), imm);
      vwecheck((INT16 *) lData, RFINDEX(FLD_GCIE), imm);
      vwecheck((INT16 *) lData, RFINDEX(FLD_MAIE), imm);
      vwecheck((INT16 *) lData, RFINDEX(FLD_MBIE), imm);
      vwecheck((INT16 *) lData, RFINDEX(FLD_SSIE), imm);
      vwecheck((INT16 *) lData, RFINDEX(FLD_XHIE), imm);
      vwecheck((INT16 *) lData, RFINDEX(FLD_RLIE), imm);
      vwecheck((INT16 *) lData, RFINDEX(FLD_URIE), imm);
      vwecheck((INT16 *) lData, RFINDEX(FLD_ISIE), imm);
      break;
    }
      
      
    case RFINDEX(REG_IFR): {
      vwecheck((INT16 *) lData, RFINDEX(FLD_BPIF), imm);
      vwecheck((INT16 *) lData, RFINDEX(FLD_BCIF), imm);
      vwecheck((INT16 *) lData, RFINDEX(FLD_GCIF), imm);
      vwecheck((INT16 *) lData, RFINDEX(FLD_MAIF), imm);
      vwecheck((INT16 *) lData, RFINDEX(FLD_MBIF), imm);
      vwecheck((INT16 *) lData, RFINDEX(FLD_SSIF), imm);
      vwecheck((INT16 *) lData, RFINDEX(FLD_XHIF), imm);
      vwecheck((INT16 *) lData, RFINDEX(FLD_RLIF), imm);
      vwecheck((INT16 *) lData, RFINDEX(FLD_URIF), imm);
      vwecheck((INT16 *) lData, RFINDEX(FLD_ISIF), imm);
      break;
    }
      
      
    case RFINDEX(REG_VWR): {
      register int i;
      
      UnpackState((INT16 *) lData, RFINDEX(FLD_VWE), imm);
      UnpackState((INT16 *) lData, RFINDEX(FLD_VWIE), imm);
      UnpackState((INT16 *) lData, RFINDEX(FLD_VWIF), imm);
      VWECHK = 0;
      for (i = 0; i < CHIPS_PER_MOD; i++)
	if (VWE[i] == 1)
	  VWECHK = 1;
      
      break;
    }
      
      
    case RFINDEX(REG_DOCR): {
      vwecheck((INT16 *) lData, RFINDEX(FLD_LDOC), imm);
      vwecheck((INT16 *) lData, RFINDEX(FLD_HDOC), imm);
      
      break;
    }
      
      
    default: {
      
      fprintf(stderr, "Don't recognize register %d\n", nRegister);
      break;
    }
    }
    
    cam8sim_iregs.PIP = (LONG32) plCurr;
  } /*   for (plCurr = plFirstInstr; !bDone; plCurr = plNext;) */
  cam8sim_iregs.ISR |= CAM_NEWLIST_INT_STATUS;
void SimReadInstr(INT16 *pnBuffer, LONG32 lInstr, LONG32 lData,
		      LONG32 lLength)
  BOOL bByteMode;
  short nRegister, i, imm;
  LONG32 pbuf[CHIPS_PER_MOD];
  bByteMode = (lInstr & BYTE_MODE_MASK) != 0;
  nRegister = lInstr & REGISTER_ADDR_MASK;
  imm = (lInstr & IMMEDIATE_DATA_MASK) != 0;
  switch (nRegister) {
    
  case RFINDEX(REG_MSR): {
    PackState(pnBuffer, RFINDEX(REG_MSR));
    break;
  }      
    
    
  case RFINDEX(REG_RMR): {
    PackState(pnBuffer, RFINDEX(FLD_SSM));
    PackState(pnBuffer, RFINDEX(FLD_RT));
    PackState(pnBuffer, RFINDEX(FLD_ECT));
    PackState(pnBuffer, RFINDEX(FLD_RPK));
    PackState(pnBuffer, RFINDEX(FLD_ALT));
    break;
    
    
  case RFINDEX(REG_KR): {
    PackState(pnBuffer, RFINDEX(FLD_KA));
    PackState(pnBuffer, RFINDEX(FLD_XKS));
    PackState(pnBuffer, RFINDEX(FLD_YKS));
    PackState(pnBuffer, RFINDEX(FLD_ZKS));
    PackState(pnBuffer, RFINDEX(FLD_XKMF));
    PackState(pnBuffer, RFINDEX(FLD_YKMF));
    PackState(pnBuffer, RFINDEX(FLD_ZKMF));
    break;
    
    
  case RFINDEX(REG_SABSR): {
    PackState(pnBuffer, RFINDEX(REG_SABSR));
    
    break;
    
    
  case RFINDEX(REG_LASR):
  case RFINDEX(REG_FOSR):
  case RFINDEX(REG_SDSR):
  case RFINDEX(REG_ECSR):
  case RFINDEX(REG_DSR): {
    PackState(pnBuffer, FLD_SELECT(nRegister));
    PackState(pnBuffer, FLD_MAP(nRegister));    
    break;
    
    
  case RFINDEX(REG_SSR): {
    *pnBuffer = 0xFFFF;
    
    break;
    
    
  case RFINDEX(REG_ECR): {
    int diff;
    if ((diff = ECL[0] - lLength) != 0){
      ConstantSetAll(RLIF, 1);
      if (diff < 0)
	Generate_Interrupt(CAM_CAM_INT_STATUS);
      else
	Generate_Interrupt(CAM_TIMEOUT_INT_STATUS);
    }
    
    else
      PackBits(pnBuffer, 0, lLength, (BYTE *) ECR, BIT32);
    
    break;
    
    
  case RFINDEX(REG_LIR): {
    PackState(pnBuffer, RFINDEX(REG_LIR));
    break;
    
    
  case RFINDEX(REG_LIPR): {
    PackState(pnBuffer, RFINDEX(REG_LIPR));
    break;
    
    
  case RFINDEX(REG_LIOR): {
    INT16 nLUTEntry, nLUTNextIndex;
    INT16 *pnLUT;
    int i, j;
    INT16 nImmediate[2];
    
    
    for (i = 0; i < lLength; i++) {
      nLUTNextIndex = 0;
      
      for (j = CHIPS_PER_MOD - 1; j >= 0; j--) {
	nLUTNextIndex <<= 1;
	if (LIPR[j] < 16)
	  nLUTNextIndex |= ((LIR[j] >> LIPR[j]) & 0x1);
	else if (LIPR[j] == 31)
	  nLUTNextIndex |= 0x1;
	LIR[j]++;
      }
      
      pnLUT = LIOR + nLUTNextIndex;                 
      
      *pnBuffer = *pnLUT;
      pnBuffer++;
    }
    
    break;
    
    
  case RFINDEX(REG_SIR): {
    PackState(pnBuffer, RFINDEX(REG_SIR));
    break;
    
    
  case RFINDEX(REG_SIPR): {
    int j;
    
    /* j counts which field of register */
    for(j = 0; j < SCAN_INDEX_LENGTH; j++)
      PackState(pnBuffer, RFINDEX(FLD_SSA(j)));
    break;
    
    
  case RFINDEX(REG_SIOR): {
    CAM8State.bByteMode = bByteMode;
    SIOR = (BYTE *) pnBuffer;
    
#ifndef INTERPRETER
	SIOREG = (LONG32) SIOR;
#endif INTERPRETER
    if (CAM8State.bReadMode !=  TRUE) {
      bDestChange = TRUE;
      CAM8State.bReadMode =  TRUE;
    }
    
    CAM8State.WhyScan = RFINDEX(REG_SIOR);
#ifndef INTERPRETER
    SimCompScan();
#ifndef _DRYRUN_                 
#ifdef _INSTRUMENTATION_
  gettimeofday(&tvStart, &tzZone);
#endif
    SimExecScan();
#ifdef _INSTRUMENTATION_
    gettimeofday(&tvEnd, &tzZone);
      
    fprintf(stderr, "Scan I/O Read took %d usecs\n",
	    (tvEnd.tv_sec - tvStart.tv_sec) * 1000000 +
	    (tvEnd.tv_usec - tvStart.tv_usec));
#endif _INSTRUMENTATION_
#endif _DRYRUN_
#else INTERPRETER
    SimExecScan();
#endif INTERPRETER
    
    break;
    
    
  case RFINDEX(REG_SFR): {
    PackState(pnBuffer, RFINDEX(FLD_SM));
    PackState(pnBuffer, RFINDEX(FLD_ESC));
    PackState(pnBuffer, RFINDEX(FLD_ESW));
    PackState(pnBuffer, RFINDEX(FLD_EST));
    PackState(pnBuffer, RFINDEX(FLD_SBRC));
    PackState(pnBuffer, RFINDEX(FLD_RCL));
    PackState(pnBuffer, RFINDEX(FLD_ECL));
    PackState(pnBuffer, RFINDEX(FLD_STM));
    
    break;
    
    
  case RFINDEX(REG_OSR): {
    PackState(pnBuffer, RFINDEX(REG_OSR));
    break;
    
    
  case RFINDEX(REG_DR): {
    PackState(pnBuffer, RFINDEX(FLD_DCM));
    PackState(pnBuffer, RFINDEX(FLD_XDCP));
    PackState(pnBuffer, RFINDEX(FLD_YDCP));
    PackState(pnBuffer, RFINDEX(FLD_ZDCP));
    
    break;
    
    
  case RFINDEX(REG_HER): {
    PackState(pnBuffer, RFINDEX(FLD_LPL));
    PackState(pnBuffer, RFINDEX(FLD_FPL));
    PackState(pnBuffer, RFINDEX(FLD_DCS));
    PackState(pnBuffer, RFINDEX(FLD_TBD));
    PackState(pnBuffer, RFINDEX(FLD_TMS));
    PackState(pnBuffer, RFINDEX(FLD_NBF));
    PackState(pnBuffer, RFINDEX(FLD_SRE));
    PackState(pnBuffer, RFINDEX(FLD_ALS));
    
    break;
    
    
  case RFINDEX(REG_MPCR): {
    PackState(pnBuffer, RFINDEX(FLD_MAFS));
    PackState(pnBuffer, RFINDEX(FLD_MBFS));
    
    break;
    
    
  case RFINDEX(REG_GPCR): {
    PackState(pnBuffer, RFINDEX(FLD_XMPC));
    PackState(pnBuffer, RFINDEX(FLD_XPPC));
    PackState(pnBuffer, RFINDEX(FLD_YMPC));
    PackState(pnBuffer, RFINDEX(FLD_YPPC));
    PackState(pnBuffer, RFINDEX(FLD_ZMPC));
    PackState(pnBuffer, RFINDEX(FLD_ZPPC));
    
    break;
    
    
  case RFINDEX(REG_MIDR): {
    PackState(pnBuffer, RFINDEX(REG_MIDR));
    
    break;
    
    
  case RFINDEX(REG_GIDR): {
    PackState(pnBuffer, RFINDEX(REG_GIDR));
    
    break;
    
    
  case RFINDEX(REG_IER): {
    PackState(pnBuffer, RFINDEX(FLD_BPIE));
    PackState(pnBuffer, RFINDEX(FLD_BCIE));
    PackState(pnBuffer, RFINDEX(FLD_GCIE));
    PackState(pnBuffer, RFINDEX(FLD_MAIE));
    PackState(pnBuffer, RFINDEX(FLD_MBIE));
    PackState(pnBuffer, RFINDEX(FLD_SSIE));
    PackState(pnBuffer, RFINDEX(FLD_XHIE));
    PackState(pnBuffer, RFINDEX(FLD_RLIE));
    PackState(pnBuffer, RFINDEX(FLD_URIE));
    PackState(pnBuffer, RFINDEX(FLD_ISIE));
    break;
    
    
  case RFINDEX(REG_IFR): {
    PackState(pnBuffer, RFINDEX(FLD_BPIF));
    PackState(pnBuffer, RFINDEX(FLD_BCIF));
    PackState(pnBuffer, RFINDEX(FLD_GCIF));
    PackState(pnBuffer, RFINDEX(FLD_MAIF));
    PackState(pnBuffer, RFINDEX(FLD_MBIF));
    PackState(pnBuffer, RFINDEX(FLD_SSIF));
    PackState(pnBuffer, RFINDEX(FLD_XHIF));
    PackState(pnBuffer, RFINDEX(FLD_RLIF));
    PackState(pnBuffer, RFINDEX(FLD_URIF));
    PackState(pnBuffer, RFINDEX(FLD_ISIF));
    
    break;
    
    
  case RFINDEX(REG_VWR): {
    PackState(pnBuffer, RFINDEX(FLD_VWE));
    PackState(pnBuffer, RFINDEX(FLD_VWIE));
    PackState(pnBuffer, RFINDEX(FLD_VWIF));
    break;
    
    
  case RFINDEX(REG_DOCR): {
    PackState(pnBuffer, RFINDEX(FLD_LDOC));
    PackState(pnBuffer, RFINDEX(FLD_HDOC));
    
    break;
    
    
  default: {
    
    fprintf(stderr, "Don't recognize register %d\n", nRegister);
    break;
void DoKick(short p)
  register int i, j;
  LONG32 lSignBitOffset, lSignBitKick, lLowBitsKick;
  LONG32 lDCM;
  LONG32 lKA;
  /************************************************************************/
  /* The kick and offset registers are two n-dimension-vectors, and the   */
  /* place where all dimensions end is determined by lDCMR. To subtract   */
  /* an n-dimension-kick from the corresponding offset, we first extract  */
  /* out the sign bits of both (by and-ing with lDCMR). Next, we set the  */
  /* most sig bits of every dimension in offset to 1, so that when we     */
  /* subtract out the kick, we don't borrow from the next higher          */
  /* dimension. Next, we subtract the value bits of kick (lowbits) from   */
  /* this offset. This will give the 'sign' bit of the new offset and its */
  /* value. The final sign bit of the offset is determined by :           */
  /*                                                                      */
  /*     sign bit = new sign bit xor (old sign bit xnor kick sign bit)    */
  /*                                                                      */
  /* To do the xnor operation, we simply store the inverse of the kick    */
  /* sign bit and then do an xor                                          */
  /*                                                                      */
  /* One easy way to derive this is to think of a sample dimension with   */
  /* 4 bits. Then, the bit positions have values  -8  4  2  1. The        */
  /* subtract operation as described above becomes (8 + 4*o.2 + 2*o.1 +   */
  /* 1*o.0 - 4*k.2 - 2*k.1 - 1*k.0) - 8 - 8*o.sign + 8.k.sign             */
  /* where o.X means the X'th bit of offset and k.X means the X'th bit of */
  /* kick. Since the final offset is of the form -8*o.sign + 4*o.2 +      */
  /* 2*o.1 + 1*o.o, we can express the sign bit as the above logical      */
  /* function of the three individual sign bits.                          */
  /*                                                                      */
  /************************************************************************/
  if (p == -1) {
    p = 0;
    j = CHIPS_PER_MOD;
  else
    j = p + 1;
  for(i = p; i < j; i++) {
    lSignBitOffset = OSR[i] & DCM[i];
    lSignBitKick = (~KA[i]) & DCM[i];
    OSR[i] |= DCM[i];
    lLowBitsKick =  KA[i] & (~ DCM[i]);
    
    OSR[i] -= lLowBitsKick;
    lSignBitOffset ^= lSignBitKick;
    OSR[i] ^= lSignBitOffset;
#ifndef INTERPRETER
int SimCompScan()
  int i;
  BOOL bNoPerm = TRUE;
  BOOL bNoPermLast5 = TRUE;
  CODEPTR pcodCurrent;
  CODEHANDLE hcodCurrent;
  LONG32 lLogScanLength = ESC[0] + 1L;
  EP("SimCompScan");  
#else INTERPRETER
void SimExecScan()
  int i;
  BOOL bNoPerm = TRUE;
  BOOL bNoPermLast5 = TRUE;
  LONG32 lLogScanLength = ESC[0] + 1L;
  EP("SimExecScan");  
#endif INTERPRETER
  /************************************************************************/
  /* First, parse down the tree to see that we are going to update atleast*/
  /* 32 sites and that the lowest dimension extends over 32 bits. This    */
  /* second requirement is necessary because the optimized code can only  */
  /* handle dimension wraparounds at word boundaries.                     */
  /************************************************************************/
  if (lLogScanLength < 5)
    bNoPerm = bNoPermLast5 = FALSE;
  else if (lNumXBits < 5)
    bNoPerm = bNoPermLast5 = FALSE;
  else
    bNoPerm = bNoPermLast5 = TRUE;
  /************************************************************************/
  /* Now, determine if there is any permutation of the scan index in the  */
  /* bits of the SIR that will be significant over this scan.             */
  /************************************************************************/
  for (i = 0; i < MIN(5, ESC[0]); i++) {
    if (SIPR[i][0] != i) {
      bNoPerm = bNoPermLast5 = FALSE;
      break;
    }
    
    lLogScanLength--;
    
    if (!lLogScanLength)
      break;
  for (i = 5; i < MIN(SCAN_INDEX_LENGTH, ESC[0]); i++) {
    if (SIPR[i][0] != i)
      bNoPerm = FALSE;
    lLogScanLength--;
    if (!lLogScanLength)
      break;
#ifndef INTERPRETER
#ifdef _FRAMEBUFFER_
  FRAME = (LONG32) FRAMEb;
#endif _FRAMEBUFFER_
  pcodCurrent = pcodScanner;
  hcodCurrent = &pcodCurrent;
  SimPrologue(hcodCurrent);
  if (bNoPerm)
    CheckNoPerm(hcodCurrent);
  else if (bNoPermLast5)
    SimGeneralScan(hcodCurrent);
  else
    SimGeneralScan(hcodCurrent);
  SimEpilogue(hcodCurrent);
  LP("SimCompScan");
#else INTERPRETER
#ifdef _FRAMEBUFFER_
  FRAME_ADDR = (LONG32) FRAMEb;
#endif _FRAMEBUFFER_
  if (bNoPerm)
    CheckNoPerm();
  else if (bNoPermLast5)
    SimGeneralScan();
  else
    SimGeneralScan();
  if (SCAN_INDEX_REG > 0xFFFFFF)
    SCAN_INDEX_REG = 0;
  SIR[0] = SCAN_INDEX_REG;
  LP("SimExecScan");
#endif INTERPRETER
/*****************************************************************************/
/*                                                                           */
/* CheckNoPerm is necessary for the following reason - suppose there is no   */
/* permutation of the Scan Index, but suppose the the bits that extend over  */
/* the lowest dimension (ie, the bits to the _right_ of the lowest bit of    */
/* DCMR) are not all zeros. Then, the first sweep will not scan a multiple-  */
/* of-two number of sites, and we cannot to an optimized scan.               */
/*                                                                           */
/*****************************************************************************/
#ifndef INTERPRETER
void CheckNoPerm(CODEHANDLE hcodCurrent)
  LONG32 lSIRSigBits, lSIR;
#else INTERPRETER
void CheckNoPerm()
  LONG32 lSIRSigBits, lSIR;
#endif INTERPRETER
  EP("CheckNoPerm");
  lSIRSigBits = MIN(ESC[0], lNumXBits);
  lSIR = SIR[0] & ~((~0x0) << lSIRSigBits);
#ifndef INTERPRETER
  if ((lSIR == 0) && (MIN(lNumXBits, ESC[0]) >= 2)) {
    if (bForceGeneralScan)
      SimGeneralScan(hcodCurrent);
    else
      SimScanNoPerm(hcodCurrent);
  else
    SimGeneralScan(hcodCurrent);
#else INTERPRETER
  if ((lSIR == 0) && (MIN(lNumXBits, ESC[0]) >= 2)) {
    if (bForceGeneralScan)
      SimGeneralScan();
    else
      SimScanNoPerm();
  else
    SimGeneralScan();
#endif INTERPRETER
  LP("CheckNoPerm");
#ifndef INTERPRETER
void SimPrologue(CODEHANDLE hcodCurrent)
  EP("SimPrologue");
  NewBlock(hcodCurrent);
  .ENTER_PROC;
  LP("SimPrologue");
}     
void SimEpilogue(CODEHANDLE hcodCurrent)
  EP("SimEpilogue");
 .RETURN_PROC;
  EndBlock();
  LP("SimEpilogue");
void SimExecScan()
  void (*fScan)(void);
  fScan = (void (*)()) pcodScanner;
  (*fScan)();
  ConstantSetAll(SIR, SCAN_INDEX_REG);
void InitSim()
  const int prot = PROT_READ | PROT_WRITE | PROT_EXEC;
  pcodScanner = VALLOC(SCANNER_CODE_SIZE, "InitSim : pcodScanner");
  pcodGenUpdate = VALLOC(SCANNER_CODE_SIZE, "InitSim : pcodGenUpdate");
  pcodSweep = VALLOC(SWEEP_CODE_SIZE, "InitSim : pcodSweep");
  pcodUpdateSite = VALLOC(UPDATE_CODE_SIZE, "InitSim : pcodUpdateSite");
  mprotect(pcodScanner, SCANNER_CODE_SIZE, prot);
  mprotect(pcodGenUpdate, SCANNER_CODE_SIZE, prot);
  mprotect(pcodSweep, SWEEP_CODE_SIZE, prot);
  mprotect(pcodUpdateSite, UPDATE_CODE_SIZE, prot);
  UPDATE_SITE_CODE = (LONG32) pcodUpdateSite;
  InitRegMgr();
#endif INTERPRETER
#ifndef INTERPRETER
void SimUpdateSite()
  short i;
  CODEPTR pcodCurrent = pcodUpdateSite;
  EP("SimUpdateSite");
#ifdef _INCREMENTAL_COMPILE_     
  if (!(bSourceRegChange || bDestChange)) {
    LP("SimUpdateSite");
    return;
  else {
    bSourceRegChange = FALSE;
    bDestChange = FALSE;
#endif
  NewBlock(&pcodCurrent);
  .ENTER_LEAF,   
#else INTERPRETER
void SimUpdateSite()
  short i;
  LONG32 SiteDataSrc = UNGLUE_DATA;
  EP("SimUpdateSite");
#endif INTERPRETER
#ifndef INTERPRETER
  if (IsSrcNeeded(SRC_TBUS) &&
      ((CAM8State.WhyScan != RFINDEX(REG_SIOR)) || (!CAM8State.bReadMode))) {
    if (!CAM8State.bImmediate) {
      if (CAM8State.bByteMode) {
	.LDUB_IND   iTbusAddr, #0, iTbusData;
	.ADD iTbusAddr, #1, iTbusAddr;
      } 
      
      else {
	.LDHW_IND iTbusAddr, #0, iTbusData;
	.ADD iTbusAddr, #2, iTbusAddr;
      }
    }
#else INTERPRETER
  if (IsSrcNeeded(SRC_TBUS) &&
      ((CAM8State.WhyScan != RFINDEX(REG_SIOR)) || (!CAM8State.bReadMode))) {
    if (!CAM8State.bImmediate) {
      if (CAM8State.bByteMode) {
	TBUS_DATA = *((BYTE *) TBUS_ADDR);
	TBUS_ADDR += 1;
      }
      
      else {
	TBUS_DATA = *((INT16 *) TBUS_ADDR);
	TBUS_ADDR += 2;
      } /* else */
    } /* if (!CAM8State.bImmediate) */
#endif INTERPRETER
#ifndef INTERPRETER
  if (IsSrcNeeded(SRC_SITE_DATA)) {
    .OR %G0, %G0, iUnGlueData;
    for (i = nNumPlanes-1; i >= 0; i--) {      
      .ADDcc (iPlaneWord+i), (iPlaneWord+i), (iPlaneWord+i);
      .ADDX iUnGlueData, iUnGlueData, iUnGlueData;
    }
  }  
#else INTERPRETER
  if (IsSrcNeeded(SRC_SITE_DATA)) {
    UNGLUE_DATA = 0;
    for (i = nNumPlanes-1; i >= 0; i--) {
      bit = HIGHB(PLANE_WORD[i]);
      PLANE_WORD[i] <<= 1; 
      UNGLUE_DATA = (UNGLUE_DATA << 1) | bit;
    }
#endif INTERPRETER
#ifndef INTERPRETER
  /* For Now glued and unglued data are the same */
  if (IsSrcNeeded(SRC_GLUED_DATA)) {
    if (!IsSrcNeeded(SRC_SITE_DATA)) {
      .OR %G0, %G0, iGlueData;
      for (i = nNumPlanes-1; i >= 0; i--) {      
	.ADDcc (iPlaneWord+i), (iPlaneWord+i), (iPlaneWord+i);
	.ADDX iGlueData, iGlueData, iGlueData;
      }
    }
    else {
      .OR %G0, iUnGlueData, iGlueData;
    }
#else INTERPRETER
  /* For Now glued and unglued data are the same */
  if (IsSrcNeeded(SRC_GLUED_DATA)) {
    if (!IsSrcNeeded(SRC_SITE_DATA)) {
      GLUE_DATA = 0;
      for (i = nNumPlanes-1; i >= 0; i--) {
	bit = HIGHB(PLANE_WORD[i]);
	PLANE_WORD[i] <<= 1; 
	GLUE_DATA = (GLUE_DATA << 1) | bit;
      }
    }
    else
      GLUE_DATA = UNGLUE_DATA;
#endif INTERPRETER
#ifndef INTERPRETER
  if (IsSrcNeeded(SRC_LUT)) {
    .OR   %G0, %G0, iLutData;
    if (IsSrcSame(DEST_LUT))
      BuildDest(DEST_LUT, iLutData, LAS[0], LAM[0]);            
    else
      BuildBitwiseDest(DEST_LUT, iLutData, LAS, LAM);
    .SH_LEFT      iLutData, #1, iLutData;
    .LDHW_IND     iLutAddr, iLutData, iLutData;
#else INTERPRETER
  if (IsSrcNeeded(SRC_LUT)) {
    LUT_DATA = 0;
    if (IsSrcSame(DEST_LUT))
      BuildDest(DEST_LUT, &LUT_DATA, LAS[0], LAM[0]);           
    else
      BuildBitwiseDest(DEST_LUT, &LUT_DATA, LAS, LAM);
    LUT_DATA = (LONG32) (((INT16 *) LUT_ADDR)[LUT_DATA]);
#endif INTERPRETER
  /************************************************************************/
  /*                                                                      */
  /* All the sources needed to update all the destinations should now be  */
  /* in place. Update all the destinations in the following order : EC,   */
  /* Display (ie, scan io reads), and Site Data. Note that Site data      */
  /* must be updated last, because it destroys the Site Data register,    */
  /* which is one of the possible Sources (unglued data).                 */
  /*                                                                      */
  /************************************************************************/
#ifndef INTERPRETER
  if (IsDestUpdated(DEST_DISPLAY)) {
    if (IsSrcSame(DEST_DISPLAY))
      BuildDest(DEST_DISPLAY, iTemp1, DDS[0], DDM[0]);
    else
      BuildBitwiseDest(DEST_DISPLAY, iTemp1, DDS, DDM);
#ifdef _FRAMEBUFFER_
    .STUB_IND iFrame, #0, iTemp1;
    .ADD iFrame, #1, iFrame;
#endif
#else INTERPRETER
  if (IsDestUpdated(DEST_DISPLAY)) {
    if (IsSrcSame(DEST_DISPLAY))
      BuildDest(DEST_DISPLAY, &DISP_DATA, DDS[0], DDM[0]);
    else
      BuildBitwiseDest(DEST_DISPLAY, &DISP_DATA, DDS, DDM);
#ifdef _FRAMEBUFFER_
    *((BYTE *) FRAME_ADDR) = DISP_DATA;
    FRAME_ADDR += 1;
#endif
    
#endif INTERPRETER
#ifndef INTERPRETER
  /* SCAN-IO READ */
  if ((CAM8State.WhyScan == RFINDEX(REG_SIOR)) && CAM8State.bReadMode) {
    if (CAM8State.bByteMode) {
      .STUB_IND iSIOR, #0, iTemp1;
      .ADD iSIOR, #1, iSIOR;
      }
    else {
      .STHW_IND iSIOR, #0, iTemp1;
      .ADD iSIOR, #2, iSIOR;
    }
#else INTERPRETER
  /* SCAN-IO READ */
  if ((CAM8State.WhyScan == RFINDEX(REG_SIOR)) && CAM8State.bReadMode) {
    if (CAM8State.bByteMode) {
      *((BYTE *) SIOR) = (BYTE) DISP_DATA;
      SIOR += 1;
    }
    else {
      *((INT16 *) SIOR) = (INT16) DISP_DATA;
      SIOR += 2;
    }
#endif INTERPRETER
#ifndef INTERPRETER
  if (IsDestUpdated(DEST_EVENT_CT)) {
    if (IsSrcSame(DEST_EVENT_CT))
      BuildDest(DEST_EVENT_CT, iTemp1, ECS[0], ECM[0]);
    else
      BuildBitwiseDest(DEST_EVENT_CT, iTemp1, ECS, ECM);
    
    .SH_LEFT iTemp1, #(32 - nNumPlanes), iTemp1;
    for (i = nNumPlanes-1; i >= 0; i--) {
      .LDW_IND %DS, #(offEventCount+(i<<2)), iTemp2;
      .ADDcc iTemp1, iTemp1, iTemp1;
      .ADDX iTemp2, #0, iTemp2;
      .STW_IND %DS, #(offEventCount+(i<<2)), iTemp2;
    }
#else INTERPRETER
  if (IsDestUpdated(DEST_EVENT_CT)) {
    if (IsSrcSame(DEST_EVENT_CT))
      BuildDest(DEST_EVENT_CT, &TEMP1, ECS[0], ECM[0]);
    else
      BuildBitwiseDest(DEST_EVENT_CT, &TEMP1, ECS, ECM);
    
    TEMP1 <<= (32 - nNumPlanes);
    for (i = nNumPlanes-1; i >= 0; i--) {
      EVENT_COUNT[i] += ((TEMP1 & 0x80000000) ? 0x1 : 0x0);
      TEMP1 <<= 1;
    }
#endif INTERPRETER
#ifndef INTERPRETER
  if (IsDestUpdated(DEST_SITE_DATA)) {
    if (IsSrcSame(DEST_SITE_DATA)) {
      if (SDM[0] == MAP_S) {
	switch(SDS[0]) {
	case SRC_SITE_DATA: {
	  .OR %G0, iUnGlueData, iSiteDataSrc;
	  break;
	case SRC_TBUS: {
	  .OR %G0, iTbusData, iSiteDataSrc;
	  break;
	case SRC_LUT: {
	  .OR %G0, iLutData, iSiteDataSrc;
	  break;
	default: {
	  .OR %G0, iTemp1, iSiteDataSrc;
	  break;
      }
      else
	BuildDest(DEST_SITE_DATA, iSiteDataSrc, SDS[0], SDM[0]);
    }    
    else
      BuildBitwiseDest(DEST_SITE_DATA, iSiteDataSrc, SDS, SDM);
    .SH_LEFT iSiteDataSrc, #(32 - nNumPlanes), iSiteDataSrc;
    for (i = nNumPlanes - 1; i >= 0; i--) {                                
      .ADDcc iSiteDataSrc, iSiteDataSrc, iSiteDataSrc;
      
      if ((IsSrcNeeded(SRC_SITE_DATA)) || (IsSrcNeeded(SRC_GLUED_DATA))) {
	.ADDX (iPlaneWord+i), #0, (iPlaneWord+i);
      }
      else {
	.ADDX (iPlaneWord+i), (iPlaneWord+i), (iPlaneWord+i);
      }
    }
  .RETURN_LEAF;
    
  EndBlock();
  LP("SimUpdateSite");
#else INTERPRETER
  if (IsDestUpdated(DEST_SITE_DATA)) {
    if (IsSrcSame(DEST_SITE_DATA)) {
      if (SDM[0] == MAP_S) {
	SiteDataSrc = (SDS[0] == SRC_SITE_DATA ? UNGLUE_DATA :
		       SDS[0] == SRC_TBUS ? TBUS_DATA :
		       SDS[0] == SRC_LUT ? LUT_DATA : TEMP1);
      }
      
      else {
	BuildDest(DEST_SITE_DATA, &SITE_DATA, SDS[0], SDM[0]);
	SiteDataSrc = SITE_DATA;
      }
    }
    
    else {
      BuildBitwiseDest(DEST_SITE_DATA, &SITE_DATA, SDS, SDM);
      SiteDataSrc = SITE_DATA;
    }
    
    SiteDataSrc <<= (32 - nNumPlanes);
    for (i = nNumPlanes - 1; i >= 0; i--) {                                
      bit = HIGHB(SiteDataSrc);
      SiteDataSrc <<= 1;
      
      if ((IsSrcNeeded(SRC_SITE_DATA)) || (IsSrcNeeded(SRC_GLUED_DATA)))
	PLANE_WORD[i] |= bit;
      else
	PLANE_WORD[i] = (PLANE_WORD[i] << 1) | bit;
    }
  LP("SimUpdateSite");
#endif INTERPRETER
#ifndef INTERPRETER
static void SimSweepCode();
#else INTERPRETER
static void SimSweepCode();
#endif INTERPRETER
#ifndef INTERPRETER
void SimScanNoPerm(CODEHANDLE hcodCurrent)
  LONG32 lTemp1, lTemp2;
  CODELABEL lblYLoop, lblAddrLoop, lblSkip;
  const short iPlaneCtr = iTemp1,
  iHeapOffset = iTemp2,
  iWordAddr = iTemp3,
  iHighBit = iTemp4;
  EP("SimScanNoPerm");
  lblSkip = NewLabel();
  lblYLoop = NewLabel();
  lblAddrLoop = NewLabel();
  /************************************************************************/
  /* Sim assuming the scan index is not permuted. This implies that   */
  /* bits to be updated during this scan are all consecutive.             */
  /************************************************************************/
#else INTERPRETER
void SimScanNoPerm()
  LONG32 PLANE_CTR, WORD_ADDR, HIGH_BIT;
  EP("SimScanNoPerm");
#endif INTERPRETER
  /************************************************************************/
  /* compute HIGH_BIT_MASK and X_HIGH_BIT_MASK				  */
  /************************************************************************/
  HIGH_BIT_MASK = lDCMRHighBit >> 3;
  X_HIGH_BIT_MASK = lDCMRLowBit >> 3;
  /************************************************************************/
  /* SITE_CTR is set to how many sweeps are to be done. X_BYTE_LENGTH is  */
  /* set to how many bytes will be updated per sweep                      */
  /************************************************************************/
  if (ESC[0] < lNumXBits) {
    SITE_CTR = 1;
    X_BYTE_LENGTH = 1 << (ESC[0] - 3);
  else {
    SITE_CTR = ScanLength() >> lNumXBits;                                  
    X_BYTE_LENGTH = lDCMRLowBit >> 2;
  nNumPlanes = CalcNumPlanes();
#ifdef INTERPRETER
  if (nNumPlanes == 0) {
    LP("SimScanNoPerm");
    return;
#endif INTERPRETER
  /************************************************************************/
  /* Code starts here                                                     */
  /************************************************************************/
#ifndef INTERPRETER
  .LDW_MEM iSiteCtr;
  .ADD_LABEL :lblYLoop;
  SimSweepCode();
  .CALL_PROC [pcodSweep];
  .NO_OP;
  .ADD %DS, #offNextWordAddr, iHeapOffset;
  .LDW_MEM iHighBitMask;
  .LDW_MEM iXByteLength;
  .ADD %G0, #0, iPlaneCtr;
  .ADD_LABEL :lblAddrLoop;
  .SUBcc iPlaneCtr, #(nNumPlanes*4), %G0;
  .BR_GRE :lblSkip;
  .LDW_IND iHeapOffset, iPlaneCtr, iWordAddr;
  .AND iHighBitMask, iWordAddr, iHighBit;
  .XNOR iHighBitMask, %G0, iHighBitMask;
  .AND iHighBitMask, iWordAddr, iWordAddr;
  .ADD iXByteLength, iWordAddr, iWordAddr;
  .XOR iHighBit, iWordAddr, iWordAddr;
  .STW_IND iHeapOffset, iPlaneCtr, iWordAddr;
  .ADD iPlaneCtr, #4, iPlaneCtr;
  .BRANCH :lblAddrLoop;
  .XNOR iHighBitMask, %G0, iHighBitMask;
  .ADD_LABEL :lblSkip;
  .SH_LEFT iXByteLength, #3, iTemp1;
  .LDW_MEM iScanIndexReg;
  .ADD iScanIndexReg, iTemp1, iScanIndexReg;
  .SUBcc iScanIndexReg, #0xFFFFFF, iTemp1;
  .BR_L :lblSkip;
  .NO_OP;
  .OR %G0, %G0, iScanIndexReg;
  .ADD_LABEL :lblSkip;
  .SUBcc iSiteCtr, #1, iSiteCtr;
  .BR_NZ :lblYLoop;
  .STW_MEM iScanIndexReg;
  LP("SimScanNoPerm");
#else INTERPRETER
  while (SITE_CTR != 0) {
    SimSweepCode();
    for(PLANE_CTR = 0; PLANE_CTR < nNumPlanes; PLANE_CTR++) {  
      WORD_ADDR = NEXT_WORD_ADDR[PLANE_CTR];
      HIGH_BIT = WORD_ADDR & HIGH_BIT_MASK;
      WORD_ADDR &= (~ HIGH_BIT_MASK);
      WORD_ADDR += X_BYTE_LENGTH;
      WORD_ADDR ^= HIGH_BIT;
      NEXT_WORD_ADDR[PLANE_CTR] = WORD_ADDR;
      /*
      NEXT_WORD_ADDR[PLANE_CTR] =
	(((NEXT_WORD_ADDR[PLANE_CTR] & (~ HIGH_BIT_MASK)) + X_BYTE_LENGTH) ^
	 (NEXT_WORD_ADDR[PLANE_CTR] & HIGH_BIT_MASK));
	 */
    }
    SCAN_INDEX_REG += (X_BYTE_LENGTH << 3);
    if (SCAN_INDEX_REG > 0xFFFFFF)
      SCAN_INDEX_REG = 0;
    SITE_CTR--;
    ConstantSetAll(SIR, SCAN_INDEX_REG);
  LP("SimScanNoPerm");
#endif INTERPRETER
#ifndef INTERPRETER
void SimSweepCode()
  LONG32 xWordLength;
  CODELABEL lblXLoop;
  unsigned short nBitOffset[CHIPS_PER_MOD];
  short i, j;
  CODEPTR pcodCurrent = pcodSweep;
  EP("SimSweepCode");
  lblXLoop = NewLabel();
#else INTERPRETER
void SimSweepCode()
  short i, j;
  LONG32 NBIT_OFFSET[CHIPS_PER_MOD], XWORD_LENGTH;
  EP("SimSweepCode");
#endif INTERPRETER
  /************************************************************************/
  /* We assume here that the scan index is not permuted to arrive at the  */
  /* site address; however, some bits of the site address could be fixed  */
  /* at constant 0 or 1 as indicated by SIPR. Here, the site address of   */
  /* the first site to be updated is computed.                            */
  /************************************************************************/
  SITE_ADDR = 0;
  for (i = SCAN_INDEX_LENGTH-1; i >= 0; i--) {
    
    SITE_ADDR <<= 1;
    if (SIPR[i][0] == PERM_CONST_1)
      SITE_ADDR |= 0x1;
    else if (SIPR[i][0] != PERM_CONST_0)
      SITE_ADDR |= (SIR[0] >> i) & 0x1;
  /************************************************************************/
  /* Now that we know the site address of the first site to be updated,   */
  /* we compute the address in sparc memory of the word that contains     */
  /* a bit of that site by adding the plane offset to the site address.   */
  /************************************************************************/
#ifndef INTERPRETER
  for (i = 0; i < nNumPlanes; i++) {
    NEXT_WORD_ADDR(i) = (AddSiteAddress(SITE_ADDR, OSR[i]) >> 5) << 2;
    NEXT_WORD_ADDR(i) += BIT_PLANE_ADDR(i);
    nBitOffset[i] = OSR[i] & 0x1F;
  xWordLength = X_BYTE_LENGTH >> 2;
  NewBlock(&pcodCurrent);
  .ENTER_PROC;
  SimLoadFirstWord(nBitOffset);
  if (IsSrcNeeded(SRC_SITE_ADDRESS)) {
    .LDW_MEM iScanIndexReg;
  if (IsSrcNeeded(SRC_LUT)) {
    .LDW_MEM iLutAddr;
  .LDW_MEM iUpdateSiteProc;
  .ADD %G0, #xWordLength, iXCtr;
  .ADD_LABEL :lblXLoop;
  SimUpdateSite();
  for (i = 0; i < 32; i++) {
    .CALL_LEAF_IND iUpdateSiteProc, #4;
    .INSTR *pcodUpdateSite;
    for (j = 0; j < nNumPlanes; j++) {
      if (nBitOffset[j] == (31 - i)) {
	SimGetNextWord(j);
      }
    }
  .SUBcc iXCtr, #1, iXCtr;
  .BR_NZ :lblXLoop;
  .NO_OP;
  SimSaveLastWord(nBitOffset);
  .RETURN_PROC;
  EndBlock();
  LP("SimSweepCode");
#else INTERPRETER
  for (i = 0; i < nNumPlanes; i++) {
    NEXT_WORD_ADDR[i] = (AddSiteAddress(SITE_ADDR, OSR[i]) >> 5) << 2;
    NEXT_WORD_ADDR[i] += BIT_PLANE_ADDR[i];
    NBIT_OFFSET[i] = OSR[i] & 0x1F;
  XWORD_LENGTH = X_BYTE_LENGTH >> 2;
  SimLoadFirstWord(NBIT_OFFSET);
  X_CTR = XWORD_LENGTH;
  do {
    for (i = 0; i < 32; i++) {
      SimUpdateSite();
      for (j = 0; j < nNumPlanes; j++) {
	if (NBIT_OFFSET[j] == (31 - i))
	  SimGetNextWord(j);
      }
    }
    X_CTR -= 1;
  } while (X_CTR);
  SimSaveLastWord(NBIT_OFFSET);
  LP("SimSweepCode");
#endif INTERPRETER
#ifndef INTERPRETER
void SimLoadFirstWord(unsigned short nBitOffset[])
  short i;
  const short iSaveBits = iTemp1;
  const short iWordAddr = iTemp1;
  EP("SimLoadFirstWord");
  for (i = 0; i < nNumPlanes; i++) {
    .LDW_IND %DS, #(offNextWordAddr+(i<<2)), iWordAddr;
    .LDW_IND iWordAddr, #0, (iPlaneWord+i);
    if (nBitOffset[i] != 0) {
      .SH_RIGHT (iPlaneWord+i), #(32 - nBitOffset[i]), iSaveBits;
      .SH_LEFT (iPlaneWord+i), #nBitOffset[i], (iPlaneWord+i);
      .OR (iPlaneWord+i), iSaveBits, (iPlaneWord+i);
    }
  LP("SimLoadFirstWord");
#else INTERPRETER
void SimLoadFirstWord(LONG32 NBIT_OFFSET[])
  short i;
  LONG32 SAVE_BITS, WORD_ADDR;
  EP("SimLoadFirstWord");
  for (i = 0; i < nNumPlanes; i++) {
    PLANE_WORD[i] = *((LONG32 *) NEXT_WORD_ADDR[i]);
    
    if (NBIT_OFFSET[i] != 0) {
      SAVE_BITS = PLANE_WORD[i] >> (32 - NBIT_OFFSET[i]);
      PLANE_WORD[i] <<= NBIT_OFFSET[i];
      PLANE_WORD[i] |= SAVE_BITS;
    }
  LP("SimLoadFirstWord");
#endif INTERPRETER
#ifndef INTERPRETER
void SimGetNextWord(unsigned short nPlane)
  const short iAddrHighBit = iTemp1;
  BOOL bWriteBack = FALSE;
  short i;
  EP("SimGetNextWord");
#else INTERPRETER
void SimGetNextWord(unsigned short nPlane)
  LONG32 ADDR_HIGH_BIT;
  BOOL bWriteBack = FALSE;
  short i;
  EP("SimGetNextWord");
#endif INTERPRETER
#ifndef INTERPRETER
  .ENTER_BASICBLK;
  if (IsDestUpdated(DEST_SITE_DATA)) {
    .STW_IND (iNextWordAddr+nPlane), #0, (iPlaneWord+nPlane);
  if (lNumXBits <= 5) {
    .RETURN_BASICBLK;
    LP("SimGetNextWord");
    return;
  .AND (iNextWordAddr+nPlane), iXHighBitMask, iAddrHighBit;
  .XNOR iXHighBitMask, %G0, iXHighBitMask;
  .AND (iNextWordAddr+nPlane), iXHighBitMask, (iNextWordAddr+nPlane);
  .ADD (iNextWordAddr+nPlane), #4, (iNextWordAddr+nPlane);
  .XOR iAddrHighBit, (iNextWordAddr+nPlane), iNextWordAddr+nPlane;
  .XNOR iXHighBitMask, %G0, iXHighBitMask;
  .LDW_IND (iNextWordAddr+nPlane), #0, (iPlaneWord+nPlane);
  .STW_MEM (iNextWordAddr+nPlane);
  .RETURN_BASICBLK;
  LP("SimGetNextWord");
#else INTERPRETER
  if (IsDestUpdated(DEST_SITE_DATA))
      *((LONG32 *) NEXT_WORD_ADDR[nPlane]) = PLANE_WORD[nPlane];
  if (lNumXBits <= 5) {
    LP("SimGetNextWord");
    return;
  ADDR_HIGH_BIT = NEXT_WORD_ADDR[nPlane] & X_HIGH_BIT_MASK;
  NEXT_WORD_ADDR[nPlane] &= (~ X_HIGH_BIT_MASK);
  NEXT_WORD_ADDR[nPlane] = (NEXT_WORD_ADDR[nPlane] + 4) ^ ADDR_HIGH_BIT;
  PLANE_WORD[nPlane] = *((LONG32 *) NEXT_WORD_ADDR[nPlane]);
  LP("SimGetNextWord");
#endif INTERPRETER
#ifndef INTERPRETER
void SimSaveLastWord(unsigned short nBitOffset[])
  short i;
  const short iSaveBits = iTemp1;
  EP("SimSaveLastWord");
#else INTERPRETER
void SimSaveLastWord(LONG32 NBIT_OFFSET[])
  short i;
  LONG32 SAVE_BITS;
  EP("SimSaveLastWord");
#endif INTERPRETER
#ifndef INTERPRETER
  if (IsDestUpdated(DEST_SITE_DATA)) {
    .ENTER_BASICBLK;
    for (i = 0; i < nNumPlanes; i++) {
      if (!nBitOffset[i])
	continue;
      .SH_RIGHT (iPlaneWord+i), #(nBitOffset[i]), iSaveBits;
      .SH_LEFT (iPlaneWord+i), #(32 - nBitOffset[i]), (iPlaneWord+i);
      .OR (iPlaneWord+i), iSaveBits, (iPlaneWord+i);
      .STW_IND (iNextWordAddr+i), #0, (iPlaneWord+i);
    }
    .RETURN_BASICBLK;
  LP("SimSaveLastWord");
#else INTERPRETER
  if (IsDestUpdated(DEST_SITE_DATA)) {
    for (i = 0; i < nNumPlanes; i++) {
      if (!NBIT_OFFSET[i])
	continue;
      SAVE_BITS = PLANE_WORD[i] >> NBIT_OFFSET[i];
      PLANE_WORD[i] <<= (32 - NBIT_OFFSET[i]);
      PLANE_WORD[i] |= SAVE_BITS;
      *((LONG32 *) NEXT_WORD_ADDR[i]) = PLANE_WORD[i];
    }
  LP("SimSaveLastWord");
#endif INTERPRETER
#ifndef INTERPRETER
void SimGeneralScan(CODEHANDLE hcodCurrent)
  /************************************************************************/
  /* Sim making no assumptions - in particular, it is expected that   */
  /* the scan index will be permuted, so that updated sites will not be   */
  /* sequentially located in memory.                                      */
  /************************************************************************/
  short i;
  CODELABEL lblMainLoop, lblAddrLoop, lblSkip1, lblSkip2;
  const short iPlaneCtr = iTemp1, iOffset = iTemp2, iPlaneBases = iTemp3;
  const short iBitOffset = iTemp4, iNextWord = iTemp5, iWordAddr = iTemp6;
  const short iSiteAddress = iTemp7, iSAHighBits = iTemp8;
  const short iOffHighBits = iTemp9, iScratch = iTemp9, iPlaneAddr = iTemp10;
  const short iSAAndMask = iTemp1, iSAOrMask = iTemp2;
  LONG32 lSAAndMask, lSAOrMask;
  LONG32 lSweepLength;
  EP("SimGeneralScan");
  nNumPlanes = CalcNumPlanes();
  lblMainLoop = NewLabel();
  lblAddrLoop = NewLabel();
  lblSkip1 = NewLabel();
  lblSkip2 = NewLabel();
#else INTERPRETER
void SimGeneralScan()
  short i;
  LONG32 PLANE_CTR;
  LONG32 SA_HIGH_BITS, OFF_HIGH_BITS, SCRATCH, PLANE_ADDR;
  LONG32 SWEEP_LENGTH, SA_OR_MASK, SA_AND_MASK, WORD_ADDR;
  nNumPlanes = CalcNumPlanes();
  EP("SimGeneralScan");
  if (nNumPlanes == 0) {
    LP("SimGeneralScan");
    return;
#endif INTERPRETER
  /************************************************************************/
  /* First, update things in the heap from where they can be accessed     */
  /* by the compiled code.                                                */
  /************************************************************************/
  /************************************************************************/
  /* Update heap copy of DCMR.						  */
  /************************************************************************/
  DCMR = DCM[0];
  /************************************************************************/
  /* Update heap copy of OFFSETS					  */
  /************************************************************************/
#ifndef INTERPRETER
  for(i =
 0 ; i < CHIPS_PER_MOD; i++)
    OFFSETS(i) = OSR[i];
#else INTERPRETER
  for(i = 0 ; i < CHIPS_PER_MOD; i++)
    OFFSETS[i] = OSR[i];
#endif INTERPRETER
  /************************************************************************/
  /* Figure out the site address of the first site to be updated. This is */
  /* needed to update SITE_ADDR for display purposes. Also,               */
  /* compute the SAAndMask and SAOrMask which will be used to do the      */
  /* permutation at execution time.                                       */
  /************************************************************************/
#ifndef INTERPRETER
  SITE_ADDR = 0;
  lSAOrMask = lSAAndMask = 0;
  for (i = SCAN_INDEX_LENGTH-1; i >= 0; i--) {
    
    SITE_ADDR <<= 1;
    lSAOrMask <<= 1;
    lSAAndMask <<= 1;
    
    if (SIPR[i][0] < SCAN_INDEX_LENGTH) {
      
      /* Get the correct bit of scan indx */
      SITE_ADDR |= (SIR[0] >> SIPR[i][0]) & 0x1;
      
      if (SIPR[i][0] == i)
	lSAAndMask |= 1;
    }
    
    /* Constant of 1 */
    else if (SIPR[i][0] == PERM_CONST_1) {
      lSAOrMask |= 1;
      SITE_ADDR |= 1;
    }
    
    else if (SIPR[i][0] != PERM_CONST_0)
      WARNING("Invalid SIPR value", "SimGenScan");
    
  /************************************************************************/
  /* Figure out how many sites will be updated, and how many sites/sweep  */
  /************************************************************************/
  SITE_CTR = ScanLength();
  lSweepLength = SweepLength(&X_CTR);
#else INTERPRETER
  SITE_ADDR = 0;
  SA_OR_MASK = SA_AND_MASK = 0;
  for (i = SCAN_INDEX_LENGTH-1; i >= 0; i--) {
    
    SITE_ADDR <<= 1;
    SA_OR_MASK <<= 1;
    SA_AND_MASK <<= 1;
    
    if (SIPR[i][0] < SCAN_INDEX_LENGTH) {
      
	/* Get the correct bit of scan indx */
      SITE_ADDR |= (SIR[0] >> SIPR[i][0]) & 0x1;
      
      if (SIPR[i][0] == i)
	SA_AND_MASK |= 1;
    }
    
    /* Constant of 1 */
    else if (SIPR[i][0] == PERM_CONST_1) {
      SA_OR_MASK |= 1;
      SITE_ADDR |= 1;
    }
      
    else if (SIPR[i][0] != PERM_CONST_0)
      WARNING("Invalid SIPR value", "SimGenScan");
  /************************************************************************/
  /* Figure out how many sites will be updated, and how many sites/sweep  */
  /************************************************************************/
  SITE_CTR = ScanLength();
  SWEEP_LENGTH = SweepLength(&X_CTR);
#endif INTERPRETER
  /************************************************************************/
  /* Next, generate the code. First, permute the scan index register to   */
  /* get the site address.                                                */
  /************************************************************************/
#ifndef INTERPRETER
    .LDW_MEM iSiteCtr;
    .LDW_MEM iXCtr;
    .LDW_MEM iXByteLength;
    
    .ADD_LABEL :lblMainLoop;
    
    .ENTER_BASICBLK;
    .LDW_MEM iScanIndexReg;
    
    .ADD %G0, #lSAAndMask, iSAAndMask;
    .ADD %G0, #lSAOrMask, iSAOrMask;
    
    .AND iScanIndexReg, iSAAndMask, iSiteAddress;
    .OR iSAOrMask, iSiteAddress, iSiteAddress;
    
    for (i = SCAN_INDEX_LENGTH-1; i >= 0; i--) {
      if ((SIPR[i][0] < SCAN_INDEX_LENGTH) && (SIPR[i][0] != i)) {
	.SH_LEFT iScanIndexReg, #(31 - SIPR[i][0]), iScratch;
	.ADDcc iScratch, iScratch, iScratch;
	.ADDX %G0, %G0, iTemp10;
	.SH_LEFT iTemp10, #i, iTemp10;
	.OR iTemp10, iSiteAddress, iSiteAddress;
      }
    }
      
#else INTERPRETER
  while (SITE_CTR != 0) {
    SITE_ADDR = SCAN_INDEX_REG & SA_AND_MASK;
    SITE_ADDR |= SA_OR_MASK;
    
    for (i = SCAN_INDEX_LENGTH-1; i >= 0; i--) {
      if ((SIPR[i][0] < SCAN_INDEX_LENGTH) && (SIPR[i][0] != i)) {
	SCRATCH = SCAN_INDEX_REG << (31 - SIPR[i][0]);
	bit = HIGHB(SCRATCH);
	SITE_ADDR |= (bit << i);
      }
    }
    
#endif INTERPRETER
    /************************************************************************/
    /* Now, add site address to the offset to get the DRAM address. The     */
    /* addition must break the carries at the dimension cuts. Also, DRAM    */
    /* address must be broken into a SPARC word address and a 5 bit offset  */
    /* into the word                                                        */
    /************************************************************************/
    
#ifndef INTERPRETER
    .ADD %DS, #offOffsets, iOffset;
    .ADD %DS, #offBitPlaneAddr, iPlaneBases;
    .ADD %DS, #offBitOffsets, iBitOffset;
    .ADD %DS, #offNextWordAddr, iNextWord;
    
    .LDW_MEM iDcmr;
    .AND iDcmr, iSiteAddress, iSAHighBits;
    .XNOR %G0, iDcmr, iDcmr;
    .AND iDcmr, iSiteAddress, iSiteAddress;
    .AND iDcmr, iSiteAddress, iScratch;
    .AND iScratch, #(SITE_ADDR_MASK), iSiteAddress;
    .XNOR %G0, iDcmr, iDcmr;
    
    .ADD %G0, #0, iPlaneCtr;
    .ADD_LABEL :lblAddrLoop;
    
    .LDW_IND iOffset, iPlaneCtr, iWordAddr;
    .AND iDcmr,  iWordAddr, iOffHighBits;
    .XNOR %G0, iDcmr, iDcmr;
    .AND iDcmr,  iWordAddr, iWordAddr;
    .ADD iSiteAddress, iWordAddr, iWordAddr;
    .XOR iWordAddr, iOffHighBits, iWordAddr;
    .XOR iWordAddr, iSAHighBits, iWordAddr;
    
    .LDW_IND iPlaneBases, iPlaneCtr, iPlaneAddr;
    .SH_RIGHT iWordAddr, #5, iScratch;
    .SH_LEFT iScratch, #2, iScratch;
    .ADD iScratch, iPlaneAddr, iScratch;
    .STW_IND iNextWord, iPlaneCtr, iScratch;
    .AND iWordAddr, #0x1F, iWordAddr;
    .STW_IND iBitOffset, iPlaneCtr, iWordAddr;
    
    .ADD iPlaneCtr, #4, iPlaneCtr;
    .SUBcc iPlaneCtr, #(nNumPlanes * 4), %G0;
    .BR_L :lblAddrLoop;
    .XNOR %G0, iDcmr, iDcmr;
    
    .RETURN_BASICBLK;
    
#else INTERPRETER
    SA_HIGH_BITS = SITE_ADDR & DCMR;
    SITE_ADDR = SITE_ADDR & (~ DCMR); 
    SITE_ADDR = (SITE_ADDR & (~ DCMR)) & SITE_ADDR_MASK;
    for(PLANE_CTR = 0; PLANE_CTR < nNumPlanes; PLANE_CTR++) {
      WORD_ADDR = OFFSETS[PLANE_CTR];
      OFF_HIGH_BITS = WORD_ADDR & DCMR;
      WORD_ADDR = SITE_ADDR + (WORD_ADDR & (~ DCMR));
      WORD_ADDR = (WORD_ADDR ^ OFF_HIGH_BITS) ^ SA_HIGH_BITS;
      PLANE_ADDR = BIT_PLANE_ADDR[PLANE_CTR];
      NEXT_WORD_ADDR[PLANE_CTR] = PLANE_ADDR + ((WORD_ADDR >> 5) << 2);
      BIT_OFFSETS[PLANE_CTR] = WORD_ADDR & 0x1F;
    }
#endif INTERPRETER
  /************************************************************************/
  /* Now, the heap has the word addresses and bit offsets for the next    */
  /* site. So go ahead and update the site.                               */
  /************************************************************************/
#ifndef INTERPRETER
  SimUpdateCode();
  .CALL_PROC [pcodGenUpdate];
  .NO_OP;
  .LDW_MEM iScanIndexReg;
  .SUBcc iXCtr, #1, iXCtr;
  .BR_NZ :lblSkip1;
  .NO_OP;
  .ADD %G0, #lSweepLength, iXCtr;
  .ADD_LABEL :lblSkip1;
  .ADD iScanIndexReg, #1, iScanIndexReg;
  .SUBcc iScanIndexReg, #(0xFFFFFF), iScratch;
  .BR_L :lblSkip2;
  .NO_OP;
  .OR %G0, %G0, iScanIndexReg;    
  .ADD_LABEL :lblSkip2;
  .SUBcc iSiteCtr, #1, iSiteCtr;
  .BR_NZ :lblMainLoop;
  .STW_MEM iScanIndexReg;
  LP("SimGeneralScan");
#else INTERPRETER
    SimUpdateCode();
    if ((--X_CTR) == 0)
      X_CTR = SWEEP_LENGTH;
    
    if ((++SCAN_INDEX_REG) > 0xFFFFFF)
      SCAN_INDEX_REG = 0;
    
    SITE_CTR--;
    ConstantSetAll(SIR, SCAN_INDEX_REG);
  LP("SimGeneralScan");
#endif INTERPRETER
#ifndef INTERPRETER
static void SimUpdateCode()
  CODEPTR pcodCurrent = pcodGenUpdate;
  EP("SimUpdateCode");
  NewBlock(&pcodCurrent);
  .ENTER_PROC;
  SimLoadPlaneWords();
  SimUpdateSite();
  .CALL_LEAF [pcodUpdateSite];
  .NO_OP;
  SimSavePlaneWords();
     
  .RETURN_PROC;
  EndBlock();
  LP("SimUpdateCode");
#else INTERPRETER
static void SimUpdateCode()
  EP("SimUpdateCode");
  SimLoadPlaneWords();
  SimUpdateSite();
  SimSavePlaneWords();
  LP("SimUpdateCode");
#endif INTERPRETER
#ifndef INTERPRETER
static void SimLoadPlaneWords()
  short i;
  const short iWordAddr = iTemp1;
  const short iBitOffset = iTemp1;
  const short iSaveBits = iTemp2;
  const short iScratch = iTemp3;
  EP("SimLoadPlaneWords");
  if (!IsSrcNeeded(SRC_SITE_DATA) && !IsSrcNeeded(SRC_GLUED_DATA) &&
      !IsDestUpdated(DEST_SITE_DATA)) {
    LP("SimLoadPlaneWords");
    return;
  .ADD %G0, #32, iScratch;
  for (i = 0; i < nNumPlanes; i++) {
    .LDW_IND %DS, #(offNextWordAddr+(i<<2)), iWordAddr;
    .LDW_IND iWordAddr, #0, (iPlaneWord+i);
    .LDW_IND %DS, #(offBitOffsets+(i<<2)), iBitOffset;
    .SUB iScratch, iBitOffset, iBitOffset;
    .SH_RIGHT (iPlaneWord+i), iBitOffset, iSaveBits;
    .SUB iScratch, iBitOffset, iBitOffset;
    .SH_LEFT (iPlaneWord+i), iBitOffset, (iPlaneWord+i);
    .OR (iPlaneWord+i), iSaveBits, (iPlaneWord+i);
  LP("SimLoadPlaneWords");
#else INTERPRETER
static void SimLoadPlaneWords()
  short i;
  LONG32 WORD_ADDR, BIT_OFFSET, SAVE_BITS;
  EP("SimLoadPlaneWords");
  if (!IsSrcNeeded(SRC_SITE_DATA) && !IsSrcNeeded(SRC_GLUED_DATA) &&
      !IsDestUpdated(DEST_SITE_DATA)) {
    LP("SimLoadPlaneWords");
    return;
  for (i = 0; i < nNumPlanes; i++) {
    WORD_ADDR = NEXT_WORD_ADDR[i];
    PLANE_WORD[i] = *((LONG32 *) WORD_ADDR);
    BIT_OFFSET = BIT_OFFSETS[i];
    SAVE_BITS = PLANE_WORD[i] >> (32 - BIT_OFFSET);
    PLANE_WORD[i] <<= BIT_OFFSET;
    PLANE_WORD[i] |= SAVE_BITS;
    PLANE_WORD[i] = (*((LONG32 *) NEXT_WORD_ADDR[i]) << BIT_OFFSETS[i]) |
                    (*((LONG32 *) NEXT_WORD_ADDR[i]) >> (32 - BIT_OFFSETS[i]));
  LP("SimLoadPlaneWords");
#endif INTERPRETER
#ifndef INTERPRETER
static void SimSavePlaneWords()
  short i;
  const short iWordAddr = iTemp1;
  const short iBitOffset = iTemp1;
  const short iSaveBits = iTemp2;
  const short iScratch = iTemp3;
  EP("SimSavePlaneWords");
  if (!IsDestUpdated(DEST_SITE_DATA)) {
    LP("SimSavePlaneWords");
    return;
  .ADD %G0, #31, iScratch;
  for (i = 0; i < nNumPlanes; i++) {
    .LDW_IND %DS, #(offBitOffsets+(i<<2)), iBitOffset;
    .SUB iScratch, iBitOffset, iBitOffset;
    .SH_LEFT (iPlaneWord+i), iBitOffset, iSaveBits;
    .SUB iScratch, iBitOffset, iBitOffset;
    .ADD iBitOffset, #1, iBitOffset;
    .SH_RIGHT (iPlaneWord+i), iBitOffset, (iPlaneWord+i);
    .OR (iPlaneWord+i), iSaveBits, (iPlaneWord+i);
    .LDW_IND %DS, #(offNextWordAddr+(i<<2)), iWordAddr;
    .STW_IND iWordAddr, #0, (iPlaneWord+i);
  LP("SimSavePlaneWords");
}     
#else INTERPRETER
static void SimSavePlaneWords()
  short i;
  LONG32 WORD_ADDR, BIT_OFFSET, SAVE_BITS;
  EP("SimSavePlaneWords");
  if (!IsDestUpdated(DEST_SITE_DATA)) {
    LP("SimSavePlaneWords");
    return;
  for (i = 0; i < nNumPlanes; i++) {
    BIT_OFFSET = BIT_OFFSETS[i];
    SAVE_BITS = PLANE_WORD[i] << (31 - BIT_OFFSET);
    PLANE_WORD[i] >>= (BIT_OFFSET + 1);
    PLANE_WORD[i] |= SAVE_BITS;
    WORD_ADDR = NEXT_WORD_ADDR[i];
    *((LONG32 *) WORD_ADDR) = PLANE_WORD[i];
    PLANE_WORD[i] = (PLANE_WORD[i] >> (BIT_OFFSETS[i] + 1)) |
                    (PLANE_WORD[i] << (31 - BIT_OFFSETS[i]));
    *((LONG32 *) NEXT_WORD_ADDR[i]) = PLANE_WORD[i];
  LP("SimSavePlaneWords");
}     
#endif INTERPRETER
#ifndef INTERPRETER
short PermuteScanIndex()
#else INTERPRETER
LONG32 *PermuteScanIndex()
#endif INTERPRETER
  short i;
  BOOL bIsPermuted = FALSE;
  EP("PermuteScanIndex");
  for (i = nNumPlanes - 1; i >= 0; i--) {
    if (SABSR[i] != i) {
      bIsPermuted = TRUE;
      break;
    }
#ifndef INTERPRETER
  if (!bIsPermuted) {
    LP("PermuteScanIndex");
    return (iScanIndexReg);
#else INTERPRETER
  if (!bIsPermuted) {
    LP("PermuteScanIndex");
    return(&SCAN_INDEX_REG);
#endif INTERPRETER
#ifndef INTERPRETER
  .OR %G0, %G0, iTemp6;
  for (i = nNumPlanes-1; i >= 0; i--) {
    if (SABSR[i] < 24) {
      .SH_LEFT iScanIndexReg, #(31 - SABSR[i]), iTemp5;
      .ADDcc iTemp5, iTemp5, iTemp5;
      .ADDXcc iTemp6, iTemp6, iTemp6;
    }
    else if (SABSR[i] == 31) {
      .SH_LEFT iTemp6, #1, iTemp6;
      .ADD iTemp6, #1, iTemp6;
    }
    else if (SABSR[i] == 30) {
      .SH_LEFT iTemp6, #1, iTemp6;
    }
    else {
      WARNING("Invalid SABSR value!", "PermuteScanIndex");
      .SH_LEFT iTemp6, #1, iTemp6;
    }
  LP("PermuteScanIndex");
  return (iTemp6);
#else INTERPRETER
  TEMP6 = 0;
  for (i = nNumPlanes-1; i >= 0; i--) {
    if (SABSR[i] < 24) {
      TEMP5 = SCAN_INDEX_REG << (31 - SABSR[i]);
      bit = HIGHB(TEMP6);
      TEMP6 = (TEMP6 << 1) | HIGHB(TEMP5);
      TEMP5 <<= 1;
    }
    else if (SABSR[i] == 31) {
      TEMP6 <<= 1;
      TEMP6 += 1;
    }
    else if (SABSR[i] == 30) {
      TEMP6 <<= 1;
    }
    else {
      WARNING("Invalid SABSR value!", "PermuteScanIndex");
      TEMP6 <<= 1;
    }
  LP("PermuteScanIndex");
  return (&TEMP6);
#endif INTERPRETER
#ifndef INTERPRETER
void MapFunction (short iSrcVar, short iDestVar, BYTE bMap)
#else INTERPRETER
void MapFunction (LONG32 *SrcVar, LONG32 *DestVar, BYTE bMap)
#endif INTERPRETER
  EP("MapFunction");
  switch (bMap) {
  case MAP_CONST_0: {
#ifndef INTERPRETER
    .OR %G0, %G0, iDestVar;
#else INTERPRETER
    *DestVar = 0;
#endif INTERPRETER
    break;
    
  case MAP_G_NOR_S: {
#ifndef INTERPRETER
    /* Surprizingly, SPARC does not have*/
    /* a native NOR instruction! ORN is */
    /* not NOR!!!                       */
    .OR iGlueData, iSrcVar, iDestVar;
    .XNOR %G0, iDestVar, iDestVar;
#else INTERPRETER
    *DestVar = ~ (GLUE_DATA | *SrcVar);
#endif INTERPRETER
    break;
}    
  case MAP_G_AND_S_BAR: {
#ifndef INTERPRETER
    .XNOR %G0, iSrcVar, iDestVar;
    .AND iGlueData, iDestVar, iDestVar;
#else INTERPRETER
    *DestVar = GLUE_DATA & (~ *SrcVar);
#endif INTERPRETER
    break;
    
  case MAP_S_BAR: {
#ifndef INTERPRETER
    .XNOR %G0, iSrcVar, iDestVar;
#else INTERPRETER
    *DestVar = ~ *SrcVar;
#endif INTERPRETER
    break;
    
  case MAP_G_BAR_AND_S: {
#ifndef INTERPRETER
    .XNOR %G0, iGlueData, iDestVar;
    .AND iSrcVar, iDestVar, iDestVar;
#else INTERPRETER
    *DestVar = (~ GLUE_DATA) & *SrcVar;
#endif INTERPRETER
    break;
    
  case MAP_G_BAR: {
#ifndef INTERPRETER
    .XNOR %G0, iGlueData, iDestVar;
#else INTERPRETER
    *DestVar = ~ GLUE_DATA;
#endif INTERPRETER
    break;
    
  case MAP_G_XOR_S: {
#ifndef INTERPRETER
    .XOR iGlueData, iSrcVar, iDestVar;
#else INTERPRETER
    *DestVar = GLUE_DATA ^ *SrcVar;
#endif INTERPRETER
    break;
    
  case MAP_G_NAND_S: {
#ifndef INTERPRETER
    /* SPARC does not have a native NAND */
    /* instruction! ANDN is not NAND     */
    .AND iGlueData, iSrcVar, iDestVar;
    .XNOR %G0, iDestVar, iDestVar;
#else INTERPRETER
    *DestVar = ~ (GLUE_DATA & *SrcVar);
#endif INTERPRETER
    break;
    
  case MAP_G_AND_S: {
#ifndef INTERPRETER
    .AND iGlueData, iSrcVar, iDestVar;
#else INTERPRETER
    *DestVar = GLUE_DATA & *SrcVar;
#endif INTERPRETER
    break;
    
  case MAP_G_EQ_S: {
#ifndef INTERPRETER
    .XNOR iGlueData, iSrcVar, iDestVar;
#else INTERPRETER
    *DestVar = ~ (GLUE_DATA ^ *SrcVar);
#endif INTERPRETER
    break;
    
  case MAP_G: {
#ifndef INTERPRETER
    .XOR %G0, iGlueData, iDestVar;
#else INTERPRETER
    *DestVar = GLUE_DATA;
#endif INTERPRETER
    break;
    
  case MAP_G_OR_S_BAR: {
#ifndef INTERPRETER
    .XNOR %G0, iSrcVar, iDestVar;
    .OR iGlueData, iDestVar, iDestVar;
#else INTERPRETER
    *DestVar = GLUE_DATA | (~ *SrcVar);
#endif INTERPRETER
    break;
    
  case MAP_S: {
#ifndef INTERPRETER
    .XOR %G0, iSrcVar, iDestVar
#else INTERPRETER
    *DestVar = *SrcVar;
#endif INTERPRETER
      break;
    
  case MAP_G_BAR_OR_S: {
#ifndef INTERPRETER
    .XNOR %G0, iGlueData, iDestVar;
    .OR iSrcVar, iDestVar, iDestVar;
#else INTERPRETER
    *DestVar = (~ GLUE_DATA) | *SrcVar;
#endif INTERPRETER
      break;
    
  case MAP_G_OR_S: {
#ifndef INTERPRETER
    .OR iGlueData, iSrcVar, iDestVar;
#else INTERPRETER
    *DestVar = GLUE_DATA | *SrcVar;
#endif INTERPRETER
    break;
    
  case MAP_CONST_1: {
#ifndef INTERPRETER
    .XNOR %G0, %G0, iDestVar;
#else INTERPRETER
    *DestVar = 0xFFFFFFFF;
#endif INTERPRETER
    break;
  LP("MapFunction");
#ifndef INTERPRETER
void BuildDest(short nDest, short iDestVar, BYTE Src, BYTE Map)
  short iSrcVar;
#else INTERPRETER
void BuildDest(short nDest, LONG32 *DestVar, BYTE Src, BYTE Map)
  LONG32 *SrcVar;
#endif INTERPRETER
  EP("BuildDest");
#ifndef INTERPRETER
  if ((Map != MAP_G) && (Map != MAP_G_BAR)) {
    iSrcVar = (Src == SRC_SITE_DATA ? iUnGlueData :
	       Src == SRC_TBUS ? iTbusData :
	       Src == SRC_LUT ? iLutData : iTemp1);
    if ((nDest == DEST_LUT) && (Src == SRC_SITE_ADDRESS)) {
      iSrcVar = PermuteScanIndex();
    }
  MapFunction(iSrcVar, iDestVar, Map);
#else INTERPRETER
  if ((Map != MAP_G) && (Map != MAP_G_BAR)) {
    SrcVar = (Src == SRC_SITE_DATA ? &UNGLUE_DATA :
	      Src == SRC_TBUS ? &TBUS_DATA :
	      Src == SRC_LUT ? &LUT_DATA : &TEMP1);
    if ((nDest == DEST_LUT) && (Src == SRC_SITE_ADDRESS)) {
      SrcVar = PermuteScanIndex();
    }
  MapFunction(SrcVar, DestVar, Map);
#endif INTERPRETER
  LP("BuildDest");
#ifndef INTERPRETER
void BuildBitDest(short nDest, short iHoldReg, BYTE Src, BYTE Map,
		  unsigned short nPlane)
{                                                               
     
#else INTERPRETER
void BuildBitDest(short nDest, LONG32 *HoldReg, BYTE Src, BYTE Map,
		  unsigned short nPlane)
{                                                               
#endif INTERPRETER
  EP("BuildBitDest");
#ifndef INTERPRETER
  if ((nDest == DEST_LUT) && (Src == SRC_SITE_ADDRESS)) {
    .OR           %G0, %G0, iTemp6;
    
    if (SABSR[nPlane] < 24) {
      .SH_LEFT iScanIndexReg, #(31 - SABSR[nPlane]), iTemp5;
      .ADDcc iTemp5, iTemp5, iTemp5;
      .ADDXcc iTemp6, iTemp6, iTemp6;
      .SH_LEFT iTemp6, #nPlane, iTemp6;
    }
    else if (SABSR[nPlane] == 31) {
      .SH_LEFT iTemp6, #1, iTemp6;
      .ADD iTemp6, #1, iTemp6;
    }
    else if (SABSR[nPlane] == 30) {
      .SH_LEFT iTemp6, #1, iTemp6;
    }
    else {
      WARNING("Invalid SABSR value", "BuildBitDest");
      .SH_LEFT iTemp6, #1, iTemp6;
    }      
    MapFunction (iTemp6, iHoldReg, Map);
  else
    BuildDest(nDest, iHoldReg, Src, Map);
#else INTERPRETER
  if ((nDest == DEST_LUT) && (Src == SRC_SITE_ADDRESS)) {
    TEMP6 = 0;
    if (SABSR[nPlane] < 24) {
      TEMP5 = SCAN_INDEX_REG << (31 - SABSR[nPlane]);
      bit = HIGHB(TEMP6);
      TEMP6 = ((TEMP6 << 1) | HIGHB(TEMP5)) << nPlane;
      TEMP5 <<= 1;
    }
    else if (SABSR[nPlane] == 31)
      TEMP6 = (TEMP6 << 1) + 1;
    else if (SABSR[nPlane] == 30)
      TEMP6 <<= 1;
    else {
      WARNING("Invalid SABSR value", "BuildBitDest");
      TEMP6 <<= 1;
    }
    MapFunction (&TEMP6, HoldReg, Map);
  else
    BuildDest(nDest, HoldReg, Src, Map);
#endif INTERPRETER
  LP("BuildBitDest");
#ifndef INTERPRETER
void BuildBitwiseDest(short nDest, short iDestVar, BYTE Src[], BYTE Map[])
  short i;
  short iHoldReg = iTemp4;
#else INTERPRETER
void BuildBitwiseDest(short nDest, LONG32 *DestVar, BYTE Src[], BYTE Map[])
  short i;
  LONG32 *HoldReg = &TEMP4;
#endif INTERPRETER
  EP("BuildBitwiseDest");
#ifndef INTERPRETER
  for (i = nNumPlanes - 1; i >= 0; i--) {
    BuildBitDest(nDest, iHoldReg, Src[i], Map[i], i);
    .SH_LEFT iHoldReg, #(31 - i), iHoldReg;
    .ADDcc iHoldReg, iHoldReg, iHoldReg;
    .ADDXcc iDestVar, iDestVar, iDestVar;
#else INTERPRETER
  for (i = nNumPlanes - 1; i >= 0; i--) {
    BuildBitDest(nDest, HoldReg, Src[i], Map[i], i);
    *HoldReg <<= (31 - i);
    bit = HIGHB(*DestVar);
    *DestVar = (*DestVar << 1) | HIGHB(*HoldReg);
    *HoldReg <<= 1;
#endif INTERPRETER
  LP("BuildBitwiseDest");
/*****************************************************************************/
/*                                                                           */
/* This routine adds two longs breaking the carries at positions indicated   */
/* by the Dimension Cut Mask Register (DCMR). The DCMR has a 1 bit at every  */
/* bit position where the carry needs to be cut.                             */
/*                                                                           */
/*****************************************************************************/
LONG32 AddSiteAddress(LONG32 lSrc1, LONG32 lSrc2)
  LONG32 lHighBits1, lHighBits2;
  lHighBits1 = lSrc1 & DCM[0];
  lHighBits2 = lSrc2 & DCM[0];
  lSrc1 &= (~DCM[0]);
  lSrc2 &= (~DCM[0]);
  return( (lSrc1 + lSrc2) ^ lHighBits1 ^ lHighBits2 );
LONG32 SubSiteAddress(LONG32 lSrc1, LONG32 lSrc2)
  LONG32 lSignBitOffset, lSignBitKick, lLowBitsKick;
  lSignBitOffset = lSrc1 & DCM[0];
  lSignBitKick = (~lSrc2) & DCM[0];
  lSrc1 |= DCM[0];
  lLowBitsKick = lSrc2 & (~ DCM[0]);
  lSrc1 -= lLowBitsKick;
  lSignBitOffset = lSignBitOffset ^ lSignBitKick;
  lSrc1 ^= lSignBitOffset;
/*****************************************************************************/
/*                                                                           */
/* Compute the Scan length - the number of sites that will be updated in     */
/* the current scan. Basically, it should be 2^ESCP, but we need to correct  */
/* for the fact that the SIR low-order bits might not be all zero            */
/*                                                                           */
/*****************************************************************************/
LONG32 ScanLength()
  LONG32 lCarryOVFBit, lScanLength, lSIRBits;
  lCarryOVFBit = ESC[0];
  lScanLength = (1 << lCarryOVFBit);                                  
  lSIRBits = SIR[0] & (lScanLength - 1);
  lScanLength -= lSIRBits;
  return (lScanLength);
/*****************************************************************************/
/*                                                                           */
/* Determine the sweep length. The sweep length is given by either the low   */
/* bit of the DCMR or the ESCP (End-of-Scan-pointer) or the SFR register.    */
/* This is because the scan could update many lines of the lowest (X) dimen- */
/* sion, or could update just part of 1 line in the X dimension.             */
/*                                                                           */
/*****************************************************************************/
LONG32 SweepLength(LONG32 *lFirstSweep)
  LONG32 lCarryOVFBit, lSweepLength;
  lCarryOVFBit = MIN(ESW[0], lNumXBits);
  lSweepLength = (1 << lCarryOVFBit);
  *lFirstSweep = (SIR[0] & (lSweepLength - 1));
  *lFirstSweep = lSweepLength - *lFirstSweep;
  return (lSweepLength);
/*****************************************************************************/
/*                                                                           */
/* DCMRHighBit returns a long with exactly one of the 32 bits set to 1. This */
/* bit position corresponds to the highest bit in the DCMR that has a 1.     */
/*                                                                           */
/*****************************************************************************/
LONG32 DCMRHighBit()
  LONG32 lTemp1, lTemp2;                                                      
  lTemp1 = DCM[0];
  lTemp2 = 1;
  while (lTemp1 > 1) {
    lTemp1 >>= 1;
    lTemp2 <<= 1;
  return (lTemp2);
/*****************************************************************************/
/*                                                                           */
/* DCMRLowBit returns a long with exactly one of the 32 bits set to 1. This  */
/* bit position corresponds to the lowest bit in the DCMR that has a 1. We   */
/* refer to this lowest dimension generically as the X dimension.            */
/*                                                                           */
/*****************************************************************************/
LONG32 DCMRLowBit()
  LONG32 lTemp1, lTemp2;
  lTemp1 = DCM[0];
  lTemp2 = 1;
  lNumXBits = 1;
  while ((lTemp1 != 0) && ((lTemp1 & 0x01) == 0)) {
    lTemp1 >>= 1;
    lTemp2 <<= 1;
    lNumXBits++;
  return (lTemp2);
void UpdateDCMR()
  lDCMRHighBit = DCMRHighBit();
  lDCMRLowBit = DCMRLowBit();
/*****************************************************************************/
/*                                                                           */
/* The following are general purpose routines that conveniently answer       */
/* queries about the sources and destinations that need to be updated        */
/*                                                                           */
/*****************************************************************************/
/*****************************************************************************/
/*                                                                           */
/* Is a particular source needed? Only checks those planes that will be      */
/* updated or used during the next scan.                                     */
/*                                                                           */
/*****************************************************************************/
BOOL IsSrcNeeded(short nSrc)
  short i, j;
  short nLastDest;
  nLastDest = (nSrc == SRC_TBUS ? DEST_LUT : DEST_DISPLAY);
  for (i = nNumPlanes - 1; i >= 0; i--) {
    for (j = DEST_SITE_DATA; j <= nLastDest; j++) {
      if (bDestSrcMatrix[i][j][nSrc]) {
	return TRUE;
      }
    }
  return FALSE;
/*****************************************************************************/
/*                                                                           */
/* Checks to see if the source/map is the same for all planes for the given  */
/* destination.                                                              */
/*                                                                           */
/*****************************************************************************/
BOOL IsSrcSame(short nDest)
  short i;
  BYTE *src, *map;
  switch (nDest) {
  case DEST_SITE_DATA:
    src = SDS;
    map = SDM;
    break;
  case DEST_EVENT_CT:
    src = ECS;
    map = ECM;
    break;
  case DEST_DISPLAY:
    src = DDS;
    map = DDM;
    break;
  case DEST_LUT:
    src = LAS;
    map = LAM;
    break;
  default:
    return FALSE;
    break;
  for(i = 1; i < nNumPlanes; i++)
    if ((src[0] != src[i]) || (map[0] != map[i]))
      return FALSE;
  return TRUE;
/*****************************************************************************/
/*                                                                           */
/* See if a particular destination will be changed during the current scan   */
/*                                                                           */
/*****************************************************************************/
BOOL IsDestUpdated(short nDest)
  short i, j;
  for (i = nNumPlanes-1; i >= 0; i--)
    for ( j = SRC_SITE_DATA; j <= SRC_CONST_DATA; j++)
      if (bDestSrcMatrix[i][nDest][j])
	return(TRUE);
  return(FALSE);
/*****************************************************************************/
/*                                                                           */
/* Calculate the number of planes that will be updated or used in the next   */
/* scan.                                                                     */
/*                                                                           */
/*****************************************************************************/
unsigned short CalcNumPlanes()
  BOOL       bPlaneUsed[CHIPS_PER_MOD];
  short      i, j;
  memset ((char *) bPlaneUsed, 0, CHIPS_PER_MOD * sizeof(BOOL));
  UpdateDestSrcMatrix();
  for (i = CHIPS_PER_MOD-1; i >= 0; i--) {
    for (j = DEST_SITE_DATA; j <= DEST_DISPLAY; j++) {
      if ( bDestSrcMatrix[i][j][SRC_SITE_DATA] || 
	  bDestSrcMatrix[i][j][SRC_GLUED_DATA] ) {
	bPlaneUsed[i] = TRUE;
      }
    }
    
    if (!bPlaneUsed[i]) {
      for (j = SRC_TBUS; j <= SRC_CONST_DATA; j++) {
	if (bDestSrcMatrix[i][DEST_SITE_DATA][j]) {
	  bPlaneUsed[i] = TRUE;
      }
    }
    if (bPlaneUsed[i])
      break;
  }  
  return ((unsigned short) i + 1);
/*****************************************************************************/
/*                                                                           */
/* Updates a matrix of sources and destinations. There are 5 sources, 4 dest */
/* and 16 planes. In addition, there is a bit per destination indicating     */
/* whether the map field selects an inverse function or just the function.   */
/* Thus, the SrcDestMatrix is a 6x4x16 matrix.                               */
/*                                                                           */
/*****************************************************************************/
void UpdateDestSrcMatrix()
  short      i;
  char       *szFuncName = "UpdateDestSrcMatrix";    
  memset((char *) bDestSrcMatrix, 0, CHIPS_PER_MOD*NUM_SRC*NUM_DEST);
  for (i = 0; i < CHIPS_PER_MOD; i++) {
    
    /*
     * If the source for the site is the site then don't bother to generate
     * code for this.  If the map selects only the glue lines then the source
     * selection is irrelevant.  If the map selects MAP_G then this is
     * effectively the same as selecting site as the source.  If the map
     * selects CONST_0 or CONST_1 then we handle this as a special case.
     */
    if (SDS[i] != SRC_SITE_DATA)
      bDestSrcMatrix[i][DEST_SITE_DATA][SDS[i]] = TRUE;
    if ((SDM[i] != MAP_S) && (SDM[i] != MAP_S_BAR)) {
      if (SDM[i] != MAP_G)
	bDestSrcMatrix[i][DEST_SITE_DATA][SRC_GLUED_DATA] = TRUE;
      if ((SDM[i] == MAP_CONST_0) || (SDM[i] == MAP_CONST_1)) {
	bDestSrcMatrix[i][DEST_SITE_DATA][SRC_CONST_DATA] = TRUE;
	bDestSrcMatrix[i][DEST_SITE_DATA][SRC_GLUED_DATA] = FALSE;
	bDestSrcMatrix[i][DEST_SITE_DATA][SDS[i]] = FALSE;
      }
      if ((SDM[i] == MAP_G) || (SDM[i] == MAP_G_BAR))
	bDestSrcMatrix[i][DEST_SITE_DATA][SDS[i]] = FALSE;
    }
    /*
     * If the source for the event counter is constant zero then don't bother
     * to generate code for this.  If the map selects only the glue lines then
     * the source selection is irrelevant.
     */
    bDestSrcMatrix[i][DEST_EVENT_CT][ECS[i]] = TRUE;
    if ((ECM[i] != MAP_S) && (ECM[i] != MAP_S_BAR)) {
      bDestSrcMatrix[i][DEST_EVENT_CT][SRC_GLUED_DATA] = TRUE;
      if ((ECM[i] == MAP_CONST_0) || (ECM[i] == MAP_CONST_1)) {
	if (ECM[i] == MAP_CONST_1)
	  bDestSrcMatrix[i][DEST_EVENT_CT][SRC_CONST_DATA] = TRUE;
	bDestSrcMatrix[i][DEST_EVENT_CT][SRC_GLUED_DATA] = FALSE;
	bDestSrcMatrix[i][DEST_EVENT_CT][ECS[i]] = FALSE;
      }
      if ((ECM[i] == MAP_G) || (ECM[i] == MAP_G_BAR))
 	bDestSrcMatrix[i][DEST_EVENT_CT][ECS[i]] = FALSE;
    }
    /*
     * If the source for the display is the host (tbus) then don't bother to
     * generate code for this.  If the map selects only the glue lines then
     * the source selection is irrelevant.
     */
    if ((DDS[i] != SRC_TBUS))
      bDestSrcMatrix[i][DEST_DISPLAY][DDS[i]] = TRUE;
    if ((DDM[i] != MAP_S) && (DDM[i] != MAP_S_BAR)) {
      bDestSrcMatrix[i][DEST_DISPLAY][SRC_GLUED_DATA] = TRUE;
      if ((DDM[i] == MAP_CONST_0) || (DDM[i] == MAP_CONST_1)) {
	bDestSrcMatrix[i][DEST_DISPLAY][SRC_CONST_DATA] = TRUE;
	bDestSrcMatrix[i][DEST_DISPLAY][SRC_GLUED_DATA] = FALSE;
	bDestSrcMatrix[i][DEST_DISPLAY][DDS[i]] = FALSE;
      }
      if ((DDM[i] == MAP_G) || (DDM[i] == MAP_G_BAR)) {
	bDestSrcMatrix[i][DEST_DISPLAY][DDS[i]] = FALSE;
      }
    }
    /*
     * If the map selects only the glue lines then the source selection is
     * irrelevant.
     */
    bDestSrcMatrix[i][DEST_LUT][LAS[i]] = TRUE;
    if ((LAM[i] != MAP_S) && (LAM[i] != MAP_S_BAR)) {
      bDestSrcMatrix[i][DEST_LUT][SRC_GLUED_DATA] = TRUE;
      if ((LAM[i] == MAP_CONST_0) || (LAM[i] == MAP_CONST_1)) {
	bDestSrcMatrix[i][DEST_LUT][SRC_CONST_DATA] = TRUE;
	bDestSrcMatrix[i][DEST_LUT][SRC_GLUED_DATA] = FALSE;
	bDestSrcMatrix[i][DEST_LUT][LAS[i]] = FALSE;
      }
      if ((LAM[i] == MAP_G) || (LAM[i] == MAP_G_BAR)) {
	bDestSrcMatrix[i][DEST_LUT][LAS[i]] = FALSE;
      }
    }

---------------------------------------------------------------------------

#ifndef _CAM8SIMULATORMODULE_H_
#define _CAM8SIMULATORMODULE_H_
#include <CAM/CALib++.H>
#include <CAM/CAM8SimJIT++.H>
#include "std++.H"
#ifdef DEBUG
#ifdef __cplusplus
extern "C" {
#endif
#include <stdio.h>
#ifdef __cplusplus
#endif
#endif
/*****************************************************************************/
/********************************* DEFINES ***********************************/
/*****************************************************************************/
#define FLD_SELECT(i)		((i) + 32)
#define FLD_MAP(i)		((i) + 64)
#define NUM_DEST		4
#define NUM_SRC			6
#define SRC_SITE_DATA		0
#define SRC_TBUS		1
#define SRC_FLYWHEEL		2
#define SRC_LUT			3
#define SRC_SITE_ADDRESS	3
#define SRC_GLUED_DATA		4
#define SRC_CONST_DATA		5
#define DEST_SITE_DATA		0
#define DEST_EVENT_CT		1
#define DEST_LUT		2
#define DEST_DISPLAY		3
#define MAP_CONST_0		0
#define MAP_G_NOR_S		1
#define MAP_G_AND_S_BAR		2
#define MAP_S_BAR		3
#define MAP_G_BAR_AND_S		4
#define MAP_G_BAR		5
#define MAP_G_XOR_S		6
#define MAP_G_NAND_S		7
#define MAP_G_AND_S		8
#define MAP_G_EQ_S		9
#define MAP_G			10
#define MAP_G_OR_S_BAR		11
#define MAP_S			12
#define MAP_G_BAR_OR_S		13
#define MAP_G_OR_S		14
#define MAP_CONST_1		15
#ifndef INTERPRETER
#define SCANNER_CODE_SIZE       (1024 * LONG32_SIZE)
#define SWEEP_CODE_SIZE         (1024 * LONG32_SIZE)
#define UPDATE_CODE_SIZE        (1024 * LONG32_SIZE)
#else !INTERPRETER
#define HIGHB(x)		(((x) & 0x80000000) ? 0x1 : 0x0)
#endif !INTERPRETER
#ifdef DEBUG
#define EP(name) fprintf(DEBUGFILE, "ENTER: %s\n", name)
#define LP(name) fprintf(DEBUGFILE, "LEAVE: %s\n", name)
#ifndef INTERPRETER
#define ASCODE(c)  fprintf(DEBUGFILE, "\t0x%x: %s\n", DASMADDR, c); fflush(DEBUGFILE)
#define ASNOTE(c)  fprintf(DEBUGFILE, "\t%s\n", c); fflush(DEBUGFILE)
#endif !INTERPRETER
#else DEBUG
#define EP(name)
#define LP(name)
#ifndef INTERPRETER
#define ASCODE(name)
#define ASNOTE(c)
#endif !INTERPRETER
#endif DEBUG
#ifdef __cplusplus
/*****************************************************************************/
/******************************** TEMPLATES **********************************/
/*****************************************************************************/
/*****************************************************************************/
/*************************** CLASSES & TYPEDEFS ******************************/
/*****************************************************************************/
class Cam8SimulatorModule {
public:
#ifdef DEBUG
  static char *REGNAMES[] = {
    "select", "run", "kick", "sa-bit", "lut-src", "fly-src", "site-src", "event-src", "display", "show-scan", "event",
    "lut-index", "lut-perm", "lut-io", "scan-index", "scan-perm", "scan-io", "scan-format", "offset", "dimension",
    "environment", "multi", "connect", "module-id", "group-id", "int-enable", "int-flags", "verify", "dram-count"
  };
#endif
  CAM8SimJIT *jit;
  /* CAM8 Registers */
  BYTE MSR[CHIPS_PER_MOD];
  BYTE SSM[CHIPS_PER_MOD];
  BYTE RT[CHIPS_PER_MOD];
  BYTE ECT[CHIPS_PER_MOD];
  BYTE RPK[CHIPS_PER_MOD];
  BYTE ALT[CHIPS_PER_MOD];
  LONG32 KA[CHIPS_PER_MOD];
  BYTE XKS[CHIPS_PER_MOD];
  BYTE YKS[CHIPS_PER_MOD];
  BYTE ZKS[CHIPS_PER_MOD];
  BYTE XKMF[CHIPS_PER_MOD];
  BYTE YKMF[CHIPS_PER_MOD];
  BYTE ZKMF[CHIPS_PER_MOD];
  BYTE SABSR[CHIPS_PER_MOD];
  BYTE LAS[CHIPS_PER_MOD];
  BYTE LAM[CHIPS_PER_MOD];
  BYTE FOS[CHIPS_PER_MOD];
  BYTE FOM[CHIPS_PER_MOD];
  BYTE SDS[CHIPS_PER_MOD];
  BYTE SDM[CHIPS_PER_MOD];
  BYTE ECS[CHIPS_PER_MOD];
  BYTE ECM[CHIPS_PER_MOD];
  BYTE DDS[CHIPS_PER_MOD];
  BYTE DDM[CHIPS_PER_MOD];
  BYTE SSR[CHIPS_PER_MOD];
  LONG32 ECR[CHIPS_PER_MOD];
  INT16 LIR[CHIPS_PER_MOD];
  BYTE LIPR[CHIPS_PER_MOD];
  INT16 *LIOR;
  LONG32 SIR[CHIPS_PER_MOD];
  BYTE SSA[24][CHIPS_PER_MOD];
  BYTE *SIOR;
  BYTE SM[CHIPS_PER_MOD];
  BYTE ESC[CHIPS_PER_MOD];
  BYTE ESW[CHIPS_PER_MOD];
  BYTE EST[CHIPS_PER_MOD];
  BYTE SBRC[CHIPS_PER_MOD];
  BYTE RCL[CHIPS_PER_MOD];
  BYTE ECL[CHIPS_PER_MOD];
  BYTE STM[CHIPS_PER_MOD];
  LONG32 OSR[CHIPS_PER_MOD];
  LONG32 DCM[CHIPS_PER_MOD];
  BYTE XDCP[CHIPS_PER_MOD];
  BYTE YDCP[CHIPS_PER_MOD];
  BYTE ZDCP[CHIPS_PER_MOD];
  BYTE LPL[CHIPS_PER_MOD];
  BYTE FPL[CHIPS_PER_MOD];
  BYTE DCS[CHIPS_PER_MOD];
  BYTE TBD[CHIPS_PER_MOD];
  BYTE TMS[CHIPS_PER_MOD];
  BYTE NBF[CHIPS_PER_MOD];
  BYTE SRE[CHIPS_PER_MOD];
  BYTE ALS[CHIPS_PER_MOD];
  BYTE MAFS[CHIPS_PER_MOD];
  BYTE MBFS[CHIPS_PER_MOD];
  BYTE XMPC[CHIPS_PER_MOD];
  BYTE XPPC[CHIPS_PER_MOD];
  BYTE YMPC[CHIPS_PER_MOD];
  BYTE YPPC[CHIPS_PER_MOD];
  BYTE ZMPC[CHIPS_PER_MOD];
  BYTE ZPPC[CHIPS_PER_MOD];
  BYTE MIDR[CHIPS_PER_MOD];
  BYTE GIDR[CHIPS_PER_MOD];
  BYTE BPIE[CHIPS_PER_MOD];
  BYTE BCIE[CHIPS_PER_MOD];
  BYTE GCIE[CHIPS_PER_MOD];
  BYTE MAIE[CHIPS_PER_MOD];
  BYTE MBIE[CHIPS_PER_MOD];
  BYTE SSIE[CHIPS_PER_MOD];
  BYTE XHIE[CHIPS_PER_MOD];
  BYTE RLIE[CHIPS_PER_MOD];
  BYTE URIE[CHIPS_PER_MOD];
  BYTE ISIE[CHIPS_PER_MOD];
  BYTE BPIF[CHIPS_PER_MOD];
  BYTE BCIF[CHIPS_PER_MOD];
  BYTE GCIF[CHIPS_PER_MOD];
  BYTE MAIF[CHIPS_PER_MOD];
  BYTE MBIF[CHIPS_PER_MOD];
  BYTE SSIF[CHIPS_PER_MOD];
  BYTE XHIF[CHIPS_PER_MOD];
  BYTE RLIF[CHIPS_PER_MOD];
  BYTE URIF[CHIPS_PER_MOD];
  BYTE ISIF[CHIPS_PER_MOD];
  BYTE VWE[CHIPS_PER_MOD];
  BYTE VWIE[CHIPS_PER_MOD];
  BYTE VWIF[CHIPS_PER_MOD];
  BYTE LDOC[CHIPS_PER_MOD];
  BYTE HDOC[CHIPS_PER_MOD];
  unsigned short nNumPlanes;
  BYTE WhyScan;
#ifdef _FRAMEBUFFER_
  BYTE *FRAMEb;							/* FRAME buffer */
#endif _FRAMEBUFFER_
  BOOL bDestSrcMatrix [CHIPS_PER_MOD][NUM_DEST][NUM_SRC];
  BOOL bSourceRegChange;
  BOOL bDestChange;
  BOOL bForceGeneralScan;
  BOOL bByteMode;
  BOOL bImmediate;
  BOOL bReadMode;
  INT16 *LUTb[2];						/* LUT buffers */
  LONG32 SITE_ADDR;
  LONG32 lDCMRHighBit;
  LONG32 lDCMRLowBit;
  LONG32 lNumXBits;
#ifndef INTERPRETER
  CODE *pcodScanNoPerm;
  CODEPTR pcodGenUpdate;
  CODEPTR pcodScanner;
  CODEPTR pcodSweep;
  CODEPTR pcodUpdateSite;
#else !INTERPRETER
  LONG32 bit;
  LONG32 HIGH_BIT_MASK;
  LONG32 X_HIGH_BIT_MASK;
  LONG32 X_BYTE_LENGTH;
  LONG32 X_CTR;
  LONG32 SITE_CTR;
  LONG32 OFFSETS[CHIPS_PER_MOD];
  LONG32 BIT_OFFSETS[CHIPS_PER_MOD];
  LONG32 DCMR;
  LONG32 SCAN_INDEX_REG;
  LONG32 LUT_ADDR;
  LONG32 BIT_PLANE_ADDR[CHIPS_PER_MOD];
  LONG32 NEXT_WORD_ADDR[CHIPS_PER_MOD];
  LONG32 PLANE_WORD[CHIPS_PER_MOD];
  LONG32 EVENT_COUNT[CHIPS_PER_MOD];
  LONG32 UNGLUE_DATA;
  LONG32 GLUE_DATA;
  LONG32 SITE_DATA;
  LONG32 TBUS_DATA;
  LONG32 LUT_DATA;
  LONG32 DISP_DATA;
  LONG32 TBUS_ADDR;
  LONG32 FRAME_ADDR;
  LONG32 TEMP1;
  LONG32 TEMP2;
  LONG32 TEMP3;
  LONG32 TEMP4;
  LONG32 TEMP5;
  LONG32 TEMP6;
  LONG32 TEMP7;
  LONG32 TEMP8;
  LONG32 TEMP9;
  LONG32 TEMP10;
#endif !INTERPRETER
#ifdef DEBUG
  FILE* DEBUGFILE;
#ifndef INTERPRETER
  CODEPTR DASMADDR;
#endif !INTERPRETER
#endif DEBUG
  CAM8SimModule(void);
  DECL_COPYCONST(CAM8SimModule);
  virtual ~CAM8SimModule(void);
  DECL_OPEQ(CAM8SimModule);
  DECL_BZERO(CAM8SimModule);
  DECL_BCOPY(CAM8SimModule);
  DECL_BCMP(CAM8SimModule);
#ifndef INTERPRETER
  void InitSim(void);
  void SimScanNoPerm(CODEHANDLE hcodCurrent);
  void SimGeneralScan(CODEHANDLE hcodCurrent);
  void SimPrologue(CODEHANDLE hcodCurrent);
  void SimEpilogue(CODEHANDLE hcodCurrent);
  void SimUpdateSite();
  void SimLoadFirstWord(unsigned short nBitOffset[]);
  void SimGetNextWord(unsigned short nPlane);
  void SimSaveLastWord(unsigned short nBitOffset[]);
  void CheckNoPerm(CODEHANDLE hcodCurrent);
  void SimUpdateCode();
  void SimLoadPlaneWords();
  void SimSavePlaneWords();
  void MapFunction (short iSrcVar, short iDestVar, BYTE bMap);
  void BuildDest(short nDest, short iDestVar, BYTE Src, BYTE Map);
  void BuildBitDest(short nDest, short iHoldReg, BYTE Src, BYTE Map, unsigned short nPlane);
  void BuildBitwiseDest(short nDest, short iDestVar, BYTE Src[], BYTE Map[]);
  short PermuteScanIndex();
#else !INTERPRETER
  void SimScanNoPerm();
  void SimGeneralScan();
  void SimUpdateSite();
  void CheckNoPerm();
  void SimLoadFirstWord(LONG32 nBitOffset[]);
  void SimGetNextWord(unsigned short nPlane);
  void SimSaveLastWord(LONG32 nBitOffset[]);
  void SimUpdateCode();
  void SimLoadPlaneWords();
  void SimSavePlaneWords();
  void MapFunction (LONG32 *SrcVar, LONG32 *DestVar, BYTE bMap);
  void BuildDest(short nDest, LONG32 *DestVar, BYTE Src, BYTE Map);
  void BuildBitDest(short nDest, LONG32 *HoldReg, BYTE Src, BYTE Map, unsigned short nPlane);
  void BuildBitwiseDest(short nDest, LONG32 *DestVar, BYTE Src[], BYTE Map[]);
  LONG32 *PermuteScanIndex();
#endif !INTERPRETER
  void InitModule(void);
  void SimStepList(LONG32 *plFirstInstr);
  void SimScan(void);
  void UpdateDCMR(void);
  void UpdateDestSrcMatrix(void);
  void UpdateDCMR();
  void UpdateDestSrcMatrix();
  unsigned short CalcNumPlanes();
  unsigned short CalcNumPlanes(void);
  BOOL IsSrcNeeded(short nSrc);
  BOOL IsSrcSame(short nDest);
  BOOL IsDestUpdated(short nDest);
  BOOL IsSrcNeeded(short nSrc);
  BOOL IsSrcSame(short nDest);
  BOOL IsDestUpdated(short nDest);
  LONG32 AddSiteAddress(LONG32 lSrc1, LONG32 lSrc2);
  LONG32 SubSiteAddress(LONG32 lSrc1, LONG32 lSrc2);
  LONG32 ScanLength(void);
  LONG32 SweepLength(LONG32 *lFirstSweep);
  LONG32 AddSiteAddress(LONG32 lSrc1, LONG32 lSrc2);
  LONG32 SubSiteAddress(LONG32 lSrc1, LONG32 lSrc2);
  LONG32 ScanLength();
  LONG32 SweepLength(LONG32 *lFirstSweep);
  LONG32 DCMRHighBit();
  LONG32 DCMRLowBit();
  inline void ConstantSetAll(BYTE r[], BYTE v);
  inline void ConstantSetAll(INT16 r[], INT16 v);
  inline void ConstantSetAll(LONG32 r[], LONG32 v);
  inline void SetAll(BYTE r[], BYTE v[]);
  inline void SetAll(INT16 r[], INT16 v[]);
  inline void SetAll(LONG32 r[], LONG32 v[]);
/*****************************************************************************/
/********************************* INLINES ***********************************/
/*****************************************************************************/
inline void Cam8SimulatorModule::ConstantSetAll(BYTE r[], BYTE v)
  register int i;
  for(i = 0; i < CHIPS_PER_MOD; i++)
    r[i]=v;
inline void Cam8SimulatorModule::ConstantSetAll(INT16 r[], INT16 v)
  register int i;
  for(i = 0; i < CHIPS_PER_MOD; i++)
    r[i]=v;
inline void Cam8SimulatorModule::ConstantSetAll(LONG32 r[], LONG32 v)
  register int i;
  for(i = 0; i < CHIPS_PER_MOD; i++)
    r[i]=v;
inline void Cam8SimulatorModule::SetAll(BYTE r[], BYTE v[])
  memcpy(r, v, CHIPS_PER_MOD * sizeof(BYTE));
inline void Cam8SimulatorModule::SetAll(INT16 r[], INT16 v[])
  memcpy(r, v, CHIPS_PER_MOD * sizeof(BYTE));
inline void Cam8SimulatorModule::SetAll(LONG32 r[], LONG32 v[])
  memcpy(r, v, CHIPS_PER_MOD * sizeof(BYTE));
#endif
/*****************************************************************************/
/******************************* PROTOTYPES **********************************/
/*****************************************************************************/
/*****************************************************************************/
/********************************* GLOBALS ***********************************/
/*****************************************************************************/
#endif

---------------------------------------------------------------------------

#ifndef _CAM8SIMJIT_H_
#define _CAM8SIMJIT_H_
#include <stdio.h>
#include <CAM/CALib++.H>
#include "std++.H"
/*****************************************************************************/
/********************************* DEFINES ***********************************/
/*****************************************************************************/
/*****************************************************************************/
/*                                                                           */
/* operand types to use when calling Emit()				     */
/*                                                                           */
/*****************************************************************************/
#define NULL_OP		0
#define REG_OP		1
#define CONST_OP	2
#define ADDR_OP		3
#define VAR_OP		4
#define LABEL_OP	5
/*****************************************************************************/
/*                                                                           */
/* op codes for emit							     */
/*                                                                           */
/*****************************************************************************/
#define PSEUDO_OP	0x8000
#define NATIVE_OP	0x4000
#define LD_ST_OP	0x2000
#define BRANCH_OP	0x1000
#define NATIVE_OP_MASK	0x3F
#define INSTR		(PSEUDO_OP | 0xFF)
#define ENTER_PROC	(PSEUDO_OP | 0x01)
#define RETURN_PROC	(PSEUDO_OP | 0x02)
#define CALL_PROC	(PSEUDO_OP | 0x03)
#define ENTER_LEAF	(PSEUDO_OP | 0x04)
#define RETURN_LEAF	(PSEUDO_OP | 0x05)
#define CALL_LEAF	(PSEUDO_OP | 0x06)
#define CALL_LEAF_IND	(PSEUDO_OP | 0x07)
#define ENTER_BASICBLK	(PSEUDO_OP | 0x08)
#define RETURN_BASICBLK	(PSEUDO_OP | 0x09)
#define ADD_LABEL	(PSEUDO_OP | 0x0A)
#define NO_OP		(PSEUDO_OP | 0x0B)
#define LDW_MEM		(LD_ST_OP | 0x00)
#define LDW_IND		(LD_ST_OP | 0x01)
#define LDHW_IND	(LD_ST_OP | 0x02)
#define LDUB_IND	(LD_ST_OP | 0x03)
#define STW_MEM		(LD_ST_OP | 0x06)
#define STW_IND		(LD_ST_OP | 0x07)
#define STHW_IND	(LD_ST_OP | 0x08)
#define STUB_IND	(LD_ST_OP | 0x09)
#define ADD		(NATIVE_OP | 0x00)
#define ADDcc		(NATIVE_OP | 0x10)
#define ADDX		(NATIVE_OP | 0x08)
#define ADDXcc		(NATIVE_OP | 0x18)
#define	SUB		(NATIVE_OP | 0x04)
#define SUBcc		(NATIVE_OP | 0x14)
#define SUBX		(NATIVE_OP | 0x0C)
#define SUBXcc		(NATIVE_OP | 0x1C)
#define AND		(NATIVE_OP | 0x01)
#define ANDcc		(NATIVE_OP | 0x11)
#define ANDN		(NATIVE_OP | 0x05)
#define ANDNcc		(NATIVE_OP | 0x15)
#define OR		(NATIVE_OP | 0x02)
#define ORcc 		(NATIVE_OP | 0x12)
#define ORN		(NATIVE_OP | 0x06)
#define ORNcc		(NATIVE_OP | 0x16)
#define XOR		(NATIVE_OP | 0x03)
#define XORcc 		(NATIVE_OP | 0x13)
#define XNOR		(NATIVE_OP | 0x07)
#define XNORcc		(NATIVE_OP | 0x17)
#define SH_LEFT		(NATIVE_OP | 0x25)
#define SH_RIGHT	(NATIVE_OP | 0x26)
#define SH_RIGHT_ARITH	(NATIVE_OP | 0x27)
#define BRANCH		(BRANCH_OP | 0x08)
#define BR_NEVER	(BRANCH_OP | 0x00)
#define BR_NEQ		(BRANCH_OP | 0x09)
#define BR_EQ		(BRANCH_OP | 0x01)
#define BR_GR		(BRANCH_OP | 0x0A)
#define BR_LE		(BRANCH_OP | 0x02)
#define BR_GRE		(BRANCH_OP | 0x0B)
#define BR_L		(BRANCH_OP | 0x03)
#define BR_GU		(BRANCH_OP | 0x0C)
#define BR_LEU		(BRANCH_OP | 0x04)
#define BR_CC		(BRANCH_OP | 0x0D)
#define BR_CS		(BRANCH_OP | 0x05)
#define BR_POS		(BRANCH_OP | 0x0E)
#define BR_NEG		(BRANCH_OP | 0x06)
#define BR_VC		(BRANCH_OP | 0x0F)
#define BR_VS		(BRANCH_OP | 0x07)
#define BR_NZ		(BRANCH_OP | 0x09)
#define BR_Z		(BRANCH_OP | 0x01)
#ifdef __cplusplus
/*****************************************************************************/
/******************************** TEMPLATES **********************************/
/*****************************************************************************/
/*****************************************************************************/
/*************************** CLASSES & TYPEDEFS ******************************/
/*****************************************************************************/
typedef unsigned long   CODE;
typedef unsigned short	CODELABEL;
typedef CODE            *CODEPTR;
typedef CODEPTR         *CODEHANDLE;
class CAM8SimJIT {
public:
  virtual void NewBlock(CODEHANDLE hcodDest) = 0;
  virtual void EndBlock() = 0;
  virtual void Emit(INT16 opcode,
	    BYTE op1Type, LONG32 op1,
	    BYTE op2Type, LONG32 op2,
	    BYTE destType, LONG32 dest) = 0;
  virtual void PrintAsm(CODEPTR pcodSource, FILE *fOut) = 0;
/*****************************************************************************/
/********************************* INLINES ***********************************/
/*****************************************************************************/
#endif
/*****************************************************************************/
/******************************* PROTOTYPES **********************************/
/*****************************************************************************/
/*****************************************************************************/
/********************************* GLOBALS ***********************************/
/*****************************************************************************/
#endif

---------------------------------------------------------------------------

#ifndef _CAM8SIMINTERFACE_H_
#define _CAM8SIMINTERFACE_H_
#include <CAM/CALib++.H>
#include "std++.H"
/*****************************************************************************/
/********************************* DEFINES ***********************************/
/*****************************************************************************/
#define RESET_CAM_MASK		0x80000000					 /* These are bits of the control or */
#define READ_CAM_MASK		0x40000000					 /* first long word of every step    */
#define IMMEDIATE_DATA_MASK	0x20000000					 /* instruction 		     */
#define BYTE_MODE_MASK		0x10000000
#define HOST_JUMP_MASK		0x00008000
#define HOST_WAIT_MASK		0x00004000
#define SOFT_INT_MASK		0x00002000
#define WAIT_EOS_MASK		0x00001000
#define REGISTER_ADDR_MASK	0x0000003F
/* NLP/NLP */
#define CAM_INTERFACE_HALTED    0x00000008 /* Interface Halted?            */
#define CAM_WAIT_FOR_HOST       0x00000004 /* CAM waiting for host? status */
#define CAM_EXCEPTION_STATUS    0x00000002 /* Interface Exception status   */
#define CAM_NLP_WRITTEN         0x00000001 /* CAM NLP written? status      */
/* ISR/RER */
#define CAM_INT_PENDING_STATUS  0x0000001F /* Status of all Interrupt Bits */
#define CAM_NEWLIST_INT_STATUS  0x00000010 /* Status new-list interrupt    */
#define CAM_TIMEOUT_INT_STATUS  0x00000008 /* Status timeout interrupt     */
#define CAM_SBUS_INT_STATUS     0x00000004 /* Status Sbus interrupt        */
#define CAM_CAM_INT_STATUS      0x00000002 /* Status CAM interrupt         */
#define CAM_SOFT_INT_STATUS     0x00000001 /* Status interrupt             */
#define CAM_RESET_INTERFACE     0x80000000 /* Reset the interface          */
#define CAM_HALT_INTERFACE      0x00008000 /* Halt the interface           */
#define CAM_CLEAR_EXCEPTION     0x00004000 /* Clear exceptions (enable     */
					   /* exceptions caused by timeout)*/
#define CAM_ENABLE_TIMEOUT_EXC  0x00004000 /* enable exceptions caused     */
					   /* by timeout (clear exceptions)*/
#define CAM_RESUME_AFTER_ERR    0x00002000 /* Resume after error ack       */
					   /* (enable exceptions by CAM    */
					   /* interrupt)                   */
#define CAM_ENABLE_CAMINT_EXC   0x00002000 /* enable exceptions by CAM     */
					   /* interrupt (resume after      */
					   /* error ack)                   */
#define CAM_ENABLE_NEWLIST_INT  0x00001000 /* Enable new-list interrupt    */
#define CAM_ENABLE_TIMEOUT_INT  0x00000800 /* Enable timeout interrupt     */
#define CAM_ENABLE_SBUS_INT     0x00000400 /* Enable Sbus interrupt        */
#define CAM_ENABLE_CAM_INT      0x00000200 /* Enable CAM interrupt         */
#define CAM_ENABLE_SOFT_INT     0x00000100 /* Enable soft interrupt        */
#define CAM_DISABLE_TIMEOUT_EXC 0x00000040 /* Disable new-list interrupt   */
#define CAM_DISABLE_CAMINT_EXC  0x00000020 /* Disable timeout interrupt    */
#define CAM_DISABLE_NEWLIST_INT 0x00000010 /* Disable new-list interrupt   */
#define CAM_DISABLE_TIMEOUT_INT 0x00000008 /* Disable timeout interrupt    */
#define CAM_DISABLE_SBUS_INT    0x00000004 /* Disable Sbus interrupt       */
#define CAM_DISABLE_CAM_INT     0x00000002 /* Disable CAM interrupt        */
#define CAM_DISABLE_SOFT_INT    0x00000001 /* Disable soft interrupt       */
/* CIP/DSL */
#define CAM_TRANSFER_WAITING   0x00000008  /* Is CAM waiting to transfer?  */
#define CAM_DONE_STATUS        0x00000004  /* CAM Done status              */
#define CAM_PARTIAL_WRITE      0x00000002  /* Partial write after Sbus err?*/
#define CAM_FSM_SUSPENDED      0x00000001  /* Is Sbus FSM suspended?       */
/* PIP/DBL */
#define CAM_INTRFC_RESET_PNDNG 0x00000008  /* Interface reset pending?     */
#define CAM_SS2                0x00000004  /* CAM SS2 mode set?            */
#define CAM_SCANNING_STATUS    0x00000002  /* CAM scanning status          */
#define CAM_INTERRUPT_STATUS   0x00000001  /* CAM interrupt status         */
#ifdef __cplusplus
/*****************************************************************************/
/******************************** TEMPLATES **********************************/
/*****************************************************************************/
/*****************************************************************************/
/*************************** CLASSES & TYPEDEFS ******************************/
/*****************************************************************************/
class CAM8Sim;		// Forward reference
typedef struct interface_registers {
    
  LONG32 NLP;                          /* Next List Pointer            */
  LONG32 ISR;                          /* Reset/Interrupt Register     */
  LONG32 CIP;                          /* Current Instruction Pointer  */
  LONG32 PIP;                          /* Previous Instruction Pointer */
    
  LONG32 RER;                          /* Reset/Enable Register        */
  LONG32 DSL;                          /* Display Scan Length          */
  LONG32 DBL;                          /* Display Blank Length         */
} INTERFACE_REGS;
typedef struct {
  char *base;
  int type;
} Bt, *BT;
class CAM8SimInterface {
public:
  CAM8Sim *simulator;
  Bt base_type[790];
  INTERFACE_REGS iregs;
  LONG32 pbuf[CHIPS_PER_MOD];
  CAM8SimInterface(void);
  DECL_COPYCONST(CAM8SimInterface);
  virtual ~CAM8SimInterface(void);
  DECL_OPEQ(CAM8SimInterface);
  DECL_BZERO(CAM8SimInterface);
  DECL_BCOPY(CAM8SimInterface);
  DECL_BCMP(CAM8SimInterface);
  virtual int main(int argc, char *argv[]);
  virtual void InitInterface(CAM8Sim *sim);
  virtual void ReadCmdLine(int argc, char *argv[]);
  virtual void InitExitProcs();
  virtual void ExitSigProc();
  virtual void ExitProc();
  virtual void Generate_Interrupt(int type) throws CAM8SimInterrupt;
  virtual void ResetInterface(void);
  virtual void InitStepList();
  virtual void UnpackState(INT16 *, int, int);
  virtual void UnpackStateInto(INT16 *, int, int, BYTE *, int);
  virtual void PackState(INT16 *, int);
  virtual void PackStateFrom(INT16 *, int, BYTE *, int);
/*****************************************************************************/
/********************************* INLINES ***********************************/
/*****************************************************************************/
inline void CAM8SimInterface::SENTER(int i, char *b, int t)
  base_type[i].base = b;
  base_type[i].type = t;
#endif
/*****************************************************************************/
/******************************* PROTOTYPES **********************************/
/*****************************************************************************/
/*****************************************************************************/
/********************************* GLOBALS ***********************************/
/*****************************************************************************/
#endif

---------------------------------------------------------------------------

#include <CAM/CALib++.H>
#include <CAM/CamStream++.H>
#include <CAM/CamError++.H>
#include <CAM/CamTrace++.H>
#include <CAM/Cam8Instr++.H>
#include <CAM/CAM8SimInterface++.H>
#include "std++.H"
CAM8SimInterface::CAM8SimInterface(void)
CAM8SimInterface::~CAM8SimInterface(void)
void CAM8SimInterface::InitInterface(CAM8Sim *sim)
  VWECHK = 0;
  simulator = sim;
int CAM8SimInterface::main(int argc, char *argv[])
  ReadCmdLine(argc, argv);
  InitStepList();
  InitExitProcs();
void CAM8SimInterface::ReadCmdLine(int argc, char *argv[])
void CAM8SimInterface::InitStepList()
  SENTER(RFINDEX(REG_MSR), MSR, BIT8);
  SENTER(RFINDEX(FLD_SSM), SSM, BIT8);
  SENTER(RFINDEX(FLD_RT), RT, BIT8);
  SENTER(RFINDEX(FLD_ECT), ECT, BIT8);
  SENTER(RFINDEX(FLD_RPK), RPK, BIT8);
  SENTER(RFINDEX(FLD_ALT), ALT, BIT8);
  SENTER(RFINDEX(FLD_KA), KA, BIT32);
  SENTER(RFINDEX(FLD_XKS), XKS, BIT8);
  SENTER(RFINDEX(FLD_YKS), YKS, BIT8);
  SENTER(RFINDEX(FLD_ZKS), ZKS, BIT8);
  SENTER(RFINDEX(FLD_XKMF), XKMF, BIT8);
  SENTER(RFINDEX(FLD_YKMF), YKMF, BIT8);
  SENTER(RFINDEX(FLD_ZKMF), ZKMF, BIT8);
  SENTER(RFINDEX(REG_SABSR), SABSR, BIT8);
  SENTER(RFINDEX(FLD_LAS), LAS, BIT8);
  SENTER(RFINDEX(FLD_LAM), LAM, BIT8);
  SENTER(RFINDEX(FLD_FOS), FOS, BIT8);
  SENTER(RFINDEX(FLD_FOM), FOM, BIT8);
  SENTER(RFINDEX(FLD_SDS), SDS, BIT8);
  SENTER(RFINDEX(FLD_SDM), SDM, BIT8);
  SENTER(RFINDEX(FLD_ECS), ECS, BIT8);
  SENTER(RFINDEX(FLD_ECM), ECM, BIT8);
  SENTER(RFINDEX(FLD_DDS), DDS, BIT8);
  SENTER(RFINDEX(FLD_DDM), DDM, BIT8);
  SENTER(RFINDEX(REG_SSR), SSR, BIT8);
  SENTER(RFINDEX(REG_ECR), ECR, BIT32);
  SENTER(RFINDEX(REG_LIR), LIR, BIT8);
  SENTER(RFINDEX(REG_LIPR), LIPR, BIT8);
  SENTER(RFINDEX(REG_SIR), SIR, BIT32);
  SENTER(RFINDEX(FLD_SSA0), SSA0, BIT8);
  SENTER(RFINDEX(FLD_SSA1), SSA1, BIT8);
  SENTER(RFINDEX(FLD_SSA2), SSA2, BIT8);
  SENTER(RFINDEX(FLD_SSA3), SSA3, BIT8);
  SENTER(RFINDEX(FLD_SSA4), SSA4, BIT8);
  SENTER(RFINDEX(FLD_SSA5), SSA5, BIT8);
  SENTER(RFINDEX(FLD_SSA6), SSA6, BIT8);
  SENTER(RFINDEX(FLD_SSA7), SSA7, BIT8);
  SENTER(RFINDEX(FLD_SSA8), SSA8, BIT8);
  SENTER(RFINDEX(FLD_SSA9), SSA9, BIT8);
  SENTER(RFINDEX(FLD_SSA10), SSA10, BIT8);
  SENTER(RFINDEX(FLD_SSA11), SSA11, BIT8);
  SENTER(RFINDEX(FLD_SSA12), SSA12, BIT8);
  SENTER(RFINDEX(FLD_SSA13), SSA13, BIT8);
  SENTER(RFINDEX(FLD_SSA14), SSA14, BIT8);
  SENTER(RFINDEX(FLD_SSA15), SSA15, BIT8);
  SENTER(RFINDEX(FLD_SSA16), SSA16, BIT8);
  SENTER(RFINDEX(FLD_SSA17), SSA17, BIT8);
  SENTER(RFINDEX(FLD_SSA18), SSA18, BIT8);
  SENTER(RFINDEX(FLD_SSA19), SSA19, BIT8);
  SENTER(RFINDEX(FLD_SSA20), SSA20, BIT8);
  SENTER(RFINDEX(FLD_SSA21), SSA21, BIT8);
  SENTER(RFINDEX(FLD_SSA22), SSA22, BIT8);
  SENTER(RFINDEX(FLD_SSA23), SSA23, BIT8);
  SENTER(RFINDEX(FLD_SM), SM, BIT8);
  SENTER(RFINDEX(FLD_ESC), ESC, BIT8);
  SENTER(RFINDEX(FLD_ESW), ESW, BIT8);
  SENTER(RFINDEX(FLD_EST), EST, BIT8);
  SENTER(RFINDEX(FLD_SBRC), SBRC, BIT8);
  SENTER(RFINDEX(FLD_RCL), RCL, BIT8);
  SENTER(RFINDEX(FLD_ECL), ECL, BIT8);
  SENTER(RFINDEX(FLD_STM), STM, BIT8);
  SENTER(RFINDEX(REG_OSR), OSR, BIT32);
  SENTER(RFINDEX(FLD_DCM), DCM, BIT32);
  SENTER(RFINDEX(FLD_XDCP), XDCP, BIT8);
  SENTER(RFINDEX(FLD_YDCP), YDCP, BIT8);
  SENTER(RFINDEX(FLD_ZDCP), ZDCP, BIT8);
  SENTER(RFINDEX(FLD_LPL), LPL, BIT8);
  SENTER(RFINDEX(FLD_FPL), FPL, BIT8);
  SENTER(RFINDEX(FLD_DCS), DCS, BIT8);
  SENTER(RFINDEX(FLD_TBD), TBD, BIT8);
  SENTER(RFINDEX(FLD_TMS), TMS, BIT8);
  SENTER(RFINDEX(FLD_NBF), NBF, BIT8);
  SENTER(RFINDEX(FLD_SRE), SRE, BIT8);
  SENTER(RFINDEX(FLD_ALS), ALS, BIT8);
  SENTER(RFINDEX(FLD_MAFS), MAFS, BIT8);
  SENTER(RFINDEX(FLD_MBFS), MBFS, BIT8);
  SENTER(RFINDEX(FLD_XMPC), XMPC, BIT8);
  SENTER(RFINDEX(FLD_XPPC), XPPC, BIT8);
  SENTER(RFINDEX(FLD_YMPC), YMPC, BIT8);
  SENTER(RFINDEX(FLD_YPPC), YPPC, BIT8);
  SENTER(RFINDEX(FLD_ZMPC), ZMPC, BIT8);
  SENTER(RFINDEX(FLD_ZPPC), ZPPC, BIT8);
  SENTER(RFINDEX(REG_MIDR), MIDR, BIT8);
  SENTER(RFINDEX(REG_GIDR), GIDR, BIT8);
  SENTER(RFINDEX(FLD_BPIE), BPIE, BIT8);
  SENTER(RFINDEX(FLD_BCIE), BCIE, BIT8);
  SENTER(RFINDEX(FLD_GCIE), GCIE, BIT8);
  SENTER(RFINDEX(FLD_MAIE), MAIE, BIT8);
  SENTER(RFINDEX(FLD_MBIE), MBIE, BIT8);
  SENTER(RFINDEX(FLD_SSIE), SSIE, BIT8);
  SENTER(RFINDEX(FLD_XHIE), XHIE, BIT8);
  SENTER(RFINDEX(FLD_RLIE), RLIE, BIT8);
  SENTER(RFINDEX(FLD_URIE), URIE, BIT8);
  SENTER(RFINDEX(FLD_ISIE), ISIE, BIT8);
  SENTER(RFINDEX(FLD_BPIF), BPIF, BIT8);
  SENTER(RFINDEX(FLD_BCIF), BCIF, BIT8);
  SENTER(RFINDEX(FLD_GCIF), GCIF, BIT8);
  SENTER(RFINDEX(FLD_MAIF), MAIF, BIT8);
  SENTER(RFINDEX(FLD_MBIF), MBIF, BIT8);
  SENTER(RFINDEX(FLD_SSIF), SSIF, BIT8);
  SENTER(RFINDEX(FLD_XHIF), XHIF, BIT8);
  SENTER(RFINDEX(FLD_RLIF), RLIF, BIT8);
  SENTER(RFINDEX(FLD_URIF), URIF, BIT8);
  SENTER(RFINDEX(FLD_ISIF), ISIF, BIT8);
  SENTER(RFINDEX(FLD_VWE), VWE, BIT8);
  SENTER(RFINDEX(FLD_VWIE), VWIE, BIT8);
  SENTER(RFINDEX(FLD_VWIF), VWIF, BIT8);
  SENTER(RFINDEX(FLD_LDOC), LDOC, BIT8);
  SENTER(RFINDEX(FLD_HDOC), HDOC, BIT8);
void CAM8SimInterface::InitExitProcs()
#ifdef BADSIG
     const void * err = BADSIG;
#else
     const void * err = SIG_ERR;
#endif
#ifdef sun
#if 0
     on_exit(ExitProc);								 /* Make sure it gets called on exit */
#else
     atexit(ExitProc);								 /* Make sure it gets called on exit */
#endif
#endif
     
     if ( (signal(SIGHUP, ExitSigProc) == err) ||
	  (signal(SIGINT, SIG_IGN) == err) ||
	  (signal(SIGQUIT, SIG_IGN) == err) ||
	  (signal(SIGILL, ExitSigProc) == err) ||
	  (signal(SIGFPE, ExitSigProc) == err) ||
	  (signal(SIGBUS, ExitSigProc) == err) ||
	  (signal(SIGSEGV, ExitSigProc) == err) ||
	  (signal(SIGSYS, ExitSigProc) == err) ||
	  (signal(SIGPIPE, ExitSigProc) == err) ||
	  (signal(SIGTERM, ExitSigProc) == err) ) {
	  WARNING("Could not install cleanup routines!", "InitExitProc");
     }
#ifdef BADSIG
void CAM8SimPipeInterface::ExitSigProc(int sig, int code, struct sigcontext *scp, char *addr)
#else
void CAM8SimPipeInterface::ExitSigProc(int sig)
#endif
  static char *pcSignalName[] = {
    "Unknown",
    "Hangup",
    "Interrupt",
    "Quit",
    "Illegal Instruction",
    "Trace Trap",
    "IO (Hardware) Trap",
    "Emulator Trap",
    "Floating Point Exception",
    "Kill",
    "Bus Error",
    "Segmentation Fault",
    "Bad Argument to system call",
    "Write to broken pipe",
    "Alarm",
    "Software Termination",
    "User1",
    "User2",
    "Child Termination",
    "Power down"
  };
  fprintf(stderr, "CAM8SIM: ");
     
  switch (sig) {
  case SIGHUP:
  case SIGSYS:
  case SIGPIPE:
    fprintf(stderr, "%s signal received - exiting.\n", pcSignalName[sig]);
    break;
    
  case SIGILL:
  case SIGFPE:
#ifdef BADSIG
    fprintf(stderr, "Attempt to execute illegal instruction at 0x%x\n", addr);
#else
    fprintf(stderr, "Attempt to execute illegal instruction\n");
#endif
    break;
  case SIGBUS:
  case SIGSEGV:
#ifdef BADSIG
    fprintf(stderr, "Attempt to access invalid memory location 0x%x\n", addr);
#else
    fprintf(stderr, "Attempt to access invalid memory location\n");
#endif
    break;
  case SIGTERM:
    fprintf(stderr, "Termination signal received - exiting.\n");
    break;
  default:
    break;
#ifdef DEBUG
  fclose(DEBUGFILE);
#endif
  _exit(0);
void CAM8SimInterface::ExitProc()
#ifdef DEBUG
  fclose(DEBUGFILE);
#endif
void CAM8SimInterface::ResetInterface(void)
  /* Zero everything out to start off */
  bzero((char *) &iregs, sizeof(iregs));
  /* Enable all interrupts and exceptions */
  iregs.RER = CAM_ENABLE_NEWLIST_INT | CAM_ENABLE_TIMEOUT_INT |
              CAM_ENABLE_SBUS_INT | CAM_ENABLE_CAM_INT |
	      CAM_ENABLE_SOFT_INT | CAM_ENABLE_TIMEOUT_EXC |
	      CAM_ENABLE_CAMINT_EXC;
  /* Mark all interrupts as enabled */
  iregs.ISR = CAM_ENABLE_NEWLIST_INT | CAM_ENABLE_TIMEOUT_INT |
              CAM_ENABLE_SBUS_INT | CAM_ENABLE_CAM_INT |
	      CAM_ENABLE_SOFT_INT;
  /* Put us in wait-for-host mode */
  iregs.NLP |= CAM_WAIT_FOR_HOST;
void CAM8SimInterface::Generate_Interrupt(int type) throws CAM8SimInterrupt
  iregs.ISR |= type;
  switch(type) {
  case CAM_CAM_INT_STATUS: {
    if ((iregs.RER & CAM_ENABLE_CAMINT_EXC) && !(iregs.RER & CAM_DISABLE_CAMINT_EXC)) {
      iregs.NLP |= CAM_EXCEPTION_STATUS;
      throw CAM8SimInterrupt;
    }
    break;
  case CAM_TIMEOUT_INT_STATUS: {
    if ((iregs.RER & CAM_ENABLE_TIMEOUT_EXC) && !(iregs.RER & CAM_DISABLE_TIMEOUT_EXC)) {
      iregs.NLP |= CAM_EXCEPTION_STATUS;
      throw CAM8SimInterrupt;
    }
    break;
void CAM8SimInterface::vwecheck(INT16 *base, int reg_fld, int imm)
  register int i;
  int f = 0, o;
  Bt bt;
  bt = base_type[reg_fld];
  if (VWECHK) {
    UnpackStateInto(base, reg_fld, imm, (BYTE *) pbuf, bt.type);
    for (i = 0; i < CHIPS_PER_MOD; i++) {
      o = bt.type * i;
      if (VWE[i]) {
	if (bcmp(bt.base + o, ((BYTE *) pbuf) + o, bt.type) != 0) {
	  f = 1;
	  VWIF[i] = 1;
      }
      else
	bcopy(((BYTE *) pbuf) + o, bt.base + o, bt.type);
    }
  else
    UnpackState(base, reg_fld, imm);
void CAM8SimInterface::SimStepList(LONG32 *plFirstInstr)
  LONG32 *plCurr = NULL, *plNext = NULL;
  LONG32 lData = 0, lLength;
  short nRegister, i, imm = FALSE;
  BOOL bHostJump, bHostWait, bByteMode, bReadMode;
  BOOL bDone = FALSE;
  LONG32 pbuf[CHIPS_PER_MOD];
  bHostJump = bHostWait = FALSE;
  for (plCurr = plFirstInstr; !bDone; plCurr = plNext) {
    bHostJump = (*plCurr & HOST_JUMP_MASK) != 0;
    bHostWait = (*plCurr & HOST_WAIT_MASK) != 0;
    bDone = bHostJump || bHostWait;
    bByteMode = (*plCurr & BYTE_MODE_MASK) != 0;
    bReadMode = (*plCurr & READ_CAM_MASK) != 0;
    
    cam8sim_iregs.PIP = cam8sim_iregs.CIP;
    cam8sim_iregs.CIP = (LONG32) plNext;
    if (*plCurr & RESET_CAM_MASK) {
      memset ((char *) &CAM8State, 0, sizeof(CAM8State));
      LIOR = LUT1;
      LUT_ADDR = (LONG32) LUT0;
      bSourceRegChange = bDestChange = TRUE;
      
#ifdef DEBUG
      fprintf(DEBUGFILE, "CAM Reset\n");
      fflush(DEBUGFILE);
#endif
    }
    
    
    nRegister = *plCurr & REGISTER_ADDR_MASK;
    imm = (*plCurr & IMMEDIATE_DATA_MASK) != 0;
    lData = *(plCurr + 1);
    lLength = *(plCurr + 2);
    
    plNext = (LONG32 *) (*(plCurr + 3));
    
    if ((*plCurr & READ_CAM_MASK) && (*plCurr & IMMEDIATE_DATA_MASK)) {
#ifdef DEBUG
      fprintf(DEBUGFILE, "NOOP\n");
#endif
      continue;
    }
    
    
#ifdef DEBUG
    fprintf(DEBUGFILE, "REG = %d (%s), ", nRegister, REGNAMES[nRegister]);
    if (imm)
      fprintf(DEBUGFILE, "IMMEDIATE DATA, ");
    fprintf(DEBUGFILE, "BYTEMODE = %d, READMODE = %d\n", bByteMode, bReadMode);
    fflush(DEBUGFILE);
#endif
    
    if ((*plCurr & READ_CAM_MASK) != 0) {
      INT16 *pnBuffer;
      
      CAM8State.bReadMode = TRUE;
      bDestChange = TRUE;
      
      pnBuffer = (INT16 *) lData;
      
      SimReadInstr(pnBuffer, *plCurr, lData, lLength);
      
      continue;
    }
    
    
    switch (nRegister) {
      
    case RFINDEX(REG_MSR): {
      vwecheck((INT16 *) lData, RFINDEX(REG_MSR), imm);
      break;
    }      
      
      
    case RFINDEX(REG_RMR): {
      vwecheck((INT16 *) lData, RFINDEX(FLD_SSM), imm);
      vwecheck((INT16 *) lData, RFINDEX(FLD_RT), imm);
      vwecheck((INT16 *) lData, RFINDEX(FLD_ECT), imm);
      vwecheck((INT16 *) lData, RFINDEX(FLD_RPK), imm);
      vwecheck((INT16 *) lData, RFINDEX(FLD_ALT), imm);
      
#ifndef INTERPRETER
      for(i = 0; i < CHIPS_PER_MOD; i++) {
	if (ECT[i] == 1) {
          ECR[i] = EVENT_COUNT(i);
          EVENT_COUNT(i) = 0L;
        }
        if (RPK[i] == 1)
          DoKick(i);
      }
      
#else INTERPRETER
      for(i = 0; i < CHIPS_PER_MOD; i++) {
	if (ECT[i] == 1) {
          ECR[i] = EVENT_COUNT[i];
          EVENT_COUNT[i] = 0L;
        }
        if (RPK[i] == 1)
          DoKick(i);
      }
      
#endif INTERPRETER
      if (ALT[0] == 1) {
        INT16 *pnTemp;
        
        pnTemp = LIOR;
        LIOR = (INT16 *) LUT_ADDR;
        LUT_ADDR = (LONG32) pnTemp;
        
        for (i = 0; i < CHIPS_PER_MOD; i++)
	  ALS[i] ^= 1;
      }
      if (CAM8State.bReadMode != FALSE) {
	bDestChange = TRUE;
	CAM8State.bReadMode = FALSE;
      }
      if (SSM[0] != 0) {
	CAM8State.WhyScan = RFINDEX(REG_RMR);
#ifndef INTERPRETER
        SimCompScan();
        
#ifndef _DRYRUN_                 
#ifdef _INSTRUMENTATION_
	gettimeofday(&tvStart, &tzZone);
#endif
        SimExecScan();
#ifdef _INSTRUMENTATION_
	gettimeofday(&tvEnd, &tzZone);
      
	fprintf(stderr, "Regular Scan took %d usecs\n",
		(tvEnd.tv_sec - tvStart.tv_sec) * 1000000 +
		(tvEnd.tv_usec - tvStart.tv_usec));
#endif _INSTRUMENTATION_
#endif _DRYRUN_
#else INTERPRETER
	SimExecScan();
#endif INTERPRETER
      }
      
      break;
    }
      
      
    case RFINDEX(REG_KR): {
      vwecheck((INT16 *) lData, RFINDEX(FLD_KA), imm);
      vwecheck((INT16 *) lData, RFINDEX(FLD_XKS), imm);
      vwecheck((INT16 *) lData, RFINDEX(FLD_YKS), imm);
      vwecheck((INT16 *) lData, RFINDEX(FLD_ZKS), imm);
      vwecheck((INT16 *) lData, RFINDEX(FLD_XKMF), imm);
      vwecheck((INT16 *) lData, RFINDEX(FLD_YKMF), imm);
      vwecheck((INT16 *) lData, RFINDEX(FLD_ZKMF), imm);
      DoKick(-1);
      break;
    }
      
      
    case RFINDEX(REG_SABSR):
      {
	vwecheck((INT16 *) lData, RFINDEX(REG_SABSR), imm);
	break;
      }
    case RFINDEX(REG_LASR):
    case RFINDEX(REG_FOSR):
    case RFINDEX(REG_SDSR):
    case RFINDEX(REG_ECSR):
    case RFINDEX(REG_DSR): {
      vwecheck((INT16 *) lData, FLD_SELECT(nRegister), imm);
      vwecheck((INT16 *) lData, FLD_MAP(nRegister), imm);
      bSourceRegChange = TRUE;
      break;
    }
      
    case RFINDEX(REG_SSR): {
      vwecheck((INT16 *) lData, RFINDEX(REG_SSR), imm);
      
      break;
    }
      
      
    case RFINDEX(REG_ECR): {
      if (ECL[0] != lLength) {
	ConstantSetAll(RLIF, 1);
	Generate_Interrupt(CAM_CAM_INT_STATUS);
      }
      else {
	int i;
	UnpackBits((INT16 *) lData, 0, lLength, imm, (BYTE *) ECR, BIT32);
	for(i = 0; i < CHIPS_PER_MOD; i++)
#ifndef INTERPRETER
	  EVENT_COUNT(i) = ECR[i];
#else INTERPRETER
	  EVENT_COUNT[i] = ECR[i];
#endif INTERPRETER
      }
      break;
    }
      
      
    case RFINDEX(REG_LIR): {
      vwecheck((INT16 *) lData, RFINDEX(REG_LIR), imm);
      break;
    }
      
      
    case RFINDEX(REG_LIPR): {
      vwecheck((INT16 *) lData, RFINDEX(REG_LIPR), imm);
      
      break;
    }
      
      
    case RFINDEX(REG_LIOR): {
      INT16 nLUTEntry, nLUTNextIndex;
      INT16 *pnLUT, *pnSource;
      int i, j;
      INT16 nImmediate[2];
      
      if (imm) {
        nImmediate[0] = (INT16) lData >> 16;
        nImmediate[1] = (INT16) lData & 0xFF;
        pnSource = &nImmediate[0];
      }
      
      else
        pnSource = (INT16 *) lData;
      
      for (i = 0; i < lLength; i++) {
        nLUTNextIndex = 0;
        for (j = CHIPS_PER_MOD - 1; j >= 0; j--) {
          nLUTNextIndex <<= 1;
          if (LIPR[j] < 16)
            nLUTNextIndex |= ((LIR[j] >> LIPR[j]) & 0x1);
          else if (LIPR[j] == 31)
            nLUTNextIndex |= 0x1;
	  LIR[j]++;
        }
        pnLUT = LIOR + nLUTNextIndex;                 
        
        if (imm) {
          *pnLUT = *pnSource;
          pnSource = &nImmediate[i % 2];
        } 
        
        else {
          *pnLUT = *pnSource;
          pnSource++;
        }
      }
      
      break;
    }
      
      
    case RFINDEX(REG_SIR): {
      vwecheck((INT16 *) lData, RFINDEX(REG_SIR), imm);
      
      SCAN_INDEX_REG = SIR[0];
      
      break;
    }
      
      
    case RFINDEX(REG_SIPR): {
      int j;
      
      for(j = 0; j < SCAN_INDEX_LENGTH; j++)
        vwecheck((INT16 *) lData, RFINDEX(FLD_SSA(j)), imm);
      
      break;
    }
      
      
    case RFINDEX(REG_SIOR): {
      if ((CAM8State.bByteMode != bByteMode) || 
          (CAM8State.bImmediate != imm)) {
        CAM8State.bByteMode = bByteMode;
        CAM8State.bImmediate = imm;
        bSourceRegChange = TRUE;
      }
      
      if (imm) {
        SIOR = (BYTE *) &lData;
        TBUS_DATA = lData;
#ifndef INTERPRETER
	SIOREG = (LONG32) SIOR;
#endif INTERPRETER
      }
      
      else {
        SIOR = (BYTE *) lData;
	TBUS_ADDR = lData;
#ifndef INTERPRETER
	SIOREG = (LONG32) SIOR;
#endif INTERPRETER
      }
      
      if (CAM8State.bReadMode != FALSE) {
        bDestChange = TRUE;
        CAM8State.bReadMode = FALSE;
      }
      
      CAM8State.WhyScan = RFINDEX(REG_SIOR);
#ifndef INTERPRETER
      SimCompScan();
#ifndef _DRYRUN_                 
#ifdef _INSTRUMENTATION_
      gettimeofday(&tvStart, &tzZone);
#endif
      SimExecScan();
#ifdef _INSTRUMENTATION_
      gettimeofday(&tvEnd, &tzZone);
      
      fprintf(stderr, "Scan I/O Write took %d usecs\n",
	      (tvEnd.tv_sec - tvStart.tv_sec) * 1000000 +
	      (tvEnd.tv_usec - tvStart.tv_usec));
#endif _INSTRUMENTATION_
#endif _DRYRUN_
      
#else INTERPRETER
      
      SimExecScan();      
#endif INTERPRETER
      break;
    }
      
      
    case RFINDEX(REG_SFR): {
      vwecheck((INT16 *) lData, RFINDEX(FLD_SM), imm);
      vwecheck((INT16 *) lData, RFINDEX(FLD_ESC), imm);
      vwecheck((INT16 *) lData, RFINDEX(FLD_ESW), imm);
      vwecheck((INT16 *) lData, RFINDEX(FLD_EST), imm);
      vwecheck((INT16 *) lData, RFINDEX(FLD_SBRC), imm);
      vwecheck((INT16 *) lData, RFINDEX(FLD_RCL), imm);
      vwecheck((INT16 *) lData, RFINDEX(FLD_ECL), imm);
      vwecheck((INT16 *) lData, RFINDEX(FLD_STM), imm);
      
      break;
    }
      
      
    case RFINDEX(REG_OSR): {
      vwecheck((INT16 *) lData, nRegister, imm);
      break;
    }
      
      
    case RFINDEX(REG_DR): {
      vwecheck((INT16 *) lData, RFINDEX(FLD_DCM), imm);
      vwecheck((INT16 *) lData, RFINDEX(FLD_XDCP), imm);
      vwecheck((INT16 *) lData, RFINDEX(FLD_YDCP), imm);
      vwecheck((INT16 *) lData, RFINDEX(FLD_ZDCP), imm);
      UpdateDCMR();
      
      break;
    }
      
      
    case RFINDEX(REG_HER): {
      vwecheck((INT16 *) lData, RFINDEX(FLD_LPL), imm);
      vwecheck((INT16 *) lData, RFINDEX(FLD_FPL), imm);
      vwecheck((INT16 *) lData, RFINDEX(FLD_DCS), imm);
      vwecheck((INT16 *) lData, RFINDEX(FLD_TBD), imm);
      vwecheck((INT16 *) lData, RFINDEX(FLD_TMS), imm);
      vwecheck((INT16 *) lData, RFINDEX(FLD_NBF), imm);
      vwecheck((INT16 *) lData, RFINDEX(FLD_SRE), imm);
      vwecheck((INT16 *) lData, RFINDEX(FLD_ALS), imm);
       
      if (ALS[0] == 1) {
        LIOR = (INT16*) LUT0;
        LUT_ADDR = (LONG32) LUT1;
      } 
      
      else {
        LIOR = (INT16 *) LUT1;
        LUT_ADDR = (LONG32) LUT0;
      }
      
      bSourceRegChange = TRUE;
      
      break;
    }
      
      
    case RFINDEX(REG_MPCR): {
      vwecheck((INT16 *) lData, RFINDEX(FLD_MAFS), imm);
      vwecheck((INT16 *) lData, RFINDEX(FLD_MBFS), imm);
      break;
    }
      
      
    case RFINDEX(REG_GPCR): {
      vwecheck((INT16 *) lData, RFINDEX(FLD_XMPC), imm);
      vwecheck((INT16 *) lData, RFINDEX(FLD_XPPC), imm);
      vwecheck((INT16 *) lData, RFINDEX(FLD_YMPC), imm);
      vwecheck((INT16 *) lData, RFINDEX(FLD_YPPC), imm);
      vwecheck((INT16 *) lData, RFINDEX(FLD_ZMPC), imm);
      vwecheck((INT16 *) lData, RFINDEX(FLD_ZPPC), imm);
      break;
    }
      
      
    case RFINDEX(REG_MIDR): {
      vwecheck((INT16 *) lData, RFINDEX(REG_MIDR), imm);
      break;
    }
      
      
    case RFINDEX(REG_GIDR): {
      vwecheck((INT16 *) lData, RFINDEX(REG_GIDR), imm);
      break;
    }
      
      
    case RFINDEX(REG_IER): {
      vwecheck((INT16 *) lData, RFINDEX(FLD_BPIE), imm);
      vwecheck((INT16 *) lData, RFINDEX(FLD_BCIE), imm);
      vwecheck((INT16 *) lData, RFINDEX(FLD_GCIE), imm);
      vwecheck((INT16 *) lData, RFINDEX(FLD_MAIE), imm);
      vwecheck((INT16 *) lData, RFINDEX(FLD_MBIE), imm);
      vwecheck((INT16 *) lData, RFINDEX(FLD_SSIE), imm);
      vwecheck((INT16 *) lData, RFINDEX(FLD_XHIE), imm);
      vwecheck((INT16 *) lData, RFINDEX(FLD_RLIE), imm);
      vwecheck((INT16 *) lData, RFINDEX(FLD_URIE), imm);
      vwecheck((INT16 *) lData, RFINDEX(FLD_ISIE), imm);
      break;
    }
      
      
    case RFINDEX(REG_IFR): {
      vwecheck((INT16 *) lData, RFINDEX(FLD_BPIF), imm);
      vwecheck((INT16 *) lData, RFINDEX(FLD_BCIF), imm);
      vwecheck((INT16 *) lData, RFINDEX(FLD_GCIF), imm);
      vwecheck((INT16 *) lData, RFINDEX(FLD_MAIF), imm);
      vwecheck((INT16 *) lData, RFINDEX(FLD_MBIF), imm);
      vwecheck((INT16 *) lData, RFINDEX(FLD_SSIF), imm);
      vwecheck((INT16 *) lData, RFINDEX(FLD_XHIF), imm);
      vwecheck((INT16 *) lData, RFINDEX(FLD_RLIF), imm);
      vwecheck((INT16 *) lData, RFINDEX(FLD_URIF), imm);
      vwecheck((INT16 *) lData, RFINDEX(FLD_ISIF), imm);
      break;
    }
      
      
    case RFINDEX(REG_VWR): {
      register int i;
      
      UnpackState((INT16 *) lData, RFINDEX(FLD_VWE), imm);
      UnpackState((INT16 *) lData, RFINDEX(FLD_VWIE), imm);
      UnpackState((INT16 *) lData, RFINDEX(FLD_VWIF), imm);
      VWECHK = 0;
      for (i = 0; i < CHIPS_PER_MOD; i++)
	if (VWE[i] == 1)
	  VWECHK = 1;
      
      break;
    }
      
      
    case RFINDEX(REG_DOCR): {
      vwecheck((INT16 *) lData, RFINDEX(FLD_LDOC), imm);
      vwecheck((INT16 *) lData, RFINDEX(FLD_HDOC), imm);
      
      break;
    }
      
      
    default: {
      
      fprintf(stderr, "Don't recognize register %d\n", nRegister);
      break;
    }
    }
    
    cam8sim_iregs.PIP = (LONG32) plCurr;
  } /*   for (plCurr = plFirstInstr; !bDone; plCurr = plNext;) */
  cam8sim_iregs.ISR |= CAM_NEWLIST_INT_STATUS;
void CAM8SimInterface::SimReadInstr(INT16 *pnBuffer, LONG32 lInstr, LONG32 lData,
		      LONG32 lLength)
  BOOL bByteMode;
  short nRegister, i, imm;
  LONG32 pbuf[CHIPS_PER_MOD];
  bByteMode = (lInstr & BYTE_MODE_MASK) != 0;
  nRegister = lInstr & REGISTER_ADDR_MASK;
  imm = (lInstr & IMMEDIATE_DATA_MASK) != 0;
  switch (nRegister) {
    
  case RFINDEX(REG_MSR): {
    PackState(pnBuffer, RFINDEX(REG_MSR));
    break;
  }      
    
    
  case RFINDEX(REG_RMR): {
    PackState(pnBuffer, RFINDEX(FLD_SSM));
    PackState(pnBuffer, RFINDEX(FLD_RT));
    PackState(pnBuffer, RFINDEX(FLD_ECT));
    PackState(pnBuffer, RFINDEX(FLD_RPK));
    PackState(pnBuffer, RFINDEX(FLD_ALT));
    break;
    
    
  case RFINDEX(REG_KR): {
    PackState(pnBuffer, RFINDEX(FLD_KA));
    PackState(pnBuffer, RFINDEX(FLD_XKS));
    PackState(pnBuffer, RFINDEX(FLD_YKS));
    PackState(pnBuffer, RFINDEX(FLD_ZKS));
    PackState(pnBuffer, RFINDEX(FLD_XKMF));
    PackState(pnBuffer, RFINDEX(FLD_YKMF));
    PackState(pnBuffer, RFINDEX(FLD_ZKMF));
    break;
    
    
  case RFINDEX(REG_SABSR): {
    PackState(pnBuffer, RFINDEX(REG_SABSR));
    
    break;
    
    
  case RFINDEX(REG_LASR):
  case RFINDEX(REG_FOSR):
  case RFINDEX(REG_SDSR):
  case RFINDEX(REG_ECSR):
  case RFINDEX(REG_DSR): {
    PackState(pnBuffer, FLD_SELECT(nRegister));
    PackState(pnBuffer, FLD_MAP(nRegister));    
    break;
    
    
  case RFINDEX(REG_SSR): {
    *pnBuffer = 0xFFFF;
    
    break;
    
    
  case RFINDEX(REG_ECR): {
    int diff;
    if ((diff = ECL[0] - lLength) != 0){
      ConstantSetAll(RLIF, 1);
      if (diff < 0)
	Generate_Interrupt(CAM_CAM_INT_STATUS);
      else
	Generate_Interrupt(CAM_TIMEOUT_INT_STATUS);
    }
    
    else
      PackBits(pnBuffer, 0, lLength, (BYTE *) ECR, BIT32);
    
    break;
    
    
  case RFINDEX(REG_LIR): {
    PackState(pnBuffer, RFINDEX(REG_LIR));
    break;
    
    
  case RFINDEX(REG_LIPR): {
    PackState(pnBuffer, RFINDEX(REG_LIPR));
    break;
    
    
  case RFINDEX(REG_LIOR): {
    INT16 nLUTEntry, nLUTNextIndex;
    INT16 *pnLUT;
    int i, j;
    INT16 nImmediate[2];
    
    
    for (i = 0; i < lLength; i++) {
      nLUTNextIndex = 0;
      
      for (j = CHIPS_PER_MOD - 1; j >= 0; j--) {
	nLUTNextIndex <<= 1;
	if (LIPR[j] < 16)
	  nLUTNextIndex |= ((LIR[j] >> LIPR[j]) & 0x1);
	else if (LIPR[j] == 31)
	  nLUTNextIndex |= 0x1;
	LIR[j]++;
      }
      
      pnLUT = LIOR + nLUTNextIndex;                 
      
      *pnBuffer = *pnLUT;
      pnBuffer++;
    }
    
    break;
    
    
  case RFINDEX(REG_SIR): {
    PackState(pnBuffer, RFINDEX(REG_SIR));
    break;
    
    
  case RFINDEX(REG_SIPR): {
    int j;
    
    /* j counts which field of register */
    for(j = 0; j < SCAN_INDEX_LENGTH; j++)
      PackState(pnBuffer, RFINDEX(FLD_SSA(j)));
    break;
    
    
  case RFINDEX(REG_SIOR): {
    CAM8State.bByteMode = bByteMode;
    SIOR = (BYTE *) pnBuffer;
    
#ifndef INTERPRETER
	SIOREG = (LONG32) SIOR;
#endif INTERPRETER
    if (CAM8State.bReadMode !=  TRUE) {
      bDestChange = TRUE;
      CAM8State.bReadMode =  TRUE;
    }
    
    CAM8State.WhyScan = RFINDEX(REG_SIOR);
#ifndef INTERPRETER
    SimCompScan();
#ifndef _DRYRUN_                 
#ifdef _INSTRUMENTATION_
  gettimeofday(&tvStart, &tzZone);
#endif
    SimExecScan();
#ifdef _INSTRUMENTATION_
    gettimeofday(&tvEnd, &tzZone);
      
    fprintf(stderr, "Scan I/O Read took %d usecs\n",
	    (tvEnd.tv_sec - tvStart.tv_sec) * 1000000 +
	    (tvEnd.tv_usec - tvStart.tv_usec));
#endif _INSTRUMENTATION_
#endif _DRYRUN_
#else INTERPRETER
    SimExecScan();
#endif INTERPRETER
    
    break;
    
    
  case RFINDEX(REG_SFR): {
    PackState(pnBuffer, RFINDEX(FLD_SM));
    PackState(pnBuffer, RFINDEX(FLD_ESC));
    PackState(pnBuffer, RFINDEX(FLD_ESW));
    PackState(pnBuffer, RFINDEX(FLD_EST));
    PackState(pnBuffer, RFINDEX(FLD_SBRC));
    PackState(pnBuffer, RFINDEX(FLD_RCL));
    PackState(pnBuffer, RFINDEX(FLD_ECL));
    PackState(pnBuffer, RFINDEX(FLD_STM));
    
    break;
    
    
  case RFINDEX(REG_OSR): {
    PackState(pnBuffer, RFINDEX(REG_OSR));
    break;
    
    
  case RFINDEX(REG_DR): {
    PackState(pnBuffer, RFINDEX(FLD_DCM));
    PackState(pnBuffer, RFINDEX(FLD_XDCP));
    PackState(pnBuffer, RFINDEX(FLD_YDCP));
    PackState(pnBuffer, RFINDEX(FLD_ZDCP));
    
    break;
    
    
  case RFINDEX(REG_HER): {
    PackState(pnBuffer, RFINDEX(FLD_LPL));
    PackState(pnBuffer, RFINDEX(FLD_FPL));
    PackState(pnBuffer, RFINDEX(FLD_DCS));
    PackState(pnBuffer, RFINDEX(FLD_TBD));
    PackState(pnBuffer, RFINDEX(FLD_TMS));
    PackState(pnBuffer, RFINDEX(FLD_NBF));
    PackState(pnBuffer, RFINDEX(FLD_SRE));
    PackState(pnBuffer, RFINDEX(FLD_ALS));
    
    break;
    
    
  case RFINDEX(REG_MPCR): {
    PackState(pnBuffer, RFINDEX(FLD_MAFS));
    PackState(pnBuffer, RFINDEX(FLD_MBFS));
    
    break;
    
    
  case RFINDEX(REG_GPCR): {
    PackState(pnBuffer, RFINDEX(FLD_XMPC));
    PackState(pnBuffer, RFINDEX(FLD_XPPC));
    PackState(pnBuffer, RFINDEX(FLD_YMPC));
    PackState(pnBuffer, RFINDEX(FLD_YPPC));
    PackState(pnBuffer, RFINDEX(FLD_ZMPC));
    PackState(pnBuffer, RFINDEX(FLD_ZPPC));
    
    break;
    
    
  case RFINDEX(REG_MIDR): {
    PackState(pnBuffer, RFINDEX(REG_MIDR));
    
    break;
    
    
  case RFINDEX(REG_GIDR): {
    PackState(pnBuffer, RFINDEX(REG_GIDR));
    
    break;
    
    
  case RFINDEX(REG_IER): {
    PackState(pnBuffer, RFINDEX(FLD_BPIE));
    PackState(pnBuffer, RFINDEX(FLD_BCIE));
    PackState(pnBuffer, RFINDEX(FLD_GCIE));
    PackState(pnBuffer, RFINDEX(FLD_MAIE));
    PackState(pnBuffer, RFINDEX(FLD_MBIE));
    PackState(pnBuffer, RFINDEX(FLD_SSIE));
    PackState(pnBuffer, RFINDEX(FLD_XHIE));
    PackState(pnBuffer, RFINDEX(FLD_RLIE));
    PackState(pnBuffer, RFINDEX(FLD_URIE));
    PackState(pnBuffer, RFINDEX(FLD_ISIE));
    break;
    
    
  case RFINDEX(REG_IFR): {
    PackState(pnBuffer, RFINDEX(FLD_BPIF));
    PackState(pnBuffer, RFINDEX(FLD_BCIF));
    PackState(pnBuffer, RFINDEX(FLD_GCIF));
    PackState(pnBuffer, RFINDEX(FLD_MAIF));
    PackState(pnBuffer, RFINDEX(FLD_MBIF));
    PackState(pnBuffer, RFINDEX(FLD_SSIF));
    PackState(pnBuffer, RFINDEX(FLD_XHIF));
    PackState(pnBuffer, RFINDEX(FLD_RLIF));
    PackState(pnBuffer, RFINDEX(FLD_URIF));
    PackState(pnBuffer, RFINDEX(FLD_ISIF));
    
    break;
    
    
  case RFINDEX(REG_VWR): {
    PackState(pnBuffer, RFINDEX(FLD_VWE));
    PackState(pnBuffer, RFINDEX(FLD_VWIE));
    PackState(pnBuffer, RFINDEX(FLD_VWIF));
    break;
    
    
  case RFINDEX(REG_DOCR): {
    PackState(pnBuffer, RFINDEX(FLD_LDOC));
    PackState(pnBuffer, RFINDEX(FLD_HDOC));
    
    break;
    
    
  default: {
    
    fprintf(stderr, "Don't recognize register %d\n", nRegister);
    break;
/* Unpack register of length < 32 bits or register field */
void CAM8SimInterface::UnpackState(INT16 *base, int reg_fld, int imm)
  if (BITLEN(reg_fld) > 32) {
    WARNING("Can't unpack a register or field of len > 32", "UnpackState");
    UnpackBits(base, BITOFF(reg_fld), 32, imm, base_type[reg_fld].base,
	       base_type[reg_fld].type);
  else
    UnpackBits(base, BITOFF(reg_fld), BITLEN(reg_fld), imm,
	       base_type[reg_fld].base, base_type[reg_fld].type);
void CAM8SimInterface::UnpackStateInto(INT16 *base, int reg_fld, int imm, BYTE *dest, int type)
  if (BITLEN(reg_fld) > 32) {
    WARNING("Can't unpack a register or field of len > 32", "UnpackStateInto");
    UnpackBits(base, BITOFF(reg_fld), 32, imm, dest, type);
  else
    UnpackBits(base, BITOFF(reg_fld), BITLEN(reg_fld), imm, dest, type);
/* Pack register of length < 32 bits or register field */
void CAM8SimInterface::PackState(INT16 *base, int reg_fld)
  if (BITLEN(reg_fld) > 32) {
    WARNING("Can't pack a register or field of len > 32", "PackState");
    PackBits(base, BITOFF(reg_fld), 32, base_type[reg_fld].base,
	     base_type[reg_fld].type);
  else
    PackBits(base, BITOFF(reg_fld), BITLEN(reg_fld),
	     base_type[reg_fld].base, base_type[reg_fld].type);
void CAM8SimInterface::PackStateFrom(INT16 *base, int reg_fld, BYTE *src, int type)
  if (BITLEN(reg_fld) > 32) {
    WARNING("Can't pack a register or field of len > 32", "PackStateFrom");
    PackBits(base, BITOFF(reg_fld), 32, src, type);
  else
    PackBits(base, BITOFF(reg_fld), BITLEN(reg_fld), src, type);

---------------------------------------------------------------------------

#include <stdio.h>
#include <strings.h>
#include <setjmp.h>
#include <sys/mman.h>
#include <sys/types.h>
#include <sys/ipc.h>
#include <sys/shm.h>
#ifdef _INSTRUMENTATION_
#include <sys/time.h>
#endif
#include <CAM/CALib++.H>
#include <CAM/CamStream++.H>
#include <CAM/CamError++.H>
#include <CAM/CamTrace++.H>
#include <CAM/CAM8Sim++.H>
#include <CAM/CAM_instr.h>
#include <CAM/CAM_util.h>
#include "std++.H"
CAM8Sim::CAM8Sim(void)
  Bzero();
CAM8Sim::~CAM8Sim(void)
  if (module)
    delete module;
void CAM8Sim::InitSimulator(CAM8SimInterface *ifc, CAM8SimModule *mod)
  iface = ifc;
  module = mod;
#ifdef DEBUG
  /* Need to open a new file, set the CAMSTREAM dbug to it and turn on a flag */
#endif
int CAM8Sim::main(int argc, char *argv[])
  ReadCmdLine(argc, argv);
  return(0);
     
void CAM8Sim::ReadCmdLine(int argc, char *argv[])
  register int i;
  for(i = 1; i < argc; i++) {
    if (strcmp(argv[i], "-g") == 0) {
      bForceGeneralScan = TRUE;
      continue;
    }

---------------------------------------------------------------------------

#ifndef _CAM8SIM_H_
#define _CAM8SIM_H_
#include <CAM/CALib++.H>
#include <CAM/CAMach++.H>
#include "std++.H"
/*****************************************************************************/
/********************************* DEFINES ***********************************/
/*****************************************************************************/
#define PERM_CONST_1            31                                               
#define PERM_CONST_0            30
#define LONG32_SIZE		(sizeof(LONG32))
#define INT16_SIZE		(sizeof(INT16))
#define ACTIVE_LUT_SELECT	0x8000						 /* bit in Hardware Env Reg (HER)    */
#ifdef __cplusplus
/*****************************************************************************/
/******************************** TEMPLATES **********************************/
/*****************************************************************************/
/*****************************************************************************/
/*************************** CLASSES & TYPEDEFS ******************************/
/*****************************************************************************/
class CAM8SimInterface;		// Forward reference
class CAM8SimModule;		// Forward reference
typedef unsigned char   BYTE;
typedef unsigned char   BOOL;
typedef unsigned long   LONG32;
typedef unsigned short  INT16;
class CAM8Sim : public CAMach {
public:
  int VWECHK = 0;
  CAM8SimInterface *iface;
  CAM8SimModule *module;
  CAMSTREAM const in, out, err, dbug;
#ifdef _INSTRUMENTATION_
  struct timeval tvStart, tvEnd;
  struct timezone tzZone;
#endif
  CAM8Sim(void);
  DECL_COPYCONST(CAM8Sim);
  virtual ~CAM8Sim(void);
  DECL_OPEQ(CAM8Sim);
  DECL_BZERO(CAM8Sim);
  DECL_BCOPY(CAM8Sim);
  DECL_BCMP(CAM8Sim);
  int main(int argc, char *argv[]);
  void InitSimulator(CAM8SimInterface *ifc);
  void InitStepList(void);
  void Generate_Interrupt(int);
protected:
  inline void SENTER(int i, char *b, int t);
/*****************************************************************************/
/********************************* INLINES ***********************************/
/*****************************************************************************/
#endif
/*****************************************************************************/
/******************************* PROTOTYPES **********************************/
/*****************************************************************************/
/*****************************************************************************/
/********************************* GLOBALS ***********************************/
/*****************************************************************************/
#endif

---------------------------------------------------------------------------

#ifndef _CAM8SIM_H_
#define _CAM8SIM_H_
#include <CAM/CALib++.H>
#include <CAM/CAMach++.H>
#include "std++.H"
/*****************************************************************************/
/********************************* DEFINES ***********************************/
/*****************************************************************************/
#define PERM_CONST_1            31                                               
#define PERM_CONST_0            30
#define LONG32_SIZE		(sizeof(LONG32))
#define INT16_SIZE		(sizeof(INT16))
#define ACTIVE_LUT_SELECT	0x8000						 /* bit in Hardware Env Reg (HER)    */
#ifdef __cplusplus
/*****************************************************************************/
/******************************** TEMPLATES **********************************/
/*****************************************************************************/
/*****************************************************************************/
/*************************** CLASSES & TYPEDEFS ******************************/
/*****************************************************************************/
class CAM8SimInterface;		// Forward reference
class CAM8SimModule;		// Forward reference
typedef unsigned char   BYTE;
typedef unsigned char   BOOL;
typedef unsigned long   LONG32;
typedef unsigned short  INT16;
typedef struct {
  char *base;
  int type;
} Bt, *BT;
class CAM8Sim : public CAMach {
public:
  int VWECHK = 0;
  CAM8SimInterface *iface;
  CAM8SimModule *module;
  CAMSTREAM const in, out, err, dbug;
#ifdef _INSTRUMENTATION_
  struct timeval tvStart, tvEnd;
  struct timezone tzZone;
#endif
  CAM8Sim(void);
  DECL_COPYCONST(CAM8Sim);
  virtual ~CAM8Sim(void);
  DECL_OPEQ(CAM8Sim);
  DECL_BZERO(CAM8Sim);
  DECL_BCOPY(CAM8Sim);
  DECL_BCMP(CAM8Sim);
  int main(int argc, char *argv[]);
  void InitSimulator(CAM8SimInterface *ifc);
  void InitStepList(void);
  void InitExitProcs();
  void ExitSigProc();
  void ExitProc();
  void UnpackState(INT16 *, int, int);
  void UnpackStateInto(INT16 *, int, int, BYTE *, int);
  void PackState(INT16 *, int);
  void PackStateFrom(INT16 *, int, BYTE *, int);
protected:
  inline void SENTER(int i, char *b, int t);
/*****************************************************************************/
/********************************* INLINES ***********************************/
/*****************************************************************************/
inline void Cam8Sim::SENTER(int i, char *b, int t)
  base_type[i].base = b;
  base_type[i].type = t;
#endif
/*****************************************************************************/
/******************************* PROTOTYPES **********************************/
/*****************************************************************************/
/*****************************************************************************/
/********************************* GLOBALS ***********************************/
/*****************************************************************************/
#endif

---------------------------------------------------------------------------

#include <stdio.h>
#include "global.h"
#include "errmgr.h"
#include "decode_steplist.h"
/*****************************************************************************/
/*                                                                           */
/* Harris L. Gilliam:                                                        */
/*                                                                           */
/*  Added routines to unpack/pack CAM8 state information out off/into        */
/*  steplists:                                                               */
/*              UnpackState, PackState                                       */
/*                                                                           */
/*****************************************************************************/
#define SENTER1(i,n,b,t,l,o) \
  specs[i].sym = (char *) n; \
  specs[i].base = (BYTE *) b; \
  specs[i].type = (short) t; \
  specs[i].bitlen = (short) l; \
  specs[i].bitoff = (short) o
static SPEC specs[790];
#define MODULE_NAME "DecodeSteplist"
void InitStepList()
  /* Module Select Register */
  SENTER1(REG_MSR, "MSR", MSR, BIT8, 3, 0);
  /* Run Mode Register */
  SENTER1(REG_RMR, "RMR", 0, 0, 6, 0);
  SENTER1(FLD_SSM, "SSM", SSM, BIT8, 2, 0);
  SENTER1(FLD_RT, "RT", RT, BIT8, 1, 2);
  SENTER1(FLD_ECT, "ECT", ECT, BIT8, 1, 3);
  SENTER1(FLD_RPK, "RPK", RPK, BIT8, 1, 4);
  SENTER1(FLD_ALT, "ALT", ALT, BIT8, 1, 5);
  /* Kick Register */
  SENTER1(REG_KR, "KR", 0, 0, 30, 0);
  SENTER1(FLD_KA, "KA", KA, BIT32, 24, 0);
  SENTER1(FLD_XKS, "XKS", XKS, BIT8, 1, 24);
  SENTER1(FLD_YKS, "YKS", YKS, BIT8, 1, 25);
  SENTER1(FLD_ZKS, "ZKS", ZKS, BIT8, 1, 26);
  SENTER1(FLD_XKMF, "XKMF", XKMF, BIT8, 1, 27);
  SENTER1(FLD_YKMF, "YKMF", YKMF, BIT8, 1, 28);
  SENTER1(FLD_ZKMF, "ZKMF", ZKMF, BIT8, 1, 29);
  /* Site Address Bit Select Register */
  SENTER1(REG_SABSR, "SABSR", SABSR, BIT8, 5, 0);
  /* LUT Address Source Register */
  SENTER1(REG_LASR, "LASR", 0, 0, 6, 0);
  SENTER1(FLD_LAS, "LAS", LAS, BIT8, 2, 0);
  SENTER1(FLD_LAM, "LAM", LAM, BIT8, 4, 2);
  /* Flywheel Output Source Register */
  SENTER1(REG_FOSR, "FOSR", 0, 0, 6, 0);
  SENTER1(FLD_FOS, "FOS", FOS, BIT8, 2, 0);
  SENTER1(FLD_FOM, "FOM", FOM, BIT8, 4, 2);
  /* Site Data Source Register */
  SENTER1(REG_SDSR, "SDSR", 0, 0, 6, 0);
  SENTER1(FLD_SDS, "SDS", SDS, BIT8, 2, 0);
  SENTER1(FLD_SDM, "SDM", SDM, BIT8, 4, 2);
  /* Event Counter Source Register */
  SENTER1(REG_ECSR, "ECSR", 0, 0, 6, 0);
  SENTER1(FLD_ECS, "ECS", ECS, BIT8, 2, 0);
  SENTER1(FLD_ECM, "ECM", ECM, BIT8, 4, 2);
  /* Display Source Register */
  SENTER1(REG_DSR, "DSR", 0, 0, 6, 0);
  SENTER1(FLD_DDS, "DDS", DDS, BIT8, 2, 0);
  SENTER1(FLD_DDM, "DDM", DDM, BIT8, 4, 2);
  /* Show Scan Register */
  SENTER1(REG_SSR, "SSR", SSR, BIT8, 1, 0);
  /* Event Count Register */
  SENTER1(REG_ECR, "ECR", ECR, BIT32, 32, 0);
  /* LUT Index Register */
  SENTER1(REG_LIR, "LIR", LIR, BIT8, 16, 0);
  /* LUT Index Permutation Register */
  SENTER1(REG_LIPR, "LIPR", LIPR, BIT8, 5, 0);
  /* LUT I/O Register */
  SENTER1(REG_LIOR, "LIOR", 0, 0, 0, 0);
  /* Scan Index Register */
  SENTER1(REG_SIR, "SIR", SIR, BIT32, 24, 0);
  /* Scan Index Permutation Register */
  SENTER1(REG_SIPR, "SIPR", 0, 0, 120, 0);
  SENTER1(FLD_SSA0, "SSA0", SSA0, BIT8, 5, 0);
  SENTER1(FLD_SSA1, "SSA1", SSA1, BIT8, 5, 5);
  SENTER1(FLD_SSA2, "SSA2", SSA2, BIT8, 5, 10);
  SENTER1(FLD_SSA3, "SSA3", SSA3, BIT8, 5, 15);
  SENTER1(FLD_SSA4, "SSA4", SSA4, BIT8, 5, 20);
  SENTER1(FLD_SSA5, "SSA5", SSA5, BIT8, 5, 25);
  SENTER1(FLD_SSA6, "SSA6", SSA6, BIT8, 5, 30);
  SENTER1(FLD_SSA7, "SSA7", SSA7, BIT8, 5, 35);
  SENTER1(FLD_SSA8, "SSA8", SSA8, BIT8, 5, 40);
  SENTER1(FLD_SSA9, "SSA9", SSA9, BIT8, 5, 45);
  SENTER1(FLD_SSA10, "SSA10", SSA10, BIT8, 5, 50);
  SENTER1(FLD_SSA11, "SSA11", SSA11, BIT8, 5, 55);
  SENTER1(FLD_SSA12, "SSA12", SSA12, BIT8, 5, 60);
  SENTER1(FLD_SSA13, "SSA13", SSA13, BIT8, 5, 65);
  SENTER1(FLD_SSA14, "SSA14", SSA14, BIT8, 5, 70);
  SENTER1(FLD_SSA15, "SSA15", SSA15, BIT8, 5, 75);
  SENTER1(FLD_SSA16, "SSA16", SSA16, BIT8, 5, 80);
  SENTER1(FLD_SSA17, "SSA17", SSA17, BIT8, 5, 85);
  SENTER1(FLD_SSA18, "SSA18", SSA18, BIT8, 5, 90);
  SENTER1(FLD_SSA19, "SSA19", SSA19, BIT8, 5, 95);
  SENTER1(FLD_SSA20, "SSA20", SSA20, BIT8, 5, 100);
  SENTER1(FLD_SSA21, "SSA21", SSA21, BIT8, 5, 105);
  SENTER1(FLD_SSA22, "SSA22", SSA22, BIT8, 5, 110);
  SENTER1(FLD_SSA23, "SSA23", SSA23, BIT8, 5, 115);
  /* Scan I/O Register */
  SENTER1(REG_SIOR, "SIOR", 0, 0, 0, 0);
  /* Scan Format Register */
  SENTER1(REG_SFR, "SFR", 0, 0, 35, 0);
  SENTER1(FLD_SM, "SM", SM, BIT8, 2, 0);
  SENTER1(FLD_ESC, "ESC", ESC, BIT8, 5, 2);
  SENTER1(FLD_ESW, "ESW", ESW, BIT8, 4, 7);
  SENTER1(FLD_EST, "EST", EST, BIT8, 4, 11);
  SENTER1(FLD_SBRC, "SBRC", SBRC, BIT8, 5, 15);
  SENTER1(FLD_RCL, "RCL", RCL, BIT8, 8, 20);
  SENTER1(FLD_ECL, "ECL", ECL, BIT8, 5, 28);
  SENTER1(FLD_STM, "STM", STM, BIT8, 2, 33);
  /* Offset Register */
  SENTER1(REG_OSR, "OSR", OSR, BIT32, 24, 0);
  /* Dimension Register */
  SENTER1(REG_DR, "DR", 0, 0, 38, 0);
  SENTER1(FLD_DCM, "DCM", DCM, BIT32, 23, 0);
  SENTER1(FLD_XDCP, "XDCP", XDCP, BIT8, 5, 23);
  SENTER1(FLD_YDCP, "YDCP", YDCP, BIT8, 5, 28);
  SENTER1(FLD_ZDCP, "ZDCP", ZDCP, BIT8, 5, 33);
  /* Hardware Environment Register */
  SENTER1(REG_HER, "HER", 0, 0, 16, 0);
  SENTER1(FLD_LPL, "LPL", LPL, BIT8, 1, 0);
  SENTER1(FLD_FPL, "FPL", FPL, BIT8, 1, 1);
  SENTER1(FLD_DCS, "DCS", DCS, BIT8, 1, 2);
  SENTER1(FLD_TBD, "TBD", TBD, BIT8, 6, 3);
  SENTER1(FLD_TMS, "TMS", TMS, BIT8, 4, 9);
  SENTER1(FLD_NBF, "NBF", NBF, BIT8, 1, 13);
  SENTER1(FLD_SRE, "SRE", SRE, BIT8, 1, 14);
  SENTER1(FLD_ALS, "ALS", ALS, BIT8, 1, 15);
  /* Multipurpose Pin Control Register */
  SENTER1(REG_MPCR, "MPCR", 0, 0, 10, 0);
  SENTER1(FLD_MAFS, "MAFS", MAFS, BIT8, 5, 0);
  SENTER1(FLD_MBFS, "MBFS", MBFS, BIT8, 5, 5);
  /* Glue Pin Connectivity Register */
  SENTER1(REG_GPCR, "GPCR", 0, 0, 18, 0);
  SENTER1(FLD_XMPC, "XMPC", XMPC, BIT8, 3, 0);
  SENTER1(FLD_XPPC, "XPPC", XPPC, BIT8, 3, 3);
  SENTER1(FLD_YMPC, "YMPC", YMPC, BIT8, 3, 6);
  SENTER1(FLD_YPPC, "YPPC", YPPC, BIT8, 3, 9);
  SENTER1(FLD_ZMPC, "ZMPC", ZMPC, BIT8, 3, 12);
  SENTER1(FLD_ZPPC, "ZPPC", ZPPC, BIT8, 3, 15);
  /* Module ID Register */
  SENTER1(REG_MIDR, "MIDR", MIDR, BIT8, 1, 0);
  /* Group ID Register */
  SENTER1(REG_GIDR, "GIDR", GIDR, BIT8, 1, 0);
  /* Interrupt Enable Register */
  SENTER1(REG_IER, "IER", 0, 0, 10, 0);
  SENTER1(FLD_BPIE, "BPIE", BPIE, BIT8, 1, 0);
  SENTER1(FLD_BCIE, "BCIE", BCIE, BIT8, 1, 1);
  SENTER1(FLD_GCIE, "GCIE", GCIE, BIT8, 1, 2);
  SENTER1(FLD_MAIE, "MAIE", MAIE, BIT8, 1, 3);
  SENTER1(FLD_MBIE, "MBIE", MBIE, BIT8, 1, 4);
  SENTER1(FLD_SSIE, "SSIE", SSIE, BIT8, 1, 5);
  SENTER1(FLD_XHIE, "XHIE", XHIE, BIT8, 1, 6);
  SENTER1(FLD_RLIE, "RLIE", RLIE, BIT8, 1, 7);
  SENTER1(FLD_URIE, "URIE", URIE, BIT8, 1, 8);
  SENTER1(FLD_ISIE, "ISIE", ISIE, BIT8, 1, 9);
  /* Interrupt Flags Register */
  SENTER1(REG_IFR, "IFR", 0, 0, 10, 0);
  SENTER1(FLD_BPIF, "BPIF", BPIF, BIT8, 1, 0);
  SENTER1(FLD_BCIF, "BCIF", BCIF, BIT8, 1, 1);
  SENTER1(FLD_GCIF, "GCIF", GCIF, BIT8, 1, 2);
  SENTER1(FLD_MAIF, "MAIF", MAIF, BIT8, 1, 3);
  SENTER1(FLD_MBIF, "MBIF", MBIF, BIT8, 1, 4);
  SENTER1(FLD_SSIF, "SSIF", SSIF, BIT8, 1, 5);
  SENTER1(FLD_XHIF, "XHIF", XHIF, BIT8, 1, 6);
  SENTER1(FLD_RLIF, "RLIF", RLIF, BIT8, 1, 7);
  SENTER1(FLD_URIF, "URIF", URIF, BIT8, 1, 8);
  SENTER1(FLD_ISIF, "ISIF", ISIF, BIT8, 1, 9);
  /* Verify Write Register */
  SENTER1(REG_VWR, "VWR", 0, 0, 3, 0);
  SENTER1(FLD_VWE, "VWE", VWE, BIT8, 1, 0);
  SENTER1(FLD_VWIE, "VWIE", VWIE, BIT8, 1, 1);
  SENTER1(FLD_VWIF, "VWIF", VWIF, BIT8, 1, 2);
  /* DRAM Ones Count Register */
  SENTER1(REG_DOCR, "DOCR", 0, 0, 16, 0);
  SENTER1(FLD_LDOC, "LDOC", LDOC, BIT8, 8, 0);
  SENTER1(FLD_HDOC, "HDOC", HDOC, BIT8, 8, 8);
SPEC GetSpec(int specnum)
  return(specs[specnum]);
/* Unpack register of length < 32 bits or register field */
void UnpackState(INT16 *base, int reg_fld, int imm)
  if (specs[reg_fld].bitlen > 32) {
    WARNING("Can't unpack a register or field of len > 32", "UnpackState");
    UnpackBits(base, specs[reg_fld].bitoff, 32, imm, specs[reg_fld].base,
	       specs[reg_fld].type);
  else
    UnpackBits(base, specs[reg_fld].bitoff, specs[reg_fld].bitlen, imm,
	       specs[reg_fld].base, specs[reg_fld].type);
void UnpackStateInto(INT16 *base, int reg_fld, int imm, BYTE *dest, int type)
  if (specs[reg_fld].bitlen > 32) {
    WARNING("Can't unpack a register or field of len > 32", "UnpackStateInto");
    UnpackBits(base, specs[reg_fld].bitoff, 32, imm, dest, type);
  else
    UnpackBits(base, specs[reg_fld].bitoff, specs[reg_fld].bitlen, imm,
	       dest, type);
/* Unpack 16 sets of bits from a steplist entry starting at base and filling array dest */
void UnpackBits(INT16 *base, int off, int len, int imm, BYTE *dest, int type)
  register int bit, plane;
  INT16 basemask;
  LONG32 destmask, immval;
  INT16 immdata[2];
  int sz;
  sz = (type == BIT8 ? 1 :
	(type == BIT16 ? 2 :
	 (type == BIT32 ? 4 : 0)));
  if (!sz) {
    WARNING("Unknown bitsize for destination - aborting", "UnpackBits");
    return;
  if (imm) {
    immval = (LONG32) base;
    immdata[0] = (INT16) (immval >> 16);
    immdata[1] = (INT16) (immval & 0xFFFF);
    for(plane = 0; plane < 16; plane++) {
      bzero(dest + plane * sz, sz);
      basemask = 0x1 << plane;
      for (bit = 0; bit < len; bit++) {
      
	destmask = 0x1 << bit;
	if (immdata[(bit + off) % 2] & basemask) {
	  switch (type) {
	  case BIT8: {
	    ((BYTE *) dest)[plane] |= destmask;
	    break;
	  }
	  case BIT16: {
	    ((INT16 *) dest)[plane] |= destmask;
	    break;
	  }
	  default: {
	    ((LONG32 *) dest)[plane] |= destmask;
	    break;
	  }
	  }
      }
    }
  else {
    for(plane = 0; plane < 16; plane++) {
      
      bzero(dest + plane * sz, sz);
      basemask = 0x1 << plane;
      
      for (bit = 0; bit < len; bit++) {
	destmask = 0x1 << bit;
	if (base[bit + off] & basemask) {
	  switch (type) {
	  case BIT8: {
	    ((BYTE *) dest)[plane] |= destmask;
	    break;
	  }
	  case BIT16: {
	    ((INT16 *) dest)[plane] |= destmask;
	    break;
	  }
	  default: {
	    ((LONG32 *) dest)[plane] |= destmask;
	    break;
	  }
	  }
      }
    }
/* Pack register of length < 32 bits or register field */
void PackState(INT16 *base, int reg_fld)
  if (specs[reg_fld].bitlen > 32) {
    WARNING("Can't pack a register or field of len > 32", "PackState");
    PackBits(base, specs[reg_fld].bitoff, 32, specs[reg_fld].base,
	     specs[reg_fld].type);
  else
    PackBits(base, specs[reg_fld].bitoff, specs[reg_fld].bitlen,
	     specs[reg_fld].base, specs[reg_fld].type);
void PackStateFrom(INT16 *base, int reg_fld, BYTE *src, int type)
  if (specs[reg_fld].bitlen > 32) {
    WARNING("Can't pack a register or field of len > 32", "PackStateFrom");
    PackBits(base, specs[reg_fld].bitoff, 32, src, type);
  else
    PackBits(base, specs[reg_fld].bitoff, specs[reg_fld].bitlen,
	     src, type);
/* Pack 16 sets of bits from array src into a steplist entry starting at base */
void PackBits(INT16 *base, int off, int len, BYTE *src, int type)
  register int bit, plane;
  INT16 basemask;
  LONG32 srcmask;
  LONG32 srcval;
  if (len > 32) {
    WARNING("Can't pack more than 32 bits", "PackBits");
    len = 32;
  if ((type != BIT8) && (type != BIT16) && (type != BIT32)) {
    WARNING("Unknown bitsize for source - aborting", "UnpackBits");
    return;
  for(bit = 0; bit < len; bit++) {
    base[bit + off] = 0;
    srcmask = 0x1 << bit;
    for(plane = 0; plane < 16; plane++) {
      basemask = 0x1 << plane;
      switch (type) {
      case BIT8: {
	srcval = (LONG32) (((BYTE *) src)[plane]);
	break;
      }
      case BIT16: {
	srcval = (LONG32) (((INT16 *) src)[plane]);
	break;
      }
      default: {
	srcval = ((LONG32 *) src)[plane];
	break;
      }
      }
      if (srcval & srcmask)
	base[bit + off] |= basemask;
    }

---------------------------------------------------------------------------

#ifndef _DECODE_STEPLIST_
#define _DECODE_STEPLIST_
#include "steplistP.h"
typedef struct reg_fld_spec {
  char *sym;
  BYTE *base;
  short type;
  short bitlen, bitoff;
} SPEC;
#define BASE(num) specs[num].base
#define BITLEN(num) specs[num].bitlen
#define BITOFF(num) specs[num].bitoff
#define BYTEIDX(bitoff, bit) ((int) ((bitoff) + (bit)) / 8)
#define BIT(num, bit) \
  ((BITOFF(num) + (bit)) % 8)
#define MULT		32
/* Indicies into specification table */
#define REG_MSR		0
#define REG_RMR		1
#define REG_KR		2
#define REG_SABSR	3
#define REG_LASR	4
#define REG_FOSR	5
#define REG_SDSR	6
#define REG_ECSR	7
#define REG_DSR		8
#define REG_SSR		9
#define REG_ECR		10
#define REG_LIR		11
#define REG_LIPR	12
#define REG_LIOR	13
#define REG_SIR		14
#define REG_SIPR	15
#define REG_SIOR	16
#define REG_SFR		17
#define REG_OSR		18
#define REG_DR		19
#define REG_HER		20
#define REG_MPCR	21
#define REG_GPCR	22
#define REG_MIDR	23
#define REG_GIDR	24
#define REG_IER		25
#define REG_IFR		26
#define REG_VWR		27
#define REG_DOCR	28
#define MAX_REGS	29
#define FLD_SSM		REG_RMR+1*MULT
#define FLD_RT		REG_RMR+2*MULT
#define FLD_ECT		REG_RMR+3*MULT
#define FLD_RPK		REG_RMR+4*MULT
#define FLD_ALT		REG_RMR+5*MULT
#define FLD_KA		REG_KR+1*MULT
#define FLD_XKS		REG_KR+2*MULT
#define FLD_YKS		REG_KR+3*MULT
#define FLD_ZKS		REG_KR+4*MULT
#define FLD_XKMF	REG_KR+5*MULT
#define FLD_YKMF	REG_KR+6*MULT
#define FLD_ZKMF	REG_KR+7*MULT
#define FLD_LAS		REG_LASR+1*MULT
#define FLD_LAM		REG_LASR+2*MULT
#define FLD_FOS		REG_FOSR+1*MULT
#define FLD_FOM		REG_FOSR+2*MULT
#define FLD_SDS		REG_SDSR+1*MULT
#define FLD_SDM		REG_SDSR+2*MULT
#define FLD_ECS		REG_ECSR+1*MULT
#define FLD_ECM		REG_ECSR+2*MULT
#define FLD_DDS		REG_DSR+1*MULT
#define FLD_DDM		REG_DSR+2*MULT
#define FLD_SSA(i)	REG_SIPR+(i+1)*MULT
#define FLD_SSA0	REG_SIPR+1*MULT
#define FLD_SSA1	REG_SIPR+2*MULT
#define FLD_SSA2	REG_SIPR+3*MULT
#define FLD_SSA3	REG_SIPR+4*MULT
#define FLD_SSA4	REG_SIPR+5*MULT
#define FLD_SSA5	REG_SIPR+6*MULT
#define FLD_SSA6	REG_SIPR+7*MULT
#define FLD_SSA7	REG_SIPR+8*MULT
#define FLD_SSA8	REG_SIPR+9*MULT
#define FLD_SSA9	REG_SIPR+10*MULT
#define FLD_SSA10	REG_SIPR+11*MULT
#define FLD_SSA11	REG_SIPR+12*MULT
#define FLD_SSA12	REG_SIPR+13*MULT
#define FLD_SSA13	REG_SIPR+14*MULT
#define FLD_SSA14	REG_SIPR+15*MULT
#define FLD_SSA15	REG_SIPR+16*MULT
#define FLD_SSA16	REG_SIPR+17*MULT
#define FLD_SSA17	REG_SIPR+18*MULT
#define FLD_SSA18	REG_SIPR+19*MULT
#define FLD_SSA19	REG_SIPR+20*MULT
#define FLD_SSA20	REG_SIPR+21*MULT
#define FLD_SSA21	REG_SIPR+22*MULT
#define FLD_SSA22	REG_SIPR+23*MULT
#define FLD_SSA23	REG_SIPR+24*MULT
#define FLD_SM		REG_SFR+1*MULT
#define FLD_ESC		REG_SFR+2*MULT
#define FLD_ESW		REG_SFR+3*MULT
#define FLD_EST		REG_SFR+4*MULT
#define FLD_SBRC	REG_SFR+5*MULT
#define FLD_RCL		REG_SFR+6*MULT
#define FLD_ECL		REG_SFR+7*MULT
#define FLD_STM		REG_SFR+8*MULT
#define FLD_DCM		REG_DR+1*MULT
#define FLD_XDCP	REG_DR+2*MULT
#define FLD_YDCP	REG_DR+3*MULT
#define FLD_ZDCP	REG_DR+4*MULT
#define FLD_LPL		REG_HER+1*MULT
#define FLD_FPL		REG_HER+2*MULT
#define FLD_DCS		REG_HER+3*MULT
#define FLD_TBD		REG_HER+4*MULT
#define FLD_TMS		REG_HER+5*MULT
#define FLD_NBF		REG_HER+6*MULT
#define FLD_SRE		REG_HER+7*MULT
#define FLD_ALS		REG_HER+8*MULT
#define FLD_MAFS	REG_MPCR+1*MULT
#define FLD_MBFS	REG_MPCR+2*MULT
#define FLD_XMPC	REG_GPCR+1*MULT
#define FLD_XPPC	REG_GPCR+2*MULT
#define FLD_YMPC	REG_GPCR+3*MULT
#define FLD_YPPC	REG_GPCR+4*MULT
#define FLD_ZMPC	REG_GPCR+5*MULT
#define FLD_ZPPC	REG_GPCR+6*MULT
#define FLD_BPIE	REG_IER+1*MULT
#define FLD_BCIE	REG_IER+2*MULT
#define FLD_GCIE	REG_IER+3*MULT
#define FLD_MAIE	REG_IER+4*MULT
#define FLD_MBIE	REG_IER+5*MULT
#define FLD_SSIE	REG_IER+6*MULT
#define FLD_XHIE	REG_IER+7*MULT
#define FLD_RLIE	REG_IER+8*MULT
#define FLD_URIE	REG_IER+9*MULT
#define FLD_ISIE	REG_IER+10*MULT
#define FLD_BPIF	REG_IFR+1*MULT
#define FLD_BCIF	REG_IFR+2*MULT
#define FLD_GCIF	REG_IFR+3*MULT
#define FLD_MAIF	REG_IFR+4*MULT
#define FLD_MBIF	REG_IFR+5*MULT
#define FLD_SSIF	REG_IFR+6*MULT
#define FLD_XHIF	REG_IFR+7*MULT
#define FLD_RLIF	REG_IFR+8*MULT
#define FLD_URIF	REG_IFR+9*MULT
#define FLD_ISIF	REG_IFR+10*MULT
#define FLD_VWE		REG_VWR+1*MULT
#define FLD_VWIE	REG_VWR+2*MULT
#define FLD_VWIF	REG_VWR+3*MULT
#define FLD_LDOC	REG_DOCR+1*MULT
#define FLD_HDOC	REG_DOCR+2*MULT
#define FLD_SELECT(i)	(i)+1*MULT
#define FLD_MAP(i)	(i)+2*MULT
#define BIT8	1
#define BIT16	2
#define BIT32	4
void InitStepList();
SPEC GetSpec(int);
void UnpackState(INT16 *, int, int);
void UnpackStateInto(INT16 *, int, int, BYTE *, int);
void UnpackBits(INT16 *, int, int, int, BYTE *, int);
void PackState(INT16 *, int);
void PackStateFrom(INT16 *, int, BYTE *, int);
void PackBits(INT16 *, int, int, BYTE *, int);
#endif
#include <stdio.h>
#include <errno.h>
#include "errmgr.h"
#include "errmgrP.h"
void errCritical(char *szMsg, char *szModule, char *szFunction)
     fprintf(stderr, "%s : %s : %s\n", szMsg, szModule, szFunction);
     exit(2);
void errWarning(char *szMsg, char *szModule, char *szFunction)
     fprintf(stderr, "%s : %s : %s\n", szMsg, szModule, szFunction);
#ifndef _ERRMGR_
#define _ERRMGR_
#include "errmgrP.h"
#define CRITICAL_ERROR(msg, func)	errCritical((msg), MODULE_NAME, (func))
#define WARNING(msg, func)		errWarning((msg), MODULE_NAME, (func))
#endif
#ifndef _ERRMGR_P_
#define _ERRMGR_P_
void 	errCritical(char *szMsg, char *szModule, char *szFunction);
void 	errWarning(char *szMsg, char *szModule, char *szFunction);
#endif
#ifndef _EXECUTE_5_PERM_
#define _EXECUTE_5_PERM_
#define ExecuteScan5Perm {}
#endif
#include "global.h"
#include "errmgr.h"
#include "memmgr.h"
#include "utils.h"
#include "executeNoPermP.h"
#include "executeGen.h"
#include "executeGenP.h"
#include "decode_steplist.h"
#define MODULE_NAME     "ExecuteGen"
#define SITE_ADDR_MASK	0xFFFFF
void ExecuteGeneralScan()
  /************************************************************************/
  /* Execute making no assumptions - in particular, it is expected that   */
  /* the scan index will be permuted, so that updated sites will not be   */
  /* sequentially located in memory.                                      */
  /************************************************************************/
  short i;
  LONG32 PLANE_CTR;
  LONG32 SA_HIGH_BITS, OFF_HIGH_BITS, SCRATCH, PLANE_ADDR;
  LONG32 SWEEP_LENGTH, SA_OR_MASK, SA_AND_MASK, WORD_ADDR;
  unsigned short nNumPlanes = CalcNumPlanes();
  EP("ExecuteGeneralScan");
  /************************************************************************/
  /* First, update things in the heap from where they can be accessed     */
  /* by the executed code.                                                */
  /************************************************************************/
  /************************************************************************/
  /* Update heap copy of DCMR.						  */
  /************************************************************************/
  DCMR = DCM[0];
  /************************************************************************/
  /* Update heap copy of OFFSETS					  */
  /************************************************************************/
  for(i = 0 ; i < CHIPS_PER_MOD; i++)
    OFFSETS[i] = OSR[i];
  /************************************************************************/
  /* Figure out the site address of the first site to be updated. This is */
  /* needed to update SITE_ADDR for display purposes. Also,               */
  /* compute the SAAndMask and SAOrMask which will be used to do the      */
  /* permutation at execution time.                                       */
  /************************************************************************/
  /************************************************************************/
  /* Next, generate the code. First, permute the scan index register to   */
  /* get the site address.                                                */
  /************************************************************************/
  while (SITE_CTR != 0) {
    /************************************************************************/
    /* All the bits of site address are either consts or have 1-1 	    */
    /* correspondence with Scan Index bits, are directly masked in.	    */
    /************************************************************************/
    SITE_ADDR = SCAN_INDEX_REG & SA_AND_MASK;
    SITE_ADDR |= SA_OR_MASK;
    /************************************************************************/
    /* Now handle any out of order SI bits.				    */
    /************************************************************************/
    for (i = SCAN_INDEX_LENGTH-1; i >= 0; i--) {
      if ((SIPR[i][0] < SCAN_INDEX_LENGTH) && (SIPR[i][0] != i)) {
	SCRATCH = SCAN_INDEX_REG << (31 - SIPR[i][0]);
	bit = HIGHB(SCRATCH);
	SITE_ADDR |= (bit << i);
      }
    }
    /************************************************************************/
    /* Now, add site address to the offset to get the DRAM address. The     */
    /* addition must break the carries at the dimension cuts. Also, DRAM    */
    /* address must be broken into a SPARC word address and a 5 bit offset  */
    /* into the word                                                        */
    /************************************************************************/
    if (nNumPlanes) {
      SA_HIGH_BITS = SITE_ADDR & DCMR;
      SITE_ADDR = (SITE_ADDR &(~ DCMR)) & SITE_ADDR_MASK;
    
      for(PLANE_CTR = 0; PLANE_CTR < nNumPlanes; PLANE_CTR++) {
	WORD_ADDR = OFFSETS[PLANE_CTR];
	OFF_HIGH_BITS = WORD_ADDR & DCMR;
	WORD_ADDR = SITE_ADDR + (WORD_ADDR & (~ DCMR));
	WORD_ADDR = (WORD_ADDR ^ OFF_HIGH_BITS) ^ SA_HIGH_BITS;
	PLANE_ADDR = BIT_PLANE_ADDR[PLANE_CTR];
	NEXT_WORD_ADDR[PLANE_CTR] = PLANE_ADDR + ((WORD_ADDR >> 5) << 2);
	BIT_OFFSETS[PLANE_CTR] = WORD_ADDR & 0x1F;
      }
      /************************************************************************/
      /* Now, the heap has the word addresses and bit offsets for the next    */
      /* site. So go ahead and update the site.                               */
      /************************************************************************/
    
      ExecuteUpdateCode(nNumPlanes);
    }
    
    if ((--X_CTR) == 0)
      X_CTR = SWEEP_LENGTH;
    
    if ((++SCAN_INDEX_REG) > 0xFFFFFF)
      SCAN_INDEX_REG = 0;
    
    SITE_CTR--;
    ConstantSetAll(SIR, SCAN_INDEX_REG);
  LP("ExecuteGeneralScan");
static void ExecuteUpdateCode(unsigned short nNumPlanes)
  EP("ExecuteUpdateCode");
     
  ExecuteLoadPlaneWords(nNumPlanes);
  ExecuteUpdateSite(nNumPlanes);
  ExecuteSavePlaneWords(nNumPlanes);
     
  LP("ExecuteUpdateCode");
static void ExecuteLoadPlaneWords(unsigned short nNumPlanes)
  short i;
  LONG32 WORD_ADDR, BIT_OFFSET, SAVE_BITS;
  EP("ExecuteLoadPlaneWords");
    
  if (!IsSrcNeeded(SRC_SITE_DATA, nNumPlanes) &&
      !IsDestUpdated(DEST_SITE_DATA, nNumPlanes)) {
    LP("ExecuteLoadPlaneWords");
    return;
  for (i = 0; i < nNumPlanes; i++) {
    WORD_ADDR = NEXT_WORD_ADDR[i];
    PLANE_WORD[i] = *((LONG32 *) WORD_ADDR);
    BIT_OFFSET = BIT_OFFSETS[i];
    SAVE_BITS = PLANE_WORD[i] >> (32 - BIT_OFFSET);
    PLANE_WORD[i] <<= BIT_OFFSET;
    PLANE_WORD[i] |= SAVE_BITS;
    PLANE_WORD[i] = (*((LONG32 *) NEXT_WORD_ADDR[i]) << BIT_OFFSETS[i]) |
                    (*((LONG32 *) NEXT_WORD_ADDR[i]) >> (32 - BIT_OFFSETS[i]));
  LP("ExecuteLoadPlaneWords");
static void ExecuteSavePlaneWords(unsigned short nNumPlanes)
  short i;
  LONG32 WORD_ADDR, BIT_OFFSET, SAVE_BITS;
  EP("ExecuteSavePlaneWords");
  if (!IsDestUpdated(DEST_SITE_DATA, nNumPlanes)) {
    LP("ExecuteSavePlaneWords");
    return;
  for (i = 0; i < nNumPlanes; i++) {
    BIT_OFFSET = BIT_OFFSETS[i];
    SAVE_BITS = PLANE_WORD[i] << (31 - BIT_OFFSET);
    PLANE_WORD[i] >>= (BIT_OFFSET + 1);
    PLANE_WORD[i] |= SAVE_BITS;
    WORD_ADDR = NEXT_WORD_ADDR[i];
    *((LONG32 *) WORD_ADDR) = PLANE_WORD[i];
    PLANE_WORD[i] = (PLANE_WORD[i] >> (BIT_OFFSETS[i] + 1)) |
                    (PLANE_WORD[i] << (31 - BIT_OFFSETS[i]));
    *((LONG32 *) NEXT_WORD_ADDR[i]) = PLANE_WORD[i];
  LP("ExecuteSavePlaneWords");
}     
#ifndef _EXECUTE_GEN_
#define _EXECUTE_GEN_
void ExecuteGeneralScan();
#endif
#ifndef _EXECUTE_GEN_P_
#define _EXECUTE_GEN_P_
#include "global.h"
static void ExecuteUpdateCode(unsigned short nNumPlanes);
static void ExecuteLoadPlaneWords(unsigned short nNumPlanes);
static void ExecuteSavePlaneWords(unsigned short nNumPlanes);
#endif
#include "global.h"
#include "errmgr.h"
#include "memmgr.h"
#include "utils.h"
#include "executeNoPerm.h"
#include "executeNoPermP.h"
#include "decode_steplist.h"
#define MODULE_NAME     "ExecuteNoPerm"
static void ExecuteSweepCode(unsigned short nNumPlanes);
/************************************************************************/
/* Execute assuming the scan index is not permuted. This implies that   */
/* bits to be updated during this scan are all consecutive.             */
/************************************************************************/
void ExecuteScanNoPerm()
  unsigned short nNumPlanes;
  LONG32 PLANE_CTR, WORD_ADDR, HIGH_BIT;
  EP("ExecuteScanNoPerm");
  /************************************************************************/
  /* compute HIGH_BIT_MASK and compute high bit mask for x dim            */
  /************************************************************************/
  HIGH_BIT_MASK = lDCMRHighBit >> 3;
  X_HIGH_BIT_MASK = lDCMRLowBit >> 3;
  /************************************************************************/
  /* SITE_CTR is set to how many sweeps are to be done. X_BYTE_LENGTH is  */
  /* set to how many bytes will be updated per sweep                      */
  /************************************************************************/
  if (ESC[0] < lNumXBits) {
    SITE_CTR = 1;
    X_BYTE_LENGTH = 1 << (ESC[0] - 3);
  else {
    SITE_CTR = ScanLength() >> lNumXBits;                                  
    X_BYTE_LENGTH = lDCMRLowBit >> 2;
  nNumPlanes = CalcNumPlanes();
  /************************************************************************/
  /* Code starts here                                                     */
  /************************************************************************/
  while (SITE_CTR != 0) {
    if (nNumPlanes) {
      ExecuteSweepCode(nNumPlanes);
      for(PLANE_CTR = 0; PLANE_CTR < nNumPlanes; PLANE_CTR++) {  
      WORD_ADDR = NEXT_WORD_ADDR[PLANE_CTR];
      HIGH_BIT = WORD_ADDR & HIGH_BIT_MASK;
      WORD_ADDR = WORD_ADDR & (~ HIGH_BIT_MASK);
      WORD_ADDR += X_BYTE_LENGTH;
      WORD_ADDR = WORD_ADDR ^ HIGH_BIT;
      NEXT_WORD_ADDR[PLANE_CTR] = WORD_ADDR;
      PLANE_CTR--;
	NEXT_WORD_ADDR[PLANE_CTR--] =
	  (((NEXT_WORD_ADDR[PLANE_CTR] & (~ HIGH_BIT_MASK)) + X_BYTE_LENGTH) ^
	   (NEXT_WORD_ADDR[PLANE_CTR] & HIGH_BIT_MASK));
      }
    }
    SCAN_INDEX_REG += (X_BYTE_LENGTH << 3);
    if (SCAN_INDEX_REG > 0xFFFFFF)
      SCAN_INDEX_REG = 0;
    SITE_CTR--;
    ConstantSetAll(SIR, SCAN_INDEX_REG);
  LP("ExecuteScanNoPerm");
void ExecuteSweepCode(unsigned short nNumPlanes)
  short i, j;
  LONG32 NBIT_OFFSET[CHIPS_PER_MOD], XWORD_LENGTH;
  EP("ExecuteSweepCode");
  /************************************************************************/
  /* We assume here that the scan index is not permuted to arrive at the  */
  /* site address; however, some bits of the site address could be fixed  */
  /* at constant 0 or 1 as indicated by SIPR. Here, the site address of   */
  /* the first site to be updated is computed.                            */
  /************************************************************************/
  SITE_ADDR = 0;
  for (i = SCAN_INDEX_LENGTH-1; i >= 0; i--) {
    
    SITE_ADDR <<= 1;
    if (SIPR[i][0] == PERM_CONST_1)
      SITE_ADDR |= 0x1;
    else if (SIPR[i][0] != 30)
      SITE_ADDR |= (SIR[0] >> i) & 0x1;
  /************************************************************************/
  /* Now that we know the site address of the first site to be updated,   */
  /* we compute the address in sparc memory of the word that contains     */
  /* a bit of that site by adding the plane offset to the site address.   */
  /************************************************************************/
  for (i = 0; i < nNumPlanes; i++) {
    
    NEXT_WORD_ADDR[i] = (AddSiteAddress(SITE_ADDR, OSR[i]) >> 5) << 2;
    
    NEXT_WORD_ADDR[i] += BIT_PLANE_ADDR[i];
    
    NBIT_OFFSET[i] = OSR[i] & 0x1F;
  XWORD_LENGTH = X_BYTE_LENGTH >> 2;
  ExecuteLoadFirstWord(nNumPlanes, NBIT_OFFSET);
  X_CTR = XWORD_LENGTH;
  while (X_CTR) {
    for (i = 0; i < 32; i++) {
      ExecuteUpdateSite(nNumPlanes);
      for (j = 0; j < nNumPlanes; j++) {
	if (NBIT_OFFSET[j] == (31 - i))
	  ExecuteGetNextWord(j);
      }
    }
    X_CTR -= 1;
  ExecuteSaveLastWord(nNumPlanes, NBIT_OFFSET);
  LP("ExecuteSweepCode");
void ExecuteLoadFirstWord(unsigned short nNumPlanes, LONG32 NBIT_OFFSET[])
  short i;
  LONG32 SAVE_BITS, WORD_ADDR;
  EP("ExecuteLoadFirstWord");
  for (i = 0; i < nNumPlanes; i++) {
    PLANE_WORD[i] = *((LONG32 *) NEXT_WORD_ADDR[i]);
    
    if (NBIT_OFFSET[i] != 0) {
      SAVE_BITS = PLANE_WORD[i] >> (32 - NBIT_OFFSET[i]);
      PLANE_WORD[i] <<= NBIT_OFFSET[i];
      PLANE_WORD[i] |= SAVE_BITS;
    }
  LP("ExecuteLoadFirstWord");
void ExecuteUpdateSite(unsigned short nNumPlanes)
  short i;
  LONG32 SiteDataSrc = UNGLUE_DATA;
  EP("ExecuteUpdateSite");
#ifdef _INCREMENTAL_EXECUTE_     
  if (bSourceRegChange || bDestChange) {
    bSourceRegChange = FALSE;
    bDestChange = FALSE;
#endif
  if (IsSrcNeeded(SRC_TBUS, nNumPlanes)) {
    if (!CAM8State.bImmediate) {
      if (CAM8State.bByteMode) {
	TBUS_DATA = *((BYTE *) TBUS_ADDR);
	TBUS_ADDR += 1;
      }
      
      else {
	TBUS_DATA = *((INT16 *) TBUS_ADDR);
	TBUS_ADDR += 2;
      } /* else */
    } /* if (!CAM8State.bImmediate) */
  if (IsSrcNeeded(SRC_SITE_DATA, nNumPlanes)) {
    UNGLUE_DATA = 0;
    for (i = nNumPlanes-1; i >= 0; i--) {
      bit = HIGHB(PLANE_WORD[i]);
      PLANE_WORD[i] <<= 1; 
      UNGLUE_DATA = (UNGLUE_DATA << 1) | bit;
    }
  /* For Now glued and unglued data are the same */
  if (IsSrcNeeded(SRC_GLUED_DATA, nNumPlanes)) {
    if (!IsSrcNeeded(SRC_SITE_DATA, nNumPlanes)) {
      GLUE_DATA = 0;
      for (i = nNumPlanes-1; i >= 0; i--) {
	bit = HIGHB(PLANE_WORD[i]);
	PLANE_WORD[i] <<= 1; 
	GLUE_DATA = (GLUE_DATA << 1) | bit;
      }
    }
    else
      GLUE_DATA = UNGLUE_DATA;
  if (IsSrcNeeded(SRC_LUT, nNumPlanes)) {
    LUT_DATA = 0;
    if (IsSrcSame(DEST_LUT, nNumPlanes))
      BuildDest(DEST_LUT, &LUT_DATA, LAS[0], LAM[0], nNumPlanes);           
    else
      BuildBitwiseDest(DEST_LUT, &LUT_DATA, LAS, LAM, nNumPlanes);
    LUT_DATA = (LONG32) (((INT16 *) LUT_ADDR)[LUT_DATA]);
  /************************************************************************/
  /*                                                                      */
  /* All the sources needed to update all the destinations should now be  */
  /* in place. Update all the destinations in the following order : EC,   */
  /* Display (ie, scan io reads), and Site Data. Note that Site data      */
  /* must be updated last, because it destroys the Site Data register,    */
  /* which is one of the possible Sources (unglued data).                 */
  /*                                                                      */
  /************************************************************************/
  if (IsDestUpdated(DEST_DISPLAY, nNumPlanes)) {
    if (IsSrcSame(DEST_DISPLAY, nNumPlanes))
      BuildDest(DEST_DISPLAY, &DISP_DATA, DDS[0], DDM[0], nNumPlanes);
    else
      BuildBitwiseDest(DEST_DISPLAY, &DISP_DATA, DDS, DDM, nNumPlanes);
    *((BYTE *) FRAME_ADDR) = DISP_DATA;
    FRAME_ADDR += 1;
    
  /* SCAN-IO READ */
  if ((CAM8State.WhyScan == REG_SIOR) && CAM8State.bReadMode) {
    if (CAM8State.bByteMode) {
      *((BYTE *) SIOR) = (BYTE) DISP_DATA;
      SIOR += 1;
    }
    
    else {
      *((INT16 *) SIOR) = (INT16) DISP_DATA;
      SIOR += 2;
    }
  if (IsDestUpdated(DEST_EVENT_CT, nNumPlanes)) {
    if (IsSrcSame(DEST_EVENT_CT, nNumPlanes))
      BuildDest(DEST_EVENT_CT, &TEMP1, ECS[0], ECM[0], nNumPlanes);
    else
      BuildBitwiseDest(DEST_EVENT_CT, &TEMP1, ECS, ECM, nNumPlanes);
    
    TEMP1 <<= (32 - nNumPlanes);
    for (i = nNumPlanes-1; i >= 0; i--) {
      EVENT_COUNT[i] += (TEMP1 & 0x80000000);
      TEMP1 <<= 1;
    }
  if (IsDestUpdated(DEST_SITE_DATA, nNumPlanes)) {
    if (IsSrcSame(DEST_SITE_DATA, nNumPlanes)) {
      if (SDM[0] == MAP_S) {
	short nSrc;
	SiteDataSrc = (SDS[0] == SRC_SITE_DATA ? UNGLUE_DATA :
		       SDS[0] == SRC_TBUS ? TBUS_DATA :
		       SDS[0] == SRC_LUT ? LUT_DATA : TEMP1);
      }
      
      else {
	BuildDest(DEST_SITE_DATA, &SITE_DATA, SDS[0], SDM[0], nNumPlanes);
	SiteDataSrc = SITE_DATA;
      }
    }
    
    else {
      BuildBitwiseDest(DEST_SITE_DATA, &SITE_DATA, SDS, SDM, nNumPlanes);
      SiteDataSrc = SITE_DATA;
    }
    
    SiteDataSrc <<= (32 - nNumPlanes);
    for (i = nNumPlanes - 1; i >= 0; i--) {                                
      bit = HIGHB(SiteDataSrc);
      SiteDataSrc <<= 1;
      
      if ((IsSrcNeeded(SRC_SITE_DATA, nNumPlanes)) ||
	  (IsSrcNeeded(SRC_GLUED_DATA, nNumPlanes)))
	PLANE_WORD[i] += bit;
      else
	PLANE_WORD[i] = (PLANE_WORD[i] << 1) | bit;
    }
  LP("ExecuteUpdateSite");
LONG32 *PermuteScanIndex(unsigned short nNumPlanes)
  short i;
  BOOL bIsPermuted = FALSE;
  EP("PermuteScanIndex");
  for (i = nNumPlanes - 1; i >= 0; i--) {
    if (SABSR[i] != i) {
      bIsPermuted = TRUE;
      break;
    }
  if (!bIsPermuted) {
    LP("PermuteScanIndex");
    return(&SCAN_INDEX_REG);
  TEMP6 = 0;
  for (i = nNumPlanes-1; i >= 0; i--) {
      
    if (SABSR[i] < 24) {
      TEMP5 = SCAN_INDEX_REG << (31 - SABSR[i]);
      bit = HIGHB(TEMP5);
      TEMP5 <<= 1;
      TEMP6 = (TEMP6 << 1) | bit;
    }
    
    else if (SABSR[i] == 31) {
      TEMP6 <<= 1;
      TEMP6 += 1;
    }
      
    else if (SABSR[i] == 30) {
      TEMP6 <<= 1;
    }
    
    else {
      WARNING("Invalid SABSR value!", "PermuteScanIndex");              
      TEMP6 <<= 1;
    } 
  LP("PermuteScanIndex");
  return (&TEMP6);
void MapFunction (LONG32 *SrcVar, LONG32 *DestVar, BYTE bMap)
  EP("MapFunction");
  switch (bMap) {
  case MAP_CONST_0:
    *DestVar = 0;
    break;
    
  case MAP_G_NOR_S:
    *DestVar = ~ (GLUE_DATA | *SrcVar);
    break;
    
  case MAP_G_AND_S_BAR:
    *DestVar = GLUE_DATA & (~ *SrcVar);
    break;
    
  case MAP_S_BAR:
    *DestVar = ~ *SrcVar;
    break;
    
  case MAP_G_BAR_AND_S:
    *DestVar = (~ GLUE_DATA) & *SrcVar;
    break;
    
  case MAP_G_BAR:
    *DestVar = ~ GLUE_DATA;
    break;
    
  case MAP_G_XOR_S:
    *DestVar = GLUE_DATA ^ *SrcVar;
    break;
    
  case MAP_G_NAND_S:
    *DestVar = ~ (GLUE_DATA & *SrcVar);
    break;
    
  case MAP_G_AND_S:
    *DestVar = GLUE_DATA & *SrcVar;
    break;
    
  case MAP_G_EQ_S:
    *DestVar = ~ (GLUE_DATA ^ *SrcVar);
    break;
    
  case MAP_G:
    *DestVar = GLUE_DATA;
    break;
    
  case MAP_G_OR_S_BAR:
    *DestVar = GLUE_DATA | (~ *SrcVar);
    break;
    
  case MAP_S:
    *DestVar = *SrcVar;
    break;
    
  case MAP_G_BAR_OR_S:
    *DestVar = (~ GLUE_DATA) | *SrcVar;
    break;
    
  case MAP_G_OR_S:
    *DestVar = GLUE_DATA | *SrcVar;
    break;
    
  case MAP_CONST_1:
    *DestVar = 0xFFFFFFFF;
    break;
  LP("MapFunction");
void BuildDest(short nDest, LONG32 *DestVar, BYTE Src, BYTE Map,
               unsigned short nNumPlanes)
  LONG32 *SrcVar;
  EP("BuildDest");
  if ((Map != MAP_G) && (Map != MAP_G_BAR)) {
    
    SrcVar = (Src == SRC_SITE_DATA ? &UNGLUE_DATA :
	      Src == SRC_TBUS ? &TBUS_DATA :
	      Src == SRC_LUT ? &LUT_DATA : &TEMP1);
    
    if ((nDest == DEST_LUT) && (Src == SRC_SITE_ADDRESS)) {
      SrcVar = PermuteScanIndex(nNumPlanes);
    }
  MapFunction(SrcVar, DestVar, Map);
  LP("BuildDest");
void BuildBitDest(short nDest, LONG32 *HoldReg, BYTE Src, BYTE Map,
		  unsigned short nPlane)
{                                                               
  EP("BuildBitDest");
  if ((nDest == DEST_LUT) && (Src == SRC_SITE_ADDRESS)) {
    TEMP6 = 0;
    
    if (SABSR[nPlane] < 24) {
      TEMP5 = SCAN_INDEX_REG << (31 - SABSR[nPlane]);
      bit = HIGHB(TEMP5);
      TEMP5 <<= 1;
      TEMP6 = ((TEMP6 << 1) | bit) << nPlane;
    }
    
    else if (SABSR[nPlane] == 31)
      TEMP6 += 1;
    
    else if (SABSR[nPlane] == 30)
      TEMP6 <<= 1;
    
    else {
      WARNING("Invalid SABSR value", "BuildBitDest");
      TEMP6 <<= 1;
    }
    
    MapFunction (&TEMP6, HoldReg, Map);
  else {
    BuildDest(nDest, HoldReg, Src, Map, CHIPS_PER_MOD);
  LP("BuildBitDest");
void BuildBitwiseDest(short nDest, LONG32 *DestVar, BYTE Src[], BYTE Map[],
                      unsigned short nNumPlanes)
  short i;
  LONG32 *HoldReg = &TEMP4;
  EP("BuildBitwiseDest");
  for (i = nNumPlanes - 1; i >= 0; i--) {
    BuildBitDest(nDest, HoldReg, Src[i], Map[i], i);
    *HoldReg <<= (31 - i);
    bit = HIGHB(*HoldReg);
    *HoldReg <<= 1;
    *DestVar = (*DestVar << 1) | bit;
  LP("BuildBitwiseDest");
void ExecuteGetNextWord(unsigned short nPlane)
  LONG32 ADDR_HIGH_BIT;
  BOOL bWriteBack = FALSE;
  short i;
  EP("ExecuteGetNextWord");
  *((LONG32 *) NEXT_WORD_ADDR[nPlane]) = PLANE_WORD[nPlane];
  if (lNumXBits <= 5) {
  LP("ExecuteGetNextWord");
  return;
  }          
  ADDR_HIGH_BIT = NEXT_WORD_ADDR[nPlane] & X_HIGH_BIT_MASK;
  NEXT_WORD_ADDR[nPlane] &= (~ X_HIGH_BIT_MASK);
  NEXT_WORD_ADDR[nPlane] = (NEXT_WORD_ADDR[nPlane] + 4) ^ ADDR_HIGH_BIT;
  PLANE_WORD[nPlane] = *((LONG32 *) NEXT_WORD_ADDR[nPlane]);
  LP("ExecuteGetNextWord");
void ExecuteSaveLastWord(unsigned short nNumPlanes, LONG32 NBIT_OFFSET[])
  short i;
  LONG32 SAVE_BITS;
  EP("ExecuteSaveLastWord");
  for (i = 0; i < nNumPlanes; i++) {
    if (!NBIT_OFFSET[i])
      continue;
    
    SAVE_BITS = PLANE_WORD[i] >> NBIT_OFFSET[i];
    PLANE_WORD[i] <<= (32 - NBIT_OFFSET[i]);
    PLANE_WORD[i] |= SAVE_BITS;
    *((LONG32 *) NEXT_WORD_ADDR[i]) = PLANE_WORD[i];
  LP("ExecuteSaveLastWord");
#ifndef _EXECUTE_NO_PERM_
#define _EXECUTE_NO_PERM_
#include "global.h"
#include "executer.h"
void ExecuteScanNoPerm();
#endif
#ifndef _EXECUTE_NO_PERM_P_
#define _EXECUTE_NO_PERM_P_
#include "global.h"
LONG32 *PermuteScanIndex(unsigned short nNumPlanes);
void MapFunction (LONG32 *SrcVar, LONG32 *DestVar, BYTE bMap);
void BuildDest(short nDest, LONG32 *DestVar, BYTE Src, BYTE Map, unsigned short nNumPlanes);
void BuildBitDest(short nDest, LONG32 *HoldReg, BYTE Src, BYTE Map, unsigned short nPlane);
void BuildBitwiseDest(short nDest, LONG32 *DestVar, BYTE Src[], BYTE Map[], unsigned short nNumPlanes);
void ExecuteLoadFirstWord(unsigned short nNumPlanes, LONG32 nBitOffset[]);
void ExecuteUpdateSite(unsigned short nNumPlanes);
void ExecuteGetNextWord(unsigned short nPlane);
void ExecuteSaveLastWord(unsigned short nNumPlanes, LONG32 nBitOffset[]);
#endif
#include <stdio.h>
#include <sys/mman.h>
#include "errmgr.h"
#include "memmgr.h"
#include "global.h"
#include "utils.h"
#include "executeNoPerm.h"
#include "execute5Perm.h"
#include "executeGen.h"
#include "executer.h"
#include "decode_steplist.h"
#define MODULE_NAME             "Executer"
BOOL            bSourceRegChange = TRUE;
BOOL            bDestChange = TRUE;
BOOL            bForceGeneralScan = FALSE;
void CheckNoPerm();
void ExecuteScan()
  int i;
  BOOL bNoPerm = TRUE;
  BOOL bNoPermLast5 = TRUE;
  LONG32 lLogScanLength = ESC[0] + 1L;
  EP("ExecuteScan");  
  /************************************************************************/
  /* First, parse down the tree to see that we are going to update atleast*/
  /* 32 sites and that the lowest dimension extends over 32 bits. This    */
  /* second requirement is necessary because the optimized code can only  */
  /* handle dimension wraparounds at word boundaries.                     */
  /************************************************************************/
  if (lLogScanLength < 5)
    bNoPerm = bNoPermLast5 = FALSE;
  else if (lNumXBits < 5)
    bNoPerm = bNoPermLast5 = FALSE;
  else
    bNoPerm = bNoPermLast5 = TRUE;
  /************************************************************************/
  /* Now, determine if there is any permutation of the scan index in the  */
  /* bits of the SIR that will be significant over this scan.             */
  /************************************************************************/
  for (i = 0; i < MIN(5, ESC[0]); i++) {
    if (SIPR[i][0] != i) {
      bNoPerm = bNoPermLast5 = FALSE;
      break;
    }
    
    lLogScanLength--;
    
    if (!lLogScanLength)
      break;
  for (i = 5; i < MIN(SCAN_INDEX_LENGTH, ESC[0]); i++) {
    if (SIPR[i][0] != i)
      bNoPerm = FALSE;
    lLogScanLength--;
    if (!lLogScanLength)
      break;
  FRAME_ADDR = (LONG32) FRAMEb;
  if (bNoPerm)
    CheckNoPerm();
  else if (bNoPermLast5)
    ExecuteGeneralScan();
  else
    ExecuteGeneralScan();
  if (SCAN_INDEX_REG > 0xFFFFFF)
    SCAN_INDEX_REG = 0;
  SIR[0] = SCAN_INDEX_REG;
  LP("ExecuteScan");
/*****************************************************************************/
/*                                                                           */
/* CheckNoPerm is necessary for the following reason - suppose there is no   */
/* permutation of the Scan Index, but suppose the the bits that extend over  */
/* the lowest dimension (ie, the bits to the _right_ of the lowest bit of    */
/* DCMR) are not all zeros. Then, the first sweep will not scan a multiple-  */
/* of-two number of sites, and we cannot to an optimized scan.               */
/*                                                                           */
/*****************************************************************************/
void CheckNoPerm()
  LONG32 lSIRSigBits, lSIR;
  EP("CheckNoPerm");
  lSIRSigBits = MIN(ESC[0], lNumXBits);
  lSIR = SIR[0] & ~((~0x0) << lSIRSigBits);
  if ((lSIR == 0) && (MIN(lNumXBits, ESC[0]) >= 2)) {
    if (bForceGeneralScan)
      ExecuteGeneralScan();
    else
      ExecuteScanNoPerm();
  else
    ExecuteGeneralScan();
  LP("CheckNoPerm");
#ifndef _EXECUTER_
#define _EXECUTER_
#include "global.h"
extern BOOL bSourceRegChange;
extern BOOL bDestChange;
extern BOOL bForceGeneralScan;
void ExecuteScan(void);
#endif
#include "global.h"
CAM8STATE CAM8State;
LONG32 bit;
#ifdef MACROREGS
LONG32 SiteAddress;
LONG32 HighBitMask;
LONG32 XHighBitMask;
LONG32 XByteLength;
LONG32 XCtr;
LONG32 SiteCtr;
LONG32 Offsets[CHIPS_PER_MOD];
LONG32 BitOffsets[CHIPS_PER_MOD];
LONG32 Dcmr;
LONG32 ScanIndexReg;
LONG32 LutAddr;
LONG32 BitPlaneAddr[CHIPS_PER_MOD];
LONG32 NextWordAddr[CHIPS_PER_MOD];
LONG32 PlaneWord[CHIPS_PER_MOD];
LONG32 EventCount[CHIPS_PER_MOD];
LONG32 UnGlueData;
LONG32 GlueData;
LONG32 SiteData;
LONG32 TbusData;
LONG32 LutData;
LONG32 DispData;
LONG32 TbusAddr;
LONG32 FrameAddr;
LONG32 Temp1;
LONG32 Temp2;
LONG32 Temp3;
LONG32 Temp4;
LONG32 Temp5;
LONG32 Temp6;
LONG32 Temp7;
LONG32 Temp8;
LONG32 Temp9;
LONG32 Temp10;
#else
LONG32 SITE_ADDR;
LONG32 HIGH_BIT_MASK;
LONG32 X_HIGH_BIT_MASK;
LONG32 X_BYTE_LENGTH;
LONG32 X_CTR;
LONG32 SITE_CTR;
LONG32 OFFSETS[CHIPS_PER_MOD];
LONG32 BIT_OFFSETS[CHIPS_PER_MOD];
LONG32 DCMR;
LONG32 SCAN_INDEX_REG;
LONG32 LUT_ADDR;
LONG32 BIT_PLANE_ADDR[CHIPS_PER_MOD];
LONG32 NEXT_WORD_ADDR[CHIPS_PER_MOD];
LONG32 PLANE_WORD[CHIPS_PER_MOD];
LONG32 EVENT_COUNT[CHIPS_PER_MOD];
LONG32 UNGLUE_DATA;
LONG32 GLUE_DATA;
LONG32 SITE_DATA;
LONG32 TBUS_DATA;
LONG32 LUT_DATA;
LONG32 DISP_DATA;
LONG32 TBUS_ADDR;
LONG32 FRAME_ADDR;
LONG32 TEMP1;
LONG32 TEMP2;
LONG32 TEMP3;
LONG32 TEMP4;
LONG32 TEMP5;
LONG32 TEMP6;
LONG32 TEMP7;
LONG32 TEMP8;
LONG32 TEMP9;
LONG32 TEMP10;
#endif
/* LUT buffers and FRAME buffer */
INT16 *LUTb[2];
BYTE *FRAMEb;
#ifndef _GLOBAL_
#define _GLOBAL_
#define SHARED_MEMORY_INTERFACE
#define CHIPS_PER_MOD           16
#define SCAN_INDEX_LENGTH       24
#define PERM_CONST_1            31                                               
#define PERM_CONST_0            30
#define TRUE                    1
#define FALSE                   0
#ifndef NULL
#define NULL                    0
#endif
#define LONG32_SIZE     (sizeof(LONG32))
#define INT16_SIZE      (sizeof(INT16))
typedef unsigned char   BYTE;
typedef unsigned char   BOOL;
typedef unsigned long   LONG32;
typedef unsigned short  INT16;
#include "decode_steplist.h"
/*****************************************************************************/
/*                                                                           */
/* Definition of struct tag_CAM8State, the CAM module state structure.       */
/*                                                                           */
/*****************************************************************************/
typedef struct cam8state {
  /* CAM8 Registers */
  BYTE MSR[CHIPS_PER_MOD];
  BYTE SSM[CHIPS_PER_MOD];
  BYTE RT[CHIPS_PER_MOD];
  BYTE ECT[CHIPS_PER_MOD];
  BYTE RPK[CHIPS_PER_MOD];
  BYTE ALT[CHIPS_PER_MOD];
  LONG32 KA[CHIPS_PER_MOD];
  BYTE XKS[CHIPS_PER_MOD];
  BYTE YKS[CHIPS_PER_MOD];
  BYTE ZKS[CHIPS_PER_MOD];
  BYTE XKMF[CHIPS_PER_MOD];
  BYTE YKMF[CHIPS_PER_MOD];
  BYTE ZKMF[CHIPS_PER_MOD];
  BYTE SABSR[CHIPS_PER_MOD];
  BYTE LAS[CHIPS_PER_MOD];
  BYTE LAM[CHIPS_PER_MOD];
  BYTE FOS[CHIPS_PER_MOD];
  BYTE FOM[CHIPS_PER_MOD];
  BYTE SDS[CHIPS_PER_MOD];
  BYTE SDM[CHIPS_PER_MOD];
  BYTE ECS[CHIPS_PER_MOD];
  BYTE ECM[CHIPS_PER_MOD];
  BYTE DDS[CHIPS_PER_MOD];
  BYTE DDM[CHIPS_PER_MOD];
  BYTE SSR[CHIPS_PER_MOD];
  LONG32 ECR[CHIPS_PER_MOD];
  INT16 LIR[CHIPS_PER_MOD];
  BYTE LIPR[CHIPS_PER_MOD];
  INT16 *LIOR;
  LONG32 SIR[CHIPS_PER_MOD];
  BYTE SSA[24][CHIPS_PER_MOD];
  BYTE *SIOR;
  BYTE SM[CHIPS_PER_MOD];
  BYTE ESC[CHIPS_PER_MOD];
  BYTE ESW[CHIPS_PER_MOD];
  BYTE EST[CHIPS_PER_MOD];
  BYTE SBRC[CHIPS_PER_MOD];
  BYTE RCL[CHIPS_PER_MOD];
  BYTE ECL[CHIPS_PER_MOD];
  BYTE STM[CHIPS_PER_MOD];
  LONG32 OSR[CHIPS_PER_MOD];
  LONG32 DCM[CHIPS_PER_MOD];
  BYTE XDCP[CHIPS_PER_MOD];
  BYTE YDCP[CHIPS_PER_MOD];
  BYTE ZDCP[CHIPS_PER_MOD];
  BYTE LPL[CHIPS_PER_MOD];
  BYTE FPL[CHIPS_PER_MOD];
  BYTE DCS[CHIPS_PER_MOD];
  BYTE TBD[CHIPS_PER_MOD];
  BYTE TMS[CHIPS_PER_MOD];
  BYTE NBF[CHIPS_PER_MOD];
  BYTE SRE[CHIPS_PER_MOD];
  BYTE ALS[CHIPS_PER_MOD];
  BYTE MAFS[CHIPS_PER_MOD];
  BYTE MBFS[CHIPS_PER_MOD];
  BYTE XMPC[CHIPS_PER_MOD];
  BYTE XPPC[CHIPS_PER_MOD];
  BYTE YMPC[CHIPS_PER_MOD];
  BYTE YPPC[CHIPS_PER_MOD];
  BYTE ZMPC[CHIPS_PER_MOD];
  BYTE ZPPC[CHIPS_PER_MOD];
  BYTE MIDR[CHIPS_PER_MOD];
  BYTE GIDR[CHIPS_PER_MOD];
  BYTE BPIE[CHIPS_PER_MOD];
  BYTE BCIE[CHIPS_PER_MOD];
  BYTE GCIE[CHIPS_PER_MOD];
  BYTE MAIE[CHIPS_PER_MOD];
  BYTE MBIE[CHIPS_PER_MOD];
  BYTE SSIE[CHIPS_PER_MOD];
  BYTE XHIE[CHIPS_PER_MOD];
  BYTE RLIE[CHIPS_PER_MOD];
  BYTE URIE[CHIPS_PER_MOD];
  BYTE ISIE[CHIPS_PER_MOD];
  BYTE BPIF[CHIPS_PER_MOD];
  BYTE BCIF[CHIPS_PER_MOD];
  BYTE GCIF[CHIPS_PER_MOD];
  BYTE MAIF[CHIPS_PER_MOD];
  BYTE MBIF[CHIPS_PER_MOD];
  BYTE SSIF[CHIPS_PER_MOD];
  BYTE XHIF[CHIPS_PER_MOD];
  BYTE RLIF[CHIPS_PER_MOD];
  BYTE URIF[CHIPS_PER_MOD];
  BYTE ISIF[CHIPS_PER_MOD];
  BYTE VWE[CHIPS_PER_MOD];
  BYTE VWIE[CHIPS_PER_MOD];
  BYTE VWIF[CHIPS_PER_MOD];
  BYTE LDOC[CHIPS_PER_MOD];
  BYTE HDOC[CHIPS_PER_MOD];
  /* Not actual CAM8 Register but needed state info */
  BYTE WhyScan;
  BOOL bByteMode;
  BOOL bImmediate;
  BOOL bReadMode;
} CAM8STATE;
#define ConstantSetAll(r, v) \
{register int i;for(i=0;i<CHIPS_PER_MOD;i++) r[i]=v;}
#define SetAll(r, v) \
{register int i;for(i=0;i<CHIPS_PER_MOD;i++) r[i]=v[i];}
#define MSR	CAM8State.MSR
#define SSM	CAM8State.SSM
#define RT	CAM8State.RT
#define ECT	CAM8State.ECT
#define RPK	CAM8State.RPK
#define ALT	CAM8State.ALT
#define KA	CAM8State.KA
#define XKS	CAM8State.XKS
#define YKS	CAM8State.YKS
#define ZKS	CAM8State.ZKS
#define XKMF	CAM8State.XKMF
#define YKMF	CAM8State.YKMF
#define ZKMF	CAM8State.ZKMF
#define SABSR	CAM8State.SABSR
#define LAS	CAM8State.LAS
#define LAM	CAM8State.LAM
#define FOS	CAM8State.FOS
#define FOM	CAM8State.FOM
#define SDS	CAM8State.SDS
#define SDM	CAM8State.SDM
#define ECS	CAM8State.ECS
#define ECM	CAM8State.ECM
#define DDS	CAM8State.DDS
#define DDM	CAM8State.DDM
#define SSR	CAM8State.SSR
#define ECR	CAM8State.ECR
#define LIR	CAM8State.LIR
#define LIPR	CAM8State.LIPR
#define LIOR	CAM8State.LIOR
#define SIR	CAM8State.SIR
#define SIPR	CAM8State.SSA
#define SSA0	CAM8State.SSA[0]
#define SSA1	CAM8State.SSA[1]
#define SSA2	CAM8State.SSA[2]
#define SSA3	CAM8State.SSA[3]
#define SSA4	CAM8State.SSA[4]
#define SSA5	CAM8State.SSA[5]
#define SSA6	CAM8State.SSA[6]
#define SSA7	CAM8State.SSA[7]
#define SSA8	CAM8State.SSA[8]
#define SSA9	CAM8State.SSA[9]
#define SSA10	CAM8State.SSA[10]
#define SSA11	CAM8State.SSA[11]
#define SSA12	CAM8State.SSA[12]
#define SSA13	CAM8State.SSA[13]
#define SSA14	CAM8State.SSA[14]
#define SSA15	CAM8State.SSA[15]
#define SSA16	CAM8State.SSA[16]
#define SSA17	CAM8State.SSA[17]
#define SSA18	CAM8State.SSA[18]
#define SSA19	CAM8State.SSA[19]
#define SSA20	CAM8State.SSA[20]
#define SSA21	CAM8State.SSA[21]
#define SSA22	CAM8State.SSA[22]
#define SSA23	CAM8State.SSA[23]
#define SIOR	CAM8State.SIOR
#define SM	CAM8State.SM
#define ESC	CAM8State.ESC
#define ESW	CAM8State.ESW
#define EST	CAM8State.EST
#define SBRC	CAM8State.SBRC
#define RCL	CAM8State.RCL
#define ECL	CAM8State.ECL
#define STM	CAM8State.STM
#define OSR	CAM8State.OSR
#define DCM	CAM8State.DCM
#define XDCP	CAM8State.XDCP
#define YDCP	CAM8State.YDCP
#define ZDCP	CAM8State.ZDCP
#define LPL	CAM8State.LPL
#define FPL	CAM8State.FPL
#define DCS	CAM8State.DCS
#define TBD	CAM8State.TBD
#define TMS	CAM8State.TMS
#define NBF	CAM8State.NBF
#define SRE	CAM8State.SRE
#define ALS	CAM8State.ALS
#define MAFS	CAM8State.MAFS
#define MBFS	CAM8State.MBFS
#define XMPC	CAM8State.XMPC
#define XPPC	CAM8State.XPPC
#define YMPC	CAM8State.YMPC
#define YPPC	CAM8State.YPPC
#define ZMPC	CAM8State.ZMPC
#define ZPPC	CAM8State.ZPPC
#define MIDR	CAM8State.MIDR
#define GIDR	CAM8State.GIDR
#define BPIE	CAM8State.BPIE
#define BCIE	CAM8State.BCIE
#define GCIE	CAM8State.GCIE
#define MAIE	CAM8State.MAIE
#define MBIE	CAM8State.MBIE
#define SSIE	CAM8State.SSIE
#define XHIE	CAM8State.XHIE
#define RLIE	CAM8State.RLIE
#define URIE	CAM8State.URIE
#define ISIE	CAM8State.ISIE
#define BPIF	CAM8State.BPIF
#define BCIF	CAM8State.BCIF
#define GCIF	CAM8State.GCIF
#define MAIF	CAM8State.MAIF
#define MBIF	CAM8State.MBIF
#define SSIF	CAM8State.SSIF
#define XHIF	CAM8State.XHIF
#define RLIF	CAM8State.RLIF
#define URIF	CAM8State.URIF
#define ISIF	CAM8State.ISIF
#define VWE	CAM8State.VWE
#define VWIE	CAM8State.VWIE
#define VWIF	CAM8State.VWIF
#define LDOC	CAM8State.LDOC
#define HDOC	CAM8State.HDOC
#define LUT0			LUTb[0]
#define LUT1			LUTb[1]
#ifdef MACROREGS
#define SITE_ADDR		SiteAddress
#define HIGH_BIT_MASK		HighBitMask
#define X_HIGH_BIT_MASK		XHighBitMask
#define X_BYTE_LENGTH		XByteLength
#define X_CTR			XCtr
#define SITE_CTR		SiteCtr
#define OFFSETS			Offsets
#define BIT_OFFSETS		BitOffsets
#define DCMR			Dcmr
#define SCAN_INDEX_REG		ScanIndexReg
#define LUT_ADDR		LutAddr
#define BIT_PLANE_ADDR		BitPlaneAddr
#define NEXT_WORD_ADDR		NextWordAddr
#define PLANE_WORD		PlaneWord
#define EVENT_COUNT		EventCount
#define UNGLUE_DATA		UnGlueData
#define GLUE_DATA		GlueData
#define SITE_DATA		SiteData
#define TBUS_DATA		TbusData
#define DISP_DATA		DispData
#define LUT_DATA		LutData
#define TBUS_ADDR		TbusAddr
#define FRAME_ADDR		FrameAddr
#define TEMP1			Temp1
#define TEMP2		        Temp2
#define TEMP3		        Temp3
#define TEMP4		        Temp4
#define TEMP5		        Temp5
#define TEMP6		        Temp6
#define TEMP7		        Temp7
#define TEMP8		        Temp8
#define TEMP9		        Temp9
#define TEMP10		        Temp10
#endif
#define HIGHB(x)		(((x) & 0x80000000) == 0x80000000)
extern CAM8STATE CAM8State;
extern LONG32 bit;
#ifdef MACROREGS
extern LONG32 SiteAddress;
extern LONG32 HighBitMask;
extern LONG32 XHighBitMask;
extern LONG32 XByteLength;
extern LONG32 XCtr;
extern LONG32 SiteCtr;
extern LONG32 Offsets[CHIPS_PER_MOD];
extern LONG32 BitOffsets[CHIPS_PER_MOD];
extern LONG32 Dcmr;
extern LONG32 ScanIndexReg;
extern LONG32 LutAddr;
extern LONG32 BitPlaneAddr[CHIPS_PER_MOD];
extern LONG32 NextWordAddr[CHIPS_PER_MOD];
extern LONG32 PlaneWord[CHIPS_PER_MOD];
extern LONG32 EventCount[CHIPS_PER_MOD];
extern LONG32 UnGlueData;
extern LONG32 GlueData;
extern LONG32 SiteData;
extern LONG32 TbusData;
extern LONG32 LutData;
extern LONG32 DispData;
extern LONG32 TbusAddr;
extern LONG32 FrameAddr;
extern LONG32 Temp1;
extern LONG32 Temp2;
extern LONG32 Temp3;
extern LONG32 Temp4;
extern LONG32 Temp5;
extern LONG32 Temp6;
extern LONG32 Temp7;
extern LONG32 Temp8;
extern LONG32 Temp9;
extern LONG32 Temp10;
#else
extern LONG32 SITE_ADDR;
extern LONG32 HIGH_BIT_MASK;
extern LONG32 X_HIGH_BIT_MASK;
extern LONG32 X_BYTE_LENGTH;
extern LONG32 X_CTR;
extern LONG32 SITE_CTR;
extern LONG32 OFFSETS[CHIPS_PER_MOD];
extern LONG32 BIT_OFFSETS[CHIPS_PER_MOD];
extern LONG32 DCMR;
extern LONG32 SCAN_INDEX_REG;
extern LONG32 LUT_ADDR;
extern LONG32 BIT_PLANE_ADDR[CHIPS_PER_MOD];
extern LONG32 NEXT_WORD_ADDR[CHIPS_PER_MOD];
extern LONG32 PLANE_WORD[CHIPS_PER_MOD];
extern LONG32 EVENT_COUNT[CHIPS_PER_MOD];
extern LONG32 UNGLUE_DATA;
extern LONG32 GLUE_DATA;
extern LONG32 SITE_DATA;
extern LONG32 TBUS_DATA;
extern LONG32 LUT_DATA;
extern LONG32 DISP_DATA;
extern LONG32 TBUS_ADDR;
extern LONG32 FRAME_ADDR;
extern LONG32 TEMP1;
extern LONG32 TEMP2;
extern LONG32 TEMP3;
extern LONG32 TEMP4;
extern LONG32 TEMP5;
extern LONG32 TEMP6;
extern LONG32 TEMP7;
extern LONG32 TEMP8;
extern LONG32 TEMP9;
extern LONG32 TEMP10;
#endif
/* LUT buffers and FRAME buffer */
extern INT16 *LUTb[2];
extern BYTE *FRAMEb;
#ifdef DEBUG
  #include <stdio.h>
  extern FILE* DEBUGFILE;
  extern char *REGNAMES[];
#endif
#define EP(name)
#define LP(name)
#endif
#include "global.h"
#include "errmgr.h"
#include "memmgr.h"
#define MODULE_NAME	"Heap"
/* 0.5 Megabytes per plane and 64K x 16bit LUT */
const int lBitPlaneSize = 512 * 1024;
const int lLUTSize = 65536*2;
void InitHeap()
  short i;
     
  for (i = 0; i < CHIPS_PER_MOD; i++) {
    BIT_PLANE_ADDR[i] = (LONG32) MEMALIGN(getpagesize(), lBitPlaneSize,
					  "InitHeap : Plane Memory");
  LUT0 = (INT16 *) VALLOC(lLUTSize, "InitHeap : LUT0");
#ifdef DEBUG
  printf("LUT0 = 0x%x\n", LUT0);
#endif
  LUT_ADDR = (LONG32) LUT0;
  LUT1 = (INT16 *) VALLOC(lLUTSize, "InitHeap : LUT1");
#ifdef DEBUG
  printf("LUT1 = 0x%x\n", LUT1);
#endif
  LIOR = (INT16 *) LUT1;
  FRAMEb = (BYTE *) VALLOC(512 * 512, "InitHeap : FRAMEBUFFER");
#include <stdio.h>
#include <fcntl.h>
#include <sys/types.h>
#include <sys/ipc.h>
#include <sys/shm.h>
#include <setjmp.h>
#include "global.h"
#include "errmgr.h"
#include "memmgr.h"
#include "steplist.h"
#include "hinterface.h"
#include "hinterfaceP.h"
#include <pipecomm.h>
#define MODULE_NAME	"Host Interface"
char *shmat(int, char *, int);
int shmdt(char *);
static struct {
  char *addr;
  int id ;
} shm[100] = { NULL, 0 };							/* Table of shared memory seg addr   */
static int retv[2];								/* Return value			     */
static jmp_buf exception;							/* Execution frame for exceptions    */
INTERFACE_REGS iregs;								/* CAM8 Interface registers	     */
int sim_infd = 0;								/* File desc to read commands from   */
int sim_outfd = 1;								/* File desc to write replies to     */
static CMDT simcmds[] = {
  { "shma", SHMATTACH },
  { "shmd", SHMDETACH },
  { "rdR0", READR0 },
  { "rdR1", READR1 },
  { "rdR2", READR2 },
  { "rdR3", READR3 },
  { "wrR0", WRITER0 },
  { "wrR1", WRITER1 },
  { "wrR2", WRITER2 },
  { "wrR3", WRITER3 },
  { "sim@", SIMFETCH },
  { "quit", QUIT }
static int qflag = 0;
static int retv[2];
void ResetInterface(void)
  /* Zero everything out to start off */
  bzero((char *) &iregs, sizeof(iregs));
  /* Enable all interrupts and exceptions */
  iregs.RER = CAM_ENABLE_NEWLIST_INT | CAM_ENABLE_TIMEOUT_INT |
              CAM_ENABLE_SBUS_INT | CAM_ENABLE_CAM_INT |
	      CAM_ENABLE_SOFT_INT | CAM_ENABLE_TIMEOUT_EXC |
	      CAM_ENABLE_CAMINT_EXC;
  /* Mark all interrupts as enabled */
  iregs.ISR = CAM_ENABLE_NEWLIST_INT | CAM_ENABLE_TIMEOUT_INT |
              CAM_ENABLE_SBUS_INT | CAM_ENABLE_CAM_INT |
	      CAM_ENABLE_SOFT_INT;
  /* Put us in wait-for-host mode */
  iregs.NLP |= CAM_WAIT_FOR_HOST;
void InitInterface(void)
  ResetInterface();
  bzero((char *) shm, sizeof(shm));
  SetCmdTable(simcmds);
  SetMode(PALL|SILENT|FDPLX);
int ReadInterfaceRegs(void)
  int rv;
  if ((rv = ParseMesg(sim_infd, sim_outfd, NULL)) < PALL) {			/* There has been a fatal error	     */
    retv[0] = FATAL;
    SendMesg(sim_outfd, (char *) retv);
    fprintf(stderr, "CAM8SIM: Fatal error, exiting\n");
    return(-1);
  return(qflag);
unsigned char *SHMATTACH(char *appdata, unsigned char *o, unsigned char *d)
  register int i;
  int shmid = *((int *) d);
  char *a;
  if ((a = shmat(shmid, 0, 0)) == (char *) -1) {
    fprintf(stderr, "CAM8SIM: failed to attach using shmid %d --> ", shmid);
    perror(NULL);
    retv[0] = BADSHMID;
    return((unsigned char *) retv);
  for(i = 0; i < 100; i++)
    if (shm[i].addr == NULL) {
      retv[1] = (int) shm[i].addr = a;
      shm[i].id = shmid;
      retv[0] = NOERR;
      return((unsigned char *) retv);
    }
  fprintf(stderr, "CAM8SIM: internal shmid table full\n");
  retv[0] = TABLEFULL;
  return((unsigned char *) retv);
unsigned char *SHMDETACH(char *appdata, unsigned char *o, unsigned char *d)
  register int i;
  char *a = *((char **) d);
  for( i = 0; i < 100; i++)
    if (shm[i].addr == a) {
      shmdt(shm[i].addr);
      
      shm[i].addr = NULL;
      retv[0] = NOERR;
      return((unsigned char *) retv);
    }
  retv[0] = BADSHMID;
  return((unsigned char *) retv);
unsigned char *READR0(char *appdata, unsigned char *o, unsigned char *d)
  retv[0] = NOERR;
  retv[1] = iregs.NLP;
  return((unsigned char *) retv);
unsigned char *READR1(char *appdata, unsigned char *o, unsigned char *d)
  retv[0] = NOERR;
  retv[1] = iregs.ISR;
  /* Turn off interrupt flags and unused bits, leave enables the same */
  iregs.ISR &= 0x00001F00;
  return((unsigned char *) retv);
unsigned char *READR2(char *appdata, unsigned char *o, unsigned char *d)
  retv[0] = NOERR;
  retv[1] = iregs.CIP;
  return((unsigned char *) retv);
unsigned char *READR3(char *appdata, unsigned char *o, unsigned char *d)
  retv[0] = NOERR;
  retv[1] = iregs.PIP;
  return((unsigned char *) retv);
unsigned char *WRITER0(char *appdata, unsigned char *o, unsigned char *d)
  LONG32 tmp = iregs.NLP & 0xF;
    
  if (!(iregs.NLP & CAM_EXCEPTION_STATUS)) {
    iregs.NLP = tmp | (*((int *) d) & 0xFFFFFFF0);
    /* Step list has been scheduled... Execute it */
    ExecuteStepList((LONG32 *) (iregs.NLP & 0xFFFFFFF0));
  setjmp(exception);
  retv[0] = NOERR;
  return((unsigned char *) retv);
unsigned char *WRITER1(char *appdata, unsigned char *o, unsigned char *d)
  iregs.RER = *((int *) d);
  if (iregs.RER & CAM_RESET_INTERFACE) {
    ResetInterface();
  if (iregs.RER & CAM_HALT_INTERFACE)
    iregs.NLP |= CAM_INTERFACE_HALTED;
  if (iregs.RER & CAM_ENABLE_TIMEOUT_EXC)
    iregs.NLP &= ~(CAM_EXCEPTION_STATUS);
  /*  This is supposed to also resume after error ack, whatever that is
  if (iregs.RER & CAM_ENABLE_CAMINT_EXC)
  */
  if (iregs.RER & CAM_ENABLE_NEWLIST_INT)
    iregs.ISR |= CAM_ENABLE_NEWLIST_INT;
  if (iregs.RER & CAM_ENABLE_TIMEOUT_INT)
    iregs.ISR |= CAM_ENABLE_TIMEOUT_INT;
  if (iregs.RER & CAM_ENABLE_SBUS_INT)
    iregs.ISR |= CAM_ENABLE_SBUS_INT;
  if (iregs.RER & CAM_ENABLE_CAM_INT)
    iregs.ISR |= CAM_ENABLE_CAM_INT;
  if (iregs.RER & CAM_ENABLE_SOFT_INT)
    iregs.ISR |= CAM_ENABLE_SOFT_INT;
  if (iregs.RER & CAM_DISABLE_NEWLIST_INT)
    iregs.ISR &= ~(CAM_ENABLE_NEWLIST_INT);
  if (iregs.RER & CAM_DISABLE_TIMEOUT_INT)
    iregs.ISR &= ~(CAM_ENABLE_TIMEOUT_INT);
  if (iregs.RER & CAM_DISABLE_SBUS_INT)
    iregs.ISR &= ~(CAM_ENABLE_SBUS_INT);
  if (iregs.RER & CAM_DISABLE_CAM_INT)
    iregs.ISR &= ~(CAM_ENABLE_CAM_INT);
  if (iregs.RER & CAM_ENABLE_SOFT_INT)
    iregs.ISR |= CAM_ENABLE_SOFT_INT;
  retv[0] = NOERR;
  return((unsigned char *) retv);
unsigned char *WRITER2(char *appdata, unsigned char *o, unsigned char *d)
  iregs.DSL = *((int *) d);
  retv[0] = NOERR;
  return((unsigned char *) retv);
unsigned char *WRITER3(char *appdata, unsigned char *o, unsigned char *d)
  iregs.DBL = *((int *) d);
  retv[0] = NOERR;
  return((unsigned char *) retv);
unsigned char *SIMFETCH(char *appdata, unsigned char *o, unsigned char *d)
  register int *a = *((int **) d);
  retv[0] = NOERR;
  retv[1] = *a;
  return((unsigned char *) retv);
void Generate_Interrupt(int type)
  iregs.ISR |= type;
  switch(type) {
  case CAM_CAM_INT_STATUS: {
    if ((iregs.RER & CAM_ENABLE_CAMINT_EXC) && !(iregs.RER & CAM_DISABLE_CAMINT_EXC)) {
      iregs.NLP |= CAM_EXCEPTION_STATUS;
      longjmp(exception, 1);
    }
    break;
  case CAM_TIMEOUT_INT_STATUS: {
    if ((iregs.RER & CAM_ENABLE_TIMEOUT_EXC) && !(iregs.RER & CAM_DISABLE_TIMEOUT_EXC)) {
      iregs.NLP |= CAM_EXCEPTION_STATUS;
      longjmp(exception, 1);
    }
    break;
unsigned char *QUIT(char *appdata, unsigned char *o, unsigned char *d)
  retv[0] = NOERR;
  qflag = -1;
  return((unsigned char *) retv);
void ExitHIFC()
  register int i;
  for(i = 0; i < 100; i++)
    if (shm[i].addr != NULL)
      shmdt(shm[i].addr);
#ifndef _H_INTERFACE_
#define _H_INTERFACE_
#include "global.h"
void InitInterface(void);
void ExitHIFC(void);
int ReadInterfaceRegs(void);
void Generate_Interrupt(int);
typedef struct interface_registers {
    
  LONG32 NLP;                          /* Next List Pointer            */
  LONG32 ISR;                          /* Reset/Interrupt Register     */
  LONG32 CIP;                          /* Current Instruction Pointer  */
  LONG32 PIP;                          /* Previous Instruction Pointer */
    
  LONG32 RER;                          /* Reset/Enable Register        */
  LONG32 DSL;                          /* Display Scan Length          */
  LONG32 DBL;                          /* Display Blank Length         */
} INTERFACE_REGS;
extern INTERFACE_REGS iregs;
extern int sim_infd, sim_outfd;
/* NLP/NLP */
#define CAM_INTERFACE_HALTED    0x00000008 /* Interface Halted?            */
#define CAM_WAIT_FOR_HOST       0x00000004 /* CAM waiting for host? status */
#define CAM_EXCEPTION_STATUS    0x00000002 /* Interface Exception status   */
#define CAM_NLP_WRITTEN         0x00000001 /* CAM NLP written? status      */
/* ISR/RER */
#define CAM_INT_PENDING_STATUS  0x0000001F /* Status of all Interrupt Bits */
#define CAM_NEWLIST_INT_STATUS  0x00000010 /* Status new-list interrupt    */
#define CAM_TIMEOUT_INT_STATUS  0x00000008 /* Status timeout interrupt     */
#define CAM_SBUS_INT_STATUS     0x00000004 /* Status Sbus interrupt        */
#define CAM_CAM_INT_STATUS      0x00000002 /* Status CAM interrupt         */
#define CAM_SOFT_INT_STATUS     0x00000001 /* Status interrupt             */
#define CAM_RESET_INTERFACE     0x80000000 /* Reset the interface          */
#define CAM_HALT_INTERFACE      0x00008000 /* Halt the interface           */
#define CAM_CLEAR_EXCEPTION     0x00004000 /* Clear exceptions (enable     */
					   /* exceptions caused by timeout)*/
#define CAM_ENABLE_TIMEOUT_EXC  0x00004000 /* enable exceptions caused     */
					   /* by timeout (clear exceptions)*/
#define CAM_RESUME_AFTER_ERR    0x00002000 /* Resume after error ack       */
					   /* (enable exceptions by CAM    */
					   /* interrupt)                   */
#define CAM_ENABLE_CAMINT_EXC   0x00002000 /* enable exceptions by CAM     */
					   /* interrupt (resume after      */
					   /* error ack)                   */
#define CAM_ENABLE_NEWLIST_INT  0x00001000 /* Enable new-list interrupt    */
#define CAM_ENABLE_TIMEOUT_INT  0x00000800 /* Enable timeout interrupt     */
#define CAM_ENABLE_SBUS_INT     0x00000400 /* Enable Sbus interrupt        */
#define CAM_ENABLE_CAM_INT      0x00000200 /* Enable CAM interrupt         */
#define CAM_ENABLE_SOFT_INT     0x00000100 /* Enable soft interrupt        */
#define CAM_DISABLE_TIMEOUT_EXC 0x00000040 /* Disable new-list interrupt   */
#define CAM_DISABLE_CAMINT_EXC  0x00000020 /* Disable timeout interrupt    */
#define CAM_DISABLE_NEWLIST_INT 0x00000010 /* Disable new-list interrupt   */
#define CAM_DISABLE_TIMEOUT_INT 0x00000008 /* Disable timeout interrupt    */
#define CAM_DISABLE_SBUS_INT    0x00000004 /* Disable Sbus interrupt       */
#define CAM_DISABLE_CAM_INT     0x00000002 /* Disable CAM interrupt        */
#define CAM_DISABLE_SOFT_INT    0x00000001 /* Disable soft interrupt       */
/* CIP/DSL */
#define CAM_TRANSFER_WAITING   0x00000008  /* Is CAM waiting to transfer?  */
#define CAM_DONE_STATUS        0x00000004  /* CAM Done status              */
#define CAM_PARTIAL_WRITE      0x00000002  /* Partial write after Sbus err?*/
#define CAM_FSM_SUSPENDED      0x00000001  /* Is Sbus FSM suspended?       */
/* PIP/DBL */
#define CAM_INTRFC_RESET_PNDNG 0x00000008  /* Interface reset pending?     */
#define CAM_SS2                0x00000004  /* CAM SS2 mode set?            */
#define CAM_SCANNING_STATUS    0x00000002  /* CAM scanning status          */
#define CAM_INTERRUPT_STATUS   0x00000001  /* CAM interrupt status         */
#define NOERR		0
#define FATAL		-1
#define BADSHMID	-2
#define TABLEFULL	-3
#endif
#ifndef _H_INTERFACE_P_
#define _H_INTERFACE_P_
unsigned char *SHMATTACH(char *, unsigned char *, unsigned char *);
unsigned char *SHMDETACH(char *, unsigned char *, unsigned char *);
unsigned char *READR0(char *, unsigned char *, unsigned char *);
unsigned char *READR1(char *, unsigned char *, unsigned char *);
unsigned char *READR2(char *, unsigned char *, unsigned char *);
unsigned char *READR3(char *, unsigned char *, unsigned char *);
unsigned char *WRITER0(char *, unsigned char *, unsigned char *);
unsigned char *WRITER1(char *, unsigned char *, unsigned char *);
unsigned char *WRITER2(char *, unsigned char *, unsigned char *);
unsigned char *WRITER3(char *, unsigned char *, unsigned char *);
unsigned char *SIMFETCH(char *, unsigned char *, unsigned char *);
unsigned char *QUIT(char *, unsigned char *, unsigned char *);
#endif
#include <stdio.h>
#include <signal.h>
#include "global.h"
#include "errmgr.h"
#include "executer.h"
#include "steplist.h"
#include "hinterface.h"
#define MODULE_NAME	"main"
void ReadCmdLine(int argc, char *argv[]);
void InitExitProcs();
#ifdef DEBUG
FILE *DEBUGFILE = (FILE *) NULL;
char *REGNAMES[] = {
  "select", "run", "kick", "sa-bit", "lut-src", "fly-src", "site-src", "event-src", "display", "show-scan", "event",
  "lut-index", "lut-perm", "lut-io", "scan-index", "scan-perm", "scan-io", "scan-format", "offset", "dimension",
  "environment", "multi", "connect", "module-id", "group-id", "int-enable", "int-flags", "verify", "dram-count"
  };
#endif
void main(int argc, char *argv[])
#ifdef DEBUG
  int i;
#endif
  InitExitProcs();
  InitHeap();
  InitInterface();
  InitStepList();
  ReadCmdLine(argc, argv);
     
#ifdef DEBUG
  DEBUGFILE = fopen("./sim.log", "w");
#endif
  while (ReadInterfaceRegs() > -1) {}
  exit(0);
     
     
void ReadCmdLine(int argc, char *argv[])
  register int i;
  for(i = 1; i < argc; i++) {
    if (strcmp(argv[i], "-g") == 0) {
      bForceGeneralScan = TRUE;
      continue;
    }
    if (strcmp(argv[i], "-in") == 0) {
      sim_infd = atoi(argv[i+1]);
      i++;
      continue;
    }
    if (strcmp(argv[i], "-out") == 0) {
      sim_outfd = atoi(argv[i+1]);
      i++;
      continue;
    }
    
void InitExitProcs()
     void ExitSigProc();
     void ExitProc();
#ifdef sun
     on_exit(ExitProc);
#endif
     
     if ( (signal(SIGHUP, ExitSigProc) == BADSIG) ||
	  (signal(SIGINT, SIG_IGN) == BADSIG) ||
	  (signal(SIGQUIT, SIG_IGN) == BADSIG) ||
	  (signal(SIGILL, ExitSigProc) == BADSIG) ||
	  (signal(SIGFPE, ExitSigProc) == BADSIG) ||
	  (signal(SIGBUS, ExitSigProc) == BADSIG) ||
	  (signal(SIGSEGV, ExitSigProc) == BADSIG) ||
	  (signal(SIGSYS, ExitSigProc) == BADSIG) ||
	  (signal(SIGPIPE, ExitSigProc) == BADSIG) ||
	  (signal(SIGTERM, ExitSigProc) == BADSIG) ) {
	  WARNING("Could not install cleanup routines!", "InitExitProc");
     }
void ExitSigProc(int sig, int code, struct sigcontext *scp, char *addr)
     static char *pcSignalName[] = {
	  "Unknown",
	  "Hangup",
	  "Interrupt",
	  "Quit",
	  "Illegal Instruction",
	  "Trace Trap",
	  "IO (Hardware) Trap",
	  "Emulator Trap",
	  "Floating Point Exception",
	  "Kill",
	  "Bus Error",
	  "Segmentation Fault",
	  "Bad Argument to system call",
	  "Write to broken pipe",
	  "Alarm",
	  "Software Termination",
	  "User1",
	  "User2",
	  "Child Termination",
	  "Power down"
       };
     fprintf(stderr, "CAM8SIM: ");
     
     switch (sig) {
	case SIGHUP:
	case SIGSYS:
	case SIGPIPE:
	  fprintf(stderr, "%s signal received - exiting.\n",
		  pcSignalName[sig]);
	  break;
	case SIGILL:
	case SIGFPE:
	  fprintf(stderr,
		  "Attempt to execute illegal instruction at %x\n",
		  addr);
	  break;
	case SIGBUS:
	case SIGSEGV:
	  fprintf(stderr,
		  "Attempt to access invalid memory location %x\n",
		  addr);
	  break;
	case SIGTERM:
	  fprintf(stderr,
		  "Termination signal received - exiting.\n");
	  break;
	default:
	  break;
     }
     ExitHIFC();
#ifdef DEBUG
     fclose(DEBUGFILE);
#endif
     _exit(0);
void ExitProc()
     ExitHIFC();
#ifdef DEBUG
     fclose(DEBUGFILE);
#endif
#include <stdio.h>
#include <fcntl.h>
#include <malloc.h>
#include <sys/types.h>
#include <sys/mman.h>
#include <sys/ipc.h>
#include <sys/shm.h>
#include "memmgr.h"
#include "memmgrP.h"
void *mmpMemAlign(unsigned nAlignment,
		  unsigned nSize,
		  char *szModule,
		  char *szFunction)
     void *pRet;
     char *memalign(unsigned, unsigned);
     
     if ( !(pRet = (void *) memalign(nAlignment, nSize)) ) {
	  fprintf(stderr,
		  "Error Allocating memory in %s : %s \n",
		  szModule, szFunction);
	  exit(2);
     }
     return (pRet);
void *mmpValloc(unsigned nSize, char *szModule, char *szFunction)
     void *pRet;
     char *valloc(unsigned size);
     if ( !(pRet = (void *) valloc(nSize)) ) {
	  fprintf(stderr,
		  "Error Allocating memory in %s : %s \n",
		  szModule, szFunction);
	  exit(2);
     }
     return (pRet);
void *mmpMalloc(unsigned nSize, char *szModule, char *szFunction)
     void *pRet;
     if ( !(pRet = malloc(nSize)) ) {
	  fprintf(stderr,
		  "Error Allocating memory in %s : %s \n",
		  szModule, szFunction);
	  exit(2);
     }
     return (pRet);
void *mmpRealloc(void *ptr, unsigned nSize, char *szModule, char *szFunction)
     void *pRet;
     if ( !(pRet = realloc(ptr, nSize)) ) {
	  fprintf(stderr,
		  "Error Reallocating memory in %s : %s \n",
		  szModule, szFunction);
	  exit(2);
     }
     return (pRet);
int mmpFree(void *ptr, char *szModule, char *szFunction)
     int ret;
     
     if (!(ret = free(ptr))) {
	  fprintf(stderr,
		  "Error Freeing memory in %s : %s \n",
		  szModule, szFunction);
	  exit(2);
     }
     return (ret);
int mmpCreateShared(unsigned len, char *szModule, char *szFunction)
     int shmid;
     if ((shmid = shmget(IPC_PRIVATE, len, 0666 | IPC_CREAT)) == -1) {
	  fprintf(stderr,
		  "Error creating shared memory segment in %s : %s \n",
		  szModule, szFunction);
	  exit(2);
     }
     return (shmid);
void *mmpAllocShared(int shmid, unsigned len,
		     char *szModule, char *szFunction)
     void *pRet;
     
     if ((pRet = (void *) shmat(shmid, 0, 0)) == (char *) -1) {
	  fprintf(stderr,
		  "Error mapping shared memory segment in %s : %s \n",
		  szModule, szFunction);
	  exit(2);
     }
     
     return (pRet);
void mmpFreeShared(void *addr,
		   char *szModule, char *szFunction)
     if (shmdt(addr) != 0) {
	  fprintf(stderr,
		  "Error un-mapping shared memory segment in %s : %s \n",
		  szModule, szFunction);
	  exit(2);
     }
     
void mmpDestroyShared(int shmid, char *szModule, char *szFunction)
     if (shmctl(shmid, IPC_RMID, NULL)) {
	  fprintf(stderr,
		  "Error deleting shared memory segment in %s : %s \n",
		  szModule, szFunction);
     }
/*****************************************************************************/
/*                                                                           */
/* Author 	: Milan Shah						     */
/* Program	: Cam8Sim						     */
/* Date		: February 6, 1992					     */
/* Module	: memmgr.h - memory manager interface with error reporting   */
/*                                                                           */
/*****************************************************************************/
#ifndef _MEMMGR_
#define _MEMMGR_
#include "memmgrP.h"
#define MEMALIGN(align, size, funcName) mmpMemAlign((align), (size), (MODULE_NAME), (funcName))
#define VALLOC(size, funcName)		mmpValloc((size), (MODULE_NAME), (funcName))
#define MALLOC(size, funcName)		mmpMalloc((size), (MODULE_NAME), (funcName))
#define REALLOC(ptr, size, funcName)	mmpRealloc((ptr), (size), (MODULE_NAME), (funcName))
#define FREE(ptr, funcName)		mmpFree((ptr), (MODULE_NAME), (funcName))
#define CREATE_SHARED(len, funcName)		mmpCreateShared((len), (MODULE_NAME), (funcName))
#define ALLOC_SHARED(shmid, len, funcName) 	mmpAllocShared((shmid), (len), (MODULE_NAME), (funcName))
#define FREE_SHARED(addr, funcName)		mmpFreeShared((addr), (MODULE_NAME), (funcName))
#define DESTROY_SHARED(shmid, funcName)		mmpDestroyShared((shmid), (MODULE_NAME), (funcName));
#endif
#ifndef _MEMMGR_P_
#define _MEMMGR_P_
void *mmpMemAlign(unsigned nAlignment, unsigned nSize,
		  char *szModule, char *szFunction);
void *mmpValloc(unsigned nSize, char *szModule, char *szFunction);
void *mmpMalloc(unsigned nSize, char *szModule, char *szFunction);
int  mmpFree(void *ptr, char *szModule, char *szFunction);
int  mmpCreateShared(unsigned len, char *szModule, char *szFunction);
void *mmpAllocShared(int shmid, unsigned len,
		     char *szModule, char *szFunction);
void mmpFreeShared(void *addr, char *szModule, char *szFunction);
void mmpDestroyShared(int shmid, char *szModule, char *szFunction);
#endif
#include <stdio.h>
#ifdef _INSTRUMENTATION_
#include <sys/time.h>
#endif
#include "global.h"
#include "memmgr.h"
#include "errmgr.h"
#include "utils.h"
#include "executer.h"
#include "steplist.h"
#include "steplistP.h"
#include "decode_steplist.h"
#include "hinterface.h"
#include <sys/types.h>
#include <sys/ipc.h>
#include <sys/shm.h>
#define MODULE_NAME "StepList"
void DoKick(short);
static int VWECHK = 0;
static LONG32 pbuf[CHIPS_PER_MOD];
#ifdef _INSTRUMENTATION_
struct timeval tvStart, tvEnd;
struct timezone tzZone;
LONG32 lRunCount = 0;
#endif
void vwecheck(INT16 *base, int reg_fld, int imm)
  register int i;
  int f = 0, o;
  SPEC s;
  s = GetSpec(reg_fld);
  if (VWECHK) {
    UnpackStateInto(base, reg_fld, imm, (BYTE *) pbuf, s.type);
    for (i = 0; i < CHIPS_PER_MOD; i++) {
      o = s.type * i;
      if (VWE[i]) {
	if (bcmp(s.base + o, ((BYTE *) pbuf) + o, s.type) != 0) {
	  f = 1;
	  VWIF[i] = 1;
      }
      else
	bcopy(((BYTE *) pbuf) + o, s.base + o, s.type);
    }
  else
    UnpackState(base, reg_fld, imm);
void ExecuteStepList(LONG32 *plFirstInstr)
  LONG32 *plCurr, *plNext;
  LONG32 lData, lLength;
  short nRegister, i, imm;
  BOOL bHostJump, bHostWait, bByteMode, bReadMode;
  BOOL bDone = FALSE;
  LONG32 pbuf[CHIPS_PER_MOD];
  bHostJump = bHostWait = FALSE;
#ifdef _INSTRUMENTATION_
  gettimeofday(&tvStart, &tzZone);
#endif
  for (plCurr = plFirstInstr; !bDone; plCurr = plNext) {
    bHostJump = (*plCurr & HOST_JUMP_MASK) != 0;
    bHostWait = (*plCurr & HOST_WAIT_MASK) != 0;
    bDone = bHostJump || bHostWait;
    bByteMode = (*plCurr & BYTE_MODE_MASK) != 0;
    bReadMode = (*plCurr & READ_CAM_MASK) != 0;
    
    iregs.PIP = iregs.CIP;
    iregs.CIP = (LONG32) plCurr;
    if (*plCurr & RESET_CAM_MASK) {
      memset ((char *) &CAM8State, 0, sizeof(CAM8State));
      LIOR = LUT1;
      LUT_ADDR = (LONG32) LUT0;
      bSourceRegChange = bDestChange = TRUE;
      
#ifdef DEBUG
      fprintf(DEBUGFILE, "CAM Reset\n");
      fflush(DEBUGFILE);
#endif
    }
    
    
    nRegister = *plCurr & REGISTER_ADDR_MASK;
    imm = (*plCurr & IMMEDIATE_DATA_MASK) != 0;
    lData = *(plCurr + 1);
    lLength = *(plCurr + 2);
    
    plNext = (LONG32 *) (*(plCurr + 3));
    
    if ((*plCurr & READ_CAM_MASK) && (*plCurr & IMMEDIATE_DATA_MASK)) {
#ifdef DEBUG
      fprintf(DEBUGFILE, "NOOP\n");
#endif
      continue;
    }
    
    
#ifdef DEBUG
    fprintf(DEBUGFILE, "REG = %d (%s), ", nRegister, REGNAMES[nRegister]);
    if (imm)
      fprintf(DEBUGFILE, "IMMEDIATE DATA, ");
    fprintf(DEBUGFILE, "BYTEMODE = %d, READMODE = %d\n", bByteMode, bReadMode);
    fflush(DEBUGFILE);
#endif
    
    if ((*plCurr & READ_CAM_MASK) != 0) {
      INT16 *pnBuffer;
      
      CAM8State.bReadMode = TRUE;
      bDestChange = TRUE;
      
      pnBuffer = (INT16 *) lData;
      
      ExecuteReadInstr(pnBuffer, *plCurr, lData, lLength);
      
      continue;
    }
    
    
    switch (nRegister) {
      
    case REG_MSR: {
      vwecheck((INT16 *) lData, REG_MSR, imm);
      
      break;
    }      
      
      
    case REG_RMR: {
      vwecheck((INT16 *) lData, FLD_SSM, imm);
      vwecheck((INT16 *) lData, FLD_RT, imm);
      vwecheck((INT16 *) lData, FLD_ECT, imm);
      vwecheck((INT16 *) lData, FLD_RPK, imm);
      vwecheck((INT16 *) lData, FLD_ALT, imm);
      
      for(i = 0; i < CHIPS_PER_MOD; i++) {
        if (ECT[i] == 1) {
          ECR[i] = EVENT_COUNT[i];
          EVENT_COUNT[i] = 0L;
        }
        if (RPK[i] == 1)
          DoKick(i);
      }
      
      if (ALT[0] == 1) {
        INT16 *pnTemp;
        
        pnTemp = LIOR;
        LIOR = (INT16 *) LUT_ADDR;
        LUT_ADDR = (LONG32) pnTemp;
        
        for (i = 0; i < CHIPS_PER_MOD; i++)
	  ALS[i] ^= 1;
      }
      
      if (CAM8State.bReadMode != FALSE) {
	bDestChange = TRUE;
	CAM8State.bReadMode = FALSE;
      }
      if (SSM[0] != 0) {
	CAM8State.WhyScan = REG_RMR;
#ifdef _INSTRUMENTATION_
        lRunCount++;
#endif                 
        ExecuteScan();
      }     
      
      break;
    }
      
      
    case REG_KR: {
      vwecheck((INT16 *) lData, FLD_KA, imm);
      vwecheck((INT16 *) lData, FLD_XKS, imm);
      vwecheck((INT16 *) lData, FLD_YKS, imm);
      vwecheck((INT16 *) lData, FLD_ZKS, imm);
      vwecheck((INT16 *) lData, FLD_XKMF, imm);
      vwecheck((INT16 *) lData, FLD_YKMF, imm);
      vwecheck((INT16 *) lData, FLD_ZKMF, imm);
      DoKick(-1);
      break;
    }
      
      
    case REG_SABSR:
    case REG_LASR:
    case REG_FOSR:
    case REG_SDSR:
    case REG_ECSR:
    case REG_DSR: {
      vwecheck((INT16 *) lData, FLD_SELECT(nRegister), imm);
      vwecheck((INT16 *) lData, FLD_MAP(nRegister), imm);
      bSourceRegChange = TRUE;
      break;
    }
      
    case REG_SSR: {
      vwecheck((INT16 *) lData, REG_SSR, imm);
      
      break;
    }
      
      
    case REG_ECR: {
      if (ECL[0] != lLength) {
	ConstantSetAll(RLIF, 1);
	Generate_Interrupt(CAM_CAM_INT_STATUS);
      }
      else {
	int i;
	UnpackBits((INT16 *) lData, 0, lLength, imm, (BYTE *) ECR, BIT32);
	for(i = 0; i < CHIPS_PER_MOD; i++)
	  EVENT_COUNT[i] = ECR[i];
      }
      break;
    }
      
      
    case REG_LIR: {
      vwecheck((INT16 *) lData, REG_LIR, imm);
      break;
    }
      
      
    case REG_LIPR: {
      vwecheck((INT16 *) lData, REG_LIPR, imm);
      
      break;
    }
      
      
    case REG_LIOR: {
      INT16 nLUTEntry, nLUTNextIndex;
      INT16 *pnLUT, *pnSource;
      int i, j;
      INT16 nImmediate[2];
      
      if (imm) {
        nImmediate[0] = (INT16) lData >> 16;
        nImmediate[1] = (INT16) lData & 0xFF;
        pnSource = &nImmediate[0];
      }
      
      else
        pnSource = (INT16 *) lData;
      
      for (i = 0; i < lLength; i++) {
        nLUTNextIndex = 0;
        for (j = CHIPS_PER_MOD - 1; j >= 0; j--) {
          nLUTNextIndex <<= 1;
          if (LIPR[j] < 16)
            nLUTNextIndex |= ((LIR[j] >> LIPR[j]) & 0x1);
          else if (LIPR[j] == 31)
            nLUTNextIndex |= 0x1;
	  LIR[j]++;
        }
        
        pnLUT = LIOR + nLUTNextIndex;                 
        
        if (imm) {
          *pnLUT = *pnSource;
          pnSource = &nImmediate[i % 2];
        } 
        
        else {
          *pnLUT = *pnSource;
          pnSource++;
        }
      }
      
      break;
    }
      
      
    case REG_SIR: {
      vwecheck((INT16 *) lData, REG_SIR, imm);
      
      SCAN_INDEX_REG = SIR[0];
      
      break;
    }
      
      
    case REG_SIPR: {
      int j;
      
      for(j = 0; j < SCAN_INDEX_LENGTH; j++)
        vwecheck((INT16 *) lData, FLD_SSA(j), imm);
      
      break;
    }
      
      
    case REG_SIOR: {
      if ((CAM8State.bByteMode != bByteMode) || 
          (CAM8State.bImmediate != imm)) {
        CAM8State.bByteMode = bByteMode;
        CAM8State.bImmediate = imm;
        bSourceRegChange = TRUE;
      }
      
      if (imm) {
        SIOR = (BYTE *) &lData;
	TBUS_DATA = lData;
      }
      else {
        SIOR = (BYTE *) lData;
	TBUS_ADDR = lData;
      }
      
      if (CAM8State.bReadMode != FALSE) {
        bDestChange = TRUE;
        CAM8State.bReadMode = FALSE;
      }
      
      CAM8State.WhyScan = REG_SIOR;
#ifdef _INSTRUMENTATION_
      lRunCount++;
#endif                 
      
      ExecuteScan();      
      break;
    }
      
      
    case REG_SFR: {
      
      vwecheck((INT16 *) lData, FLD_SM, imm);
      vwecheck((INT16 *) lData, FLD_ESC, imm);
      vwecheck((INT16 *) lData, FLD_ESW, imm);
      vwecheck((INT16 *) lData, FLD_EST, imm);
      vwecheck((INT16 *) lData, FLD_SBRC, imm);
      vwecheck((INT16 *) lData, FLD_RCL, imm);
      vwecheck((INT16 *) lData, FLD_ECL, imm);
      vwecheck((INT16 *) lData, FLD_STM, imm);
      break;
    }
      
      
    case REG_OSR: {
      vwecheck((INT16 *) lData, nRegister, imm);
       
      break;
    }
      
      
    case REG_DR: {
      
      vwecheck((INT16 *) lData, FLD_DCM, imm);
      vwecheck((INT16 *) lData, FLD_XDCP, imm);
      vwecheck((INT16 *) lData, FLD_YDCP, imm);
      vwecheck((INT16 *) lData, FLD_ZDCP, imm);
      UpdateDCMR();
      
      break;
    }
      
      
    case REG_HER: {
      vwecheck((INT16 *) lData, FLD_LPL, imm);
      vwecheck((INT16 *) lData, FLD_FPL, imm);
      vwecheck((INT16 *) lData, FLD_DCS, imm);
      vwecheck((INT16 *) lData, FLD_TBD, imm);
      vwecheck((INT16 *) lData, FLD_TMS, imm);
      vwecheck((INT16 *) lData, FLD_NBF, imm);
      vwecheck((INT16 *) lData, FLD_SRE, imm);
      vwecheck((INT16 *) lData, FLD_ALS, imm);
       
      if (ALS[0] == 1) {
        LIOR = (INT16*) LUT0;
        LUT_ADDR = (LONG32) LUT1;
      } 
      
      else {
        LIOR = (INT16 *) LUT1;
        LUT_ADDR = (LONG32) LUT0;
      }
      
      bSourceRegChange = TRUE;
      
      break;
    }
      
      
    case REG_MPCR: {
      vwecheck((INT16 *) lData, FLD_MAFS, imm);
      vwecheck((INT16 *) lData, FLD_MBFS, imm);
       
      break;
    }
      
      
    case REG_GPCR: {
      vwecheck((INT16 *) lData, FLD_XMPC, imm);
      vwecheck((INT16 *) lData, FLD_XPPC, imm);
      vwecheck((INT16 *) lData, FLD_YMPC, imm);
      vwecheck((INT16 *) lData, FLD_YPPC, imm);
      vwecheck((INT16 *) lData, FLD_ZMPC, imm);
      vwecheck((INT16 *) lData, FLD_ZPPC, imm);
      
      break;
    }
      
      
    case REG_MIDR: {
      vwecheck((INT16 *) lData, REG_MIDR, imm);
      
      break;
    }
      
      
    case REG_GIDR: {
      vwecheck((INT16 *) lData, REG_GIDR, imm);
      
      break;
    }
      
      
    case REG_IER: {
      vwecheck((INT16 *) lData, FLD_BPIE, imm);
      vwecheck((INT16 *) lData, FLD_BCIE, imm);
      vwecheck((INT16 *) lData, FLD_GCIE, imm);
      vwecheck((INT16 *) lData, FLD_MAIE, imm);
      vwecheck((INT16 *) lData, FLD_MBIE, imm);
      vwecheck((INT16 *) lData, FLD_SSIE, imm);
      vwecheck((INT16 *) lData, FLD_XHIE, imm);
      vwecheck((INT16 *) lData, FLD_RLIE, imm);
      vwecheck((INT16 *) lData, FLD_URIE, imm);
      vwecheck((INT16 *) lData, FLD_ISIE, imm);
      
      break;
    }
      
      
    case REG_IFR: {
      vwecheck((INT16 *) lData, FLD_BPIF, imm);
      vwecheck((INT16 *) lData, FLD_BCIF, imm);
      vwecheck((INT16 *) lData, FLD_GCIF, imm);
      vwecheck((INT16 *) lData, FLD_MAIF, imm);
      vwecheck((INT16 *) lData, FLD_MBIF, imm);
      vwecheck((INT16 *) lData, FLD_SSIF, imm);
      vwecheck((INT16 *) lData, FLD_XHIF, imm);
      vwecheck((INT16 *) lData, FLD_RLIF, imm);
      vwecheck((INT16 *) lData, FLD_URIF, imm);
      vwecheck((INT16 *) lData, FLD_ISIF, imm);
      
      break;
    }
      
      
    case REG_VWR: {
      register int i;
      UnpackState((INT16 *) lData, FLD_VWE, imm);
      UnpackState((INT16 *) lData, FLD_VWIE, imm);
      UnpackState((INT16 *) lData, FLD_VWIF, imm);
      VWECHK = 0;
      for (i = 0; i < CHIPS_PER_MOD; i++)
	if (VWE[i] == 1)
	  VWECHK = 1;
      
      break;
    }
      
      
    case REG_DOCR: {
      vwecheck((INT16 *) lData, FLD_LDOC, imm);
      vwecheck((INT16 *) lData, FLD_HDOC, imm);
      
      break;
    }
      
      
    default: {
      
      fprintf(stderr, "Don't recognize register %d\n", nRegister);
      break;
    }
    }
    
    iregs.PIP = (LONG32) plCurr;
#ifdef _INSTRUMENTATION_
    if (lRunCount != 0) {
      gettimeofday(&tvEnd, &tzZone);
      
      fprintf(stderr, "Performed %d scans in %d usecs\n", lRunCount,
              (tvEnd.tv_sec - tvStart.tv_sec) * 1000000 +
              (tvEnd.tv_usec - tvStart.tv_usec));
      lRunCount = 0;
    }
#endif
  }  /* for(plCurr = plFirstInstr; !bDone; plCurr = plNext) */
  iregs.ISR |= CAM_NEWLIST_INT_STATUS;
void DoKick(short p)
  register int i, j;
  LONG32 lSignBitOffset, lSignBitKick, lLowBitsKick;
  LONG32 lDCM;
  LONG32 lKA;
  /************************************************************************/
  /* The kick and offset registers are two n-dimension-vectors, and the   */
  /* place where all dimensions end is determined by lDCMR. To subtract   */
  /* an n-dimension-kick from the corresponding offset, we first extract  */
  /* out the sign bits of both (by and-ing with lDCMR). Next, we set the  */
  /* most sig bits of every dimension in offset to 1, so that when we     */
  /* subtract out the kick, we don't borrow from the next higher          */
  /* dimension. Next, we subtract the value bits of kick (lowbits) from   */
  /* this offset. This will give the 'sign' bit of the new offset and its */
  /* value. The final sign bit of the offset is determined by :           */
  /*                                                                      */
  /*     sign bit = new sign bit xor (old sign bit xnor kick sign bit)    */
  /*                                                                      */
  /* To do the xnor operation, we simply store the inverse of the kick    */
  /* sign bit and then do an xor                                          */
  /*                                                                      */
  /* One easy way to derive this is to think of a sample dimension with   */
  /* 4 bits. Then, the bit positions have values  -8  4  2  1. The        */
  /* subtract operation as described above becomes (8 + 4*o.2 + 2*o.1 +   */
  /* 1*o.0 - 4*k.2 - 2*k.1 - 1*k.0) - 8 - 8*o.sign + 8.k.sign             */
  /* where o.X means the X'th bit of offset and k.X means the X'th bit of */
  /* kick. Since the final offset is of the form -8*o.sign + 4*o.2 +      */
  /* 2*o.1 + 1*o.o, we can express the sign bit as the above logical      */
  /* function of the three individual sign bits.                          */
  /*                                                                      */
  /************************************************************************/
  if (p == -1) {
    p = 0;
    j = CHIPS_PER_MOD;
  else
    j = p + 1;
  for(i = p; i < j; i++) {
    lSignBitOffset = OSR[i] & DCM[i];
    lSignBitKick = (~KA[i]) & DCM[i];
    OSR[i] |= DCM[i];
    
    lLowBitsKick =  KA[i] & (~ DCM[i]);
    OSR[i] -= lLowBitsKick;
    lSignBitOffset = lSignBitOffset ^ lSignBitKick;
    
    OSR[i] ^= lSignBitOffset;
#ifndef _STEP_LIST_
#define _STEP_LIST_
void InitStepList(void);
void ReadStepList(char *szStepFileName);
void ExecuteStepList(LONG32 *plFirstInstr);
#endif
#ifndef _STEP_LIST_P_
#define _STEP_LIST_P_
void ExecuteReadInstr(INT16 *pnBuffer, LONG32 lInstr, LONG32 lData, LONG32 lLength);
#define RESET_CAM_MASK		0x80000000					 /* These are bits of the control or */
#define READ_CAM_MASK		0x40000000					 /* first long word of every step    */
#define IMMEDIATE_DATA_MASK	0x20000000					 /* instruction 		     */
#define BYTE_MODE_MASK		0x10000000
#define HOST_JUMP_MASK		0x00008000
#define HOST_WAIT_MASK		0x00004000
#define SOFT_INT_MASK		0x00002000
#define WAIT_EOS_MASK		0x00001000
#define REGISTER_ADDR_MASK	0x0000003F
#define ACTIVE_LUT_SELECT	0x8000						 /* bit in Hardware Env Reg (HER)    */
#define REG_MSR			0
#define REG_RMR			1
#define REG_KR			2
#define REG_SABSR		3
#define REG_LASR		4
#define REG_FOSR		5
#define REG_SDSR		6
#define REG_ECSR		7
#define REG_DSR			8
#define REG_SSR			9
#define REG_ECR			10
#define REG_LIR			11
#define REG_LIPR		12
#define REG_LIOR		13
#define REG_SIR			14
#define REG_SIPR		15
#define REG_SIOR		16
#define REG_SFR			17
#define REG_OSR			18
#define REG_DR			19
#define REG_HER			20
#define REG_MPCR		21
#define REG_GPCR		22
#define REG_MIDR		23
#define REG_GIDR		24
#define REG_IER			25
#define REG_IFR			26
#define REG_VWR			27
#define REG_DOCR		28
#endif
#include <stdio.h>
#include "global.h"
#include "errmgr.h"
#include "utils.h"
#include "executer.h"
#include "steplist.h"
#include "steplistP.h"
#include "decode_steplist.h"
#include "hinterface.h"
#define MODULE_NAME "StepListR"
void ExecuteReadInstr(INT16 *pnBuffer, LONG32 lInstr, LONG32 lData,
		      LONG32 lLength)
  BOOL bByteMode;
  short nRegister, i, imm;
  LONG32 pbuf[CHIPS_PER_MOD];
  bByteMode = (lInstr & BYTE_MODE_MASK) != 0;
  nRegister = lInstr & REGISTER_ADDR_MASK;
  imm = (lInstr & IMMEDIATE_DATA_MASK) != 0;
  switch (nRegister) {
    
  case REG_MSR: {
    PackState(pnBuffer, REG_MSR);
    
    break;
  }      
    
    
  case REG_RMR: {
    PackState(pnBuffer, FLD_SSM);
    PackState(pnBuffer, FLD_RT);
    PackState(pnBuffer, FLD_ECT);
    PackState(pnBuffer, FLD_RPK);
    PackState(pnBuffer, FLD_ALT);
    break;
    
    
  case REG_KR: {
    PackState(pnBuffer, FLD_KA);
    PackState(pnBuffer, FLD_XKS);
    PackState(pnBuffer, FLD_YKS);
    PackState(pnBuffer, FLD_ZKS);
    PackState(pnBuffer, FLD_XKMF);
    PackState(pnBuffer, FLD_YKMF);
    PackState(pnBuffer, FLD_ZKMF);
    
    break;
    
    
  case REG_SABSR: {
    PackState(pnBuffer, REG_SABSR);
    
    break;
    
    
  case REG_LASR:
  case REG_FOSR:
  case REG_SDSR:
  case REG_ECSR:
  case REG_DSR: {
    PackState(pnBuffer, FLD_SELECT(nRegister));
    PackState(pnBuffer, FLD_MAP(nRegister));    
    
    break;
    
    
  case REG_SSR: {
    *pnBuffer = 0xFFFF;
    
    break;
    
    
  case REG_ECR: {
    int diff;
    if ((diff = ECL[0] - lLength) != 0){
      ConstantSetAll(RLIF, 1);
      if (diff < 0)
	Generate_Interrupt(CAM_CAM_INT_STATUS);
      else
	Generate_Interrupt(CAM_TIMEOUT_INT_STATUS);
    }
    
    else
      PackBits(pnBuffer, 0, lLength, (BYTE *) ECR, BIT32);
    
    break;
    
    
  case REG_LIR: {
    PackState(pnBuffer, REG_LIR);
    
    break;
    
    
  case REG_LIPR: {
    PackState(pnBuffer, REG_LIPR);
    
    break;
    
    
  case REG_LIOR: {
    INT16 nLUTEntry, nLUTNextIndex;
    INT16 *pnLUT;
    int i, j;
    INT16 nImmediate[2];
    
    
    for (i = 0; i < lLength; i++) {
      nLUTNextIndex = 0;
      
      for (j = CHIPS_PER_MOD - 1; j >= 0; j--) {
	nLUTNextIndex <<= 1;
	if (LIPR[j] < 16)
	  nLUTNextIndex |= ((LIR[j] >> LIPR[j]) & 0x1);
	else if (LIPR[j] == 31)
	  nLUTNextIndex |= 0x1;
	LIR[j]++;
      }
      
      pnLUT = LIOR + nLUTNextIndex;                 
      
      *pnBuffer = *pnLUT;
      pnBuffer++;
    }
    
    break;
    
    
  case REG_SIR: {
    PackState(pnBuffer, REG_SIR);
    
    break;
    
    
  case REG_SIPR: {
    int j;
    
    for(j = 0; j < SCAN_INDEX_LENGTH; j++)
      PackState(pnBuffer, FLD_SSA(j));
    
    break;
    
    
  case REG_SIOR: {
    CAM8State.bByteMode = bByteMode;
    SIOR = (BYTE *) pnBuffer;
    
    if (CAM8State.bReadMode != TRUE) {
      bDestChange = TRUE;
      CAM8State.bReadMode = TRUE;
    }
    
    CAM8State.WhyScan = REG_SIOR;
    ExecuteScan();
    
    break;
    
    
  case REG_SFR: {
    PackState(pnBuffer, FLD_SM);
    PackState(pnBuffer, FLD_ESC);
    PackState(pnBuffer, FLD_ESW);
    PackState(pnBuffer, FLD_EST);
    PackState(pnBuffer, FLD_SBRC);
    PackState(pnBuffer, FLD_RCL);
    PackState(pnBuffer, FLD_ECL);
    PackState(pnBuffer, FLD_STM);
    
    break;
    
    
  case REG_OSR: {
    PackState(pnBuffer, REG_OSR);
    
    break;
    
    
  case REG_DR: {
    PackState(pnBuffer, FLD_DCM);
    PackState(pnBuffer, FLD_XDCP);
    PackState(pnBuffer, FLD_YDCP);
    PackState(pnBuffer, FLD_ZDCP);
    
    break;
    
    
  case REG_HER: {
    PackState(pnBuffer, FLD_LPL);
    PackState(pnBuffer, FLD_FPL);
    PackState(pnBuffer, FLD_DCS);
    PackState(pnBuffer, FLD_TBD);
    PackState(pnBuffer, FLD_TMS);
    PackState(pnBuffer, FLD_NBF);
    PackState(pnBuffer, FLD_SRE);
    PackState(pnBuffer, FLD_ALS);
    
    break;
    
    
  case REG_MPCR: {
    PackState(pnBuffer, FLD_MAFS);
    PackState(pnBuffer, FLD_MBFS);
    
    break;
    
    
  case REG_GPCR: {
    PackState(pnBuffer, FLD_XMPC);
    PackState(pnBuffer, FLD_XPPC);
    PackState(pnBuffer, FLD_YMPC);
    PackState(pnBuffer, FLD_YPPC);
    PackState(pnBuffer, FLD_ZMPC);
    PackState(pnBuffer, FLD_ZPPC);
    
    break;
    
    
  case REG_MIDR: {
    PackState(pnBuffer, REG_MIDR);
    
    break;
    
    
  case REG_GIDR: {
    PackState(pnBuffer, REG_GIDR);
    
    break;
    
    
  case REG_IER: {
    PackState(pnBuffer, FLD_BPIE);
    PackState(pnBuffer, FLD_BCIE);
    PackState(pnBuffer, FLD_GCIE);
    PackState(pnBuffer, FLD_MAIE);
    PackState(pnBuffer, FLD_MBIE);
    PackState(pnBuffer, FLD_SSIE);
    PackState(pnBuffer, FLD_XHIE);
    PackState(pnBuffer, FLD_RLIE);
    PackState(pnBuffer, FLD_URIE);
    PackState(pnBuffer, FLD_ISIE);
    
    break;
    
    
  case REG_IFR: {
    PackState(pnBuffer, FLD_BPIF);
    PackState(pnBuffer, FLD_BCIF);
    PackState(pnBuffer, FLD_GCIF);
    PackState(pnBuffer, FLD_MAIF);
    PackState(pnBuffer, FLD_MBIF);
    PackState(pnBuffer, FLD_SSIF);
    PackState(pnBuffer, FLD_XHIF);
    PackState(pnBuffer, FLD_RLIF);
    PackState(pnBuffer, FLD_URIF);
    PackState(pnBuffer, FLD_ISIF);
    
    break;
    
    
  case REG_VWR: {
    PackState(pnBuffer, FLD_VWE);
    PackState(pnBuffer, FLD_VWIE);
    PackState(pnBuffer, FLD_VWIF);
    
    break;
    
    
  case REG_DOCR: {
    PackState(pnBuffer, FLD_LDOC);
    PackState(pnBuffer, FLD_HDOC);
    
    break;
    
    
  default: {
    
    fprintf(stderr, "Don't recognize register %d\n", nRegister);
    break;
#include <stdio.h>
#include <sys/types.h>      /* defs of things like caddr_t */
#include <fcntl.h>
#include <camio.h>
main()
  int f;
  f = open("/dev/cam0", O_RDWR, 0);
  while(-1) {}
#include "global.h"
#include "errmgr.h"
#include "utils.h"
#define MODULE_NAME     "utils"
LONG32 lDCMRHighBit;
LONG32 lDCMRLowBit;
LONG32 lNumXBits;
/*****************************************************************************/
/*                                                                           */
/* This routine adds two longs breaking the carries at positions indicated   */
/* by the Dimension Cut Mask Register (DCMR). The DCMR has a 1 bit at every  */
/* bit position where the carry needs to be cut.                             */
/*                                                                           */
/*****************************************************************************/
LONG32 AddSiteAddress(LONG32 lSrc1, LONG32 lSrc2)
  LONG32 lHighBits1, lHighBits2;
  lHighBits1 = lSrc1 & DCM[0];
  lHighBits2 = lSrc2 & DCM[0];
  lSrc1 &= (~DCM[0]);
  lSrc2 &= (~DCM[0]);
  return( (lSrc1 + lSrc2) ^ lHighBits1 ^ lHighBits2 );
LONG32 SubSiteAddress(LONG32 lSrc1, LONG32 lSrc2)
  LONG32 lSignBitOffset, lSignBitKick, lLowBitsKick;
  lSignBitOffset = lSrc1 & DCM[0];
  lSignBitKick = (~lSrc2) & DCM[0];
  lSrc1 |= DCM[0];
  lLowBitsKick = lSrc2 & (~ DCM[0]);
  lSrc1 -= lLowBitsKick;
  lSignBitOffset = lSignBitOffset ^ lSignBitKick;
  lSrc1 ^= lSignBitOffset;
/*****************************************************************************/
/*                                                                           */
/* Compute the Scan length - the number of sites that will be updated in     */
/* the current scan. Basically, it should be 2^ESCP, but we need to correct  */
/* for the fact that the SIR low-order bits might not be all zero            */
/*                                                                           */
/*****************************************************************************/
LONG32 ScanLength()
  LONG32 lCarryOVFBit, lScanLength, lSIRBits;
  lCarryOVFBit = ESC[0];
  lScanLength = (1 << lCarryOVFBit);                                  
  lSIRBits = SIR[0] & (lScanLength - 1);
  lScanLength -= lSIRBits;
  return (lScanLength);
/*****************************************************************************/
/*                                                                           */
/* Determine the sweep length. The sweep length is given by either the low   */
/* bit of the DCMR or the ESCP (End-of-Scan-pointer) or the SFR register.    */
/* This is because the scan could update many lines of the lowest (X) dimen- */
/* sion, or could update just part of 1 line in the X dimension.             */
/*                                                                           */
/*****************************************************************************/
LONG32 SweepLength(LONG32 *lFirstSweep)
  LONG32 lCarryOVFBit, lSweepLength;
  lCarryOVFBit = MIN(ESW[0], lNumXBits);
  lSweepLength = (1 << lCarryOVFBit);
  *lFirstSweep = (SIR[0] & (lSweepLength - 1));
  *lFirstSweep = lSweepLength - *lFirstSweep;
  return (lSweepLength);
/*****************************************************************************/
/*                                                                           */
/* DCMRHighBit returns a long with exactly one of the 32 bits set to 1. This */
/* bit position corresponds to the highest bit in the DCMR that has a 1.     */
/*                                                                           */
/*****************************************************************************/
static LONG32 DCMRHighBit()
  LONG32 lTemp1, lTemp2;                                                      
  lTemp1 = DCM[0];
  if (lTemp1) {
    lTemp2 = 1;
    while (lTemp1 > 1) {
      lTemp1 >>= 1;
      lTemp2 <<= 1;
    }
  else
    lTemp2 = 0;
  return (lTemp2);
/*****************************************************************************/
/*                                                                           */
/* DCMRLowBit returns a long with exactly one of the 32 bits set to 1. This  */
/* bit position corresponds to the lowest bit in the DCMR that has a 1. We   */
/* refer to this lowest dimension generically as the X dimension.            */
/*                                                                           */
/*****************************************************************************/
static LONG32 DCMRLowBit()
  LONG32 lTemp1, lTemp2;
  lTemp1 = DCM[0];
  if (lTemp1) {
    lTemp2 = 1;
    lNumXBits = 1;
    while ((lTemp1 & 0x01) == 0) {
      lTemp1 >>= 1;
      lTemp2 <<= 1;
      lNumXBits++;
    }
  else
    lTemp2 = 0;
  return (lTemp2);
void UpdateDCMR()
  lDCMRHighBit = DCMRHighBit();
  lDCMRLowBit = DCMRLowBit();
/*****************************************************************************/
/*                                                                           */
/* The following are general purpose routines that conveniently answer       */
/* queries about the sources and destinations that need to be updated        */
/*                                                                           */
/*****************************************************************************/
BOOL bDestSrcMatrix [CHIPS_PER_MOD][NUM_DEST][NUM_SRC];
/*****************************************************************************/
/*                                                                           */
/* Is a particular source needed? Only checks those planes that will be      */
/* updated or used during the next scan.                                     */
/*                                                                           */
/*****************************************************************************/
BOOL IsSrcNeeded(short nSrc, short nNumPlanes)
  short i, j;
  short nLastDest;
  nLastDest = (nSrc == SRC_TBUS ? DEST_LUT : DEST_DISPLAY);
  for (i = nNumPlanes - 1; i >= 0; i--) {
    for (j = DEST_SITE_DATA; j <= nLastDest; j++) {
      if (bDestSrcMatrix[i][j][nSrc]) {
	return TRUE;
      }
    }
  return FALSE;
/*****************************************************************************/
/*                                                                           */
/* Checks to see if the source/map is the same for all planes for the given  */
/* destination.                                                              */
/*                                                                           */
/*****************************************************************************/
BOOL IsSrcSame(short nDest, short nNumPlanes)
  short i;
  BYTE *src, *map;
  switch (nDest) {
  case DEST_SITE_DATA:
    src = SDS;
    map = SDM;
    break;
  case DEST_EVENT_CT:
    src = ECS;
    map = ECM;
    break;
  case DEST_DISPLAY:
    src = DDS;
    map = DDM;
    break;
  case DEST_LUT:
    src = LAS;
    map = LAM;
    break;
  default:
    return FALSE;
    break;
  for(i = 1; i < nNumPlanes; i++)
    if ((src[0] != src[i]) || (map[0] != map[i]))
      return FALSE;
  return TRUE;
/*****************************************************************************/
/*                                                                           */
/* See if a particular destination will be changed during the current scan   */
/*                                                                           */
/*****************************************************************************/
BOOL IsDestUpdated(short nDest, short nNumPlanes)
  short i, j;
  for (i = nNumPlanes-1; i >= 0; i--)
    for ( j = SRC_SITE_DATA; j <= SRC_GLUED_DATA; j++)
      if (bDestSrcMatrix[i][nDest][j])
	return(TRUE);
  return(FALSE);
/*****************************************************************************/
/*                                                                           */
/* Calculate the number of planes that will be updated or used in the next   */
/* scan.                                                                     */
/*                                                                           */
/*****************************************************************************/
unsigned short CalcNumPlanes()
  BOOL       bPlaneUsed[CHIPS_PER_MOD];
  short      i, j;
  memset ((char *) bPlaneUsed, 0, CHIPS_PER_MOD * sizeof(BOOL));
  UpdateDestSrcMatrix();
  for (i = CHIPS_PER_MOD-1; i >= 0; i--) {
    for (j = DEST_SITE_DATA; j <= DEST_DISPLAY; j++) {
      if (bDestSrcMatrix [i] [j] [SRC_SITE_DATA]) {
	bPlaneUsed[i] = TRUE;
      }
    }
    
    if (!bPlaneUsed[i]) {
      for (j = SRC_TBUS; j <= SRC_GLUED_DATA; j++) {
	if (bDestSrcMatrix [i] [DEST_SITE_DATA] [j]) {
	  bPlaneUsed[i] = TRUE;
      }
    }
    if (bPlaneUsed[i])
      break;
  }  
  return ((unsigned short) i + 1);
/*****************************************************************************/
/*                                                                           */
/* Updates a matrix of sources and destinations. There are 5 sources, 4 dest */
/* and 16 planes. In addition, there is a bit per destination indicating     */
/* whether the map field selects an inverse function or just the function.   */
/* Thus, the SrcDestMatrix is a 6x4x16 matrix.                               */
/*                                                                           */
/*****************************************************************************/
void UpdateDestSrcMatrix()
  short      i;
  char       *szFuncName = "UpdateDestSrcMatrix";    
  memset((char *) bDestSrcMatrix, 0, CHIPS_PER_MOD*NUM_SRC*NUM_DEST);
  for (i = 0; i < CHIPS_PER_MOD; i++) {
    
    if (SDS[i] != SRC_SITE_DATA)
      bDestSrcMatrix[i][DEST_SITE_DATA][SDS[i]] = TRUE;
    if ((SDM[i] != MAP_S) && (SDM[i] != MAP_S_BAR) &&
	(SDM[i] != MAP_CONST_0) && (SDM[i] != MAP_CONST_1))
      bDestSrcMatrix[i][DEST_SITE_DATA][SRC_GLUED_DATA] = TRUE;
    if ((ECM[i] != MAP_CONST_0))
      bDestSrcMatrix[i][DEST_EVENT_CT][ECS[i]] = TRUE;
    if ((ECM[i] != MAP_S) && (ECM[i] != MAP_S_BAR) &&
	(ECM[i] != MAP_CONST_0) && (ECM[i] != MAP_CONST_1))
      bDestSrcMatrix[i][DEST_EVENT_CT][SRC_GLUED_DATA] = TRUE;
    if ((DDS[i] != SRC_TBUS))
      bDestSrcMatrix[i][DEST_DISPLAY][DDS[i]] = TRUE;
    if ((DDM[i] != MAP_S) && (DDM[i] != MAP_S_BAR) &&
	(DDM[i] != MAP_CONST_0) && (DDM[i] != MAP_CONST_1))
      bDestSrcMatrix[i][DEST_DISPLAY][SRC_GLUED_DATA] = TRUE;
    bDestSrcMatrix[i][DEST_LUT][LAS[i]] = TRUE;
    if ((LAM[i] != MAP_S) && (LAM[i] != MAP_S_BAR) &&
	(LAM[i] != MAP_CONST_0) && (LAM[i] != MAP_CONST_1))
      bDestSrcMatrix[i][DEST_LUT][SRC_GLUED_DATA] = TRUE;
/*****************************************************************************/
/*                                                                           */
/* Author	: Milan Shah						     */
/* Program	: Cam8Sim						     */
/* Date		: February 28, 1992					     */
/* Module	: utils.h - general purpose utilities to query cam8 state    */
/*                                                                           */
/*****************************************************************************/
#ifndef _UTILS_
#define _UTILS_
#include "global.h"
extern LONG32 lDCMRHighBit;
extern LONG32 lDCMRLowBit;
extern LONG32 lNumXBits;
#ifndef MIN
#define MIN(x, y) 	((x) < (y) ? (x) : (y))
#endif
LONG32 AddSiteAddress(LONG32 lSrc1, LONG32 lSrc2);
LONG32 SubSiteAddress(LONG32 lSrc1, LONG32 lSrc2);
LONG32 ScanLength(void);
LONG32 SweepLength(LONG32 *lFirstSweep);
void UpdateDCMR(void);
BOOL IsSrcNeeded(short nSrc, short nNumPlanes);
BOOL IsSrcSame(short nDest, short nNumPlanes);
BOOL IsDestUpdated(short nDest, short nNumPlanes);
unsigned short CalcNumPlanes(void);
void  UpdateDestSrcMatrix(void);
#define NUM_DEST	4
#define NUM_SRC		5
extern BOOL bDestSrcMatrix [CHIPS_PER_MOD][NUM_DEST][NUM_SRC];
#define SRC_SITE_DATA			0
#define SRC_TBUS			1
#define SRC_FLYWHEEL			2
#define SRC_LUT				3
#define SRC_SITE_ADDRESS		3
#define SRC_GLUED_DATA			4
#define DEST_SITE_DATA			0
#define DEST_EVENT_CT			1
#define DEST_LUT			2
#define DEST_DISPLAY			3
#define MAP_CONST_0			0
#define MAP_G_NOR_S			1
#define MAP_G_AND_S_BAR			2
#define MAP_S_BAR			3
#define MAP_G_BAR_AND_S			4
#define MAP_G_BAR			5
#define MAP_G_XOR_S			6
#define MAP_G_NAND_S			7
#define MAP_G_AND_S			8
#define MAP_G_EQ_S			9
#define MAP_G				10
#define MAP_G_OR_S_BAR			11
#define MAP_S				12
#define MAP_G_BAR_OR_S			13
#define MAP_G_OR_S			14
#define MAP_CONST_1			15
#endif

---------------------------------------------------------------------------

/*****************************************************************************/
/*                                                                           */
/* decode_steplists.c:	modifications to original code made by		     */
/*			Harris L. Gilliam March 1994 - June 1995	     */
/*                                                                           */
/*****************************************************************************/
/*                                                                           */
/*  Added routines to unpack/pack CAM8 state information out off/into        */
/*  steplists:                                                               */
/*              UnpackState, PackState                                       */
/*                                                                           */
/*****************************************************************************/
#include <stdio.h>
#include <CAM/CAM.h>
#include <CAM/CAM_init.h>
#include <CAM/CAM_instr.h>
#include <CAM/CAM_util.h>
#include "global.h"
#include "errmgr.h"
#include "decode_steplist.h"
#define MODULE_NAME "DecodeSteplist"
#define SENTER(i,b,t) base_type[i].base = (char *)(b); base_type[i].type = t
Bt base_type[790];
void InitStepList()
  SENTER(RFINDEX(REG_MSR), MSR, BIT8);
  SENTER(RFINDEX(FLD_SSM), SSM, BIT8);
  SENTER(RFINDEX(FLD_RT), RT, BIT8);
  SENTER(RFINDEX(FLD_ECT), ECT, BIT8);
  SENTER(RFINDEX(FLD_RPK), RPK, BIT8);
  SENTER(RFINDEX(FLD_ALT), ALT, BIT8);
  SENTER(RFINDEX(FLD_KA), KA, BIT32);
  SENTER(RFINDEX(FLD_XKS), XKS, BIT8);
  SENTER(RFINDEX(FLD_YKS), YKS, BIT8);
  SENTER(RFINDEX(FLD_ZKS), ZKS, BIT8);
  SENTER(RFINDEX(FLD_XKMF), XKMF, BIT8);
  SENTER(RFINDEX(FLD_YKMF), YKMF, BIT8);
  SENTER(RFINDEX(FLD_ZKMF), ZKMF, BIT8);
  SENTER(RFINDEX(REG_SABSR), SABSR, BIT8);
  SENTER(RFINDEX(FLD_LAS), LAS, BIT8);
  SENTER(RFINDEX(FLD_LAM), LAM, BIT8);
  SENTER(RFINDEX(FLD_FOS), FOS, BIT8);
  SENTER(RFINDEX(FLD_FOM), FOM, BIT8);
  SENTER(RFINDEX(FLD_SDS), SDS, BIT8);
  SENTER(RFINDEX(FLD_SDM), SDM, BIT8);
  SENTER(RFINDEX(FLD_ECS), ECS, BIT8);
  SENTER(RFINDEX(FLD_ECM), ECM, BIT8);
  SENTER(RFINDEX(FLD_DDS), DDS, BIT8);
  SENTER(RFINDEX(FLD_DDM), DDM, BIT8);
  SENTER(RFINDEX(REG_SSR), SSR, BIT8);
  SENTER(RFINDEX(REG_ECR), ECR, BIT32);
  SENTER(RFINDEX(REG_LIR), LIR, BIT8);
  SENTER(RFINDEX(REG_LIPR), LIPR, BIT8);
  SENTER(RFINDEX(REG_SIR), SIR, BIT32);
  SENTER(RFINDEX(FLD_SSA0), SSA0, BIT8);
  SENTER(RFINDEX(FLD_SSA1), SSA1, BIT8);
  SENTER(RFINDEX(FLD_SSA2), SSA2, BIT8);
  SENTER(RFINDEX(FLD_SSA3), SSA3, BIT8);
  SENTER(RFINDEX(FLD_SSA4), SSA4, BIT8);
  SENTER(RFINDEX(FLD_SSA5), SSA5, BIT8);
  SENTER(RFINDEX(FLD_SSA6), SSA6, BIT8);
  SENTER(RFINDEX(FLD_SSA7), SSA7, BIT8);
  SENTER(RFINDEX(FLD_SSA8), SSA8, BIT8);
  SENTER(RFINDEX(FLD_SSA9), SSA9, BIT8);
  SENTER(RFINDEX(FLD_SSA10), SSA10, BIT8);
  SENTER(RFINDEX(FLD_SSA11), SSA11, BIT8);
  SENTER(RFINDEX(FLD_SSA12), SSA12, BIT8);
  SENTER(RFINDEX(FLD_SSA13), SSA13, BIT8);
  SENTER(RFINDEX(FLD_SSA14), SSA14, BIT8);
  SENTER(RFINDEX(FLD_SSA15), SSA15, BIT8);
  SENTER(RFINDEX(FLD_SSA16), SSA16, BIT8);
  SENTER(RFINDEX(FLD_SSA17), SSA17, BIT8);
  SENTER(RFINDEX(FLD_SSA18), SSA18, BIT8);
  SENTER(RFINDEX(FLD_SSA19), SSA19, BIT8);
  SENTER(RFINDEX(FLD_SSA20), SSA20, BIT8);
  SENTER(RFINDEX(FLD_SSA21), SSA21, BIT8);
  SENTER(RFINDEX(FLD_SSA22), SSA22, BIT8);
  SENTER(RFINDEX(FLD_SSA23), SSA23, BIT8);
  SENTER(RFINDEX(FLD_SM), SM, BIT8);
  SENTER(RFINDEX(FLD_ESC), ESC, BIT8);
  SENTER(RFINDEX(FLD_ESW), ESW, BIT8);
  SENTER(RFINDEX(FLD_EST), EST, BIT8);
  SENTER(RFINDEX(FLD_SBRC), SBRC, BIT8);
  SENTER(RFINDEX(FLD_RCL), RCL, BIT8);
  SENTER(RFINDEX(FLD_ECL), ECL, BIT8);
  SENTER(RFINDEX(FLD_STM), STM, BIT8);
  SENTER(RFINDEX(REG_OSR), OSR, BIT32);
  SENTER(RFINDEX(FLD_DCM), DCM, BIT32);
  SENTER(RFINDEX(FLD_XDCP), XDCP, BIT8);
  SENTER(RFINDEX(FLD_YDCP), YDCP, BIT8);
  SENTER(RFINDEX(FLD_ZDCP), ZDCP, BIT8);
  SENTER(RFINDEX(FLD_LPL), LPL, BIT8);
  SENTER(RFINDEX(FLD_FPL), FPL, BIT8);
  SENTER(RFINDEX(FLD_DCS), DCS, BIT8);
  SENTER(RFINDEX(FLD_TBD), TBD, BIT8);
  SENTER(RFINDEX(FLD_TMS), TMS, BIT8);
  SENTER(RFINDEX(FLD_NBF), NBF, BIT8);
  SENTER(RFINDEX(FLD_SRE), SRE, BIT8);
  SENTER(RFINDEX(FLD_ALS), ALS, BIT8);
  SENTER(RFINDEX(FLD_MAFS), MAFS, BIT8);
  SENTER(RFINDEX(FLD_MBFS), MBFS, BIT8);
  SENTER(RFINDEX(FLD_XMPC), XMPC, BIT8);
  SENTER(RFINDEX(FLD_XPPC), XPPC, BIT8);
  SENTER(RFINDEX(FLD_YMPC), YMPC, BIT8);
  SENTER(RFINDEX(FLD_YPPC), YPPC, BIT8);
  SENTER(RFINDEX(FLD_ZMPC), ZMPC, BIT8);
  SENTER(RFINDEX(FLD_ZPPC), ZPPC, BIT8);
  SENTER(RFINDEX(REG_MIDR), MIDR, BIT8);
  SENTER(RFINDEX(REG_GIDR), GIDR, BIT8);
  SENTER(RFINDEX(FLD_BPIE), BPIE, BIT8);
  SENTER(RFINDEX(FLD_BCIE), BCIE, BIT8);
  SENTER(RFINDEX(FLD_GCIE), GCIE, BIT8);
  SENTER(RFINDEX(FLD_MAIE), MAIE, BIT8);
  SENTER(RFINDEX(FLD_MBIE), MBIE, BIT8);
  SENTER(RFINDEX(FLD_SSIE), SSIE, BIT8);
  SENTER(RFINDEX(FLD_XHIE), XHIE, BIT8);
  SENTER(RFINDEX(FLD_RLIE), RLIE, BIT8);
  SENTER(RFINDEX(FLD_URIE), URIE, BIT8);
  SENTER(RFINDEX(FLD_ISIE), ISIE, BIT8);
  SENTER(RFINDEX(FLD_BPIF), BPIF, BIT8);
  SENTER(RFINDEX(FLD_BCIF), BCIF, BIT8);
  SENTER(RFINDEX(FLD_GCIF), GCIF, BIT8);
  SENTER(RFINDEX(FLD_MAIF), MAIF, BIT8);
  SENTER(RFINDEX(FLD_MBIF), MBIF, BIT8);
  SENTER(RFINDEX(FLD_SSIF), SSIF, BIT8);
  SENTER(RFINDEX(FLD_XHIF), XHIF, BIT8);
  SENTER(RFINDEX(FLD_RLIF), RLIF, BIT8);
  SENTER(RFINDEX(FLD_URIF), URIF, BIT8);
  SENTER(RFINDEX(FLD_ISIF), ISIF, BIT8);
  SENTER(RFINDEX(FLD_VWE), VWE, BIT8);
  SENTER(RFINDEX(FLD_VWIE), VWIE, BIT8);
  SENTER(RFINDEX(FLD_VWIF), VWIF, BIT8);
  SENTER(RFINDEX(FLD_LDOC), LDOC, BIT8);
  SENTER(RFINDEX(FLD_HDOC), HDOC, BIT8);
/* Unpack register of length < 32 bits or register field */
void UnpackState(INT16 *base, int reg_fld, int imm)
  if (BITLEN(reg_fld) > 32) {
    WARNING("Can't unpack a register or field of len > 32", "UnpackState");
    UnpackBits(base, BITOFF(reg_fld), 32, imm, base_type[reg_fld].base,
	       base_type[reg_fld].type);
  else
    UnpackBits(base, BITOFF(reg_fld), BITLEN(reg_fld), imm,
	       base_type[reg_fld].base, base_type[reg_fld].type);
void UnpackStateInto(INT16 *base, int reg_fld, int imm, BYTE *dest, int type)
  if (BITLEN(reg_fld) > 32) {
    WARNING("Can't unpack a register or field of len > 32", "UnpackStateInto");
    UnpackBits(base, BITOFF(reg_fld), 32, imm, dest, type);
  else
    UnpackBits(base, BITOFF(reg_fld), BITLEN(reg_fld), imm, dest, type);
/* Pack register of length < 32 bits or register field */
void PackState(INT16 *base, int reg_fld)
  if (BITLEN(reg_fld) > 32) {
    WARNING("Can't pack a register or field of len > 32", "PackState");
    PackBits(base, BITOFF(reg_fld), 32, base_type[reg_fld].base,
	     base_type[reg_fld].type);
  else
    PackBits(base, BITOFF(reg_fld), BITLEN(reg_fld),
	     base_type[reg_fld].base, base_type[reg_fld].type);
void PackStateFrom(INT16 *base, int reg_fld, BYTE *src, int type)
  if (BITLEN(reg_fld) > 32) {
    WARNING("Can't pack a register or field of len > 32", "PackStateFrom");
    PackBits(base, BITOFF(reg_fld), 32, src, type);
  else
    PackBits(base, BITOFF(reg_fld), BITLEN(reg_fld), src, type);
#ifndef _DECODE_STEPLIST_
#define _DECODE_STEPLIST_
#include "steplistP.h"
typedef struct {
  char *base;
  int type;
} Bt, *BT;
void UnpackState(INT16 *, int, int);
void UnpackStateInto(INT16 *, int, int, BYTE *, int);
void PackState(INT16 *, int);
void PackStateFrom(INT16 *, int, BYTE *, int);
extern Bt base_type[790];
#endif
/*****************************************************************************/
/*                                                                           */
/* Author	: Milan Shah						     */
/* Program	: Cam8Sim						     */
/* Date		: February 6, 1992					     */
/* Module	: errmgr.c - error manager interface			     */
/*                                                                           */
/*****************************************************************************/
#include <stdio.h>
#include <errno.h>
#include "errmgr.h"
#include "errmgrP.h"
void errCritical(char *szMsg, char *szModule, char *szFunction)
     fprintf(stderr, "%s : %s : %s\n", szMsg, szModule, szFunction);
     exit(2);
void errWarning(char *szMsg, char *szModule, char *szFunction)
     fprintf(stderr, "%s : %s : %s\n", szMsg, szModule, szFunction);
/*****************************************************************************/
/*                                                                           */
/* Author	: Milan Shah						     */
/* Program	: Cam8Sim						     */
/* Date		: February 6, 1992					     */
/* Module	: errmgr.h - error manager interface			     */
/*                                                                           */
/*****************************************************************************/
#ifndef _ERRMGR_
#define _ERRMGR_
#include "errmgrP.h"
#define CRITICAL_ERROR(msg, func)	errCritical((msg), MODULE_NAME, (func))
#define WARNING(msg, func)		errWarning((msg), MODULE_NAME, (func))
#endif
/*****************************************************************************/
/*                                                                           */
/* sim.c:	modifications to original code made by Harris L. Gilliam     */
/*		March 1994 - June 1995					     */
/*                                                                           */
/*****************************************************************************/
/*                                                                           */
/* Author       : Milan Shah                                                 */
/* Program      : Cam8Sim                                                    */
/* Date         : February 5, 1992                                           */
/* Module       : compiler.c - top level code generator                      */
/*                                                                           */
/*****************************************************************************/
#include <stdio.h>
#include <sys/mman.h>
#include "errmgr.h"
#include "memmgr.h"
#include "global.h"
#include "heap.h"
#include "utils.h"
#ifndef INTERPRETER
#include "regmgr.h"
#include "icode.h"
#endif
#include "simNoPerm.h"
#include "simGen.h"
#include "sim.h"
#include "decode_steplist.h"
#define MODULE_NAME "Sim"
BOOL bSourceRegChange = TRUE;
BOOL bDestChange = TRUE;
BOOL bForceGeneralScan = FALSE;
void CheckNoPerm();
#ifndef INTERPRETER
#define SCANNER_CODE_SIZE       (1024 * LONG32_SIZE)
#define SWEEP_CODE_SIZE         (1024 * LONG32_SIZE)
#define UPDATE_CODE_SIZE        (1024 * LONG32_SIZE)
CODEPTR pcodScanner;
CODEPTR pcodSweep;
CODEPTR pcodUpdateSite;
void SimPrologue(CODEHANDLE hcodCurrent);
void SimEpilogue(CODEHANDLE hcodCurrent);
void CheckNoPerm(CODEHANDLE hcodCurrent);
#endif INTERPRETER
#ifndef INTERPRETER
int SimCompScan()
  int i;
  BOOL bNoPerm = TRUE;
  BOOL bNoPermLast5 = TRUE;
  CODEPTR pcodCurrent;
  CODEHANDLE hcodCurrent;
  LONG32 lLogScanLength = ESC[0] + 1L;
  EP("SimCompScan");  
#else INTERPRETER
void SimExecScan()
  int i;
  BOOL bNoPerm = TRUE;
  BOOL bNoPermLast5 = TRUE;
  LONG32 lLogScanLength = ESC[0] + 1L;
  EP("SimExecScan");  
#endif INTERPRETER
  /************************************************************************/
  /* First, parse down the tree to see that we are going to update atleast*/
  /* 32 sites and that the lowest dimension extends over 32 bits. This    */
  /* second requirement is necessary because the optimized code can only  */
  /* handle dimension wraparounds at word boundaries.                     */
  /************************************************************************/
  if (lLogScanLength < 5)
    bNoPerm = bNoPermLast5 = FALSE;
  else if (lNumXBits < 5)
    bNoPerm = bNoPermLast5 = FALSE;
  else
    bNoPerm = bNoPermLast5 = TRUE;
  /************************************************************************/
  /* Now, determine if there is any permutation of the scan index in the  */
  /* bits of the SIR that will be significant over this scan.             */
  /************************************************************************/
  for (i = 0; i < MIN(5, ESC[0]); i++) {
    if (SIPR[i][0] != i) {
      bNoPerm = bNoPermLast5 = FALSE;
      break;
    }
    
    lLogScanLength--;
    
    if (!lLogScanLength)
      break;
  for (i = 5; i < MIN(SCAN_INDEX_LENGTH, ESC[0]); i++) {
    if (SIPR[i][0] != i)
      bNoPerm = FALSE;
    lLogScanLength--;
    if (!lLogScanLength)
      break;
#ifndef INTERPRETER
#ifdef _FRAMEBUFFER_
  FRAME = (LONG32) FRAMEb;
#endif _FRAMEBUFFER_
  pcodCurrent = pcodScanner;
  hcodCurrent = &pcodCurrent;
  SimPrologue(hcodCurrent);
  if (bNoPerm)
    CheckNoPerm(hcodCurrent);
  else if (bNoPermLast5)
    SimGeneralScan(hcodCurrent);
  else
    SimGeneralScan(hcodCurrent);
  SimEpilogue(hcodCurrent);
  LP("SimCompScan");
#else INTERPRETER
#ifdef _FRAMEBUFFER_
  FRAME_ADDR = (LONG32) FRAMEb;
#endif _FRAMEBUFFER_
  if (bNoPerm)
    CheckNoPerm();
  else if (bNoPermLast5)
    SimGeneralScan();
  else
    SimGeneralScan();
  if (SCAN_INDEX_REG > 0xFFFFFF)
    SCAN_INDEX_REG = 0;
  SIR[0] = SCAN_INDEX_REG;
  LP("SimExecScan");
#endif INTERPRETER
/*****************************************************************************/
/*                                                                           */
/* CheckNoPerm is necessary for the following reason - suppose there is no   */
/* permutation of the Scan Index, but suppose the the bits that extend over  */
/* the lowest dimension (ie, the bits to the _right_ of the lowest bit of    */
/* DCMR) are not all zeros. Then, the first sweep will not scan a multiple-  */
/* of-two number of sites, and we cannot to an optimized scan.               */
/*                                                                           */
/*****************************************************************************/
#ifndef INTERPRETER
void CheckNoPerm(CODEHANDLE hcodCurrent)
  LONG32 lSIRSigBits, lSIR;
#else INTERPRETER
void CheckNoPerm()
  LONG32 lSIRSigBits, lSIR;
#endif INTERPRETER
  EP("CheckNoPerm");
  lSIRSigBits = MIN(ESC[0], lNumXBits);
  lSIR = SIR[0] & ~((~0x0) << lSIRSigBits);
#ifndef INTERPRETER
  if ((lSIR == 0) && (MIN(lNumXBits, ESC[0]) >= 2)) {
    if (bForceGeneralScan)
      SimGeneralScan(hcodCurrent);
    else
      SimScanNoPerm(hcodCurrent);
  else
    SimGeneralScan(hcodCurrent);
#else INTERPRETER
  if ((lSIR == 0) && (MIN(lNumXBits, ESC[0]) >= 2)) {
    if (bForceGeneralScan)
      SimGeneralScan();
    else
      SimScanNoPerm();
  else
    SimGeneralScan();
#endif INTERPRETER
  LP("CheckNoPerm");
#ifndef INTERPRETER
void SimPrologue(CODEHANDLE hcodCurrent)
  EP("SimPrologue");
  NewBlock(hcodCurrent);
Emit(ENTER_PROC, NULL_OP, 0, NULL_OP, 0, NULL_OP, 0);
ASCODE("  .ENTER_PROC;");
  LP("SimPrologue");
}     
void SimEpilogue(CODEHANDLE hcodCurrent)
  EP("SimEpilogue");
Emit(RETURN_PROC, NULL_OP, 0, NULL_OP, 0, NULL_OP, 0);
ASCODE(" .RETURN_PROC;");
  EndBlock();
  LP("SimEpilogue");
void SimExecScan()
  void (*fScan)(void);
  fScan = (void (*)()) pcodScanner;
  (*fScan)();
  ConstantSetAll(SIR, SCAN_INDEX_REG);
void InitSim()
  const int prot = PROT_READ | PROT_WRITE | PROT_EXEC;
  pcodScanner = VALLOC(SCANNER_CODE_SIZE, "InitSim : pcodScanner");
  pcodGenUpdate = VALLOC(SCANNER_CODE_SIZE, "InitSim : pcodGenUpdate");
  pcodSweep = VALLOC(SWEEP_CODE_SIZE, "InitSim : pcodSweep");
  pcodUpdateSite = VALLOC(UPDATE_CODE_SIZE, "InitSim : pcodUpdateSite");
  mprotect(pcodScanner, SCANNER_CODE_SIZE, prot);
  mprotect(pcodGenUpdate, SCANNER_CODE_SIZE, prot);
  mprotect(pcodSweep, SWEEP_CODE_SIZE, prot);
  mprotect(pcodUpdateSite, UPDATE_CODE_SIZE, prot);
  UPDATE_SITE_CODE = (LONG32) pcodUpdateSite;
  InitRegMgr();
#endif INTERPRETER
/*****************************************************************************/
/*                                                                           */
/* Author	: Milan Shah						     */
/* Program	: Cam8Sim						     */
/* Date		: February 6, 1992					     */
/* Module	: errmgrP.h - error manager interface - private functions    */
/*                                                                           */
/*****************************************************************************/
#ifndef _ERRMGR_P_
#define _ERRMGR_P_
void 	errCritical(char *szMsg, char *szModule, char *szFunction);
void 	errWarning(char *szMsg, char *szModule, char *szFunction);
#endif
/******************************************************************************
 * Author  : Milan Shah
 * Program : Cam8Sim
 * Date    : 2/2/92
 * Module  : Global : Defines the global state of the CAM-8 simulator
 *****************************************************************************/
#include "global.h"
LONG32 SITE_ADDR;
CAM8STATE CAM8State;
unsigned short nNumPlanes;
/* LUT buffers and FRAME buffer */
INT16 *LUTb[2];
#ifdef _FRAMEBUFFER_
BYTE *FRAMEb;
#endif _FRAMEBUFFER_
#ifdef INTERPRETER
LONG32 bit;
LONG32 HIGH_BIT_MASK;
LONG32 X_HIGH_BIT_MASK;
LONG32 X_BYTE_LENGTH;
LONG32 X_CTR;
LONG32 SITE_CTR;
LONG32 OFFSETS[CHIPS_PER_MOD];
LONG32 BIT_OFFSETS[CHIPS_PER_MOD];
LONG32 DCMR;
LONG32 SCAN_INDEX_REG;
LONG32 LUT_ADDR;
LONG32 BIT_PLANE_ADDR[CHIPS_PER_MOD];
LONG32 NEXT_WORD_ADDR[CHIPS_PER_MOD];
LONG32 PLANE_WORD[CHIPS_PER_MOD];
LONG32 EVENT_COUNT[CHIPS_PER_MOD];
LONG32 UNGLUE_DATA;
LONG32 GLUE_DATA;
LONG32 SITE_DATA;
LONG32 TBUS_DATA;
LONG32 LUT_DATA;
LONG32 DISP_DATA;
LONG32 TBUS_ADDR;
LONG32 FRAME_ADDR;
LONG32 TEMP1;
LONG32 TEMP2;
LONG32 TEMP3;
LONG32 TEMP4;
LONG32 TEMP5;
LONG32 TEMP6;
LONG32 TEMP7;
LONG32 TEMP8;
LONG32 TEMP9;
LONG32 TEMP10;
#endif INTERPRETER
/*****************************************************************************/
/*                                                                           */
/* global.h:	modifications to original code made by Harris L. Gilliam     */
/*		March 1994 - June 1995					     */
/*                                                                           */
/*****************************************************************************/
/*                                                                           */
/* Author  : Milan Shah                                                      */
/* Program : Cam8Sim                                                         */
/* Date    : 2/2/92                                                          */
/* Module  : Global.h : Defines the global state of the CAM-8 simulator      */
/*                                                                           */
/*****************************************************************************/
#ifndef _GLOBAL_
#define _GLOBAL_
#define SHARED_MEMORY_INTERFACE
#define CHIPS_PER_MOD           16
#define SCAN_INDEX_LENGTH       24
#define PERM_CONST_1            31                                               
#define PERM_CONST_0            30
#undef TRUE
#undef FLASE
#define TRUE                    1
#define FALSE                   0
#ifndef NULL
#define NULL                    0
#endif
#define LONG32_SIZE     (sizeof(LONG32))
#define INT16_SIZE      (sizeof(INT16))
typedef unsigned char   BYTE;
typedef unsigned char   BOOL;
typedef unsigned long   LONG32;
typedef unsigned short  INT16;
#ifndef INTERPRETER
typedef unsigned long   CODE;
typedef CODE            *CODEPTR;
typedef CODEPTR         *CODEHANDLE;
#endif INTERPRETER
#include "decode_steplist.h"
/*****************************************************************************/
/*                                                                           */
/* Definition of struct cam8state, the CAM module state structure.       */
/*                                                                           */
/*****************************************************************************/
typedef struct cam8state {
  /* CAM8 Registers */
  BYTE MSR[CHIPS_PER_MOD];
  BYTE SSM[CHIPS_PER_MOD];
  BYTE RT[CHIPS_PER_MOD];
  BYTE ECT[CHIPS_PER_MOD];
  BYTE RPK[CHIPS_PER_MOD];
  BYTE ALT[CHIPS_PER_MOD];
  LONG32 KA[CHIPS_PER_MOD];
  BYTE XKS[CHIPS_PER_MOD];
  BYTE YKS[CHIPS_PER_MOD];
  BYTE ZKS[CHIPS_PER_MOD];
  BYTE XKMF[CHIPS_PER_MOD];
  BYTE YKMF[CHIPS_PER_MOD];
  BYTE ZKMF[CHIPS_PER_MOD];
  BYTE SABSR[CHIPS_PER_MOD];
  BYTE LAS[CHIPS_PER_MOD];
  BYTE LAM[CHIPS_PER_MOD];
  BYTE FOS[CHIPS_PER_MOD];
  BYTE FOM[CHIPS_PER_MOD];
  BYTE SDS[CHIPS_PER_MOD];
  BYTE SDM[CHIPS_PER_MOD];
  BYTE ECS[CHIPS_PER_MOD];
  BYTE ECM[CHIPS_PER_MOD];
  BYTE DDS[CHIPS_PER_MOD];
  BYTE DDM[CHIPS_PER_MOD];
  BYTE SSR[CHIPS_PER_MOD];
  LONG32 ECR[CHIPS_PER_MOD];
  INT16 LIR[CHIPS_PER_MOD];
  BYTE LIPR[CHIPS_PER_MOD];
  INT16 *LIOR;
  LONG32 SIR[CHIPS_PER_MOD];
  BYTE SSA[24][CHIPS_PER_MOD];
  BYTE *SIOR;
  BYTE SM[CHIPS_PER_MOD];
  BYTE ESC[CHIPS_PER_MOD];
  BYTE ESW[CHIPS_PER_MOD];
  BYTE EST[CHIPS_PER_MOD];
  BYTE SBRC[CHIPS_PER_MOD];
  BYTE RCL[CHIPS_PER_MOD];
  BYTE ECL[CHIPS_PER_MOD];
  BYTE STM[CHIPS_PER_MOD];
  LONG32 OSR[CHIPS_PER_MOD];
  LONG32 DCM[CHIPS_PER_MOD];
  BYTE XDCP[CHIPS_PER_MOD];
  BYTE YDCP[CHIPS_PER_MOD];
  BYTE ZDCP[CHIPS_PER_MOD];
  BYTE LPL[CHIPS_PER_MOD];
  BYTE FPL[CHIPS_PER_MOD];
  BYTE DCS[CHIPS_PER_MOD];
  BYTE TBD[CHIPS_PER_MOD];
  BYTE TMS[CHIPS_PER_MOD];
  BYTE NBF[CHIPS_PER_MOD];
  BYTE SRE[CHIPS_PER_MOD];
  BYTE ALS[CHIPS_PER_MOD];
  BYTE MAFS[CHIPS_PER_MOD];
  BYTE MBFS[CHIPS_PER_MOD];
  BYTE XMPC[CHIPS_PER_MOD];
  BYTE XPPC[CHIPS_PER_MOD];
  BYTE YMPC[CHIPS_PER_MOD];
  BYTE YPPC[CHIPS_PER_MOD];
  BYTE ZMPC[CHIPS_PER_MOD];
  BYTE ZPPC[CHIPS_PER_MOD];
  BYTE MIDR[CHIPS_PER_MOD];
  BYTE GIDR[CHIPS_PER_MOD];
  BYTE BPIE[CHIPS_PER_MOD];
  BYTE BCIE[CHIPS_PER_MOD];
  BYTE GCIE[CHIPS_PER_MOD];
  BYTE MAIE[CHIPS_PER_MOD];
  BYTE MBIE[CHIPS_PER_MOD];
  BYTE SSIE[CHIPS_PER_MOD];
  BYTE XHIE[CHIPS_PER_MOD];
  BYTE RLIE[CHIPS_PER_MOD];
  BYTE URIE[CHIPS_PER_MOD];
  BYTE ISIE[CHIPS_PER_MOD];
  BYTE BPIF[CHIPS_PER_MOD];
  BYTE BCIF[CHIPS_PER_MOD];
  BYTE GCIF[CHIPS_PER_MOD];
  BYTE MAIF[CHIPS_PER_MOD];
  BYTE MBIF[CHIPS_PER_MOD];
  BYTE SSIF[CHIPS_PER_MOD];
  BYTE XHIF[CHIPS_PER_MOD];
  BYTE RLIF[CHIPS_PER_MOD];
  BYTE URIF[CHIPS_PER_MOD];
  BYTE ISIF[CHIPS_PER_MOD];
  BYTE VWE[CHIPS_PER_MOD];
  BYTE VWIE[CHIPS_PER_MOD];
  BYTE VWIF[CHIPS_PER_MOD];
  BYTE LDOC[CHIPS_PER_MOD];
  BYTE HDOC[CHIPS_PER_MOD];
  /* Not actual CAM8 Register but needed state info */
  BYTE WhyScan;
  BOOL bByteMode;
  BOOL bImmediate;
  BOOL bReadMode;
} CAM8STATE;
#define ConstantSetAll(r, v) \
{register int i;for(i=0;i<CHIPS_PER_MOD;i++) r[i]=v;}
#define SetAll(r, v) \
{register int i;for(i=0;i<CHIPS_PER_MOD;i++) r[i]=v[i];}
/*****************************************************************************/
/*                                                                           */
/* Global State Variables.                                                   */
/*                                                                           */
/*****************************************************************************/
#define MSR	CAM8State.MSR
#define SSM	CAM8State.SSM
#define RT	CAM8State.RT
#define ECT	CAM8State.ECT
#define RPK	CAM8State.RPK
#define ALT	CAM8State.ALT
#define KA	CAM8State.KA
#define XKS	CAM8State.XKS
#define YKS	CAM8State.YKS
#define ZKS	CAM8State.ZKS
#define XKMF	CAM8State.XKMF
#define YKMF	CAM8State.YKMF
#define ZKMF	CAM8State.ZKMF
#define SABSR	CAM8State.SABSR
#define LAS	CAM8State.LAS
#define LAM	CAM8State.LAM
#define FOS	CAM8State.FOS
#define FOM	CAM8State.FOM
#define SDS	CAM8State.SDS
#define SDM	CAM8State.SDM
#define ECS	CAM8State.ECS
#define ECM	CAM8State.ECM
#define DDS	CAM8State.DDS
#define DDM	CAM8State.DDM
#define SSR	CAM8State.SSR
#define ECR	CAM8State.ECR
#define LIR	CAM8State.LIR
#define LIPR	CAM8State.LIPR
#define LIOR	CAM8State.LIOR
#define SIR	CAM8State.SIR
#define SIPR	CAM8State.SSA
#define SSA0	CAM8State.SSA[0]
#define SSA1	CAM8State.SSA[1]
#define SSA2	CAM8State.SSA[2]
#define SSA3	CAM8State.SSA[3]
#define SSA4	CAM8State.SSA[4]
#define SSA5	CAM8State.SSA[5]
#define SSA6	CAM8State.SSA[6]
#define SSA7	CAM8State.SSA[7]
#define SSA8	CAM8State.SSA[8]
#define SSA9	CAM8State.SSA[9]
#define SSA10	CAM8State.SSA[10]
#define SSA11	CAM8State.SSA[11]
#define SSA12	CAM8State.SSA[12]
#define SSA13	CAM8State.SSA[13]
#define SSA14	CAM8State.SSA[14]
#define SSA15	CAM8State.SSA[15]
#define SSA16	CAM8State.SSA[16]
#define SSA17	CAM8State.SSA[17]
#define SSA18	CAM8State.SSA[18]
#define SSA19	CAM8State.SSA[19]
#define SSA20	CAM8State.SSA[20]
#define SSA21	CAM8State.SSA[21]
#define SSA22	CAM8State.SSA[22]
#define SSA23	CAM8State.SSA[23]
#define SIOR	CAM8State.SIOR
#define SM	CAM8State.SM
#define ESC	CAM8State.ESC
#define ESW	CAM8State.ESW
#define EST	CAM8State.EST
#define SBRC	CAM8State.SBRC
#define RCL	CAM8State.RCL
#define ECL	CAM8State.ECL
#define STM	CAM8State.STM
#define OSR	CAM8State.OSR
#define DCM	CAM8State.DCM
#define XDCP	CAM8State.XDCP
#define YDCP	CAM8State.YDCP
#define ZDCP	CAM8State.ZDCP
#define LPL	CAM8State.LPL
#define FPL	CAM8State.FPL
#define DCS	CAM8State.DCS
#define TBD	CAM8State.TBD
#define TMS	CAM8State.TMS
#define NBF	CAM8State.NBF
#define SRE	CAM8State.SRE
#define ALS	CAM8State.ALS
#define MAFS	CAM8State.MAFS
#define MBFS	CAM8State.MBFS
#define XMPC	CAM8State.XMPC
#define XPPC	CAM8State.XPPC
#define YMPC	CAM8State.YMPC
#define YPPC	CAM8State.YPPC
#define ZMPC	CAM8State.ZMPC
#define ZPPC	CAM8State.ZPPC
#define MIDR	CAM8State.MIDR
#define GIDR	CAM8State.GIDR
#define BPIE	CAM8State.BPIE
#define BCIE	CAM8State.BCIE
#define GCIE	CAM8State.GCIE
#define MAIE	CAM8State.MAIE
#define MBIE	CAM8State.MBIE
#define SSIE	CAM8State.SSIE
#define XHIE	CAM8State.XHIE
#define RLIE	CAM8State.RLIE
#define URIE	CAM8State.URIE
#define ISIE	CAM8State.ISIE
#define BPIF	CAM8State.BPIF
#define BCIF	CAM8State.BCIF
#define GCIF	CAM8State.GCIF
#define MAIF	CAM8State.MAIF
#define MBIF	CAM8State.MBIF
#define SSIF	CAM8State.SSIF
#define XHIF	CAM8State.XHIF
#define RLIF	CAM8State.RLIF
#define URIF	CAM8State.URIF
#define ISIF	CAM8State.ISIF
#define VWE	CAM8State.VWE
#define VWIE	CAM8State.VWIE
#define VWIF	CAM8State.VWIF
#define LDOC	CAM8State.LDOC
#define HDOC	CAM8State.HDOC
#define LUT0			LUTb[0]
#define LUT1			LUTb[1]
#ifdef INTERPRETER
#define HIGHB(x)		(((x) & 0x80000000) ? 0x1 : 0x0)
extern LONG32 bit;
extern LONG32 HIGH_BIT_MASK;
extern LONG32 X_HIGH_BIT_MASK;
extern LONG32 X_BYTE_LENGTH;
extern LONG32 X_CTR;
extern LONG32 SITE_CTR;
extern LONG32 OFFSETS[CHIPS_PER_MOD];
extern LONG32 BIT_OFFSETS[CHIPS_PER_MOD];
extern LONG32 DCMR;
extern LONG32 SCAN_INDEX_REG;
extern LONG32 LUT_ADDR;
extern LONG32 BIT_PLANE_ADDR[CHIPS_PER_MOD];
extern LONG32 NEXT_WORD_ADDR[CHIPS_PER_MOD];
extern LONG32 PLANE_WORD[CHIPS_PER_MOD];
extern LONG32 EVENT_COUNT[CHIPS_PER_MOD];
extern LONG32 UNGLUE_DATA;
extern LONG32 GLUE_DATA;
extern LONG32 SITE_DATA;
extern LONG32 TBUS_DATA;
extern LONG32 LUT_DATA;
extern LONG32 DISP_DATA;
extern LONG32 TBUS_ADDR;
extern LONG32 FRAME_ADDR;
extern LONG32 TEMP1;
extern LONG32 TEMP2;
extern LONG32 TEMP3;
extern LONG32 TEMP4;
extern LONG32 TEMP5;
extern LONG32 TEMP6;
extern LONG32 TEMP7;
extern LONG32 TEMP8;
extern LONG32 TEMP9;
extern LONG32 TEMP10;
#endif INTERPRETER
extern LONG32 SITE_ADDR;
extern CAM8STATE CAM8State;
extern unsigned short nNumPlanes;
extern int sim_camfd;
/* LUT buffers and FRAME buffer */
extern INT16 *LUTb[2];
#ifdef _FRAMEBUFFER_
extern BYTE *FRAMEb;
#endif _FRAMEBUFFER_
#ifdef DEBUG
  #include <stdio.h>
  extern FILE* DEBUGFILE;
  extern char *REGNAMES[];
  #define EP(name) fprintf(DEBUGFILE, "ENTER: %s\n", name)
  #define LP(name) fprintf(DEBUGFILE, "LEAVE: %s\n", name)
#ifndef INTERPRETER
  extern CODEPTR DASMADDR;
  #define ASCODE(c)  fprintf(DEBUGFILE, "\t0x%x: %s\n", DASMADDR, c); fflush(DEBUGFILE)
  #define ASNOTE(c)  fprintf(DEBUGFILE, "\t%s\n", c); fflush(DEBUGFILE)
#endif INTERPRETER
#else DEBUG
  #define EP(name)
  #define LP(name)
#ifndef INTERPRETER
  #define ASCODE(name)
  #define ASNOTE(c)
#endif INTERPRETER
#endif DEBUG
#endif
/*****************************************************************************/
/*                                                                           */
/* heap.c:	modifications to original code made by Harris L. Gilliam     */
/*		March 1994 - June 1995					     */
/*                                                                           */
/*****************************************************************************/
/*                                                                           */
/* Author	: Milan Shah						     */
/* Program	: Cam8Sim						     */
/* Date		: February 14, 1992					     */
/* Module	: heap.c - The symbol table interface, and heap init	     */
/*		  routines.						     */
/*                                                                           */
/*****************************************************************************/
#include <sys/types.h>
#include <sys/mman.h>
#include "global.h"
#include "errmgr.h"
#include "memmgr.h"
#include "heap.h"
#define MODULE_NAME	"Heap"
/* 0.5 Megabytes per plane and 64K x 16bit LUT */
const int lBitPlaneSize = 512 * 1024;
const int lLUTSize = 65536*2;
#ifndef INTERPRETER
BYTE *pcHeap = NULL;
#endif INTERPRETER
void InitHeap()
  short i;
     
#ifndef INTERPRETER
  if (!pcHeap) {
    pcHeap = (BYTE *) VALLOC(HeapSize, "InitHeap : Heap");
    madvise(pcHeap, HeapSize, MADV_RANDOM|MADV_WILLNEED);
  for (i = 0; i < CHIPS_PER_MOD; i++) {
    BIT_PLANE_ADDR(i) = (LONG32) MEMALIGN(lBitPlaneSize, lBitPlaneSize,
					  "InitHeap : Plane Memory");
    madvise(BIT_PLANE_ADDR(i), lBitPlaneSize, MADV_SEQUENTIAL|MADV_WILLNEED);
#else INTERPRETER
  for (i = 0; i < CHIPS_PER_MOD; i++) {
    BIT_PLANE_ADDR[i] = (LONG32) MEMALIGN(lBitPlaneSize, lBitPlaneSize,
					  "InitHeap : Plane Memory");
    madvise((caddr_t) BIT_PLANE_ADDR[i], lBitPlaneSize, MADV_SEQUENTIAL|MADV_WILLNEED);
#endif INTERPRETER
  LUT0 = (INT16 *) VALLOC(lLUTSize, "InitHeap : LUT0");
  madvise((caddr_t) LUT0, lLUTSize, MADV_SEQUENTIAL|MADV_WILLNEED);
#ifdef DEBUG
  printf("LUT0 = 0x%x\n", LUT0);
#endif
  LUT_ADDR = (LONG32) LUT0;
  LUT1 = (INT16 *) VALLOC(lLUTSize, "InitHeap : LUT1");
  madvise((caddr_t) LUT1, lLUTSize, MADV_SEQUENTIAL|MADV_WILLNEED);
#ifdef DEBUG
  printf("LUT1 = 0x%x\n", LUT1);
#endif
  LIOR = (INT16 *) LUT1;
#ifdef _FRAMEBUFFER_
  FRAMEb = (BYTE *) VALLOC(512 * 512, "InitHeap : FRAMEBUFFER");
  madvise(FRAMEb, 512 * 512, MADV_SEQUENTIAL|MADV_WILLNEED);
#endif
#ifndef INTERPRETER
const LONG32 iHighBitMask	= 1;						 /* Indexes Into Symboltable	     */
const LONG32 iXHighBitMask	= (offXHighBitMask/LONG32_SIZE + 1);		 /* Used As "Variable Names". 	     */
const LONG32 iXByteLength	= (offXByteLength/LONG32_SIZE	 + 1);				 
const LONG32 iXCtr		= (offXCtr/LONG32_SIZE + 1);
const LONG32 iSiteCtr		= (offSiteCtr/LONG32_SIZE + 1);
const LONG32 iOffsets		= (offOffsets/LONG32_SIZE + 1);			 /* Each Element Of Arrays Have Own  */
const LONG32 iBitOffsets	= (offBitOffsets/LONG32_SIZE + 1);		 /* Symbol Table Entry 		     */
const LONG32 iDcmr		= (offDcmr/LONG32_SIZE + 1);
const LONG32 iScanIndexReg	= (offScanIndexReg/LONG32_SIZE + 1);
const LONG32 iLutAddr		= (offLutAddr/LONG32_SIZE + 1);
const LONG32 iBitPlaneAddr	= (offBitPlaneAddr/LONG32_SIZE + 1);
const LONG32 iNextWordAddr	= (offNextWordAddr/LONG32_SIZE + 1);
const LONG32 iPlaneWord		= (offPlaneWord/LONG32_SIZE + 1);
const LONG32 iEventCount	= (offEventCount/LONG32_SIZE + 1);
const LONG32 iGlueData		= (offGlueData/LONG32_SIZE + 1);
const LONG32 iUnGlueData	= (offUnGlueData/LONG32_SIZE + 1);
const LONG32 iSiteDataSrc	= (offSiteDataSrc/LONG32_SIZE + 1);
const LONG32 iTbusData		= (offTbusData/LONG32_SIZE + 1);
const LONG32 iLutData		= (offLutData/LONG32_SIZE + 1);
const LONG32 iTbusAddr		= (offTbusAddr/LONG32_SIZE + 1);
const LONG32 iFrame		= (offFrame/LONG32_SIZE + 1);
const LONG32 iSIOR		= (offSIOR/LONG32_SIZE + 1);
const LONG32 iUpdateSiteProc	= (offUpdateSiteProc/LONG32_SIZE + 1);
const LONG32 iTemp1		= (offTemp1/LONG32_SIZE + 1);
const LONG32 iTemp2		= (offTemp2/LONG32_SIZE + 1);
const LONG32 iTemp3		= (offTemp3/LONG32_SIZE + 1);
const LONG32 iTemp4		= (offTemp4/LONG32_SIZE + 1);
const LONG32 iTemp5		= (offTemp5/LONG32_SIZE + 1);
const LONG32 iTemp6		= (offTemp6/LONG32_SIZE + 1);
const LONG32 iTemp7		= (offTemp7/LONG32_SIZE + 1);
const LONG32 iTemp8		= (offTemp8/LONG32_SIZE + 1);
const LONG32 iTemp9		= (offTemp9/LONG32_SIZE + 1);
const LONG32 iTemp10		= (offTemp10/LONG32_SIZE + 1);
struct tag_SymTableEntry SymbolTable[SymbolTableSize];				 /* The Symbol Table 		     */
     
#define ENTER(idx, pri, off, r)		SymbolTable[(idx)].nPriority = (pri); \
  					SymbolTable[(idx)].nHeapOffset = (off); \
  				        SymbolTable[(idx)].regLoc = (r);
#ifdef DEBUG
char SYMBOLS[SymbolTableSize][64];
#define SYM(idx, sym)			strcpy(SYMBOLS[idx], sym)
#endif
void InitSymbolTable()
  short i;
     
  ENTER( iHighBitMask, TEMP, offHighBitMask, 0);
  ENTER( iXHighBitMask, TEMP, offXHighBitMask, 0);
  ENTER( iXByteLength, TEMP,	offXByteLength,	0);
     
  ENTER( iXCtr, LOOP_CTR, offXCtr, 0);
  ENTER( iSiteCtr, LOOP_CTR,	offSiteCtr, 0);
  for (i = 0; i < CHIPS_PER_MOD; i++) {
    ENTER( iOffsets + i, TEMP, offOffsets + (4*i), 0);
  for (i = 0; i < CHIPS_PER_MOD; i++) {
    ENTER( iBitOffsets + i, TEMP, offBitOffsets + (4*i), 0);
  ENTER( iDcmr, TEMP, offDcmr, 0);
  ENTER( iScanIndexReg, TEMP, offScanIndexReg, 0);
     
  ENTER( iLutAddr, GLOBAL, offLutAddr, 0);
  for (i = 0; i < CHIPS_PER_MOD; i++) {
    ENTER( iBitPlaneAddr + i, TEMP, offBitPlaneAddr + (4*i), 0);
  for (i = 0; i < CHIPS_PER_MOD; i++) {
    ENTER( iNextWordAddr + i, TEMP, offNextWordAddr + (4*i), 0);
  for (i = 0; i < CHIPS_PER_MOD; i++) {
    ENTER( iPlaneWord + i, GLOBAL, offPlaneWord + (4*i), 0);
  for (i = 0; i < CHIPS_PER_MOD; i++) {
    ENTER( iEventCount + i, TEMP, offEventCount + (4*i), 0);
  } 
  ENTER( iGlueData, TEMP, offGlueData, 0);
  ENTER( iUnGlueData, TEMP, offUnGlueData, 0);
  ENTER( iSiteDataSrc, TEMP, offSiteDataSrc, 0);
  ENTER( iTbusData, TEMP, offTbusData, 0);
  ENTER( iLutData, TEMP, offTbusData, 0);
  ENTER( iTbusAddr, TEMP, offTbusAddr, 0);
  ENTER( iFrame, TEMP, offFrame, 0);
  ENTER( iSIOR, TEMP, offSIOR, 0);
  ENTER( iUpdateSiteProc, TEMP, offUpdateSiteProc, 0);
  for (i = 0; i < LAST_TEMP; i++) {
    ENTER( (iTemp1 + i), VOLATILE, (offTemp1 + (i * LONG32_SIZE)), 0);
#ifdef DEBUG
  SYM( iHighBitMask, "iHighBitMask" );
  SYM( iXHighBitMask, "iXHighBitMask" );
  SYM( iXByteLength, "iXByteLength" );
     
  SYM( iXCtr, "iXCtr" );
  SYM( iSiteCtr, "iSiteCtr" );
  for (i = 0; i < CHIPS_PER_MOD; i++) {
    char name[64];
    sprintf(name, "iOffsets[%d]", i);
    SYM( iOffsets + i, name );
  for (i = 0; i < CHIPS_PER_MOD; i++) {
    char name[64];
    sprintf(name, "iBitOffsets[%d]", i);
    SYM( iBitOffsets + i, name );
  SYM( iDcmr, "iDcmr" );
  SYM( iScanIndexReg, "iScanIndexReg" );
     
  SYM( iLutAddr, "iLutAddr" );
  for (i = 0; i < CHIPS_PER_MOD; i++) {
    char name[64];
    sprintf(name, "iBitPlaneAddr[%d]", i);
    SYM( iBitPlaneAddr + i, name );
  for (i = 0; i < CHIPS_PER_MOD; i++) {
    char name[64];
    sprintf(name, "iNextWordAddr[%d]", i);
    SYM( iNextWordAddr + i, name );
  for (i = 0; i < CHIPS_PER_MOD; i++) {
    char name[64];
    sprintf(name, "iPlaneWord[%d]", i);
    SYM( iPlaneWord + i, name );
  for (i = 0; i < CHIPS_PER_MOD; i++) {
    char name[64];
    sprintf(name, "iEventCount[%d]", i);
    SYM( iEventCount + i, name );
  } 
  SYM( iGlueData, "iGlueData" );
  SYM( iUnGlueData, "iUnGlueData" );
  SYM( iSiteDataSrc, "iSiteDataSrc" );
  SYM( iTbusData, "iTbusData" );
  SYM( iLutData, "iLutData" );
  SYM( iTbusAddr, "iTbusAddr" );
  SYM( iFrame, "iFrame" );
  SYM( iSIOR, "iSIOR" );
  SYM( iUpdateSiteProc, "iUpdateSiteProc" );
  for (i = 0; i < LAST_TEMP; i++) {
    char name[64];
    sprintf(name, "iTemp%d", i+1);
    SYM( iTemp1 + i, name );
#endif
#endif INTERPRETER
/*****************************************************************************/
/*                                                                           */
/* heap.h:	modifications to original code made by Harris L. Gilliam     */
/*		March 1994 - June 1995					     */
/*                                                                           */
/*****************************************************************************/
/*                                                                           */
/* Author  : Milan Shah							     */
/* Program : Cam8Sim							     */
/* Date    : 2/4/92							     */
/* Module  : Heap.h - Defines heap-like structure to store simulator state   */
/*                                                                           */
/* In addition to the state of a CAM-8 module, the simulator has its         */
/* own state, maintained in a heap-like structure. Some of the state of a    */
/* CAM-8 module is duplicated here for easy access; the CAM-8 state is       */
/* updated after every scan.						     */
/*                                                                           */
/*****************************************************************************/
#ifndef _HEAP_
#define _HEAP_
extern BYTE *pcHeap;								 /* Pointer to simulator heap 	     */
void InitHeap(void);
#ifndef INTERPRETER 
#include "regmgr.h"
void InitSymbolTable(void);
/*****************************************************************************/
/*                                                                           */
/* the following define offsets into the heap for all the state variables    */
/* that are stored there.						     */
/*                                                                           */
/*****************************************************************************/
#define ARRAY_16_SIZE		(CHIPS_PER_MOD * LONG32_SIZE)
#define offHighBitMask		0						 /* 0 				     */
#define offXHighBitMask		(offHighBitMask + LONG32_SIZE)			 /* 4 				     */
#define offXByteLength		(offXHighBitMask + LONG32_SIZE)			 /* 8 				     */
#define offXCtr			(offXByteLength + LONG32_SIZE)			 /* 12 				     */
#define offSiteCtr		(offXCtr + LONG32_SIZE)				 /* 16 				     */
#define offOffsets		(offSiteCtr + LONG32_SIZE)			 /* 20 				     */
#define offBitOffsets		(offOffsets + ARRAY_16_SIZE)			 /* 84 				     */
#define offDcmr			(offBitOffsets + ARRAY_16_SIZE)			 /* 148				     */
#define offScanIndexReg		(offDcmr + LONG32_SIZE)				 /* 152				     */
#define offLutAddr		(offScanIndexReg + LONG32_SIZE)			 /* 156				     */
#define offBitPlaneAddr		(offLutAddr + LONG32_SIZE)			 /* 160				     */
#define offNextWordAddr		(offBitPlaneAddr + ARRAY_16_SIZE)		 /* 224				     */
#define offPlaneWord		(offNextWordAddr + ARRAY_16_SIZE)		 /* 288				     */
#define offEventCount		(offPlaneWord + ARRAY_16_SIZE)			 /* 352 			     */
#define offGlueData		(offEventCount + ARRAY_16_SIZE)			 /* 416 			     */
#define offUnGlueData		(offGlueData + LONG32_SIZE)			 /* 420 			     */
#define offSiteDataSrc		(offUnGlueData + LONG32_SIZE)			 /* 424				     */
#define offTbusData		(offSiteDataSrc + LONG32_SIZE)			 /* 428 			     */
#define offLutData		(offTbusData + LONG32_SIZE)			 /* 432 			     */
#define offTbusAddr		(offLutData + LONG32_SIZE)			 /* 436 			     */
#define offFrame		(offTbusAddr + LONG32_SIZE)			 /* 440				     */
#define offSIOR			(offFrame + LONG32_SIZE)			 /* 444				     */
#define offUpdateSiteProc	(offSIOR + LONG32_SIZE)			 	 /* 448				     */
#define offTemp1		(offUpdateSiteProc + LONG32_SIZE)		 /* 452 			     */
#define offTemp2		(offTemp1 + LONG32_SIZE)			 /* 456 			     */
#define offTemp3		(offTemp2 + LONG32_SIZE)			 /* 460 			     */
#define offTemp4		(offTemp3 + LONG32_SIZE)			 /* 464				     */
#define offTemp5		(offTemp4 + LONG32_SIZE)			 /* 468 			     */
#define offTemp6		(offTemp5 + LONG32_SIZE)			 /* 472 			     */
#define offTemp7		(offTemp6 + LONG32_SIZE)			 /* 476				     */
#define offTemp8		(offTemp7 + LONG32_SIZE)			 /* 480 			     */
#define offTemp9		(offTemp8 + LONG32_SIZE)			 /* 484				     */
#define offTemp10		(offTemp9 + LONG32_SIZE)			 /* 488 			     */
#define LAST_TEMP		10
#define HeapSize	 	(offTemp10 + LONG32_SIZE)
#define SymbolTableSize		  (offTemp10/LONG32_SIZE + 1 + 1)		 /* Should Be 1 More Than Last Name  */
										 /* because SymbolTable[0] is invalid*/
/*****************************************************************************/
/*                                                                           */
/* The following define macros to access variables on the heap. The macros   */
/* can be used as lvalues or rvalues.					     */
/*                                                                           */
/*****************************************************************************/
#define HIGH_BIT_MASK		(*((long *) (pcHeap + offHighBitMask)))		 /* macro to access into heap	     */
#define X_HIGH_BIT_MASK		(*((long *) (pcHeap + offXHighBitMask)))
#define X_BYTE_LENGTH		(*((long *) (pcHeap + offXByteLength)))
#define X_CTR			(*((long *) (pcHeap + offXCtr)))
#define SITE_CTR		(*((long *) (pcHeap + offSiteCtr)))
#define OFFSETS(x)		(*((long *) (pcHeap + offOffsets + (x) * LONG32_SIZE)))
#define BITOFFSETS(x)		(*((long *) (pcHeap + offBitOffsets + (x) * LONG32_SIZE)))
#define DCMR			(*((long *) (pcHeap + offDcmr)))
#define SCAN_INDEX_REG		(*((long *) (pcHeap + offScanIndexReg)))
#define LUT_ADDR		(*((long *) (pcHeap + offLutAddr)))
#define BIT_PLANE_ADDR(x)	(*((long *) (pcHeap + offBitPlaneAddr + (x) * LONG32_SIZE)))
#define NEXT_WORD_ADDR(x)	(*((long *) (pcHeap + offNextWordAddr + (x) * LONG32_SIZE)))
#define PLANE_WORD(x)		(*((long *) (pcHeap + offPlaneWord + (x) * LONG32_SIZE)))
#define EVENT_COUNT(x)		(*((long *) (pcHeap + offEventCount + (x) * LONG32_SIZE)))
#define TBUS_DATA		(*((long *) (pcHeap + offTbusData)))
#define TBUS_ADDR		(*((long *) (pcHeap + offTbusAddr)))
#define FRAME			(*((long *) (pcHeap + offFrame)))
#define SIOREG			(*((long *) (pcHeap + offSIOR)))
#define UPDATE_SITE_CODE	(*((long *) (pcHeap + offUpdateSiteProc)))
/*****************************************************************************/
/*                                                                           */
/* The following define the SymbolTable - a structure used by the register   */
/* manager to keep track of which of the heap "variables" are in registers.  */
/*                                                                           */
/*****************************************************************************/
struct tag_SymTableEntry {
     INT16	nPriority;							 /* For register manager 	     */
     INT16	nHeapOffset;							 /* Offset from beginning of heap    */
     REGISTER	regLoc; 							 /* which reg, if any, has this var  */
#define VOLATILE		1						 /* Priority values for nPriority    */
#define TEMP			2						 /* field of SymbolTable. Used by    */
#define LOOP_CTR		3						 /* register manager. 		     */
#define GLOBAL			4
extern struct tag_SymTableEntry		SymbolTable[];				 /* The SymbolTable 		     */
extern const LONG32 iHighBitMask;						 /* Use these as indexes into  	     */
extern const LONG32 iXHighBitMask;						 /* SymbolTable 		     */
extern const LONG32 iXByteLength;
extern const LONG32 iXCtr;
extern const LONG32 iSiteCtr;
extern const LONG32 iOffsets;
extern const LONG32 iBitOffsets;
extern const LONG32 iDcmr;
extern const LONG32 iScanIndexReg;
extern const LONG32 iLutAddr;
extern const LONG32 iBitPlaneAddr;
extern const LONG32 iNextWordAddr;
extern const LONG32 iPlaneWord;
extern const LONG32 iEventCount;
extern const LONG32 iGlueData;
extern const LONG32 iUnGlueData;
extern const LONG32 iSiteDataSrc;
extern const LONG32 iTbusData;
extern const LONG32 iLutData;
extern const LONG32 iTbusAddr;
extern const LONG32 iFrame;
extern const LONG32 iSIOR;
extern const LONG32 iUpdateSiteProc;
extern const LONG32 iTemp1;
extern const LONG32 iTemp2;
extern const LONG32 iTemp3;
extern const LONG32 iTemp4;
extern const LONG32 iTemp5;
extern const LONG32 iTemp6;
extern const LONG32 iTemp7;
extern const LONG32 iTemp8;
extern const LONG32 iTemp9;
extern const LONG32 iTemp10;
#endif INTERPRETER
#endif
#include <strings.h>
#include <setjmp.h>
#include "global.h"
#include "errmgr.h"
#include "memmgr.h"
#include "steplist.h"
#include "hinterface.h"
#define MODULE_NAME	"Host Interface"
INTERFACE_REGS cam8sim_iregs;							/* CAM8 Interface registers	     */
jmp_buf cam8sim_exception;							/* Execution frame for exceptions    */
void ResetInterface(void)
  /* Zero everything out to start off */
  bzero((char *) &cam8sim_iregs, sizeof(cam8sim_iregs));
  /* Enable all interrupts and exceptions */
  cam8sim_iregs.RER = CAM_ENABLE_NEWLIST_INT | CAM_ENABLE_TIMEOUT_INT |
              CAM_ENABLE_SBUS_INT | CAM_ENABLE_CAM_INT |
	      CAM_ENABLE_SOFT_INT | CAM_ENABLE_TIMEOUT_EXC |
	      CAM_ENABLE_CAMINT_EXC;
  /* Mark all interrupts as enabled */
  cam8sim_iregs.ISR = CAM_ENABLE_NEWLIST_INT | CAM_ENABLE_TIMEOUT_INT |
              CAM_ENABLE_SBUS_INT | CAM_ENABLE_CAM_INT |
	      CAM_ENABLE_SOFT_INT;
  /* Put us in wait-for-host mode */
  cam8sim_iregs.NLP |= CAM_WAIT_FOR_HOST;
void Generate_Interrupt(int type)
  cam8sim_iregs.ISR |= type;
  switch(type) {
  case CAM_CAM_INT_STATUS: {
    if ((cam8sim_iregs.RER & CAM_ENABLE_CAMINT_EXC) && !(cam8sim_iregs.RER & CAM_DISABLE_CAMINT_EXC)) {
      cam8sim_iregs.NLP |= CAM_EXCEPTION_STATUS;
      longjmp(cam8sim_exception, 1);
    }
    break;
  case CAM_TIMEOUT_INT_STATUS: {
    if ((cam8sim_iregs.RER & CAM_ENABLE_TIMEOUT_EXC) && !(cam8sim_iregs.RER & CAM_DISABLE_TIMEOUT_EXC)) {
      cam8sim_iregs.NLP |= CAM_EXCEPTION_STATUS;
      longjmp(cam8sim_exception, 1);
    }
    break;
#ifndef _H_INTERFACE_
#define _H_INTERFACE_
#include "global.h"
void InitInterface(void);
int ReadInterfaceRegs(void);
void Generate_Interrupt(int);
typedef struct interface_registers {
    
  LONG32 NLP;                          /* Next List Pointer            */
  LONG32 ISR;                          /* Reset/Interrupt Register     */
  LONG32 CIP;                          /* Current Instruction Pointer  */
  LONG32 PIP;                          /* Previous Instruction Pointer */
    
  LONG32 RER;                          /* Reset/Enable Register        */
  LONG32 DSL;                          /* Display Scan Length          */
  LONG32 DBL;                          /* Display Blank Length         */
} INTERFACE_REGS;
extern INTERFACE_REGS cam8sim_iregs;
extern int sim_infd, sim_outfd;
/* NLP/NLP */
#define CAM_INTERFACE_HALTED    0x00000008 /* Interface Halted?            */
#define CAM_WAIT_FOR_HOST       0x00000004 /* CAM waiting for host? status */
#define CAM_EXCEPTION_STATUS    0x00000002 /* Interface Exception status   */
#define CAM_NLP_WRITTEN         0x00000001 /* CAM NLP written? status      */
/* ISR/RER */
#define CAM_INT_PENDING_STATUS  0x0000001F /* Status of all Interrupt Bits */
#define CAM_NEWLIST_INT_STATUS  0x00000010 /* Status new-list interrupt    */
#define CAM_TIMEOUT_INT_STATUS  0x00000008 /* Status timeout interrupt     */
#define CAM_SBUS_INT_STATUS     0x00000004 /* Status Sbus interrupt        */
#define CAM_CAM_INT_STATUS      0x00000002 /* Status CAM interrupt         */
#define CAM_SOFT_INT_STATUS     0x00000001 /* Status interrupt             */
#define CAM_RESET_INTERFACE     0x80000000 /* Reset the interface          */
#define CAM_HALT_INTERFACE      0x00008000 /* Halt the interface           */
#define CAM_CLEAR_EXCEPTION     0x00004000 /* Clear exceptions (enable     */
					   /* exceptions caused by timeout)*/
#define CAM_ENABLE_TIMEOUT_EXC  0x00004000 /* enable exceptions caused     */
					   /* by timeout (clear exceptions)*/
#define CAM_RESUME_AFTER_ERR    0x00002000 /* Resume after error ack       */
					   /* (enable exceptions by CAM    */
					   /* interrupt)                   */
#define CAM_ENABLE_CAMINT_EXC   0x00002000 /* enable exceptions by CAM     */
					   /* interrupt (resume after      */
					   /* error ack)                   */
#define CAM_ENABLE_NEWLIST_INT  0x00001000 /* Enable new-list interrupt    */
#define CAM_ENABLE_TIMEOUT_INT  0x00000800 /* Enable timeout interrupt     */
#define CAM_ENABLE_SBUS_INT     0x00000400 /* Enable Sbus interrupt        */
#define CAM_ENABLE_CAM_INT      0x00000200 /* Enable CAM interrupt         */
#define CAM_ENABLE_SOFT_INT     0x00000100 /* Enable soft interrupt        */
#define CAM_DISABLE_TIMEOUT_EXC 0x00000040 /* Disable new-list interrupt   */
#define CAM_DISABLE_CAMINT_EXC  0x00000020 /* Disable timeout interrupt    */
#define CAM_DISABLE_NEWLIST_INT 0x00000010 /* Disable new-list interrupt   */
#define CAM_DISABLE_TIMEOUT_INT 0x00000008 /* Disable timeout interrupt    */
#define CAM_DISABLE_SBUS_INT    0x00000004 /* Disable Sbus interrupt       */
#define CAM_DISABLE_CAM_INT     0x00000002 /* Disable CAM interrupt        */
#define CAM_DISABLE_SOFT_INT    0x00000001 /* Disable soft interrupt       */
/* CIP/DSL */
#define CAM_TRANSFER_WAITING   0x00000008  /* Is CAM waiting to transfer?  */
#define CAM_DONE_STATUS        0x00000004  /* CAM Done status              */
#define CAM_PARTIAL_WRITE      0x00000002  /* Partial write after Sbus err?*/
#define CAM_FSM_SUSPENDED      0x00000001  /* Is Sbus FSM suspended?       */
/* PIP/DBL */
#define CAM_INTRFC_RESET_PNDNG 0x00000008  /* Interface reset pending?     */
#define CAM_SS2                0x00000004  /* CAM SS2 mode set?            */
#define CAM_SCANNING_STATUS    0x00000002  /* CAM scanning status          */
#define CAM_INTERRUPT_STATUS   0x00000001  /* CAM interrupt status         */
#endif
#ifndef _H_INTERFACE_P_
#define _H_INTERFACE_P_
#endif
/*****************************************************************************/
/*                                                                           */
/* Author	: Milan Shah						     */
/* Program	: Cam8Sim						     */
/* Date		: February 10, 1992					     */
/* Module	: icode.c - intermediate code generator and xlator	     */
/*                                                                           */
/*****************************************************************************/
#include "global.h"
#include "errmgr.h"
#include "memmgr.h"
#include "heap.h"
#include "regmgr.h"
#include "sparc_asm.h"
#include "icode.h"
#define MODULE_NAME	"Icode"
static CODEHANDLE hcodTarget = NULL;						 /* Handle to Target Code Location   */
static CODEPTR pcodNext = NULL;							 /* Pointer to location of next inst */
static CODELABEL lblNext = 0;							 /* Next Label 			     */
/*****************************************************************************/
/*                                                                           */
/* Interface to label managing routines. 				     */
/*                                                                           */
/*****************************************************************************/
struct tag_lblref;
struct tag_lblrec;
typedef struct tag_lblref LABELREF;						 /* record of a reference to a label */
typedef struct tag_lblrec LABELREC;						 /* record of a label 		     */
LABELREC *AddLabel(CODELABEL lblName, CODEPTR pcodLabelLoc, BOOL bValid);	 /* Add a new label record 	     */
LABELREC *FindLabel(CODELABEL lblName);						 /* Find a label 		     */
CODEPTR GetLabelAddress(LABELREC *plblrec);					 /* Returns label's address 	     */
void AddLabelRef(LABELREC *plblrec, CODEPTR lAddress);				 /* Add a reference to a label 	     */
void ResolveRefs(LABELREC *plblrec, CODEPTR lAddress);				 /* Resolve all references to a labl */
void FreeLabels(void);								 /* Free all storage used by labels  */
/*****************************************************************************/
/*                                                                           */
/* Routines to start and end code blocks, and emit instructions into code    */
/* blocks.								     */
/*                                                                           */
/*****************************************************************************/
void NewBlock(CODEHANDLE hcodDest)
     void pushblk(void);
     
     pushblk();									 /* save code block state 	     */
     hcodTarget = hcodDest;							 /* point to new code block 	     */
     pcodNext = *hcodDest;
     lblNext = 0;
/*****************************************************************************/
/*                                                                           */
/* Translate an intermediate instruction into target code. 		     */
/*                                                                           */
/*****************************************************************************/
void Emit(INT16 opcode,
	  BYTE op1Type, LONG32 op1,
	  BYTE op2Type, LONG32 op2,
	  BYTE destType, LONG32 dest)
     char *szFuncName = "Emit";
     
#ifdef DEBUG
     DASMADDR = pcodNext;
#endif
     if (opcode & NATIVE_OP) {							 /* NATIVE INSTRUCTION 		     */
	  REGISTER rs1, rs2, rd;						 
	  switch (op1Type) {							 /* Figure out rs1 		     */
	     case NULL_OP:
	       rs1 = REG_G0;
	       break;
	     case REG_OP:
	       rs1 = (REGISTER) op1;
	       break;
	     case VAR_OP:
	       rs1 = GetReg(op1, CURRENT_HANDLE, TRUE);
	       break;
	     default:
	       CRITICAL_ERROR("Invalid argument for rs1", szFuncName);
	       break;
	  }
	  switch (destType) {							 /* Figure out the dest register     */
	     case NULL_OP:
	       rs1 = REG_G0;
	       break;
	     case REG_OP:
	       rd = (REGISTER) dest;
	       break;
	     case VAR_OP:
	       rd = GetReg(dest, CURRENT_HANDLE, FALSE);
	       break;
	     default:
	       CRITICAL_ERROR("Invalid argument for rd", szFuncName);
	       break;
	  }
	  switch (op2Type) {							 /* Figure out rs2. This is done     */
	     case REG_OP:							 /* last because rs2 might be a      */
	       rs2 = (REGISTER) op2;						 /* constant > 13 bits, and we might */
	       break;								 /* have to preload it into the dest */
	     case VAR_OP:
	       rs2 = GetReg(op2, CURRENT_HANDLE, TRUE);
	       break;
	     case CONST_OP:
	       if (((signed long) op2) > 4095 ||				 /* if op2 will not fit in 13 bits   */
		   ((signed long) op2) < -4096) {
		    EMIT( SETHI(HI22(op2), rd) );
		    EMIT( OR_REG_IMM(rd, LOW10(op2), rd) );
		    op2Type = REG_OP;
		    rs2 = rd;
	       }
	       break;
	       
	     default:
	       CRITICAL_ERROR("Invalid argument for rs2", szFuncName);
	       break;
	  }
	  opcode = opcode & NATIVE_OP_MASK;					 /* extract the target's native op-  */
										 /* code... 			     */
	  if (op2Type == CONST_OP) {
	       *pcodNext++ = FMT3_INST(0x02L, opcode, rs1, IMMEDIATE, op2, rd);	 /* and emit the instruction 	     */
	  } else {
	       *pcodNext++ = FMT3_INST(0x02L, opcode, rs1, REG_SOURCE, rs2, rd);
	  }									 /* -------------------------------- */
     } else if (opcode & LD_ST_OP) {						 /* LOAD-STORE INSTRUCTION 	     */
	  REGISTER rs1, rs2, rd;
	  switch (opcode) {
	     case LDW_MEM:							 /* bring op1 into a register 	     */
	       if (op1Type == VAR_OP) {
		    rs1 = GetReg(op1, CURRENT_HANDLE, TRUE);
	       } else {
		    CRITICAL_ERROR("Invalid LDW_MEM argument",
				   szFuncName);
	       }
	       break;
	     case LDUB_IND:
	     case LDHW_IND:
	     case LDW_IND:							 /* load indirect : dest <- [op1+op2]*/
	       if (op1Type == VAR_OP) {
		    rs1 = GetReg(op1, CURRENT_HANDLE, TRUE);
	       } else if (op1Type == REG_OP) {
		    rs1 = (REGISTER) op1;
	       } else {
		    CRITICAL_ERROR("Invalid LDW_IND argument 1",
				   szFuncName);
	       }
	       if (op2Type == VAR_OP) {
		    rs2 = GetReg(op2, CURRENT_HANDLE, TRUE);
	       } else if (op2Type == REG_OP) {
		    rs2 = (REGISTER) op2;
	       } else if (op2Type == CONST_OP) {
		    /* do nothing */
	       } else {
		    CRITICAL_ERROR("Invalid LDW_IND argument 2",
				   szFuncName);
	       }
		    
	       if (destType == VAR_OP) {
		    rd = GetReg(dest, CURRENT_HANDLE, FALSE);
	       } else if (op2Type == REG_OP) {
		    rd = (REGISTER) dest;
	       } else {
		    CRITICAL_ERROR("Invalid LDW_IND argument",
				   szFuncName);
	       }
	       
	       if (opcode == LDW_IND) {
		    (op2Type == CONST_OP) ? (EMIT( LDW_REG_IMM(rs1, op2, rd) )) :
		      (EMIT( LDW_REG_REG(rs1, rs2, rd)));
	       } else if (opcode == LDHW_IND) {
		    (op2Type == CONST_OP) ? (EMIT( LDHW_REG_IMM(rs1, op2, rd) )) :
		      (EMIT( LDHW_REG_REG(rs1, rs2, rd)));	
	       } else {
		    (op2Type == CONST_OP) ? (EMIT( LDUB_REG_IMM(rs1, op2, rd) )) :
		      (EMIT( LDUB_REG_REG(rs1, rs2, rd) ));
	       }
	       break;
	       
	     case STW_MEM:							 /* flush op1 to memory 	     */
	       if (op1Type == VAR_OP) {
		    rs1 = GetReg(op1, CURRENT_HANDLE, TRUE);			 /* 	hopefully, op1 is already    */
		    FlushReg(rs1, CURRENT_HANDLE);				 /* 	in a register!		     */
	       } else {
		    CRITICAL_ERROR("Invalid STW_MEM argument",
				   szFuncName);
	       }
	       break;
	     case STUB_IND:
	     case STHW_IND:
	     case STW_IND:							 /* store indirect: [op1+op2] <- dest*/
	       if (op1Type == VAR_OP) {						 /* 	get op1 - var or reg 	     */
		    rs1 = GetReg(op1, CURRENT_HANDLE, TRUE);
	       } else if (op1Type == REG_OP) {
		    rs1 = (REGISTER) op1;
	       } else {
		    CRITICAL_ERROR("Invalid STW_IND argument",
				   szFuncName);
	       }
	       if (op2Type == VAR_OP) {						 /* 	get op2 - var, reg, or const */
		    rs2 = GetReg(op2, CURRENT_HANDLE, TRUE);
	       } else if (op2Type == REG_OP) {
		    rs2 = (REGISTER) op2;
	       } else if (op2Type == CONST_OP) {
		    /* do nothing */
	       } else {
		    CRITICAL_ERROR("Invalid LDW_IND argument 2",
				   szFuncName);
	       }
		    
	       if (destType == VAR_OP) {					 /* 	get dest - var or reg 	     */
		    rd = GetReg(dest, CURRENT_HANDLE, TRUE);
	       } else if (op2Type == REG_OP) {
		    rd = (REGISTER) dest;
	       } else {
		    CRITICAL_ERROR("Invalid STW_IND argument",
				   szFuncName);
	       }
	       if (opcode == STW_IND) {
		    (op2Type == CONST_OP) ? (EMIT( STW_REG_IMM(rs1, op2, rd))) :
		      (EMIT( STW_REG_REG(rs1, rs2, rd)));
	       } else if (opcode == STHW_IND) {
		    (op2Type == CONST_OP) ? (EMIT( STHW_REG_IMM(rs1, op2, rd))) :
		      (EMIT( STHW_REG_REG(rs1, rs2, rd)));
	       } else {
		    (op2Type == CONST_OP) ? (EMIT( STUB_REG_IMM(rs1, op2, rd))) :
		      (EMIT( STUB_REG_REG(rs1, rs2, rd)));
	       }
	       break;
	       
	     default:
	       CRITICAL_ERROR("Unknown Load Store operation",
			      szFuncName);
	       break;
	  }									 /* -------------------------------- */
     } else if (opcode & BRANCH_OP) {						 /* BRANCH INSTRUCTION 		     */
	  LABELREC	*plblrecBranch;
	  LONG32	lDisp;
	  opcode &= NATIVE_OP_MASK;						 /* extract the native branch code   */
	  if (op1Type == LABEL_OP) {
	       if ((plblrecBranch = FindLabel((CODELABEL) op1)) != NULL) {	 /* if label was encountered before  */
		    CODEPTR pcodBranchLoc = GetLabelAddress(plblrecBranch);	 /*     Get address of branch loc    */
		    if (!pcodBranchLoc) {					 /* 	if label's addrss is unknown */
			 AddLabelRef(plblrecBranch, CURRENT_LOC);		 /* 	   add a ref record. 	     */
			 lDisp = 0;						 /* 	   dummy disp 		     */
		    } else {							 /*     else label's addr is known   */
			 lDisp = pcodBranchLoc - CURRENT_LOC;			 /*        calculate displacement    */
		    }
		    EMIT( BRANCH_INST(0, opcode, lDisp) );			 /* 	Emit branch instruction      */
	       } else {								 /* Label was not encountered before */
		    plblrecBranch = AddLabel((CODELABEL) op1, 0, FALSE);	 /* 	So create new record 	     */
		    AddLabelRef(plblrecBranch, CURRENT_LOC);			 /* 	add a ref record to it 	     */
		    EMIT( BRANCH_INST(0, opcode, 0) );				 /* 	emit filler branch instr     */
	       }
	  } else {
	       CRITICAL_ERROR("Branch to a non-label", szFuncName);
	  }									 /* -------------------------------- */
     } else {									 /* PSEUDO INSTRUCTION 		     */
	  switch (opcode) {
	     case INSTR:							 /* op1 is a valid sparc instruction */
	       EMIT( op1 );							 /* 	simply insert it 	     */
	       break;								 /* 	useful to fill delay slots   */
	       
	     case ENTER_PROC:							 /* procedure entry prologue 	     */
	       PushRegWindow();							 /*     Inform register manager of   */
	       if (op1Type == CONST_OP) {					 /*     new register window 	     */
		    EMIT( SAVE_REG_IMM(REG_SP, -112-8-op1, REG_SP) );		 /* 	-112 is gcc's local frame    */
	       } else {								 /*     and we need 2 words to save  */
		    EMIT( SAVE_REG_IMM(REG_SP, -112-8, REG_SP) );		 /* 	our own fp and return addr   */
	       }								 /*     registers. 		     */
	       EMIT( STW_REG_IMM(REG_SP, 72, REG_G7) );				 /* 	sp+8 = our fp register       */
	       EMIT( STW_REG_IMM(REG_SP, 68, REG_RA) );				 /* 	sp+4 = our return address    */
	       EMIT( SETHI(HI22(pcHeap), REG_DS) );				 /* 	make ds point to heap base   */
	       if ( LOW10(pcHeap) != 0) {
		    EMIT( OR_REG_IMM(REG_DS, LOW10(pcHeap), REG_DS) );
	       }
	       break;
	       
	     case RETURN_PROC:							 /* return from procedure 	     */
	       PopRegWindow(CURRENT_HANDLE);					 /* 	restore reg. window 	     */
	       EMIT( LDW_REG_IMM(REG_SP, 72, REG_G7) );				 /* 	restore saved fp register    */
	       EMIT( LDW_REG_IMM(REG_SP, 68, REG_RA) );				 /* 	restore our return address   */
	       EMIT( RET );							 /* 	return from procedure	     */
	       EMIT( RESTORE );							 /* 	and restore the reg window   */
	       break;
	       
	     case CALL_PROC:							 /* call a procedure 		     */
	       if (op1Type == ADDR_OP) {
		    op1 -= (LONG32) pcodNext;
		    EMIT( CALL(op1) );						 /* 	call procedure at addr op1   */
	       } else {
		    CRITICAL_ERROR("Invalid procedure call", szFuncName);
	       }
	       break;
	     case ENTER_LEAF:							 /* leaf procedure entry 	     */
	       SaveRegState();							 /*     Save all the live registers  */
	       break;
	     case RETURN_LEAF:							 /* return from leaf procedure 	     */
	       RestoreRegState(CURRENT_HANDLE);					 /*  	Restore live registers	     */
	       EMIT( RETL );							 /*     return to caller 	     */
	       EMIT( NOP );							 /* 	delay slot 		     */
	       break;
	       
	     case CALL_LEAF:							 /* call a leaf procedure 	     */
	       if (op1Type == ADDR_OP) {
		    EMIT( SETHI(HI22(op1), REG_RA) );
		    EMIT( CALL_REG_IMM(REG_RA, LOW10(op1)) );
	       } else {
		    CRITICAL_ERROR("Invalid leaf procedure call",
				   szFuncName);
	       }
	       break;
	     case CALL_LEAF_IND: {
		  REGISTER rs1, rs2, rd;
		  
		  if (op1Type == VAR_OP) {
		       rs1 = GetReg(op1, CURRENT_HANDLE, TRUE);
		  } else {
		       CRITICAL_ERROR("Invalid op1 : indirect leaf procedure call",
				      szFuncName);
		  }
		  if (op2Type == CONST_OP) {
		       /* do nothing */
		  } else if (op2Type != NULL_OP) {
		       CRITICAL_ERROR("Invalid op2 : indirect leaf procedure call",
		       		      szFuncName);
		  } 
		  
		  EMIT( CALL_REG_IMM(rs1, op2) );
	       }
	       break;
		       
		       
	     case ENTER_BASICBLK:
	       SaveRegState();
	       break;
	     case RETURN_BASICBLK:
	       RestoreRegState(CURRENT_HANDLE);
	       break;
	       
	     case ADD_LABEL:							 /* define a label 		     */
	       if (op1Type == LABEL_OP) {
		    LABELREC *plblrec;
		    
		    if ((plblrec = FindLabel((CODELABEL) op1)) == NULL) {	 /* 	if first time seeing label   */
			 AddLabel((CODELABEL) op1, CURRENT_LOC, TRUE);		 /* 	   add a new label record    */
		    } else {							 /* 	else  			     */
			 ResolveRefs(plblrec, CURRENT_LOC);			 /* 	   resolve all refs to label */
		    }
	       } else {
		    CRITICAL_ERROR("Invalid operand to ADD_LABEL",		
				   szFuncName);
	       }
	       break;
	     case NO_OP:
	       EMIT( NOP );
	       break;
	       
	     default:
	       CRITICAL_ERROR("Unknown pseudo-op", szFuncName);
	       break;
     }
CODELABEL NewLabel()
     return (lblNext++);
void EndBlock()
     void popblk(void);
     FreeLabels();								 /* Free up all label records 	     */
     *pcodNext = 0L;								 
     *hcodTarget = pcodNext;							 /* Update caller's code handle      */
     popblk();									 /* Restore previous block state     */
/*****************************************************************************/
/*                                                                           */
/* Utilities for managing labels and references to labels.		     */
/*                                                                           */
/*****************************************************************************/
struct tag_lblref {
     CODEPTR	pcodRefLoc;
     struct tag_lblref *prefNext;
struct tag_lblrec {
     INT16	lblName;
     BYTE	bValid;
     CODEPTR	lAddress;
     struct tag_lblref *prefFirst;
     struct tag_lblrec *precNext;
static LABELREC *plblrecFirst = NULL;
LABELREC *AddLabel(CODELABEL lblName, CODEPTR pcodLabelLoc, BOOL bValid)
     LABELREC	*plblrecNew;
     plblrecNew = (LABELREC *) MALLOC(sizeof(LABELREC), "AddLabel");
     plblrecNew->lblName = lblName;
     if ((plblrecNew->bValid = bValid) == TRUE) {
	  plblrecNew->lAddress = pcodLabelLoc;
     }
     plblrecNew->precNext = plblrecFirst;
     plblrecNew->prefFirst = NULL;
     plblrecFirst = plblrecNew;
     return (plblrecNew);
LABELREC *FindLabel(CODELABEL lblName)
     LABELREC *plblrecNext;
     for (plblrecNext = plblrecFirst;
	  (plblrecNext != NULL) && (plblrecNext->lblName != lblName);
	  plblrecNext = plblrecNext->precNext);
     return (plblrecNext);
CODEPTR GetLabelAddress(LABELREC *plblrec)
     if (plblrec->bValid) {
	  return (plblrec->lAddress);
     } else {
	  return (NULL);
     }
void AddLabelRef(LABELREC *plblrec, CODEPTR lAddress)
     LABELREF *prefNew;
     prefNew = (LABELREF *) MALLOC(sizeof(LABELREF), "AddLabelRef");
     prefNew->pcodRefLoc = lAddress;
     prefNew->prefNext = plblrec->prefFirst;
     plblrec->prefFirst = prefNew;
void ResolveRefs(LABELREC *plblrec, CODEPTR lAddress)
     if (plblrec->bValid == TRUE) {
	  WARNING("Possible redefinition of label", "ResolveRefs");
     } else {
	  LABELREF *prefNext;
	  CODEPTR pcodRefLoc;
	  LONG32 lDisp;
	  plblrec->bValid = TRUE;						 /* update label record for future   */
	  plblrec->lAddress = lAddress;						 /* reference resolutions 	     */
	  do {									 /* Now, update all references.      */
	       prefNext = plblrec->prefFirst;					 /* Assume at least one reference!   */
	       pcodRefLoc = prefNext->pcodRefLoc;				 
	       lDisp = lAddress - pcodRefLoc;					 /* calculate displacement 	     */
	       lDisp &= 0x3FFFFF;						 /* least sig 22 bits only 	     */
	       *pcodRefLoc |= lDisp;						 /* and patch the refering instruct  */
	       plblrec->prefFirst = prefNext->prefNext;
	       FREE(prefNext, "ResolveRefs");					 /* release the reference record     */
	  } while (plblrec->prefFirst != NULL);
     }
     
void FreeLabels()
     LABELREC *plblrec;
     while (plblrecFirst != NULL) {
	  plblrec = plblrecFirst;
	  plblrecFirst = plblrec->precNext;
	  FREE(plblrec, "FreeLabels");
     }
/*****************************************************************************/
/*                                                                           */
/* Simple stack manager for pushing and pop-ing code block states.	     */
/*                                                                           */
/*****************************************************************************/
struct tag_codeblk {
     CODEHANDLE hcodTarget;
     CODEPTR    pcodNext;
     CODELABEL	lblNext;
     LABELREC   *plblrecFirst;
     struct tag_codeblk *pblkPrev;
typedef struct tag_codeblk	CODEBLK;
static CODEBLK *pblkTOS = NULL;
void pushblk()
     CODEBLK *pNew;
     pNew = MALLOC(sizeof(CODEBLK), "icode : pushblk");
     pNew->hcodTarget = hcodTarget;
     pNew->pcodNext = pcodNext;
     pNew->lblNext = lblNext;
     pNew->plblrecFirst = plblrecFirst;
     
     pNew->pblkPrev = pblkTOS;
     pblkTOS = pNew;
     plblrecFirst = NULL;
void popblk()
     CODEBLK *pblkOld;
     if (!pblkTOS) {
	  CRITICAL_ERROR("I-Code Block stack underflow", "popblk");
     }
     hcodTarget = pblkTOS->hcodTarget;
     pcodNext = pblkTOS->pcodNext;
     lblNext = pblkTOS->lblNext;
     plblrecFirst = pblkTOS->plblrecFirst;
     pblkOld = pblkTOS;
     pblkTOS = pblkTOS->pblkPrev;
     FREE(pblkOld, "popblk");
/*****************************************************************************/
/*                                                                           */
/* Author	: Milan Shah						     */
/* Program	: Cam8Sim						     */
/* Date		: February 10, 1992					     */
/* Module	: icode.h - intermediate code interface.		     */
/*                                                                           */
/*****************************************************************************/
#ifndef _ICODE_
#define _ICODE_
#include "global.h"
typedef INT16	CODELABEL;
void 	NewBlock(CODEHANDLE hcodDest);
void	Emit(INT16 opcode,							 /* Emit instruction into hcodDest   */
	     BYTE op1Type, LONG32 op1,						 /* see the REG, LABEL, CONST, and   */
	     BYTE op2Type, LONG32 op2,						 /* ADDRESS macros below 	     */
	     BYTE destType, LONG32 dest);
CODELABEL NewLabel();
void 	EndBlock();
/*****************************************************************************/
/*                                                                           */
/* operand types to use when calling Emit()				     */
/*                                                                           */
/*****************************************************************************/
#define NULL_OP		0
#define REG_OP		1
#define CONST_OP	2
#define ADDR_OP		3
#define VAR_OP		4
#define LABEL_OP	5
/*****************************************************************************/
/*                                                                           */
/* op codes for emit							     */
/*                                                                           */
/*****************************************************************************/
#define PSEUDO_OP	0x8000
#define NATIVE_OP	0x4000
#define LD_ST_OP	0x2000
#define BRANCH_OP	0x1000
#define NATIVE_OP_MASK	0x3F
#define INSTR		(PSEUDO_OP | 0xFF)
#define ENTER_PROC	(PSEUDO_OP | 0x01)
#define RETURN_PROC	(PSEUDO_OP | 0x02)
#define CALL_PROC	(PSEUDO_OP | 0x03)
#define ENTER_LEAF	(PSEUDO_OP | 0x04)
#define RETURN_LEAF	(PSEUDO_OP | 0x05)
#define CALL_LEAF	(PSEUDO_OP | 0x06)
#define CALL_LEAF_IND	(PSEUDO_OP | 0x07)
#define ENTER_BASICBLK	(PSEUDO_OP | 0x08)
#define RETURN_BASICBLK	(PSEUDO_OP | 0x09)
#define ADD_LABEL	(PSEUDO_OP | 0x0A)
#define NO_OP		(PSEUDO_OP | 0x0B)
#define LDW_MEM		(LD_ST_OP | 0x00)
#define LDW_IND		(LD_ST_OP | 0x01)
#define LDHW_IND	(LD_ST_OP | 0x02)
#define LDUB_IND	(LD_ST_OP | 0x03)
#define STW_MEM		(LD_ST_OP | 0x06)
#define STW_IND		(LD_ST_OP | 0x07)
#define STHW_IND	(LD_ST_OP | 0x08)
#define STUB_IND	(LD_ST_OP | 0x09)
#define ADD		(NATIVE_OP | 0x00)
#define ADDcc		(NATIVE_OP | 0x10)
#define ADDX		(NATIVE_OP | 0x08)
#define ADDXcc		(NATIVE_OP | 0x18)
#define	SUB		(NATIVE_OP | 0x04)
#define SUBcc		(NATIVE_OP | 0x14)
#define SUBX		(NATIVE_OP | 0x0C)
#define SUBXcc		(NATIVE_OP | 0x1C)
#define AND		(NATIVE_OP | 0x01)
#define ANDcc		(NATIVE_OP | 0x11)
#define ANDN		(NATIVE_OP | 0x05)
#define ANDNcc		(NATIVE_OP | 0x15)
#define OR		(NATIVE_OP | 0x02)
#define ORcc 		(NATIVE_OP | 0x12)
#define ORN		(NATIVE_OP | 0x06)
#define ORNcc		(NATIVE_OP | 0x16)
#define XOR		(NATIVE_OP | 0x03)
#define XORcc 		(NATIVE_OP | 0x13)
#define XNOR		(NATIVE_OP | 0x07)
#define XNORcc		(NATIVE_OP | 0x17)
#define SH_LEFT		(NATIVE_OP | 0x25)
#define SH_RIGHT	(NATIVE_OP | 0x26)
#define SH_RIGHT_ARITH	(NATIVE_OP | 0x27)
#define BRANCH		(BRANCH_OP | 0x08)
#define BR_NEVER	(BRANCH_OP | 0x00)
#define BR_NEQ		(BRANCH_OP | 0x09)
#define BR_EQ		(BRANCH_OP | 0x01)
#define BR_GR		(BRANCH_OP | 0x0A)
#define BR_LE		(BRANCH_OP | 0x02)
#define BR_GRE		(BRANCH_OP | 0x0B)
#define BR_L		(BRANCH_OP | 0x03)
#define BR_GU		(BRANCH_OP | 0x0C)
#define BR_LEU		(BRANCH_OP | 0x04)
#define BR_CC		(BRANCH_OP | 0x0D)
#define BR_CS		(BRANCH_OP | 0x05)
#define BR_POS		(BRANCH_OP | 0x0E)
#define BR_NEG		(BRANCH_OP | 0x06)
#define BR_VC		(BRANCH_OP | 0x0F)
#define BR_VS		(BRANCH_OP | 0x07)
#define BR_NZ		(BRANCH_OP | 0x09)
#define BR_Z		(BRANCH_OP | 0x01)
#endif

---------------------------------------------------------------------------

/*****************************************************************************/
/*                                                                           */
/* main.c:	modifications to original code made by Harris L. Gilliam     */
/*		March 1994 - June 1995					     */
/*                                                                           */
/*****************************************************************************/
/*                                                                           */
/* Author	: Milan Shah						     */
/* Program	: Cam8Sim						     */
/* Date		: February 18, 1992					     */
/* Module	: main.c 						     */
/*                                                                           */
/*****************************************************************************/
#include <CAM/CAM.h>
#include <CAM/CAM_err.h>
#include <stdio.h>
#include <signal.h>
#include "global.h"
#include "errmgr.h"
#include "heap.h"
#include "sim.h"
#include "steplist.h"
#include "hinterface.h"
#define MODULE_NAME	"main"
void ReadCmdLine(int argc, char *argv[]);
void InitExitProcs(), InitStepList();
#ifdef DEBUG
FILE *DEBUGFILE = (FILE *) NULL;
char *REGNAMES[] = {
  "select", "run", "kick", "sa-bit", "lut-src", "fly-src", "site-src", "event-src", "display", "show-scan", "event",
  "lut-index", "lut-perm", "lut-io", "scan-index", "scan-perm", "scan-io", "scan-format", "offset", "dimension",
  "environment", "multi", "connect", "module-id", "group-id", "int-enable", "int-flags", "verify", "dram-count"
  };
#ifndef INTERPRETER
CODEPTR DASMADDR;
#endif INTERPRETER
#endif
int main(int argc, char *argv[])
#ifdef DEBUG
  int i;
#endif
#ifndef INTERPRETER
  InitSymbolTable();
#endif INTERPRETER
  InitExitProcs();
  InitHeap();
#ifndef INTERPRETER
  InitSim();
#endif INTERPRETER
  InitInterface();
  InitStepList();
  ReadCmdLine(argc, argv);
     
#ifdef DEBUG
  DEBUGFILE = fopen("./sim.log", "w");
#endif
  while (ReadInterfaceRegs() > -1) {}
  exit(0);
     
     
void ReadCmdLine(int argc, char *argv[])
  register int i;
  for(i = 1; i < argc; i++) {
    if (strcmp(argv[i], "-g") == 0) {
      bForceGeneralScan = TRUE;
      continue;
    }
    if (strcmp(argv[i], "-fd") == 0) {
      sim_camfd = atoi(argv[i+1]);
      i++;
      continue;
    }
    if (strcmp(argv[i], "-in") == 0) {
      sim_infd = atoi(argv[i+1]);
      i++;
      continue;
    }
    if (strcmp(argv[i], "-out") == 0) {
      sim_outfd = atoi(argv[i+1]);
      i++;
      continue;
    }
    
void InitExitProcs()
#ifdef BADSIG
     const void * err = BADSIG;
#else
     const void * err = SIG_ERR;
#endif
     void ExitSigProc();
     void ExitProc();
#ifdef sun
#if 0
     on_exit(ExitProc);								 /* Make sure it gets called on exit */
#else
     atexit(ExitProc);								 /* Make sure it gets called on exit */
#endif
#endif
     
     if ( (signal(SIGHUP, ExitSigProc) == err) ||
	  (signal(SIGINT, SIG_IGN) == err) ||
	  (signal(SIGQUIT, SIG_IGN) == err) ||
	  (signal(SIGILL, ExitSigProc) == err) ||
	  (signal(SIGFPE, ExitSigProc) == err) ||
	  (signal(SIGBUS, ExitSigProc) == err) ||
	  (signal(SIGSEGV, ExitSigProc) == err) ||
	  (signal(SIGSYS, ExitSigProc) == err) ||
	  (signal(SIGPIPE, ExitSigProc) == err) ||
	  (signal(SIGTERM, ExitSigProc) == err) ) {
	  WARNING("Could not install cleanup routines!", "InitExitProc");
     }
#ifdef BADSIG
void ExitSigProc(int sig, int code, struct sigcontext *scp, char *addr)
#else
void ExitSigProc(int sig)
#endif
  static char *pcSignalName[] = {
    "Unknown",
    "Hangup",
    "Interrupt",
    "Quit",
    "Illegal Instruction",
    "Trace Trap",
    "IO (Hardware) Trap",
    "Emulator Trap",
    "Floating Point Exception",
    "Kill",
    "Bus Error",
    "Segmentation Fault",
    "Bad Argument to system call",
    "Write to broken pipe",
    "Alarm",
    "Software Termination",
    "User1",
    "User2",
    "Child Termination",
    "Power down"
  };
  fprintf(stderr, "CAM8SIM: ");
     
  switch (sig) {
  case SIGHUP:
  case SIGSYS:
  case SIGPIPE:
    fprintf(stderr, "%s signal received - exiting.\n", pcSignalName[sig]);
    break;
    
  case SIGILL:
  case SIGFPE:
#ifdef BADSIG
    fprintf(stderr, "Attempt to execute illegal instruction at 0x%x\n", addr);
#else
    fprintf(stderr, "Attempt to execute illegal instruction\n");
#endif
    break;
  case SIGBUS:
  case SIGSEGV:
#ifdef BADSIG
    fprintf(stderr, "Attempt to access invalid memory location 0x%x\n", addr);
#else
    fprintf(stderr, "Attempt to access invalid memory location\n");
#endif
    break;
  case SIGTERM:
    fprintf(stderr, "Termination signal received - exiting.\n");
    break;
  default:
    break;
#ifdef DEBUG
  fclose(DEBUGFILE);
#endif
  _exit(0);
void ExitProc()
#ifdef DEBUG
  fclose(DEBUGFILE);
#endif
gcc -E -dM -g -Dsun4 -DINTERPRETER -D_INCREMENTAL_COMPILE_ -I/cam8/working/include -o main.o -c main.c
/*****************************************************************************/
/*                                                                           */
/* Author 	: Milan Shah						     */
/* Program	: Cam8Sim						     */
/* Date		: February 6, 1992					     */
/* Module	: memmgr.c - memory manager interface with error reporting   */
/*                                                                           */
/*****************************************************************************/
#include <stdio.h>
#include <fcntl.h>
#include <malloc.h>
#include <sys/types.h>
#include <sys/mman.h>
#include <sys/ipc.h>
#include <sys/shm.h>
#include "memmgr.h"
#include "memmgrP.h"
void *mmpMemAlign(unsigned nAlignment,
		  unsigned nSize,
		  char *szModule,
		  char *szFunction)
     void *pRet;
     char *memalign(unsigned, unsigned);
     
     if ( !(pRet = (void *) memalign(nAlignment, nSize)) ) {
	  fprintf(stderr, "Error Allocating memory in %s : %s \n",
		  szModule, szFunction);
	  exit(2);
     }
     return (pRet);
void *mmpValloc(unsigned nSize, char *szModule, char *szFunction)
     void *pRet;
     char *valloc(unsigned size);
     if ( !(pRet = (void *) valloc(nSize)) ) {
	  fprintf(stderr, "Error Allocating memory in %s : %s \n",
		  szModule, szFunction);
	  exit(2);
     }
     return (pRet);
void *mmpMalloc(unsigned nSize, char *szModule, char *szFunction)
     void *pRet;
     if ( !(pRet = malloc(nSize)) ) {
	  fprintf(stderr, "Error Allocating memory in %s : %s \n",
		  szModule, szFunction);
	  exit(2);
     }
     return (pRet);
void *mmpRealloc(void *ptr, unsigned nSize, char *szModule, char *szFunction)
     void *pRet;
     if ( !(pRet = realloc(ptr, nSize)) ) {
	  fprintf(stderr, "Error Reallocating memory in %s : %s \n",
		  szModule, szFunction);
	  exit(2);
     }
     return (pRet);
int mmpFree(void *ptr, char *szModule, char *szFunction)
     free(ptr);
     return (1);
int mmpCreateShared(unsigned len, char *szModule, char *szFunction)
     int shmid;
     if ((shmid = shmget(IPC_PRIVATE, len, 0666 | IPC_CREAT)) == -1) {
	  fprintf(stderr,
		  "Error creating shared memory segment in %s : %s \n",
		  szModule, szFunction);
	  exit(2);
     }
     return (shmid);
void *mmpAllocShared(int shmid, unsigned len,
		     char *szModule, char *szFunction)
     void *pRet;
     
     if ((pRet = (void *) shmat(shmid, 0, 0)) == (char *) -1) {
	  fprintf(stderr,
		  "Error mapping shared memory segment in %s : %s \n",
		  szModule, szFunction);
	  exit(2);
     }
     
     return (pRet);
void mmpFreeShared(void *addr,
		   char *szModule, char *szFunction)
     if (shmdt(addr) != 0) {
	  fprintf(stderr,
		  "Error un-mapping shared memory segment in %s : %s \n",
		  szModule, szFunction);
	  exit(2);
     }
     
void mmpDestroyShared(int shmid, char *szModule, char *szFunction)
     if (shmctl(shmid, IPC_RMID, NULL)) {
	  fprintf(stderr,
		  "Error deleting shared memory segment in %s : %s \n",
		  szModule, szFunction);
     }
/*****************************************************************************/
/*                                                                           */
/* Author 	: Milan Shah						     */
/* Program	: Cam8Sim						     */
/* Date		: February 6, 1992					     */
/* Module	: memmgr.h - memory manager interface with error reporting   */
/*                                                                           */
/*****************************************************************************/
#ifndef _MEMMGR_
#define _MEMMGR_
#include "memmgrP.h"
#define MEMALIGN(align, size, funcName) mmpMemAlign((align), (size), (MODULE_NAME), (funcName))
#define VALLOC(size, funcName)		mmpValloc((size), (MODULE_NAME), (funcName))
#define MALLOC(size, funcName)		mmpMalloc((size), (MODULE_NAME), (funcName))
#define REALLOC(ptr, size, funcName)	mmpRealloc((ptr), (size), (MODULE_NAME), (funcName))
#define FREE(ptr, funcName)		mmpFree((ptr), (MODULE_NAME), (funcName))
#define CREATE_SHARED(len, funcName)		mmpCreateShared((len), (MODULE_NAME), (funcName))
#define ALLOC_SHARED(shmid, len, funcName) 	mmpAllocShared((shmid), (len), (MODULE_NAME), (funcName))
#define FREE_SHARED(addr, funcName)		mmpFreeShared((addr), (MODULE_NAME), (funcName))
#define DESTROY_SHARED(shmid, funcName)		mmpDestroyShared((shmid), (MODULE_NAME), (funcName));
#endif
/*****************************************************************************/
/*                                                                           */
/* Author 	: Milan Shah						     */
/* Program	: Cam8Sim						     */
/* Date		: February 6, 1992					     */
/* Module	: memmgrP.h - memory manager interface with error reporting  */
/*                Private Functions.                                         */
/*                                                                           */
/*****************************************************************************/
#ifndef _MEMMGR_P_
#define _MEMMGR_P_
void *mmpMemAlign(unsigned nAlignment, unsigned nSize,
		  char *szModule, char *szFunction);
void *mmpValloc(unsigned nSize, char *szModule, char *szFunction);
void *mmpMalloc(unsigned nSize, char *szModule, char *szFunction);
int  mmpFree(void *ptr, char *szModule, char *szFunction);
int  mmpCreateShared(unsigned len, char *szModule, char *szFunction);
void *mmpAllocShared(int shmid, unsigned len,
		     char *szModule, char *szFunction);
void mmpFreeShared(void *addr, char *szModule, char *szFunction);
void mmpDestroyShared(int shmid, char *szModule, char *szFunction);
#endif
/*****************************************************************************/
/*                                                                           */
/* Author	: Milan Shah						     */
/* Program	: Cam8Sim						     */
/* Date		: February 12, 1992					     */
/* Module	: regmgr.c - register allocator 			     */
/*                                                                           */
/*****************************************************************************/
#include "stdio.h"
#include "global.h"
#include "heap.h"
#include "errmgr.h"
#include "memmgr.h"
#include "sparc_asm.h"
#include "regmgr.h"
#ifdef DEBUG
static char REGISTERS[32][64] = {
  "G0", "G1", "G2", "G3", "G4", "G5", "G6", "G7",
  "O0", "O1", "O2", "O3", "O4", "O5", "O6", "O7",
  "L0", "L1", "L2", "L3", "L4", "L5", "L6", "L7",
  "I0", "I1", "I2", "I3", "I4", "I5", "I6", "I7",
extern char SYMBOLS[SymbolTableSize][64];
#endif
#define MODULE_NAME	"RegMgr"
#define MREGS	32
struct tag_regEntry {								 /* Describes register contents      */
     INT16	nVar;								 /*    Name (index) of variable      */
     INT16	nPriority;							 /*    Priority of variable 	     */
     INT16	nHeapOffset;							 /*    Offset into heap of variable  */
typedef struct tag_regEntry REGENTRY;
     
REGENTRY rCurrWindow[MREGS];
BYTE NumFreeRegs(void);
REGISTER GetFreeReg(void);
void FreeReg(REGISTER reg);
void ResetFreeQue(void);
REGISTER GetSpillable(void);
void InsertSpillable(REGISTER reg);
void ResetSpillQue(void);
REGISTER GetReg(INT16 nVar, CODEHANDLE hcodCurrent, BOOL bLoad)
     REGISTER reg;
     CODEPTR pcodNext;
     pcodNext = *hcodCurrent;
     
     if (SymbolTable[nVar].regLoc != 0) {					 /* if nVar is already in a register */
	  return (SymbolTable[nVar].regLoc);					 /* 	return the register 	     */
     }
     if (NumFreeRegs() != 0) {						 	 /* else if there is a free register */
	  reg = GetFreeReg();							 /* 	get free register 	     */
     } else {
	  reg = GetSpillable();							 /* else get a spillable register    */
#ifdef _INSTRUMENTATION_
	  fprintf(stderr, "Spilling Register : Variable %x : Priority %x\n",
		  	  rCurrWindow[reg].nVar,
		  	  rCurrWindow[reg].nPriority);
#endif	  
#ifdef DEBUG
	  fprintf(DEBUGFILE, "Spilling Register : Variable %s : Priority %x\n",
		  	  SYMBOLS[rCurrWindow[reg].nVar],
		  	  rCurrWindow[reg].nPriority);
#endif
	  SymbolTable[rCurrWindow[reg].nVar].regLoc = 0;			 /* 	Unmark old var's reg alias   */
	  EMIT(STW_REG_IMM(REG_DS, rCurrWindow[reg].nHeapOffset, reg));		 /* 	spill the register 	     */
     }
     
     SymbolTable[nVar].regLoc = reg;						 /* Update SymbolTable	    	     */
     rCurrWindow[reg].nVar = nVar;						 /* and Current Reg Window recs      */
     rCurrWindow[reg].nHeapOffset = SymbolTable[nVar].nHeapOffset;		 
     rCurrWindow[reg].nPriority = SymbolTable[nVar].nPriority;
     if (rCurrWindow[reg].nPriority != VOLATILE) {				 /* if nVar is not a VOLATILE        */
	  if (bLoad) {
	       EMIT(LDW_REG_IMM(REG_DS, rCurrWindow[reg].nHeapOffset, reg));	 /*    load it into reg	  	     */
	  }
	  InsertSpillable(reg);							 /*    and mark it as spillable	     */
     }
     *hcodCurrent = pcodNext;							 /* Update caller's code handle      */
#ifdef DEBUG
     fprintf(DEBUGFILE, "%s is in register %s\n", SYMBOLS[nVar],
	     REGISTERS[reg]);
     fflush(stderr);
#endif
     return (reg);
     
void FlushReg(REGISTER rFlush, CODEHANDLE hcodCurrent)
     CODEPTR 	pcodNext = *hcodCurrent;
     if (rCurrWindow[rFlush].nPriority != VOLATILE) {
	  EMIT(STW_REG_IMM(REG_DS, rCurrWindow[rFlush].nHeapOffset, rFlush));	 /* Store rFlush back to heap 	     */
	  *hcodCurrent = pcodNext;
     }
     SymbolTable[rCurrWindow[rFlush].nVar].regLoc = 0;
     FreeReg(rFlush);
void PushRegWindow()
     short i, j;
     SaveRegState();								 /* Save state of registers 	     */
     ResetFreeQue();
     ResetSpillQue();
     for (i = REG_L0; i <= REG_L7; i++) {					 /* Free all the new Local Registers */
	  SymbolTable[rCurrWindow[i].nVar].regLoc = 0;				 /* if nVar == 0, who cares? 	     */
	  FreeReg(i);
     }
     for (i = REG_O0, j = REG_I0; i <= REG_O5; i++, j++) {
	  SymbolTable[rCurrWindow[j].nVar].regLoc = 0;				 /* Vars in previous in register     */
										 /* become inaccessible 	     */
	  rCurrWindow[j] = rCurrWindow[i];					 /* Out registers become in regs     */
	  if (rCurrWindow[j].nVar != 0) {					 /* Update SymbolTable regLoc entries*/
	       SymbolTable[rCurrWindow[j].nVar].regLoc = j;			 /* for symbols in new In Registers  */
	       if (rCurrWindow[j].nPriority != VOLATILE) {			 /* if the var is also spillable,    */
		    InsertSpillable(j);						 /*    mark it as such 		     */
	       }
	  } else {								 /* If no symbol in new In Register, */
	       FreeReg(j);							 /* mark it as free 		     */
	  }
     }
     for (i = REG_O0; i <= REG_O5; i++) {					 /* Free all the new Out Registers,  */
	  SymbolTable[rCurrWindow[i].nVar].regLoc = 0;				 /* except SP and DS  		     */
	  FreeReg(i);
     }
     
     for (i = REG_G1; i <= REG_G6; i++) {					 /* Since we reset the free and spil */
	  if (rCurrWindow[i].nVar == 0) {					 /* queues, add unused global regs   */
	       FreeReg(i);							 /* to the appropriate queues 	     */
	  } else {
	       if (rCurrWindow[i].nPriority != VOLATILE) {
		    InsertSpillable(i);
	       }
	  }
     }
     
struct tag_regRec {
     REGENTRY rWindow[MREGS];
     struct tag_regRec *precPrev;
typedef struct tag_regRec REGREC;
REGREC *precTOS = NULL;
void PopRegWindow(CODEHANDLE hcodCurrent)					 /* Reverse the action of PushRegWi. */
{										 /* This window's local and out regs */
     short i, j;								 /* will go out of scope, so store   */
     CODEPTR pcodNext = *hcodCurrent;						 /* any vars in there back to heap   */
										 /* In regs of this window become out*/
     ResetFreeQue();								 /* regs of prev window 	     */
     ResetSpillQue();
     /* The following loop restores the local registers to the state of the  */
     /* parent's local registers. All vars in current local registers are    */
     /* stored back to heap, and their symbol table entries updated	     */
     for (i = REG_L0; i <= REG_L7; i++) {					 /* Restore local regs to state of   */
	  if (rCurrWindow[i].nVar != 0) {					 /* previous window 		     */
	       SymbolTable[rCurrWindow[i].nVar].regLoc = 0;
	       if (rCurrWindow[i].nPriority != VOLATILE) {			 /* if this window was using reg,    */
		    EMIT(STW_REG_IMM(REG_DS,					 /* update heap 		     */
				     rCurrWindow[i].nHeapOffset, i));
	       }
	  }
	  rCurrWindow[i] = precTOS->rWindow[i];					 /* Now, restore to state of prev    */
	  if (rCurrWindow[i].nVar != 0) {					 /* window 			     */
	       SymbolTable[rCurrWindow[i].nVar].regLoc = i;
	       if (rCurrWindow[i].nPriority != VOLATILE) {
		    InsertSpillable(i);
	       }
	  } else {
	       FreeReg(i);
	  }
     }
     /* The following loop stores all vars in OUT registers back to heap     */
     /* and updates their symbol table entries. At the end of this loop, all */
     /* OUT registers are marked as empty. 				     */
     for (i = REG_O0; i <= REG_O5; i++) {					 /* Store vars in OUT regs to heap   */
	  if (rCurrWindow[i].nVar != 0) {
	       SymbolTable[rCurrWindow[i].nVar].regLoc = 0;
	       if (rCurrWindow[i].nPriority != VOLATILE) {			 /* if this window was using reg,    */
		    EMIT(STW_REG_IMM(REG_DS,					 /* update heap 		     */
				     rCurrWindow[i].nHeapOffset, i));
	       }
	       rCurrWindow[i].nVar = 0;
	       rCurrWindow[i].nPriority = 0;
	       rCurrWindow[i].nHeapOffset = 0;
	  }
     }
     /* The following loop does two things: one, it restores the OUT reg     */
     /* to the parent's state; two, it leaves the IN registers empty. Since  */
     /* popping a reg window means that the current IN registers become the  */
     /* OUT registers, this loop must do both things simultaneously. Effect  */
     /* is that any vars in IN registers which are in the parent's OUT reg   */
     /* are simply marked to be in the OUT registers. Any vars in IN reg     */
     /* which are not in the the parent's OUT reg, are restored back to heap.*/
     /* At the end of this loop, the OUT regs are back to their parent's     */
     /* state, and all the IN regs are empty, either spilled or marked to    */
     /* to the OUT regs							     */
     for (i = REG_I0, j = REG_O0; i <= REG_I5; i++, j++) {
	  if (rCurrWindow[i].nVar == precTOS->rWindow[j].nVar) {		 /* if var in IN register was inh-   */
	       rCurrWindow[j] = rCurrWindow[i];					 /* erited from parent's OUT reg,    */
	       if (rCurrWindow[j].nPriority != VOLATILE) {			 /* restore it to out reg 	     */
		    InsertSpillable(j);
	       }
	       SymbolTable[rCurrWindow[j].nVar].regLoc = j;
	  } else {								 /* var not inherited from parent    */
	       if (rCurrWindow[i].nPriority != VOLATILE) {			 /* if var not volatile		     */
		    EMIT(STW_REG_IMM(REG_DS,					 /*    restore to heap 		     */
				     rCurrWindow[i].nHeapOffset, i));
	       }
	       SymbolTable[rCurrWindow[i].nVar].regLoc = 0;			 /* update symbol table 	     */
	       rCurrWindow[j] = precTOS->rWindow[j];				 /* restore parent's var 	     */
	       if (rCurrWindow[j].nVar != 0) {					 /* if parent had a var in reg 	     */
		    SymbolTable[rCurrWindow[i].nVar].regLoc = i;		 /*    update symbol table 	     */
		    if (rCurrWindow[i].nPriority != VOLATILE) {			 /*    and spill que 		     */
			 InsertSpillable(j);
		    }
	       } else {								 /* else parent had no var in reg    */
		    FreeReg(j);							 /*    so free it 		     */
	       }
	  }
	  rCurrWindow[i].nVar = 0;
	  rCurrWindow[i].nPriority = 0;
	  rCurrWindow[i].nHeapOffset = 0;
     }
     /* The following loop restores the IN regs to the state of the parents  */
     /* It assumes that all the IN regs are currently marked empty.	     */
     for (i = REG_I0; i <= REG_I5; i++) {					 /* Restore in registers to that of  */
	  rCurrWindow[i] = precTOS->rWindow[i];					 /* parent 			     */
	  if (rCurrWindow[i].nVar == 0) {
	       FreeReg(i);
	  } else {
	       if (rCurrWindow[i].nPriority != VOLATILE) {
		    InsertSpillable(i);
	       }
	       SymbolTable[rCurrWindow[i].nVar].regLoc = i;
	  }
     }
     
     for (i = REG_G1; i <= REG_G6; i++) {					 /* Since we reset the free and spil */
	  if (rCurrWindow[i].nVar == 0) {					 /* queues, add unused global regs   */
	       FreeReg(i);							 /* to the appropriate queues 	     */
	  } else {
	       if (rCurrWindow[i].nPriority != VOLATILE) {
		    InsertSpillable(i);
	       }
	  }
     }
     
     RestoreRegState(CURRENT_HANDLE);						 /* now, restore register state      */
     *hcodCurrent = pcodNext;
     
void SaveRegState()								 /* Take a snapshot of register      */
{										 /* contents. 			     */
     REGREC *precNew;
     precNew = (REGREC *) MALLOC(sizeof(REGREC), "SaveRegState");
     memcpy((char *)precNew, (char *)rCurrWindow, sizeof(REGREC));		 /* Ok, so this is a litte flaky     */
     precNew->precPrev = precTOS;
     precTOS = precNew;
void RestoreRegState(CODEHANDLE hcodCurrent)					 /* Restore state to snapshot. Only  */
{										 /* non-volatile priority registers  */
     CODEPTR pcodNext = *hcodCurrent;						 /* are guaranteed to be restored.   */
     short i;
     REGREC *precOld;
     /************************************************************************/
     /* First, save all the registers which have different variables than    */
     /* the parent.							     */
     /************************************************************************/
     
     for (i = REG_G1; i <= REG_I5; i++) {
	  if (rCurrWindow[i].nVar == 0) {
	       continue;
	  } else if (rCurrWindow[i].nVar != precTOS->rWindow[i].nVar) {
	       FlushReg(i, CURRENT_HANDLE);
	  }
     }
     /************************************************************************/
     /* Now, go through each register, and for all those registers which are */
     /* not in the same state as the parent, refresh the register	     */
     /************************************************************************/
     
     for (i = REG_G1; i <= REG_I5; i++) {
	  if (precTOS->rWindow[i].nVar == 0) {
	       continue;
	  } else if (    (precTOS->rWindow[i].nVar != rCurrWindow[i].nVar)
		      && (precTOS->rWindow[i].nPriority != VOLATILE)) {
	       EMIT( LDW_REG_IMM(REG_DS, precTOS->rWindow[i].nHeapOffset, i) );
	       rCurrWindow[i] = precTOS->rWindow[i];
	       SymbolTable[rCurrWindow[i].nVar].regLoc = i;
	  }
     }
	       
     /************************************************************************/
     /* Now, we need to refresh the state of the free and spill ques.	     */
     /************************************************************************/
     
     ResetFreeQue();
     ResetSpillQue();
     for (i = REG_L0; i <= REG_L7; i++) {
	  if (rCurrWindow[i].nVar == 0) {
	       FreeReg(i);
	  } else if (rCurrWindow[i].nPriority != VOLATILE) {
	       InsertSpillable(i);
	  }
     }
     for (i = REG_O0; i <= REG_O5; i++) {
	  if (rCurrWindow[i].nVar == 0) {
	       FreeReg(i);
	  } else if (rCurrWindow[i].nPriority != VOLATILE) {
	       InsertSpillable(i);
	  }
     }
     for (i = REG_I0; i <= REG_I5; i++) {
	  if (rCurrWindow[i].nVar == 0) {
	       FreeReg(i);
	  } else if (rCurrWindow[i].nPriority != VOLATILE) {
	       InsertSpillable(i);
	  }
     }
     for (i = REG_G1; i <= REG_G6; i++) {
	  if (rCurrWindow[i].nVar == 0) {
	       FreeReg(i);
	  } else if (rCurrWindow[i].nPriority != VOLATILE) {
	       InsertSpillable(i);
	  }
     }
     *hcodCurrent = pcodNext;
     precOld = precTOS;
     precTOS = precTOS->precPrev;
     FREE(precOld, "RestoreRegState");
}			 
void InitRegMgr()
     short i;
     REGENTRY rentNull = {0, 0, 0};
     REGREC *precOld;
     for (i = 0; i < MREGS; i++) {						 /* Mark all register entries as     */
	  rCurrWindow[i] = rentNull;						 /* NULL 			     */
     }
     while (precTOS) {								 /* Free up stack of saved states    */
	  precOld = precTOS;
	  precTOS = precTOS->precPrev;
	  FREE(precOld, "InitRegMgr");
     }
     ResetFreeQue();
     ResetSpillQue();
     for (i = REG_L0; i <= REG_L7; i++) {
	  FreeReg(i);
     }
     for (i = REG_O0; i <= REG_O5; i++) {
	  FreeReg(i);
     }
     for (i = REG_I0; i <= REG_I5; i++) {
	  FreeReg(i);
     }
     for (i = REG_G1; i <= REG_G6; i++) {					 /* Free up all registers except     */
	  FreeReg(i);								 /* FP, RA, DS, and SP 		     */
     }
     
/*****************************************************************************/
/*                                                                           */
/* Utilities to keep track of Free and Spillable registers.		     */
/*                                                                           */
/*****************************************************************************/
struct tag_regQue {
     REGISTER rRegQue[MREGS];
     BYTE bHead;
     BYTE bTail;
     BYTE bNumElements;
typedef struct tag_regQue REGQUE;
BYTE NumQueElements(REGQUE rque);
REGISTER GetQueElement(REGQUE *prque);
void AddQueElement(REGQUE *prque, REGISTER reg);
void ResetQue(REGQUE *prque);
/*****************************************************************************/
/*                                                                           */
/* Routines to manipulate free registers				     */
/*                                                                           */
/*****************************************************************************/
REGQUE rqueFree;
BYTE NumFreeRegs()
     return (NumQueElements(rqueFree));
REGISTER GetFreeReg()
     return (GetQueElement(&rqueFree));
void FreeReg(REGISTER reg)
     AddQueElement(&rqueFree, reg);
     rCurrWindow[reg].nVar = 0;
     rCurrWindow[reg].nPriority = VOLATILE;
     rCurrWindow[reg].nHeapOffset = 0;
void ResetFreeQue()
     ResetQue(&rqueFree);
/*****************************************************************************/
/*                                                                           */
/* Routines to manipulate spillable registers.				     */
/*                                                                           */
/*****************************************************************************/
REGQUE rqueSpillable[4];							 /* Que of spillable registers, one  */
										 /* que per priority 		     */
REGISTER GetSpillable()
     if (NumQueElements(rqueSpillable[TEMP-1]) != 0) {				 /* Check for spillable register in  */
	  return (GetQueElement(&rqueSpillable[TEMP-1]));			 /* TEMP priority que, then LOOP_CTR,*/
     } else if (NumQueElements(rqueSpillable[LOOP_CTR-1]) != 0) {		 /* and last in GLOBAL priority que  */
	  return (GetQueElement(&rqueSpillable[LOOP_CTR-1]));
     } else if (NumQueElements(rqueSpillable[GLOBAL-1]) != 0) {
	  return (GetQueElement(&rqueSpillable[GLOBAL-1]));
     } else {
	  return (0);
     }
	   
void InsertSpillable(REGISTER reg)
     short nPriority = rCurrWindow[reg].nPriority - 1;
     
     AddQueElement(&rqueSpillable[nPriority], reg);
void ResetSpillQue()
     short i;
     
     for (i = 0; i < 4; i++) {
	  ResetQue(&rqueSpillable[i]);
     }
/*****************************************************************************/
/*                                                                           */
/* Implementation of queues of registers. Lists of Free registers and 	     */
/* registers containing different priority variables are organized as queues */
/*                                                                           */
/*****************************************************************************/
BYTE NumQueElements(REGQUE rque)
     return (rque.bNumElements);
REGISTER GetQueElement(REGQUE *prque)
     REGISTER reg;
     
     if (prque->bNumElements != 0) {
	  reg = prque->rRegQue[prque->bTail];
	  prque->bTail = (prque->bTail + 1) % MREGS;
	  prque->bNumElements--;
     } else {
	  reg = 0;
     }
     return (reg);
void AddQueElement(REGQUE *prque, REGISTER reg)
#ifdef _CAUTIOUS_
     if (prque->bNumElements < MREGS) {
#endif	  
	  prque->bNumElements++;
	  prque->rRegQue[prque->bHead] = reg;
	  prque->bHead = (prque->bHead + 1) % MREGS;
#ifdef _CAUTIOUS_	  
     } else {
	  CRITICAL_ERROR("Queue Overflow", "AddQueElement");
     }
#endif     
void ResetQue(REGQUE *prque)
     prque->bNumElements = 0;
     prque->bHead = 0;
     prque->bTail = 0;
     
     
/*****************************************************************************/
/*                                                                           */
/* Author	: Milan Shah						     */
/* Program	: Cam8Sim						     */
/* Date		: February 6, 1992					     */
/* Module	: regmgr.h - register manager module			     */
/*                                                                           */
/*****************************************************************************/
#ifndef _REGMGR_
#define _REGMGR_
#include "global.h"
typedef unsigned long REGISTER;
REGISTER GetReg(INT16 nVar, CODEHANDLE hcodCurrent, BOOL bLoad);		 /* allocates a register for nVar    */
void FlushReg(REGISTER rFlush, CODEHANDLE hcodCurrent);				 /* flushes rFlush back to memory    */
void PushRegWindow(void);
void PopRegWindow(CODEHANDLE hcodCurrent);
void SaveRegState(void);							 /* record all the "live" registers  */
void RestoreRegState(CODEHANDLE hcodCurrent);					 /* returns all regs to state they   */
										 /* were in when SaveRegState was    */
										 /* last called. 		     */
void InitRegMgr(void);
/*****************************************************************************/
/*                                                                           */
/* macros for convenient addressing of SPARC registers			     */
/*                                                                           */
/*****************************************************************************/
#define REG_G0	0L
#define REG_G1	1L
#define REG_G2	2L
#define REG_G3	3L
#define REG_G4	4L
#define REG_G5	5L
#define REG_G6	6L
#define REG_G7	7L
#define REG_O0	8L
#define REG_O1	9L
#define REG_O2	10L
#define REG_O3	11L
#define REG_O4	12L
#define REG_O5	13L
#define REG_O6	14L
#define REG_O7	15L
#define REG_L0	16L
#define REG_L1	17L
#define REG_L2	18L
#define REG_L3	19L
#define REG_L4	20L
#define REG_L5	21L
#define REG_L6	22L
#define REG_L7	23L
#define REG_I0	24L
#define REG_I1	25L
#define REG_I2	26L
#define REG_I3	27L
#define REG_I4	28L
#define REG_I5	29L
#define REG_I6	30L
#define REG_I7	31L
#define REG_SP	14L								 /* Stack Pointer 		     */
#define REG_TP	15L								 /* The Temp register 		     */
#define REG_DS	07L								 /* pointer to Heap base	     */
#define REG_FP	30L								 /* Frame Pointer 		     */
#define REG_RA	31L								 /* Return Address 		     */
#endif
/*****************************************************************************/
/*                                                                           */
/* sim.c:	modifications to original code made by Harris L. Gilliam     */
/*		March 1994 - June 1995					     */
/*                                                                           */
/*****************************************************************************/
/*                                                                           */
/* Author       : Milan Shah                                                 */
/* Program      : Cam8Sim                                                    */
/* Date         : February 5, 1992                                           */
/* Module       : compiler.c - top level code generator                      */
/*                                                                           */
/*****************************************************************************/
#include <stdio.h>
#include <sys/mman.h>
#include "errmgr.h"
#include "memmgr.h"
#include "global.h"
#include "heap.h"
#include "utils.h"
#ifndef INTERPRETER
#include "regmgr.h"
#include "icode.h"
#endif
#include "simNoPerm.h"
#include "simGen.h"
#include "sim.h"
#include "decode_steplist.h"
#define MODULE_NAME "Sim"
BOOL bSourceRegChange = TRUE;
BOOL bDestChange = TRUE;
BOOL bForceGeneralScan = FALSE;
void CheckNoPerm();
#ifndef INTERPRETER
#define SCANNER_CODE_SIZE       (1024 * LONG32_SIZE)
#define SWEEP_CODE_SIZE         (1024 * LONG32_SIZE)
#define UPDATE_CODE_SIZE        (1024 * LONG32_SIZE)
CODEPTR pcodScanner;
CODEPTR pcodSweep;
CODEPTR pcodUpdateSite;
void SimPrologue(CODEHANDLE hcodCurrent);
void SimEpilogue(CODEHANDLE hcodCurrent);
void CheckNoPerm(CODEHANDLE hcodCurrent);
#endif INTERPRETER
#ifndef INTERPRETER
int SimCompScan()
  int i;
  BOOL bNoPerm = TRUE;
  BOOL bNoPermLast5 = TRUE;
  CODEPTR pcodCurrent;
  CODEHANDLE hcodCurrent;
  LONG32 lLogScanLength = ESC[0] + 1L;
  EP("SimCompScan");  
#else INTERPRETER
void SimExecScan()
  int i;
  BOOL bNoPerm = TRUE;
  BOOL bNoPermLast5 = TRUE;
  LONG32 lLogScanLength = ESC[0] + 1L;
  EP("SimExecScan");  
#endif INTERPRETER
  /************************************************************************/
  /* First, parse down the tree to see that we are going to update atleast*/
  /* 32 sites and that the lowest dimension extends over 32 bits. This    */
  /* second requirement is necessary because the optimized code can only  */
  /* handle dimension wraparounds at word boundaries.                     */
  /************************************************************************/
  if (lLogScanLength < 5)
    bNoPerm = bNoPermLast5 = FALSE;
  else if (lNumXBits < 5)
    bNoPerm = bNoPermLast5 = FALSE;
  else
    bNoPerm = bNoPermLast5 = TRUE;
  /************************************************************************/
  /* Now, determine if there is any permutation of the scan index in the  */
  /* bits of the SIR that will be significant over this scan.             */
  /************************************************************************/
  for (i = 0; i < MIN(5, ESC[0]); i++) {
    if (SIPR[i][0] != i) {
      bNoPerm = bNoPermLast5 = FALSE;
      break;
    }
    
    lLogScanLength--;
    
    if (!lLogScanLength)
      break;
  for (i = 5; i < MIN(SCAN_INDEX_LENGTH, ESC[0]); i++) {
    if (SIPR[i][0] != i)
      bNoPerm = FALSE;
    lLogScanLength--;
    if (!lLogScanLength)
      break;
#ifndef INTERPRETER
#ifdef _FRAMEBUFFER_
  FRAME = (LONG32) FRAMEb;
#endif _FRAMEBUFFER_
  pcodCurrent = pcodScanner;
  hcodCurrent = &pcodCurrent;
  SimPrologue(hcodCurrent);
  if (bNoPerm)
    CheckNoPerm(hcodCurrent);
  else if (bNoPermLast5)
    SimGeneralScan(hcodCurrent);
  else
    SimGeneralScan(hcodCurrent);
  SimEpilogue(hcodCurrent);
  LP("SimCompScan");
#else INTERPRETER
#ifdef _FRAMEBUFFER_
  FRAME_ADDR = (LONG32) FRAMEb;
#endif _FRAMEBUFFER_
  if (bNoPerm)
    CheckNoPerm();
  else if (bNoPermLast5)
    SimGeneralScan();
  else
    SimGeneralScan();
  if (SCAN_INDEX_REG > 0xFFFFFF)
    SCAN_INDEX_REG = 0;
  SIR[0] = SCAN_INDEX_REG;
  LP("SimExecScan");
#endif INTERPRETER
/*****************************************************************************/
/*                                                                           */
/* CheckNoPerm is necessary for the following reason - suppose there is no   */
/* permutation of the Scan Index, but suppose the the bits that extend over  */
/* the lowest dimension (ie, the bits to the _right_ of the lowest bit of    */
/* DCMR) are not all zeros. Then, the first sweep will not scan a multiple-  */
/* of-two number of sites, and we cannot to an optimized scan.               */
/*                                                                           */
/*****************************************************************************/
#ifndef INTERPRETER
void CheckNoPerm(CODEHANDLE hcodCurrent)
  LONG32 lSIRSigBits, lSIR;
#else INTERPRETER
void CheckNoPerm()
  LONG32 lSIRSigBits, lSIR;
#endif INTERPRETER
  EP("CheckNoPerm");
  lSIRSigBits = MIN(ESC[0], lNumXBits);
  lSIR = SIR[0] & ~((~0x0) << lSIRSigBits);
#ifndef INTERPRETER
  if ((lSIR == 0) && (MIN(lNumXBits, ESC[0]) >= 2)) {
    if (bForceGeneralScan)
      SimGeneralScan(hcodCurrent);
    else
      SimScanNoPerm(hcodCurrent);
  else
    SimGeneralScan(hcodCurrent);
#else INTERPRETER
  if ((lSIR == 0) && (MIN(lNumXBits, ESC[0]) >= 2)) {
    if (bForceGeneralScan)
      SimGeneralScan();
    else
      SimScanNoPerm();
  else
    SimGeneralScan();
#endif INTERPRETER
  LP("CheckNoPerm");
#ifndef INTERPRETER
void SimPrologue(CODEHANDLE hcodCurrent)
  EP("SimPrologue");
  NewBlock(hcodCurrent);
  .ENTER_PROC;
  LP("SimPrologue");
}     
void SimEpilogue(CODEHANDLE hcodCurrent)
  EP("SimEpilogue");
 .RETURN_PROC;
  EndBlock();
  LP("SimEpilogue");
void SimExecScan()
  void (*fScan)(void);
  fScan = (void (*)()) pcodScanner;
  (*fScan)();
  ConstantSetAll(SIR, SCAN_INDEX_REG);
void InitSim()
  const int prot = PROT_READ | PROT_WRITE | PROT_EXEC;
  pcodScanner = VALLOC(SCANNER_CODE_SIZE, "InitSim : pcodScanner");
  pcodGenUpdate = VALLOC(SCANNER_CODE_SIZE, "InitSim : pcodGenUpdate");
  pcodSweep = VALLOC(SWEEP_CODE_SIZE, "InitSim : pcodSweep");
  pcodUpdateSite = VALLOC(UPDATE_CODE_SIZE, "InitSim : pcodUpdateSite");
  mprotect(pcodScanner, SCANNER_CODE_SIZE, prot);
  mprotect(pcodGenUpdate, SCANNER_CODE_SIZE, prot);
  mprotect(pcodSweep, SWEEP_CODE_SIZE, prot);
  mprotect(pcodUpdateSite, UPDATE_CODE_SIZE, prot);
  UPDATE_SITE_CODE = (LONG32) pcodUpdateSite;
  InitRegMgr();
#endif INTERPRETER
/*****************************************************************************/
/*                                                                           */
/* sim.h:	modifications to original code made by Harris L. Gilliam     */
/*		March 1994 - June 1995					     */
/*                                                                           */
/*****************************************************************************/
/*                                                                           */
/* Author 	: Milan Shah						     */
/* Program	: Cam8Sim						     */
/* Date		: February 5, 1992					     */
/* Module	: compiler.h - the top level scan compiler		     */
/*                                                                           */
/*****************************************************************************/
#ifndef _SIM_
#define _SIM_
#include "global.h"
extern BOOL bSourceRegChange;
extern BOOL bDestChange;
extern BOOL bForceGeneralScan;
#ifndef INTERPRETER
extern CODEPTR pcodScanner;
void InitSim(void);
void SimScan(void);
#endif INTERPRETER
void SimScan(void);
#endif
/*****************************************************************************/
/*                                                                           */
/* simNoPerm.c:	modifications to original code made by Harris L. Gilliam     */
/*		March 1994 - June 1995					     */
/*                                                                           */
/*****************************************************************************/
/*                                                                           */
/* Author       : Milan Shah                                                 */
/* Program      : Cam8Sim                                                    */
/* Date         : February 6, 1992                                           */
/* Module       : compileNoPerm.c - generate code for no scan index          */
/*                permutation case.                                          */
/*                                                                           */
/*****************************************************************************/
#include "global.h"
#include "errmgr.h"
#include "memmgr.h"
#include "heap.h"
#include "utils.h"
#ifndef INTERPRETER
#include "regmgr.h"
#include "icode.h"
#endif INTERPRETER
#include "simNoPerm.h"
#include "simNoPermP.h"
#include "decode_steplist.h"
#define MODULE_NAME "SimNoPerm"
#ifndef INTERPRETER
static void SimSweepCode();
#else INTERPRETER
static void SimSweepCode();
#endif INTERPRETER
#ifndef INTERPRETER
void SimScanNoPerm(CODEHANDLE hcodCurrent)
  LONG32 lTemp1, lTemp2;
  CODELABEL lblYLoop, lblAddrLoop, lblSkip;
  const short iPlaneCtr = iTemp1,
  iHeapOffset = iTemp2,
  iWordAddr = iTemp3,
  iHighBit = iTemp4;
  EP("SimScanNoPerm");
  lblSkip = NewLabel();
  lblYLoop = NewLabel();
  lblAddrLoop = NewLabel();
  /************************************************************************/
  /* Sim assuming the scan index is not permuted. This implies that   */
  /* bits to be updated during this scan are all consecutive.             */
  /************************************************************************/
#else INTERPRETER
void SimScanNoPerm()
  LONG32 PLANE_CTR, WORD_ADDR, HIGH_BIT;
  EP("SimScanNoPerm");
#endif INTERPRETER
  /************************************************************************/
  /* compute HIGH_BIT_MASK and X_HIGH_BIT_MASK				  */
  /************************************************************************/
  HIGH_BIT_MASK = lDCMRHighBit >> 3;
  X_HIGH_BIT_MASK = lDCMRLowBit >> 3;
  /************************************************************************/
  /* SITE_CTR is set to how many sweeps are to be done. X_BYTE_LENGTH is  */
  /* set to how many bytes will be updated per sweep                      */
  /************************************************************************/
  if (ESC[0] < lNumXBits) {
    SITE_CTR = 1;
    X_BYTE_LENGTH = 1 << (ESC[0] - 3);
  else {
    SITE_CTR = ScanLength() >> lNumXBits;                                  
    X_BYTE_LENGTH = lDCMRLowBit >> 2;
  nNumPlanes = CalcNumPlanes();
#ifdef INTERPRETER
  if (nNumPlanes == 0) {
    LP("SimScanNoPerm");
    return;
#endif INTERPRETER
  /************************************************************************/
  /* Code starts here                                                     */
  /************************************************************************/
#ifndef INTERPRETER
Emit(LDW_MEM, VAR_OP, iSiteCtr, NULL_OP, 0, NULL_OP, 0);
ASCODE("  .LDW_MEM iSiteCtr;");
Emit(ADD_LABEL, LABEL_OP, lblYLoop, NULL_OP, 0, NULL_OP, 0);
ASCODE("  .ADD_LABEL :lblYLoop;");
  SimSweepCode();
Emit(CALL_PROC, ADDR_OP, (LONG32) pcodSweep, NULL_OP, 0, NULL_OP, 0);
ASCODE("  .CALL_PROC [pcodSweep];");
Emit(NO_OP, NULL_OP, 0, NULL_OP, 0, NULL_OP, 0);
ASCODE("  .NO_OP;");
Emit(ADD, REG_OP, REG_DS, CONST_OP, offNextWordAddr, VAR_OP, iHeapOffset);
ASCODE("  .ADD %DS, #offNextWordAddr, iHeapOffset;");
Emit(LDW_MEM, VAR_OP, iHighBitMask, NULL_OP, 0, NULL_OP, 0);
ASCODE("  .LDW_MEM iHighBitMask;");
Emit(LDW_MEM, VAR_OP, iXByteLength, NULL_OP, 0, NULL_OP, 0);
ASCODE("  .LDW_MEM iXByteLength;");
Emit(ADD, REG_OP, REG_G0, CONST_OP, 0, VAR_OP, iPlaneCtr);
ASCODE("  .ADD %G0, #0, iPlaneCtr;");
Emit(ADD_LABEL, LABEL_OP, lblAddrLoop, NULL_OP, 0, NULL_OP, 0);
ASCODE("  .ADD_LABEL :lblAddrLoop;");
Emit(SUBcc, VAR_OP, iPlaneCtr, CONST_OP, (nNumPlanes*4), REG_OP, REG_G0);
ASCODE("  .SUBcc iPlaneCtr, #(nNumPlanes*4), %G0;");
Emit(BR_GRE, LABEL_OP, lblSkip, NULL_OP, 0, NULL_OP, 0);
ASCODE("  .BR_GRE :lblSkip;");
Emit(LDW_IND, VAR_OP, iHeapOffset, VAR_OP, iPlaneCtr, VAR_OP, iWordAddr);
ASCODE("  .LDW_IND iHeapOffset, iPlaneCtr, iWordAddr;");
Emit(AND, VAR_OP, iHighBitMask, VAR_OP, iWordAddr, VAR_OP, iHighBit);
ASCODE("  .AND iHighBitMask, iWordAddr, iHighBit;");
Emit(XNOR, VAR_OP, iHighBitMask, REG_OP, REG_G0, VAR_OP, iHighBitMask);
ASCODE("  .XNOR iHighBitMask, %G0, iHighBitMask;");
Emit(AND, VAR_OP, iHighBitMask, VAR_OP, iWordAddr, VAR_OP, iWordAddr);
ASCODE("  .AND iHighBitMask, iWordAddr, iWordAddr;");
Emit(ADD, VAR_OP, iXByteLength, VAR_OP, iWordAddr, VAR_OP, iWordAddr);
ASCODE("  .ADD iXByteLength, iWordAddr, iWordAddr;");
Emit(XOR, VAR_OP, iHighBit, VAR_OP, iWordAddr, VAR_OP, iWordAddr);
ASCODE("  .XOR iHighBit, iWordAddr, iWordAddr;");
Emit(STW_IND, VAR_OP, iHeapOffset, VAR_OP, iPlaneCtr, VAR_OP, iWordAddr);
ASCODE("  .STW_IND iHeapOffset, iPlaneCtr, iWordAddr;");
Emit(ADD, VAR_OP, iPlaneCtr, CONST_OP, 4, VAR_OP, iPlaneCtr);
ASCODE("  .ADD iPlaneCtr, #4, iPlaneCtr;");
Emit(BRANCH, LABEL_OP, lblAddrLoop, NULL_OP, 0, NULL_OP, 0);
ASCODE("  .BRANCH :lblAddrLoop;");
Emit(XNOR, VAR_OP, iHighBitMask, REG_OP, REG_G0, VAR_OP, iHighBitMask);
ASCODE("  .XNOR iHighBitMask, %G0, iHighBitMask;");
Emit(ADD_LABEL, LABEL_OP, lblSkip, NULL_OP, 0, NULL_OP, 0);
ASCODE("  .ADD_LABEL :lblSkip;");
Emit(SH_LEFT, VAR_OP, iXByteLength, CONST_OP, 3, VAR_OP, iTemp1);
ASCODE("  .SH_LEFT iXByteLength, #3, iTemp1;");
Emit(LDW_MEM, VAR_OP, iScanIndexReg, NULL_OP, 0, NULL_OP, 0);
ASCODE("  .LDW_MEM iScanIndexReg;");
Emit(ADD, VAR_OP, iScanIndexReg, VAR_OP, iTemp1, VAR_OP, iScanIndexReg);
ASCODE("  .ADD iScanIndexReg, iTemp1, iScanIndexReg;");
Emit(SUBcc, VAR_OP, iScanIndexReg, CONST_OP, 0xFFFFFF, VAR_OP, iTemp1);
ASCODE("  .SUBcc iScanIndexReg, #0xFFFFFF, iTemp1;");
Emit(BR_L, LABEL_OP, lblSkip, NULL_OP, 0, NULL_OP, 0);
ASCODE("  .BR_L :lblSkip;");
Emit(NO_OP, NULL_OP, 0, NULL_OP, 0, NULL_OP, 0);
ASCODE("  .NO_OP;");
Emit(OR, REG_OP, REG_G0, REG_OP, REG_G0, VAR_OP, iScanIndexReg);
ASCODE("  .OR %G0, %G0, iScanIndexReg;");
Emit(ADD_LABEL, LABEL_OP, lblSkip, NULL_OP, 0, NULL_OP, 0);
ASCODE("  .ADD_LABEL :lblSkip;");
Emit(SUBcc, VAR_OP, iSiteCtr, CONST_OP, 1, VAR_OP, iSiteCtr);
ASCODE("  .SUBcc iSiteCtr, #1, iSiteCtr;");
Emit(BR_NZ, LABEL_OP, lblYLoop, NULL_OP, 0, NULL_OP, 0);
ASCODE("  .BR_NZ :lblYLoop;");
Emit(STW_MEM, VAR_OP, iScanIndexReg, NULL_OP, 0, NULL_OP, 0);
ASCODE("  .STW_MEM iScanIndexReg;");
  LP("SimScanNoPerm");
#else INTERPRETER
  while (SITE_CTR != 0) {
    SimSweepCode();
    for(PLANE_CTR = 0; PLANE_CTR < nNumPlanes; PLANE_CTR++) {  
      WORD_ADDR = NEXT_WORD_ADDR[PLANE_CTR];
      HIGH_BIT = WORD_ADDR & HIGH_BIT_MASK;
      WORD_ADDR &= (~ HIGH_BIT_MASK);
      WORD_ADDR += X_BYTE_LENGTH;
      WORD_ADDR ^= HIGH_BIT;
      NEXT_WORD_ADDR[PLANE_CTR] = WORD_ADDR;
      /*
      NEXT_WORD_ADDR[PLANE_CTR] =
	(((NEXT_WORD_ADDR[PLANE_CTR] & (~ HIGH_BIT_MASK)) + X_BYTE_LENGTH) ^
	 (NEXT_WORD_ADDR[PLANE_CTR] & HIGH_BIT_MASK));
	 */
    }
    SCAN_INDEX_REG += (X_BYTE_LENGTH << 3);
    if (SCAN_INDEX_REG > 0xFFFFFF)
      SCAN_INDEX_REG = 0;
    SITE_CTR--;
    ConstantSetAll(SIR, SCAN_INDEX_REG);
  LP("SimScanNoPerm");
#endif INTERPRETER
#ifndef INTERPRETER
void SimSweepCode()
  LONG32 xWordLength;
  CODELABEL lblXLoop;
  unsigned short nBitOffset[CHIPS_PER_MOD];
  short i, j;
  CODEPTR pcodCurrent = pcodSweep;
  EP("SimSweepCode");
  lblXLoop = NewLabel();
#else INTERPRETER
void SimSweepCode()
  short i, j;
  LONG32 NBIT_OFFSET[CHIPS_PER_MOD], XWORD_LENGTH;
  EP("SimSweepCode");
#endif INTERPRETER
  /************************************************************************/
  /* We assume here that the scan index is not permuted to arrive at the  */
  /* site address; however, some bits of the site address could be fixed  */
  /* at constant 0 or 1 as indicated by SIPR. Here, the site address of   */
  /* the first site to be updated is computed.                            */
  /************************************************************************/
  SITE_ADDR = 0;
  for (i = SCAN_INDEX_LENGTH-1; i >= 0; i--) {
    
    SITE_ADDR <<= 1;
    if (SIPR[i][0] == PERM_CONST_1)
      SITE_ADDR |= 0x1;
    else if (SIPR[i][0] != PERM_CONST_0)
      SITE_ADDR |= (SIR[0] >> i) & 0x1;
  /************************************************************************/
  /* Now that we know the site address of the first site to be updated,   */
  /* we compute the address in sparc memory of the word that contains     */
  /* a bit of that site by adding the plane offset to the site address.   */
  /************************************************************************/
#ifndef INTERPRETER
  for (i = 0; i < nNumPlanes; i++) {
    NEXT_WORD_ADDR(i) = (AddSiteAddress(SITE_ADDR, OSR[i]) >> 5) << 2;
    NEXT_WORD_ADDR(i) += BIT_PLANE_ADDR(i);
    nBitOffset[i] = OSR[i] & 0x1F;
  xWordLength = X_BYTE_LENGTH >> 2;
  NewBlock(&pcodCurrent);
Emit(ENTER_PROC, NULL_OP, 0, NULL_OP, 0, NULL_OP, 0);
ASCODE("  .ENTER_PROC;");
  SimLoadFirstWord(nBitOffset);
  if (IsSrcNeeded(SRC_SITE_ADDRESS)) {
Emit(LDW_MEM, VAR_OP, iScanIndexReg, NULL_OP, 0, NULL_OP, 0);
ASCODE("    .LDW_MEM iScanIndexReg;");
  if (IsSrcNeeded(SRC_LUT)) {
Emit(LDW_MEM, VAR_OP, iLutAddr, NULL_OP, 0, NULL_OP, 0);
ASCODE("    .LDW_MEM iLutAddr;");
Emit(LDW_MEM, VAR_OP, iUpdateSiteProc, NULL_OP, 0, NULL_OP, 0);
ASCODE("  .LDW_MEM iUpdateSiteProc;");
Emit(ADD, REG_OP, REG_G0, CONST_OP, xWordLength, VAR_OP, iXCtr);
ASCODE("  .ADD %G0, #xWordLength, iXCtr;");
Emit(ADD_LABEL, LABEL_OP, lblXLoop, NULL_OP, 0, NULL_OP, 0);
ASCODE("  .ADD_LABEL :lblXLoop;");
  SimUpdateSite();
  for (i = 0; i < 32; i++) {
Emit(CALL_LEAF_IND, VAR_OP, iUpdateSiteProc, CONST_OP, 4, NULL_OP, 0);
ASCODE("    .CALL_LEAF_IND iUpdateSiteProc, #4;");
Emit(INSTR, VAR_OP, *pcodUpdateSite, NULL_OP, 0, NULL_OP, 0);
ASCODE("    .INSTR *pcodUpdateSite;");
    for (j = 0; j < nNumPlanes; j++) {
      if (nBitOffset[j] == (31 - i)) {
	SimGetNextWord(j);
      }
    }
Emit(SUBcc, VAR_OP, iXCtr, CONST_OP, 1, VAR_OP, iXCtr);
ASCODE("  .SUBcc iXCtr, #1, iXCtr;");
Emit(BR_NZ, LABEL_OP, lblXLoop, NULL_OP, 0, NULL_OP, 0);
ASCODE("  .BR_NZ :lblXLoop;");
Emit(NO_OP, NULL_OP, 0, NULL_OP, 0, NULL_OP, 0);
ASCODE("  .NO_OP;");
  SimSaveLastWord(nBitOffset);
Emit(RETURN_PROC, NULL_OP, 0, NULL_OP, 0, NULL_OP, 0);
ASCODE("  .RETURN_PROC;");
  EndBlock();
  LP("SimSweepCode");
#else INTERPRETER
  for (i = 0; i < nNumPlanes; i++) {
    NEXT_WORD_ADDR[i] = (AddSiteAddress(SITE_ADDR, OSR[i]) >> 5) << 2;
    NEXT_WORD_ADDR[i] += BIT_PLANE_ADDR[i];
    NBIT_OFFSET[i] = OSR[i] & 0x1F;
  XWORD_LENGTH = X_BYTE_LENGTH >> 2;
  SimLoadFirstWord(NBIT_OFFSET);
  X_CTR = XWORD_LENGTH;
  do {
    for (i = 0; i < 32; i++) {
      SimUpdateSite();
      for (j = 0; j < nNumPlanes; j++) {
	if (NBIT_OFFSET[j] == (31 - i))
	  SimGetNextWord(j);
      }
    }
    X_CTR -= 1;
  } while (X_CTR);
  SimSaveLastWord(NBIT_OFFSET);
  LP("SimSweepCode");
#endif INTERPRETER
#ifndef INTERPRETER
void SimLoadFirstWord(unsigned short nBitOffset[])
  short i;
  const short iSaveBits = iTemp1;
  const short iWordAddr = iTemp1;
  EP("SimLoadFirstWord");
  for (i = 0; i < nNumPlanes; i++) {
Emit(LDW_IND, REG_OP, REG_DS, CONST_OP, (offNextWordAddr+(i<<2)), VAR_OP, iWordAddr);
ASCODE("    .LDW_IND %DS, #(offNextWordAddr+(i<<2)), iWordAddr;");
Emit(LDW_IND, VAR_OP, iWordAddr, CONST_OP, 0, VAR_OP, (iPlaneWord+i));
ASCODE("    .LDW_IND iWordAddr, #0, (iPlaneWord+i);");
    if (nBitOffset[i] != 0) {
Emit(SH_RIGHT, VAR_OP, (iPlaneWord+i), CONST_OP, (32 - nBitOffset[i]), VAR_OP, iSaveBits);
ASCODE("      .SH_RIGHT (iPlaneWord+i), #(32 - nBitOffset[i]), iSaveBits;");
Emit(SH_LEFT, VAR_OP, (iPlaneWord+i), CONST_OP, nBitOffset[i], VAR_OP, (iPlaneWord+i));
ASCODE("      .SH_LEFT (iPlaneWord+i), #nBitOffset[i], (iPlaneWord+i);");
Emit(OR, VAR_OP, (iPlaneWord+i), VAR_OP, iSaveBits, VAR_OP, (iPlaneWord+i));
ASCODE("      .OR (iPlaneWord+i), iSaveBits, (iPlaneWord+i);");
    }
  LP("SimLoadFirstWord");
#else INTERPRETER
void SimLoadFirstWord(LONG32 NBIT_OFFSET[])
  short i;
  LONG32 SAVE_BITS, WORD_ADDR;
  EP("SimLoadFirstWord");
  for (i = 0; i < nNumPlanes; i++) {
    PLANE_WORD[i] = *((LONG32 *) NEXT_WORD_ADDR[i]);
    
    if (NBIT_OFFSET[i] != 0) {
      SAVE_BITS = PLANE_WORD[i] >> (32 - NBIT_OFFSET[i]);
      PLANE_WORD[i] <<= NBIT_OFFSET[i];
      PLANE_WORD[i] |= SAVE_BITS;
    }
  LP("SimLoadFirstWord");
#endif INTERPRETER
#ifndef INTERPRETER
void SimGetNextWord(unsigned short nPlane)
  const short iAddrHighBit = iTemp1;
  BOOL bWriteBack = FALSE;
  short i;
  EP("SimGetNextWord");
#else INTERPRETER
void SimGetNextWord(unsigned short nPlane)
  LONG32 ADDR_HIGH_BIT;
  BOOL bWriteBack = FALSE;
  short i;
  EP("SimGetNextWord");
#endif INTERPRETER
#ifndef INTERPRETER
Emit(ENTER_BASICBLK, NULL_OP, 0, NULL_OP, 0, NULL_OP, 0);
ASCODE("  .ENTER_BASICBLK;");
  if (IsDestUpdated(DEST_SITE_DATA)) {
Emit(STW_IND, VAR_OP, (iNextWordAddr+nPlane), CONST_OP, 0, VAR_OP, (iPlaneWord+nPlane));
ASCODE("    .STW_IND (iNextWordAddr+nPlane), #0, (iPlaneWord+nPlane);");
  if (lNumXBits <= 5) {
Emit(RETURN_BASICBLK, NULL_OP, 0, NULL_OP, 0, NULL_OP, 0);
ASCODE("    .RETURN_BASICBLK;");
    LP("SimGetNextWord");
    return;
Emit(AND, VAR_OP, (iNextWordAddr+nPlane), VAR_OP, iXHighBitMask, VAR_OP, iAddrHighBit);
ASCODE("  .AND (iNextWordAddr+nPlane), iXHighBitMask, iAddrHighBit;");
Emit(XNOR, VAR_OP, iXHighBitMask, REG_OP, REG_G0, VAR_OP, iXHighBitMask);
ASCODE("  .XNOR iXHighBitMask, %G0, iXHighBitMask;");
Emit(AND, VAR_OP, (iNextWordAddr+nPlane), VAR_OP, iXHighBitMask, VAR_OP, (iNextWordAddr+nPlane));
ASCODE("  .AND (iNextWordAddr+nPlane), iXHighBitMask, (iNextWordAddr+nPlane);");
Emit(ADD, VAR_OP, (iNextWordAddr+nPlane), CONST_OP, 4, VAR_OP, (iNextWordAddr+nPlane));
ASCODE("  .ADD (iNextWordAddr+nPlane), #4, (iNextWordAddr+nPlane);");
Emit(XOR, VAR_OP, iAddrHighBit, VAR_OP, (iNextWordAddr+nPlane), VAR_OP, iNextWordAddr+nPlane);
ASCODE("  .XOR iAddrHighBit, (iNextWordAddr+nPlane), iNextWordAddr+nPlane;");
Emit(XNOR, VAR_OP, iXHighBitMask, REG_OP, REG_G0, VAR_OP, iXHighBitMask);
ASCODE("  .XNOR iXHighBitMask, %G0, iXHighBitMask;");
Emit(LDW_IND, VAR_OP, (iNextWordAddr+nPlane), CONST_OP, 0, VAR_OP, (iPlaneWord+nPlane));
ASCODE("  .LDW_IND (iNextWordAddr+nPlane), #0, (iPlaneWord+nPlane);");
Emit(STW_MEM, VAR_OP, (iNextWordAddr+nPlane), NULL_OP, 0, NULL_OP, 0);
ASCODE("  .STW_MEM (iNextWordAddr+nPlane);");
Emit(RETURN_BASICBLK, NULL_OP, 0, NULL_OP, 0, NULL_OP, 0);
ASCODE("  .RETURN_BASICBLK;");
  LP("SimGetNextWord");
#else INTERPRETER
  if (IsDestUpdated(DEST_SITE_DATA))
      *((LONG32 *) NEXT_WORD_ADDR[nPlane]) = PLANE_WORD[nPlane];
  if (lNumXBits <= 5) {
    LP("SimGetNextWord");
    return;
  ADDR_HIGH_BIT = NEXT_WORD_ADDR[nPlane] & X_HIGH_BIT_MASK;
  NEXT_WORD_ADDR[nPlane] &= (~ X_HIGH_BIT_MASK);
  NEXT_WORD_ADDR[nPlane] = (NEXT_WORD_ADDR[nPlane] + 4) ^ ADDR_HIGH_BIT;
  PLANE_WORD[nPlane] = *((LONG32 *) NEXT_WORD_ADDR[nPlane]);
  LP("SimGetNextWord");
#endif INTERPRETER
#ifndef INTERPRETER
void SimSaveLastWord(unsigned short nBitOffset[])
  short i;
  const short iSaveBits = iTemp1;
  EP("SimSaveLastWord");
#else INTERPRETER
void SimSaveLastWord(LONG32 NBIT_OFFSET[])
  short i;
  LONG32 SAVE_BITS;
  EP("SimSaveLastWord");
#endif INTERPRETER
#ifndef INTERPRETER
  if (IsDestUpdated(DEST_SITE_DATA)) {
Emit(ENTER_BASICBLK, NULL_OP, 0, NULL_OP, 0, NULL_OP, 0);
ASCODE("    .ENTER_BASICBLK;");
    for (i = 0; i < nNumPlanes; i++) {
      if (!nBitOffset[i])
	continue;
Emit(SH_RIGHT, VAR_OP, (iPlaneWord+i), CONST_OP, (nBitOffset[i]), VAR_OP, iSaveBits);
ASCODE("      .SH_RIGHT (iPlaneWord+i), #(nBitOffset[i]), iSaveBits;");
Emit(SH_LEFT, VAR_OP, (iPlaneWord+i), CONST_OP, (32 - nBitOffset[i]), VAR_OP, (iPlaneWord+i));
ASCODE("      .SH_LEFT (iPlaneWord+i), #(32 - nBitOffset[i]), (iPlaneWord+i);");
Emit(OR, VAR_OP, (iPlaneWord+i), VAR_OP, iSaveBits, VAR_OP, (iPlaneWord+i));
ASCODE("      .OR (iPlaneWord+i), iSaveBits, (iPlaneWord+i);");
Emit(STW_IND, VAR_OP, (iNextWordAddr+i), CONST_OP, 0, VAR_OP, (iPlaneWord+i));
ASCODE("      .STW_IND (iNextWordAddr+i), #0, (iPlaneWord+i);");
    }
Emit(RETURN_BASICBLK, NULL_OP, 0, NULL_OP, 0, NULL_OP, 0);
ASCODE("    .RETURN_BASICBLK;");
  LP("SimSaveLastWord");
#else INTERPRETER
  if (IsDestUpdated(DEST_SITE_DATA)) {
    for (i = 0; i < nNumPlanes; i++) {
      if (!NBIT_OFFSET[i])
	continue;
      SAVE_BITS = PLANE_WORD[i] >> NBIT_OFFSET[i];
      PLANE_WORD[i] <<= (32 - NBIT_OFFSET[i]);
      PLANE_WORD[i] |= SAVE_BITS;
      *((LONG32 *) NEXT_WORD_ADDR[i]) = PLANE_WORD[i];
    }
  LP("SimSaveLastWord");
#endif INTERPRETER
/*****************************************************************************/
/*                                                                           */
/* simBuildDest.c:	modifications to original code made by		     */
/*			Harris L. Gilliam March 1994 - June 1995	     */
/*                                                                           */
/*****************************************************************************/
/*                                                                           */
/* Author       : Milan Shah                                                 */
/* Program      : Cam8Sim                                                    */
/* Date         : February 6, 1992                                           */
/* Module       : compileNoPerm.c - generate code for no scan index          */
/*                permutation case.                                          */
/*                                                                           */
/*****************************************************************************/
#include "global.h"
#include "errmgr.h"
#include "memmgr.h"
#include "heap.h"
#include "utils.h"
#ifndef INTERPRETER
#include "regmgr.h"
#include "icode.h"
#endif INTERPRETER
#include "simBuildDestP.h"
#include "decode_steplist.h"
#define MODULE_NAME "SimBuildDest"
#ifndef INTERPRETER
short PermuteScanIndex()
#else INTERPRETER
LONG32 *PermuteScanIndex()
#endif INTERPRETER
  short i;
  BOOL bIsPermuted = FALSE;
  EP("PermuteScanIndex");
  for (i = nNumPlanes - 1; i >= 0; i--) {
    if (SABSR[i] != i) {
      bIsPermuted = TRUE;
      break;
    }
#ifndef INTERPRETER
  if (!bIsPermuted) {
    LP("PermuteScanIndex");
    return (iScanIndexReg);
#else INTERPRETER
  if (!bIsPermuted) {
    LP("PermuteScanIndex");
    return(&SCAN_INDEX_REG);
#endif INTERPRETER
#ifndef INTERPRETER
  .OR %G0, %G0, iTemp6;
  for (i = nNumPlanes-1; i >= 0; i--) {
    if (SABSR[i] < 24) {
      .SH_LEFT iScanIndexReg, #(31 - SABSR[i]), iTemp5;
      .ADDcc iTemp5, iTemp5, iTemp5;
      .ADDXcc iTemp6, iTemp6, iTemp6;
    }
    else if (SABSR[i] == 31) {
      .SH_LEFT iTemp6, #1, iTemp6;
      .ADD iTemp6, #1, iTemp6;
    }
    else if (SABSR[i] == 30) {
      .SH_LEFT iTemp6, #1, iTemp6;
    }
    else {
      WARNING("Invalid SABSR value!", "PermuteScanIndex");
      .SH_LEFT iTemp6, #1, iTemp6;
    }
  LP("PermuteScanIndex");
  return (iTemp6);
#else INTERPRETER
  TEMP6 = 0;
  for (i = nNumPlanes-1; i >= 0; i--) {
    if (SABSR[i] < 24) {
      TEMP5 = SCAN_INDEX_REG << (31 - SABSR[i]);
      bit = HIGHB(TEMP6);
      TEMP6 = (TEMP6 << 1) | HIGHB(TEMP5);
      TEMP5 <<= 1;
    }
    else if (SABSR[i] == 31) {
      TEMP6 <<= 1;
      TEMP6 += 1;
    }
    else if (SABSR[i] == 30) {
      TEMP6 <<= 1;
    }
    else {
      WARNING("Invalid SABSR value!", "PermuteScanIndex");
      TEMP6 <<= 1;
    }
  LP("PermuteScanIndex");
  return (&TEMP6);
#endif INTERPRETER
#ifndef INTERPRETER
void MapFunction (short iSrcVar, short iDestVar, BYTE bMap)
#else INTERPRETER
void MapFunction (LONG32 *SrcVar, LONG32 *DestVar, BYTE bMap)
#endif INTERPRETER
  EP("MapFunction");
  switch (bMap) {
  case MAP_CONST_0: {
#ifndef INTERPRETER
    .OR %G0, %G0, iDestVar;
#else INTERPRETER
    *DestVar = 0;
#endif INTERPRETER
    break;
    
  case MAP_G_NOR_S: {
#ifndef INTERPRETER
    /* Surprizingly, SPARC does not have*/
    /* a native NOR instruction! ORN is */
    /* not NOR!!!                       */
    .OR iGlueData, iSrcVar, iDestVar;
    .XNOR %G0, iDestVar, iDestVar;
#else INTERPRETER
    *DestVar = ~ (GLUE_DATA | *SrcVar);
#endif INTERPRETER
    break;
}    
  case MAP_G_AND_S_BAR: {
#ifndef INTERPRETER
    .XNOR %G0, iSrcVar, iDestVar;
    .AND iGlueData, iDestVar, iDestVar;
#else INTERPRETER
    *DestVar = GLUE_DATA & (~ *SrcVar);
#endif INTERPRETER
    break;
    
  case MAP_S_BAR: {
#ifndef INTERPRETER
    .XNOR %G0, iSrcVar, iDestVar;
#else INTERPRETER
    *DestVar = ~ *SrcVar;
#endif INTERPRETER
    break;
    
  case MAP_G_BAR_AND_S: {
#ifndef INTERPRETER
    .XNOR %G0, iGlueData, iDestVar;
    .AND iSrcVar, iDestVar, iDestVar;
#else INTERPRETER
    *DestVar = (~ GLUE_DATA) & *SrcVar;
#endif INTERPRETER
    break;
    
  case MAP_G_BAR: {
#ifndef INTERPRETER
    .XNOR %G0, iGlueData, iDestVar;
#else INTERPRETER
    *DestVar = ~ GLUE_DATA;
#endif INTERPRETER
    break;
    
  case MAP_G_XOR_S: {
#ifndef INTERPRETER
    .XOR iGlueData, iSrcVar, iDestVar;
#else INTERPRETER
    *DestVar = GLUE_DATA ^ *SrcVar;
#endif INTERPRETER
    break;
    
  case MAP_G_NAND_S: {
#ifndef INTERPRETER
    /* SPARC does not have a native NAND */
    /* instruction! ANDN is not NAND     */
    .AND iGlueData, iSrcVar, iDestVar;
    .XNOR %G0, iDestVar, iDestVar;
#else INTERPRETER
    *DestVar = ~ (GLUE_DATA & *SrcVar);
#endif INTERPRETER
    break;
    
  case MAP_G_AND_S: {
#ifndef INTERPRETER
    .AND iGlueData, iSrcVar, iDestVar;
#else INTERPRETER
    *DestVar = GLUE_DATA & *SrcVar;
#endif INTERPRETER
    break;
    
  case MAP_G_EQ_S: {
#ifndef INTERPRETER
    .XNOR iGlueData, iSrcVar, iDestVar;
#else INTERPRETER
    *DestVar = ~ (GLUE_DATA ^ *SrcVar);
#endif INTERPRETER
    break;
    
  case MAP_G: {
#ifndef INTERPRETER
    .XOR %G0, iGlueData, iDestVar;
#else INTERPRETER
    *DestVar = GLUE_DATA;
#endif INTERPRETER
    break;
    
  case MAP_G_OR_S_BAR: {
#ifndef INTERPRETER
    .XNOR %G0, iSrcVar, iDestVar;
    .OR iGlueData, iDestVar, iDestVar;
#else INTERPRETER
    *DestVar = GLUE_DATA | (~ *SrcVar);
#endif INTERPRETER
    break;
    
  case MAP_S: {
#ifndef INTERPRETER
    .XOR %G0, iSrcVar, iDestVar
#else INTERPRETER
    *DestVar = *SrcVar;
#endif INTERPRETER
      break;
    
  case MAP_G_BAR_OR_S: {
#ifndef INTERPRETER
    .XNOR %G0, iGlueData, iDestVar;
    .OR iSrcVar, iDestVar, iDestVar;
#else INTERPRETER
    *DestVar = (~ GLUE_DATA) | *SrcVar;
#endif INTERPRETER
      break;
    
  case MAP_G_OR_S: {
#ifndef INTERPRETER
    .OR iGlueData, iSrcVar, iDestVar;
#else INTERPRETER
    *DestVar = GLUE_DATA | *SrcVar;
#endif INTERPRETER
    break;
    
  case MAP_CONST_1: {
#ifndef INTERPRETER
    .XNOR %G0, %G0, iDestVar;
#else INTERPRETER
    *DestVar = 0xFFFFFFFF;
#endif INTERPRETER
    break;
  LP("MapFunction");
#ifndef INTERPRETER
void BuildDest(short nDest, short iDestVar, BYTE Src, BYTE Map)
  short iSrcVar;
#else INTERPRETER
void BuildDest(short nDest, LONG32 *DestVar, BYTE Src, BYTE Map)
  LONG32 *SrcVar;
#endif INTERPRETER
  EP("BuildDest");
#ifndef INTERPRETER
  if ((Map != MAP_G) && (Map != MAP_G_BAR)) {
    iSrcVar = (Src == SRC_SITE_DATA ? iUnGlueData :
	       Src == SRC_TBUS ? iTbusData :
	       Src == SRC_LUT ? iLutData : iTemp1);
    if ((nDest == DEST_LUT) && (Src == SRC_SITE_ADDRESS)) {
      iSrcVar = PermuteScanIndex();
    }
  MapFunction(iSrcVar, iDestVar, Map);
#else INTERPRETER
  if ((Map != MAP_G) && (Map != MAP_G_BAR)) {
    SrcVar = (Src == SRC_SITE_DATA ? &UNGLUE_DATA :
	      Src == SRC_TBUS ? &TBUS_DATA :
	      Src == SRC_LUT ? &LUT_DATA : &TEMP1);
    if ((nDest == DEST_LUT) && (Src == SRC_SITE_ADDRESS)) {
      SrcVar = PermuteScanIndex();
    }
  MapFunction(SrcVar, DestVar, Map);
#endif INTERPRETER
  LP("BuildDest");
#ifndef INTERPRETER
void BuildBitDest(short nDest, short iHoldReg, BYTE Src, BYTE Map,
		  unsigned short nPlane)
{                                                               
     
#else INTERPRETER
void BuildBitDest(short nDest, LONG32 *HoldReg, BYTE Src, BYTE Map,
		  unsigned short nPlane)
{                                                               
#endif INTERPRETER
  EP("BuildBitDest");
#ifndef INTERPRETER
  if ((nDest == DEST_LUT) && (Src == SRC_SITE_ADDRESS)) {
    .OR           %G0, %G0, iTemp6;
    
    if (SABSR[nPlane] < 24) {
      .SH_LEFT iScanIndexReg, #(31 - SABSR[nPlane]), iTemp5;
      .ADDcc iTemp5, iTemp5, iTemp5;
      .ADDXcc iTemp6, iTemp6, iTemp6;
      .SH_LEFT iTemp6, #nPlane, iTemp6;
    }
    else if (SABSR[nPlane] == 31) {
      .SH_LEFT iTemp6, #1, iTemp6;
      .ADD iTemp6, #1, iTemp6;
    }
    else if (SABSR[nPlane] == 30) {
      .SH_LEFT iTemp6, #1, iTemp6;
    }
    else {
      WARNING("Invalid SABSR value", "BuildBitDest");
      .SH_LEFT iTemp6, #1, iTemp6;
    }      
    MapFunction (iTemp6, iHoldReg, Map);
  else
    BuildDest(nDest, iHoldReg, Src, Map);
#else INTERPRETER
  if ((nDest == DEST_LUT) && (Src == SRC_SITE_ADDRESS)) {
    TEMP6 = 0;
    if (SABSR[nPlane] < 24) {
      TEMP5 = SCAN_INDEX_REG << (31 - SABSR[nPlane]);
      bit = HIGHB(TEMP6);
      TEMP6 = ((TEMP6 << 1) | HIGHB(TEMP5)) << nPlane;
      TEMP5 <<= 1;
    }
    else if (SABSR[nPlane] == 31)
      TEMP6 = (TEMP6 << 1) + 1;
    else if (SABSR[nPlane] == 30)
      TEMP6 <<= 1;
    else {
      WARNING("Invalid SABSR value", "BuildBitDest");
      TEMP6 <<= 1;
    }
    MapFunction (&TEMP6, HoldReg, Map);
  else
    BuildDest(nDest, HoldReg, Src, Map);
#endif INTERPRETER
  LP("BuildBitDest");
#ifndef INTERPRETER
void BuildBitwiseDest(short nDest, short iDestVar, BYTE Src[], BYTE Map[])
  short i;
  short iHoldReg = iTemp4;
#else INTERPRETER
void BuildBitwiseDest(short nDest, LONG32 *DestVar, BYTE Src[], BYTE Map[])
  short i;
  LONG32 *HoldReg = &TEMP4;
#endif INTERPRETER
  EP("BuildBitwiseDest");
#ifndef INTERPRETER
  for (i = nNumPlanes - 1; i >= 0; i--) {
    BuildBitDest(nDest, iHoldReg, Src[i], Map[i], i);
    .SH_LEFT iHoldReg, #(31 - i), iHoldReg;
    .ADDcc iHoldReg, iHoldReg, iHoldReg;
    .ADDXcc iDestVar, iDestVar, iDestVar;
#else INTERPRETER
  for (i = nNumPlanes - 1; i >= 0; i--) {
    BuildBitDest(nDest, HoldReg, Src[i], Map[i], i);
    *HoldReg <<= (31 - i);
    bit = HIGHB(*DestVar);
    *DestVar = (*DestVar << 1) | HIGHB(*HoldReg);
    *HoldReg <<= 1;
#endif INTERPRETER
  LP("BuildBitwiseDest");
/*****************************************************************************/
/*                                                                           */
/* simGen.c:	modifications to original code made by Harris L. Gilliam     */
/*		March 1994 - June 1995					     */
/*                                                                           */
/*****************************************************************************/
/*                                                                           */
/* Author       : Milan Shah                                                 */
/* Program      : Cam8Sim                                                    */
/* Date         : April 15, 1992                                             */
/* Module       : compileGen.c - compile code to update in the presence of   */
/*                of scan index permutation                                  */
/*                                                                           */
/*****************************************************************************/
#include "global.h"
#include "errmgr.h"
#include "memmgr.h"
#include "heap.h"
#include "utils.h"
#ifndef INTERPRETER
#include "regmgr.h"
#include "icode.h"
#endif
#include "simNoPermP.h"
#include "simGen.h"
#include "simGenP.h"
#include "decode_steplist.h"
#define MODULE_NAME "SimGen"
#define SITE_ADDR_MASK	0xFFFFF
#ifndef INTERPRETER
CODEPTR pcodGenUpdate;
#endif INTERPRETER
#ifndef INTERPRETER
void SimGeneralScan(CODEHANDLE hcodCurrent)
  /************************************************************************/
  /* Sim making no assumptions - in particular, it is expected that   */
  /* the scan index will be permuted, so that updated sites will not be   */
  /* sequentially located in memory.                                      */
  /************************************************************************/
  short i;
  CODELABEL lblMainLoop, lblAddrLoop, lblSkip1, lblSkip2;
  const short iPlaneCtr = iTemp1, iOffset = iTemp2, iPlaneBases = iTemp3;
  const short iBitOffset = iTemp4, iNextWord = iTemp5, iWordAddr = iTemp6;
  const short iSiteAddress = iTemp7, iSAHighBits = iTemp8;
  const short iOffHighBits = iTemp9, iScratch = iTemp9, iPlaneAddr = iTemp10;
  const short iSAAndMask = iTemp1, iSAOrMask = iTemp2;
  LONG32 lSAAndMask, lSAOrMask;
  LONG32 lSweepLength;
  EP("SimGeneralScan");
  nNumPlanes = CalcNumPlanes();
  lblMainLoop = NewLabel();
  lblAddrLoop = NewLabel();
  lblSkip1 = NewLabel();
  lblSkip2 = NewLabel();
#else INTERPRETER
void SimGeneralScan()
  short i;
  LONG32 PLANE_CTR;
  LONG32 SA_HIGH_BITS, OFF_HIGH_BITS, SCRATCH, PLANE_ADDR;
  LONG32 SWEEP_LENGTH, SA_OR_MASK, SA_AND_MASK, WORD_ADDR;
  nNumPlanes = CalcNumPlanes();
  EP("SimGeneralScan");
  if (nNumPlanes == 0) {
    LP("SimGeneralScan");
    return;
#endif INTERPRETER
  /************************************************************************/
  /* First, update things in the heap from where they can be accessed     */
  /* by the compiled code.                                                */
  /************************************************************************/
  /************************************************************************/
  /* Update heap copy of DCMR.						  */
  /************************************************************************/
  DCMR = DCM[0];
  /************************************************************************/
  /* Update heap copy of OFFSETS					  */
  /************************************************************************/
#ifndef INTERPRETER
  for(i = 0 ; i < CHIPS_PER_MOD; i++)
    OFFSETS(i) = OSR[i];
#else INTERPRETER
  for(i = 0 ; i < CHIPS_PER_MOD; i++)
    OFFSETS[i] = OSR[i];
#endif INTERPRETER
  /************************************************************************/
  /* Figure out the site address of the first site to be updated. This is */
  /* needed to update SITE_ADDR for display purposes. Also,               */
  /* compute the SAAndMask and SAOrMask which will be used to do the      */
  /* permutation at execution time.                                       */
  /************************************************************************/
#ifndef INTERPRETER
  SITE_ADDR = 0;
  lSAOrMask = lSAAndMask = 0;
  for (i = SCAN_INDEX_LENGTH-1; i >= 0; i--) {
    
    SITE_ADDR <<= 1;
    lSAOrMask <<= 1;
    lSAAndMask <<= 1;
    
    if (SIPR[i][0] < SCAN_INDEX_LENGTH) {
      
      /* Get the correct bit of scan indx */
      SITE_ADDR |= (SIR[0] >> SIPR[i][0]) & 0x1;
      
      if (SIPR[i][0] == i)
	lSAAndMask |= 1;
    }
    
    /* Constant of 1 */
    else if (SIPR[i][0] == PERM_CONST_1) {
      lSAOrMask |= 1;
      SITE_ADDR |= 1;
    }
    
    else if (SIPR[i][0] != PERM_CONST_0)
      WARNING("Invalid SIPR value", "SimGenScan");
    
  /************************************************************************/
  /* Figure out how many sites will be updated, and how many sites/sweep  */
  /************************************************************************/
  SITE_CTR = ScanLength();
  lSweepLength = SweepLength(&X_CTR);
#else INTERPRETER
  SITE_ADDR = 0;
  SA_OR_MASK = SA_AND_MASK = 0;
  for (i = SCAN_INDEX_LENGTH-1; i >= 0; i--) {
    
    SITE_ADDR <<= 1;
    SA_OR_MASK <<= 1;
    SA_AND_MASK <<= 1;
    
    if (SIPR[i][0] < SCAN_INDEX_LENGTH) {
      
	/* Get the correct bit of scan indx */
      SITE_ADDR |= (SIR[0] >> SIPR[i][0]) & 0x1;
      
      if (SIPR[i][0] == i)
	SA_AND_MASK |= 1;
    }
    
    /* Constant of 1 */
    else if (SIPR[i][0] == PERM_CONST_1) {
      SA_OR_MASK |= 1;
      SITE_ADDR |= 1;
    }
      
    else if (SIPR[i][0] != PERM_CONST_0)
      WARNING("Invalid SIPR value", "SimGenScan");
  /************************************************************************/
  /* Figure out how many sites will be updated, and how many sites/sweep  */
  /************************************************************************/
  SITE_CTR = ScanLength();
  SWEEP_LENGTH = SweepLength(&X_CTR);
#endif INTERPRETER
  /************************************************************************/
  /* Next, generate the code. First, permute the scan index register to   */
  /* get the site address.                                                */
  /************************************************************************/
#ifndef INTERPRETER
Emit(LDW_MEM, VAR_OP, iSiteCtr, NULL_OP, 0, NULL_OP, 0);
ASCODE("    .LDW_MEM iSiteCtr;");
Emit(LDW_MEM, VAR_OP, iXCtr, NULL_OP, 0, NULL_OP, 0);
ASCODE("    .LDW_MEM iXCtr;");
Emit(LDW_MEM, VAR_OP, iXByteLength, NULL_OP, 0, NULL_OP, 0);
ASCODE("    .LDW_MEM iXByteLength;");
    
Emit(ADD_LABEL, LABEL_OP, lblMainLoop, NULL_OP, 0, NULL_OP, 0);
ASCODE("    .ADD_LABEL :lblMainLoop;");
    
Emit(ENTER_BASICBLK, NULL_OP, 0, NULL_OP, 0, NULL_OP, 0);
ASCODE("    .ENTER_BASICBLK;");
Emit(LDW_MEM, VAR_OP, iScanIndexReg, NULL_OP, 0, NULL_OP, 0);
ASCODE("    .LDW_MEM iScanIndexReg;");
    
Emit(ADD, REG_OP, REG_G0, CONST_OP, lSAAndMask, VAR_OP, iSAAndMask);
ASCODE("    .ADD %G0, #lSAAndMask, iSAAndMask;");
Emit(ADD, REG_OP, REG_G0, CONST_OP, lSAOrMask, VAR_OP, iSAOrMask);
ASCODE("    .ADD %G0, #lSAOrMask, iSAOrMask;");
    
Emit(AND, VAR_OP, iScanIndexReg, VAR_OP, iSAAndMask, VAR_OP, iSiteAddress);
ASCODE("    .AND iScanIndexReg, iSAAndMask, iSiteAddress;");
Emit(OR, VAR_OP, iSAOrMask, VAR_OP, iSiteAddress, VAR_OP, iSiteAddress);
ASCODE("    .OR iSAOrMask, iSiteAddress, iSiteAddress;");
    
    for (i = SCAN_INDEX_LENGTH-1; i >= 0; i--) {
      if ((SIPR[i][0] < SCAN_INDEX_LENGTH) && (SIPR[i][0] != i)) {
Emit(SH_LEFT, VAR_OP, iScanIndexReg, CONST_OP, (31 - SIPR[i][0]), VAR_OP, iScratch);
ASCODE("	.SH_LEFT iScanIndexReg, #(31 - SIPR[i][0]), iScratch;");
Emit(ADDcc, VAR_OP, iScratch, VAR_OP, iScratch, VAR_OP, iScratch);
ASCODE("	.ADDcc iScratch, iScratch, iScratch;");
Emit(ADDX, REG_OP, REG_G0, REG_OP, REG_G0, VAR_OP, iTemp10);
ASCODE("	.ADDX %G0, %G0, iTemp10;");
Emit(SH_LEFT, VAR_OP, iTemp10, CONST_OP, i, VAR_OP, iTemp10);
ASCODE("	.SH_LEFT iTemp10, #i, iTemp10;");
Emit(OR, VAR_OP, iTemp10, VAR_OP, iSiteAddress, VAR_OP, iSiteAddress);
ASCODE("	.OR iTemp10, iSiteAddress, iSiteAddress;");
      }
    }
      
#else INTERPRETER
  while (SITE_CTR != 0) {
    SITE_ADDR = SCAN_INDEX_REG & SA_AND_MASK;
    SITE_ADDR |= SA_OR_MASK;
    
    for (i = SCAN_INDEX_LENGTH-1; i >= 0; i--) {
      if ((SIPR[i][0] < SCAN_INDEX_LENGTH) && (SIPR[i][0] != i)) {
	SCRATCH = SCAN_INDEX_REG << (31 - SIPR[i][0]);
	bit = HIGHB(SCRATCH);
	SITE_ADDR |= (bit << i);
      }
    }
    
#endif INTERPRETER
    /************************************************************************/
    /* Now, add site address to the offset to get the DRAM address. The     */
    /* addition must break the carries at the dimension cuts. Also, DRAM    */
    /* address must be broken into a SPARC word address and a 5 bit offset  */
    /* into the word                                                        */
    /************************************************************************/
    
#ifndef INTERPRETER
Emit(ADD, REG_OP, REG_DS, CONST_OP, offOffsets, VAR_OP, iOffset);
ASCODE("    .ADD %DS, #offOffsets, iOffset;");
Emit(ADD, REG_OP, REG_DS, CONST_OP, offBitPlaneAddr, VAR_OP, iPlaneBases);
ASCODE("    .ADD %DS, #offBitPlaneAddr, iPlaneBases;");
Emit(ADD, REG_OP, REG_DS, CONST_OP, offBitOffsets, VAR_OP, iBitOffset);
ASCODE("    .ADD %DS, #offBitOffsets, iBitOffset;");
Emit(ADD, REG_OP, REG_DS, CONST_OP, offNextWordAddr, VAR_OP, iNextWord);
ASCODE("    .ADD %DS, #offNextWordAddr, iNextWord;");
    
Emit(LDW_MEM, VAR_OP, iDcmr, NULL_OP, 0, NULL_OP, 0);
ASCODE("    .LDW_MEM iDcmr;");
Emit(AND, VAR_OP, iDcmr, VAR_OP, iSiteAddress, VAR_OP, iSAHighBits);
ASCODE("    .AND iDcmr, iSiteAddress, iSAHighBits;");
Emit(XNOR, REG_OP, REG_G0, VAR_OP, iDcmr, VAR_OP, iDcmr);
ASCODE("    .XNOR %G0, iDcmr, iDcmr;");
Emit(AND, VAR_OP, iDcmr, VAR_OP, iSiteAddress, VAR_OP, iSiteAddress);
ASCODE("    .AND iDcmr, iSiteAddress, iSiteAddress;");
Emit(AND, VAR_OP, iDcmr, VAR_OP, iSiteAddress, VAR_OP, iScratch);
ASCODE("    .AND iDcmr, iSiteAddress, iScratch;");
Emit(AND, VAR_OP, iScratch, CONST_OP, (SITE_ADDR_MASK), VAR_OP, iSiteAddress);
ASCODE("    .AND iScratch, #(SITE_ADDR_MASK), iSiteAddress;");
Emit(XNOR, REG_OP, REG_G0, VAR_OP, iDcmr, VAR_OP, iDcmr);
ASCODE("    .XNOR %G0, iDcmr, iDcmr;");
    
Emit(ADD, REG_OP, REG_G0, CONST_OP, 0, VAR_OP, iPlaneCtr);
ASCODE("    .ADD %G0, #0, iPlaneCtr;");
Emit(ADD_LABEL, LABEL_OP, lblAddrLoop, NULL_OP, 0, NULL_OP, 0);
ASCODE("    .ADD_LABEL :lblAddrLoop;");
    
Emit(LDW_IND, VAR_OP, iOffset, VAR_OP, iPlaneCtr, VAR_OP, iWordAddr);
ASCODE("    .LDW_IND iOffset, iPlaneCtr, iWordAddr;");
Emit(AND, VAR_OP, iDcmr, VAR_OP, iWordAddr, VAR_OP, iOffHighBits);
ASCODE("    .AND iDcmr,  iWordAddr, iOffHighBits;");
Emit(XNOR, REG_OP, REG_G0, VAR_OP, iDcmr, VAR_OP, iDcmr);
ASCODE("    .XNOR %G0, iDcmr, iDcmr;");
Emit(AND, VAR_OP, iDcmr, VAR_OP, iWordAddr, VAR_OP, iWordAddr);
ASCODE("    .AND iDcmr,  iWordAddr, iWordAddr;");
Emit(ADD, VAR_OP, iSiteAddress, VAR_OP, iWordAddr, VAR_OP, iWordAddr);
ASCODE("    .ADD iSiteAddress, iWordAddr, iWordAddr;");
Emit(XOR, VAR_OP, iWordAddr, VAR_OP, iOffHighBits, VAR_OP, iWordAddr);
ASCODE("    .XOR iWordAddr, iOffHighBits, iWordAddr;");
Emit(XOR, VAR_OP, iWordAddr, VAR_OP, iSAHighBits, VAR_OP, iWordAddr);
ASCODE("    .XOR iWordAddr, iSAHighBits, iWordAddr;");
    
Emit(LDW_IND, VAR_OP, iPlaneBases, VAR_OP, iPlaneCtr, VAR_OP, iPlaneAddr);
ASCODE("    .LDW_IND iPlaneBases, iPlaneCtr, iPlaneAddr;");
Emit(SH_RIGHT, VAR_OP, iWordAddr, CONST_OP, 5, VAR_OP, iScratch);
ASCODE("    .SH_RIGHT iWordAddr, #5, iScratch;");
Emit(SH_LEFT, VAR_OP, iScratch, CONST_OP, 2, VAR_OP, iScratch);
ASCODE("    .SH_LEFT iScratch, #2, iScratch;");
Emit(ADD, VAR_OP, iScratch, VAR_OP, iPlaneAddr, VAR_OP, iScratch);
ASCODE("    .ADD iScratch, iPlaneAddr, iScratch;");
Emit(STW_IND, VAR_OP, iNextWord, VAR_OP, iPlaneCtr, VAR_OP, iScratch);
ASCODE("    .STW_IND iNextWord, iPlaneCtr, iScratch;");
Emit(AND, VAR_OP, iWordAddr, CONST_OP, 0x1F, VAR_OP, iWordAddr);
ASCODE("    .AND iWordAddr, #0x1F, iWordAddr;");
Emit(STW_IND, VAR_OP, iBitOffset, VAR_OP, iPlaneCtr, VAR_OP, iWordAddr);
ASCODE("    .STW_IND iBitOffset, iPlaneCtr, iWordAddr;");
    
Emit(ADD, VAR_OP, iPlaneCtr, CONST_OP, 4, VAR_OP, iPlaneCtr);
ASCODE("    .ADD iPlaneCtr, #4, iPlaneCtr;");
Emit(SUBcc, VAR_OP, iPlaneCtr, CONST_OP, (nNumPlanes * 4), REG_OP, REG_G0);
ASCODE("    .SUBcc iPlaneCtr, #(nNumPlanes * 4), %G0;");
Emit(BR_L, LABEL_OP, lblAddrLoop, NULL_OP, 0, NULL_OP, 0);
ASCODE("    .BR_L :lblAddrLoop;");
Emit(XNOR, REG_OP, REG_G0, VAR_OP, iDcmr, VAR_OP, iDcmr);
ASCODE("    .XNOR %G0, iDcmr, iDcmr;");
    
Emit(RETURN_BASICBLK, NULL_OP, 0, NULL_OP, 0, NULL_OP, 0);
ASCODE("    .RETURN_BASICBLK;");
    
#else INTERPRETER
    SA_HIGH_BITS = SITE_ADDR & DCMR;
    SITE_ADDR = SITE_ADDR & (~ DCMR); 
    SITE_ADDR = (SITE_ADDR & (~ DCMR)) & SITE_ADDR_MASK;
    for(PLANE_CTR = 0; PLANE_CTR < nNumPlanes; PLANE_CTR++) {
      WORD_ADDR = OFFSETS[PLANE_CTR];
      OFF_HIGH_BITS = WORD_ADDR & DCMR;
      WORD_ADDR = SITE_ADDR + (WORD_ADDR & (~ DCMR));
      WORD_ADDR = (WORD_ADDR ^ OFF_HIGH_BITS) ^ SA_HIGH_BITS;
      PLANE_ADDR = BIT_PLANE_ADDR[PLANE_CTR];
      NEXT_WORD_ADDR[PLANE_CTR] = PLANE_ADDR + ((WORD_ADDR >> 5) << 2);
      BIT_OFFSETS[PLANE_CTR] = WORD_ADDR & 0x1F;
    }
#endif INTERPRETER
  /************************************************************************/
  /* Now, the heap has the word addresses and bit offsets for the next    */
  /* site. So go ahead and update the site.                               */
  /************************************************************************/
#ifndef INTERPRETER
  SimUpdateCode();
Emit(CALL_PROC, ADDR_OP, (LONG32) pcodGenUpdate, NULL_OP, 0, NULL_OP, 0);
ASCODE("  .CALL_PROC [pcodGenUpdate];");
Emit(NO_OP, NULL_OP, 0, NULL_OP, 0, NULL_OP, 0);
ASCODE("  .NO_OP;");
Emit(LDW_MEM, VAR_OP, iScanIndexReg, NULL_OP, 0, NULL_OP, 0);
ASCODE("  .LDW_MEM iScanIndexReg;");
Emit(SUBcc, VAR_OP, iXCtr, CONST_OP, 1, VAR_OP, iXCtr);
ASCODE("  .SUBcc iXCtr, #1, iXCtr;");
Emit(BR_NZ, LABEL_OP, lblSkip1, NULL_OP, 0, NULL_OP, 0);
ASCODE("  .BR_NZ :lblSkip1;");
Emit(NO_OP, NULL_OP, 0, NULL_OP, 0, NULL_OP, 0);
ASCODE("  .NO_OP;");
Emit(ADD, REG_OP, REG_G0, CONST_OP, lSweepLength, VAR_OP, iXCtr);
ASCODE("  .ADD %G0, #lSweepLength, iXCtr;");
Emit(ADD_LABEL, LABEL_OP, lblSkip1, NULL_OP, 0, NULL_OP, 0);
ASCODE("  .ADD_LABEL :lblSkip1;");
Emit(ADD, VAR_OP, iScanIndexReg, CONST_OP, 1, VAR_OP, iScanIndexReg);
ASCODE("  .ADD iScanIndexReg, #1, iScanIndexReg;");
Emit(SUBcc, VAR_OP, iScanIndexReg, CONST_OP, (0xFFFFFF), VAR_OP, iScratch);
ASCODE("  .SUBcc iScanIndexReg, #(0xFFFFFF), iScratch;");
Emit(BR_L, LABEL_OP, lblSkip2, NULL_OP, 0, NULL_OP, 0);
ASCODE("  .BR_L :lblSkip2;");
Emit(NO_OP, NULL_OP, 0, NULL_OP, 0, NULL_OP, 0);
ASCODE("  .NO_OP;");
Emit(OR, REG_OP, REG_G0, REG_OP, REG_G0, VAR_OP, iScanIndexReg);
ASCODE("  .OR %G0, %G0, iScanIndexReg;    ");
Emit(ADD_LABEL, LABEL_OP, lblSkip2, NULL_OP, 0, NULL_OP, 0);
ASCODE("  .ADD_LABEL :lblSkip2;");
Emit(SUBcc, VAR_OP, iSiteCtr, CONST_OP, 1, VAR_OP, iSiteCtr);
ASCODE("  .SUBcc iSiteCtr, #1, iSiteCtr;");
Emit(BR_NZ, LABEL_OP, lblMainLoop, NULL_OP, 0, NULL_OP, 0);
ASCODE("  .BR_NZ :lblMainLoop;");
Emit(STW_MEM, VAR_OP, iScanIndexReg, NULL_OP, 0, NULL_OP, 0);
ASCODE("  .STW_MEM iScanIndexReg;");
  LP("SimGeneralScan");
#else INTERPRETER
    SimUpdateCode();
    if ((--X_CTR) == 0)
      X_CTR = SWEEP_LENGTH;
    
    if ((++SCAN_INDEX_REG) > 0xFFFFFF)
      SCAN_INDEX_REG = 0;
    
    SITE_CTR--;
    ConstantSetAll(SIR, SCAN_INDEX_REG);
  LP("SimGeneralScan");
#endif INTERPRETER
#ifndef INTERPRETER
static void SimUpdateCode()
  CODEPTR pcodCurrent = pcodGenUpdate;
  EP("SimUpdateCode");
  NewBlock(&pcodCurrent);
Emit(ENTER_PROC, NULL_OP, 0, NULL_OP, 0, NULL_OP, 0);
ASCODE("  .ENTER_PROC;");
  SimLoadPlaneWords();
  SimUpdateSite();
Emit(CALL_LEAF, ADDR_OP, (LONG32) pcodUpdateSite, NULL_OP, 0, NULL_OP, 0);
ASCODE("  .CALL_LEAF [pcodUpdateSite];");
Emit(NO_OP, NULL_OP, 0, NULL_OP, 0, NULL_OP, 0);
ASCODE("  .NO_OP;");
  SimSavePlaneWords();
     
Emit(RETURN_PROC, NULL_OP, 0, NULL_OP, 0, NULL_OP, 0);
ASCODE("  .RETURN_PROC;");
  EndBlock();
  LP("SimUpdateCode");
#else INTERPRETER
static void SimUpdateCode()
  EP("SimUpdateCode");
  SimLoadPlaneWords();
  SimUpdateSite();
  SimSavePlaneWords();
  LP("SimUpdateCode");
#endif INTERPRETER
#ifndef INTERPRETER
static void SimLoadPlaneWords()
  short i;
  const short iWordAddr = iTemp1;
  const short iBitOffset = iTemp1;
  const short iSaveBits = iTemp2;
  const short iScratch = iTemp3;
  EP("SimLoadPlaneWords");
  if (!IsSrcNeeded(SRC_SITE_DATA) && !IsSrcNeeded(SRC_GLUED_DATA) &&
      !IsDestUpdated(DEST_SITE_DATA)) {
    LP("SimLoadPlaneWords");
    return;
Emit(ADD, REG_OP, REG_G0, CONST_OP, 32, VAR_OP, iScratch);
ASCODE("  .ADD %G0, #32, iScratch;");
  for (i = 0; i < nNumPlanes; i++) {
Emit(LDW_IND, REG_OP, REG_DS, CONST_OP, (offNextWordAddr+(i<<2)), VAR_OP, iWordAddr);
ASCODE("    .LDW_IND %DS, #(offNextWordAddr+(i<<2)), iWordAddr;");
Emit(LDW_IND, VAR_OP, iWordAddr, CONST_OP, 0, VAR_OP, (iPlaneWord+i));
ASCODE("    .LDW_IND iWordAddr, #0, (iPlaneWord+i);");
Emit(LDW_IND, REG_OP, REG_DS, CONST_OP, (offBitOffsets+(i<<2)), VAR_OP, iBitOffset);
ASCODE("    .LDW_IND %DS, #(offBitOffsets+(i<<2)), iBitOffset;");
Emit(SUB, VAR_OP, iScratch, VAR_OP, iBitOffset, VAR_OP, iBitOffset);
ASCODE("    .SUB iScratch, iBitOffset, iBitOffset;");
Emit(SH_RIGHT, VAR_OP, (iPlaneWord+i), VAR_OP, iBitOffset, VAR_OP, iSaveBits);
ASCODE("    .SH_RIGHT (iPlaneWord+i), iBitOffset, iSaveBits;");
Emit(SUB, VAR_OP, iScratch, VAR_OP, iBitOffset, VAR_OP, iBitOffset);
ASCODE("    .SUB iScratch, iBitOffset, iBitOffset;");
Emit(SH_LEFT, VAR_OP, (iPlaneWord+i), VAR_OP, iBitOffset, VAR_OP, (iPlaneWord+i));
ASCODE("    .SH_LEFT (iPlaneWord+i), iBitOffset, (iPlaneWord+i);");
Emit(OR, VAR_OP, (iPlaneWord+i), VAR_OP, iSaveBits, VAR_OP, (iPlaneWord+i));
ASCODE("    .OR (iPlaneWord+i), iSaveBits, (iPlaneWord+i);");
  LP("SimLoadPlaneWords");
#else INTERPRETER
static void SimLoadPlaneWords()
  short i;
  LONG32 WORD_ADDR, BIT_OFFSET, SAVE_BITS;
  EP("SimLoadPlaneWords");
  if (!IsSrcNeeded(SRC_SITE_DATA) && !IsSrcNeeded(SRC_GLUED_DATA) &&
      !IsDestUpdated(DEST_SITE_DATA)) {
    LP("SimLoadPlaneWords");
    return;
  for (i = 0; i < nNumPlanes; i++) {
    WORD_ADDR = NEXT_WORD_ADDR[i];
    PLANE_WORD[i] = *((LONG32 *) WORD_ADDR);
    BIT_OFFSET = BIT_OFFSETS[i];
    SAVE_BITS = PLANE_WORD[i] >> (32 - BIT_OFFSET);
    PLANE_WORD[i] <<= BIT_OFFSET;
    PLANE_WORD[i] |= SAVE_BITS;
    PLANE_WORD[i] = (*((LONG32 *) NEXT_WORD_ADDR[i]) << BIT_OFFSETS[i]) |
                    (*((LONG32 *) NEXT_WORD_ADDR[i]) >> (32 - BIT_OFFSETS[i]));
  LP("SimLoadPlaneWords");
#endif INTERPRETER
#ifndef INTERPRETER
static void SimSavePlaneWords()
  short i;
  const short iWordAddr = iTemp1;
  const short iBitOffset = iTemp1;
  const short iSaveBits = iTemp2;
  const short iScratch = iTemp3;
  EP("SimSavePlaneWords");
  if (!IsDestUpdated(DEST_SITE_DATA)) {
    LP("SimSavePlaneWords");
    return;
Emit(ADD, REG_OP, REG_G0, CONST_OP, 31, VAR_OP, iScratch);
ASCODE("  .ADD %G0, #31, iScratch;");
  for (i = 0; i < nNumPlanes; i++) {
Emit(LDW_IND, REG_OP, REG_DS, CONST_OP, (offBitOffsets+(i<<2)), VAR_OP, iBitOffset);
ASCODE("    .LDW_IND %DS, #(offBitOffsets+(i<<2)), iBitOffset;");
Emit(SUB, VAR_OP, iScratch, VAR_OP, iBitOffset, VAR_OP, iBitOffset);
ASCODE("    .SUB iScratch, iBitOffset, iBitOffset;");
Emit(SH_LEFT, VAR_OP, (iPlaneWord+i), VAR_OP, iBitOffset, VAR_OP, iSaveBits);
ASCODE("    .SH_LEFT (iPlaneWord+i), iBitOffset, iSaveBits;");
Emit(SUB, VAR_OP, iScratch, VAR_OP, iBitOffset, VAR_OP, iBitOffset);
ASCODE("    .SUB iScratch, iBitOffset, iBitOffset;");
Emit(ADD, VAR_OP, iBitOffset, CONST_OP, 1, VAR_OP, iBitOffset);
ASCODE("    .ADD iBitOffset, #1, iBitOffset;");
Emit(SH_RIGHT, VAR_OP, (iPlaneWord+i), VAR_OP, iBitOffset, VAR_OP, (iPlaneWord+i));
ASCODE("    .SH_RIGHT (iPlaneWord+i), iBitOffset, (iPlaneWord+i);");
Emit(OR, VAR_OP, (iPlaneWord+i), VAR_OP, iSaveBits, VAR_OP, (iPlaneWord+i));
ASCODE("    .OR (iPlaneWord+i), iSaveBits, (iPlaneWord+i);");
Emit(LDW_IND, REG_OP, REG_DS, CONST_OP, (offNextWordAddr+(i<<2)), VAR_OP, iWordAddr);
ASCODE("    .LDW_IND %DS, #(offNextWordAddr+(i<<2)), iWordAddr;");
Emit(STW_IND, VAR_OP, iWordAddr, CONST_OP, 0, VAR_OP, (iPlaneWord+i));
ASCODE("    .STW_IND iWordAddr, #0, (iPlaneWord+i);");
  LP("SimSavePlaneWords");
}     
#else INTERPRETER
static void SimSavePlaneWords()
  short i;
  LONG32 WORD_ADDR, BIT_OFFSET, SAVE_BITS;
  EP("SimSavePlaneWords");
  if (!IsDestUpdated(DEST_SITE_DATA)) {
    LP("SimSavePlaneWords");
    return;
  for (i = 0; i < nNumPlanes; i++) {
    BIT_OFFSET = BIT_OFFSETS[i];
    SAVE_BITS = PLANE_WORD[i] << (31 - BIT_OFFSET);
    PLANE_WORD[i] >>= (BIT_OFFSET + 1);
    PLANE_WORD[i] |= SAVE_BITS;
    WORD_ADDR = NEXT_WORD_ADDR[i];
    *((LONG32 *) WORD_ADDR) = PLANE_WORD[i];
    PLANE_WORD[i] = (PLANE_WORD[i] >> (BIT_OFFSETS[i] + 1)) |
                    (PLANE_WORD[i] << (31 - BIT_OFFSETS[i]));
    *((LONG32 *) NEXT_WORD_ADDR[i]) = PLANE_WORD[i];
  LP("SimSavePlaneWords");
}     
#endif INTERPRETER
/*****************************************************************************/
/*                                                                           */
/* simBuildDestP.h:	modifications to original code made by		     */
/*			Harris L. Gilliam March 1994 - June 1995	     */
/*                                                                           */
/*****************************************************************************/
/*                                                                           */
/* Author	: Milan Shah						     */
/* Program	: Cam8Sim						     */
/* Date		: February 6, 1992					     */
/* Module	: compileNoPermP.h - generate code for no scan index 	     */
/*		  permutation case. Private interface.			     */
/*                                                                           */
/*****************************************************************************/
#ifndef _SIM_BUILD_DEST_P_
#define _SIM_BUILD_DEST_P_
#include "global.h"
#ifndef INTERPRETER
short PermuteScanIndex();
void MapFunction (short iSrcVar, short iDestVar, BYTE bMap);
void BuildDest(short nDest, short iDestVar, BYTE Src, BYTE Map);
void BuildBitDest(short nDest, short iHoldReg, BYTE Src, BYTE Map, unsigned short nPlane);
void BuildBitwiseDest(short nDest, short iDestVar, BYTE Src[], BYTE Map[]);
#else INTERPRETER
LONG32 *PermuteScanIndex();
void MapFunction (LONG32 *SrcVar, LONG32 *DestVar, BYTE bMap);
void BuildDest(short nDest, LONG32 *DestVar, BYTE Src, BYTE Map);
void BuildBitDest(short nDest, LONG32 *HoldReg, BYTE Src, BYTE Map, unsigned short nPlane);
void BuildBitwiseDest(short nDest, LONG32 *DestVar, BYTE Src[], BYTE Map[]);
#endif INTERPRETER
#endif
/*****************************************************************************/
/*                                                                           */
/* simGen.c:	modifications to original code made by Harris L. Gilliam     */
/*		March 1994 - June 1995					     */
/*                                                                           */
/*****************************************************************************/
/*                                                                           */
/* Author       : Milan Shah                                                 */
/* Program      : Cam8Sim                                                    */
/* Date         : April 15, 1992                                             */
/* Module       : compileGen.c - compile code to update in the presence of   */
/*                of scan index permutation                                  */
/*                                                                           */
/*****************************************************************************/
#include "global.h"
#include "errmgr.h"
#include "memmgr.h"
#include "heap.h"
#include "utils.h"
#ifndef INTERPRETER
#include "regmgr.h"
#include "icode.h"
#endif
#include "simNoPermP.h"
#include "simGen.h"
#include "simGenP.h"
#include "decode_steplist.h"
#define MODULE_NAME "SimGen"
#define SITE_ADDR_MASK	0xFFFFF
#ifndef INTERPRETER
CODEPTR pcodGenUpdate;
#endif INTERPRETER
#ifndef INTERPRETER
void SimGeneralScan(CODEHANDLE hcodCurrent)
  /************************************************************************/
  /* Sim making no assumptions - in particular, it is expected that   */
  /* the scan index will be permuted, so that updated sites will not be   */
  /* sequentially located in memory.                                      */
  /************************************************************************/
  short i;
  CODELABEL lblMainLoop, lblAddrLoop, lblSkip1, lblSkip2;
  const short iPlaneCtr = iTemp1, iOffset = iTemp2, iPlaneBases = iTemp3;
  const short iBitOffset = iTemp4, iNextWord = iTemp5, iWordAddr = iTemp6;
  const short iSiteAddress = iTemp7, iSAHighBits = iTemp8;
  const short iOffHighBits = iTemp9, iScratch = iTemp9, iPlaneAddr = iTemp10;
  const short iSAAndMask = iTemp1, iSAOrMask = iTemp2;
  LONG32 lSAAndMask, lSAOrMask;
  LONG32 lSweepLength;
  EP("SimGeneralScan");
  nNumPlanes = CalcNumPlanes();
  lblMainLoop = NewLabel();
  lblAddrLoop = NewLabel();
  lblSkip1 = NewLabel();
  lblSkip2 = NewLabel();
#else INTERPRETER
void SimGeneralScan()
  short i;
  LONG32 PLANE_CTR;
  LONG32 SA_HIGH_BITS, OFF_HIGH_BITS, SCRATCH, PLANE_ADDR;
  LONG32 SWEEP_LENGTH, SA_OR_MASK, SA_AND_MASK, WORD_ADDR;
  nNumPlanes = CalcNumPlanes();
  EP("SimGeneralScan");
  if (nNumPlanes == 0) {
    LP("SimGeneralScan");
    return;
#endif INTERPRETER
  /************************************************************************/
  /* First, update things in the heap from where they can be accessed     */
  /* by the compiled code.                                                */
  /************************************************************************/
  /************************************************************************/
  /* Update heap copy of DCMR.						  */
  /************************************************************************/
  DCMR = DCM[0];
  /************************************************************************/
  /* Update heap copy of OFFSETS					  */
  /************************************************************************/
#ifndef INTERPRETER
  for(i = 0 ; i < CHIPS_PER_MOD; i++)
    OFFSETS(i) = OSR[i];
#else INTERPRETER
  for(i = 0 ; i < CHIPS_PER_MOD; i++)
    OFFSETS[i] = OSR[i];
#endif INTERPRETER
  /************************************************************************/
  /* Figure out the site address of the first site to be updated. This is */
  /* needed to update SITE_ADDR for display purposes. Also,               */
  /* compute the SAAndMask and SAOrMask which will be used to do the      */
  /* permutation at execution time.                                       */
  /************************************************************************/
#ifndef INTERPRETER
  SITE_ADDR = 0;
  lSAOrMask = lSAAndMask = 0;
  for (i = SCAN_INDEX_LENGTH-1; i >= 0; i--) {
    
    SITE_ADDR <<= 1;
    lSAOrMask <<= 1;
    lSAAndMask <<= 1;
    
    if (SIPR[i][0] < SCAN_INDEX_LENGTH) {
      
      /* Get the correct bit of scan indx */
      SITE_ADDR |= (SIR[0] >> SIPR[i][0]) & 0x1;
      
      if (SIPR[i][0] == i)
	lSAAndMask |= 1;
    }
    
    /* Constant of 1 */
    else if (SIPR[i][0] == PERM_CONST_1) {
      lSAOrMask |= 1;
      SITE_ADDR |= 1;
    }
    
    else if (SIPR[i][0] != PERM_CONST_0)
      WARNING("Invalid SIPR value", "SimGenScan");
    
  /************************************************************************/
  /* Figure out how many sites will be updated, and how many sites/sweep  */
  /************************************************************************/
  SITE_CTR = ScanLength();
  lSweepLength = SweepLength(&X_CTR);
#else INTERPRETER
  SITE_ADDR = 0;
  SA_OR_MASK = SA_AND_MASK = 0;
  for (i = SCAN_INDEX_LENGTH-1; i >= 0; i--) {
    
    SITE_ADDR <<= 1;
    SA_OR_MASK <<= 1;
    SA_AND_MASK <<= 1;
    
    if (SIPR[i][0] < SCAN_INDEX_LENGTH) {
      
	/* Get the correct bit of scan indx */
      SITE_ADDR |= (SIR[0] >> SIPR[i][0]) & 0x1;
      
      if (SIPR[i][0] == i)
	SA_AND_MASK |= 1;
    }
    
    /* Constant of 1 */
    else if (SIPR[i][0] == PERM_CONST_1) {
      SA_OR_MASK |= 1;
      SITE_ADDR |= 1;
    }
      
    else if (SIPR[i][0] != PERM_CONST_0)
      WARNING("Invalid SIPR value", "SimGenScan");
  /************************************************************************/
  /* Figure out how many sites will be updated, and how many sites/sweep  */
  /************************************************************************/
  SITE_CTR = ScanLength();
  SWEEP_LENGTH = SweepLength(&X_CTR);
#endif INTERPRETER
  /************************************************************************/
  /* Next, generate the code. First, permute the scan index register to   */
  /* get the site address.                                                */
  /************************************************************************/
#ifndef INTERPRETER
    .LDW_MEM iSiteCtr;
    .LDW_MEM iXCtr;
    .LDW_MEM iXByteLength;
    
    .ADD_LABEL :lblMainLoop;
    
    .ENTER_BASICBLK;
    .LDW_MEM iScanIndexReg;
    
    .ADD %G0, #lSAAndMask, iSAAndMask;
    .ADD %G0, #lSAOrMask, iSAOrMask;
    
    .AND iScanIndexReg, iSAAndMask, iSiteAddress;
    .OR iSAOrMask, iSiteAddress, iSiteAddress;
    
    for (i = SCAN_INDEX_LENGTH-1; i >= 0; i--) {
      if ((SIPR[i][0] < SCAN_INDEX_LENGTH) && (SIPR[i][0] != i)) {
	.SH_LEFT iScanIndexReg, #(31 - SIPR[i][0]), iScratch;
	.ADDcc iScratch, iScratch, iScratch;
	.ADDX %G0, %G0, iTemp10;
	.SH_LEFT iTemp10, #i, iTemp10;
	.OR iTemp10, iSiteAddress, iSiteAddress;
      }
    }
      
#else INTERPRETER
  while (SITE_CTR != 0) {
    SITE_ADDR = SCAN_INDEX_REG & SA_AND_MASK;
    SITE_ADDR |= SA_OR_MASK;
    
    for (i = SCAN_INDEX_LENGTH-1; i >= 0; i--) {
      if ((SIPR[i][0] < SCAN_INDEX_LENGTH) && (SIPR[i][0] != i)) {
	SCRATCH = SCAN_INDEX_REG << (31 - SIPR[i][0]);
	bit = HIGHB(SCRATCH);
	SITE_ADDR |= (bit << i);
      }
    }
    
#endif INTERPRETER
    /************************************************************************/
    /* Now, add site address to the offset to get the DRAM address. The     */
    /* addition must break the carries at the dimension cuts. Also, DRAM    */
    /* address must be broken into a SPARC word address and a 5 bit offset  */
    /* into the word                                                        */
    /************************************************************************/
    
#ifndef INTERPRETER
    .ADD %DS, #offOffsets, iOffset;
    .ADD %DS, #offBitPlaneAddr, iPlaneBases;
    .ADD %DS, #offBitOffsets, iBitOffset;
    .ADD %DS, #offNextWordAddr, iNextWord;
    
    .LDW_MEM iDcmr;
    .AND iDcmr, iSiteAddress, iSAHighBits;
    .XNOR %G0, iDcmr, iDcmr;
    .AND iDcmr, iSiteAddress, iSiteAddress;
    .AND iDcmr, iSiteAddress, iScratch;
    .AND iScratch, #(SITE_ADDR_MASK), iSiteAddress;
    .XNOR %G0, iDcmr, iDcmr;
    
    .ADD %G0, #0, iPlaneCtr;
    .ADD_LABEL :lblAddrLoop;
    
    .LDW_IND iOffset, iPlaneCtr, iWordAddr;
    .AND iDcmr,  iWordAddr, iOffHighBits;
    .XNOR %G0, iDcmr, iDcmr;
    .AND iDcmr,  iWordAddr, iWordAddr;
    .ADD iSiteAddress, iWordAddr, iWordAddr;
    .XOR iWordAddr, iOffHighBits, iWordAddr;
    .XOR iWordAddr, iSAHighBits, iWordAddr;
    
    .LDW_IND iPlaneBases, iPlaneCtr, iPlaneAddr;
    .SH_RIGHT iWordAddr, #5, iScratch;
    .SH_LEFT iScratch, #2, iScratch;
    .ADD iScratch, iPlaneAddr, iScratch;
    .STW_IND iNextWord, iPlaneCtr, iScratch;
    .AND iWordAddr, #0x1F, iWordAddr;
    .STW_IND iBitOffset, iPlaneCtr, iWordAddr;
    
    .ADD iPlaneCtr, #4, iPlaneCtr;
    .SUBcc iPlaneCtr, #(nNumPlanes * 4), %G0;
    .BR_L :lblAddrLoop;
    .XNOR %G0, iDcmr, iDcmr;
    
    .RETURN_BASICBLK;
    
#else INTERPRETER
    SA_HIGH_BITS = SITE_ADDR & DCMR;
    SITE_ADDR = SITE_ADDR & (~ DCMR); 
    SITE_ADDR = (SITE_ADDR & (~ DCMR)) & SITE_ADDR_MASK;
    for(PLANE_CTR = 0; PLANE_CTR < nNumPlanes; PLANE_CTR++) {
      WORD_ADDR = OFFSETS[PLANE_CTR];
      OFF_HIGH_BITS = WORD_ADDR & DCMR;
      WORD_ADDR = SITE_ADDR + (WORD_ADDR & (~ DCMR));
      WORD_ADDR = (WORD_ADDR ^ OFF_HIGH_BITS) ^ SA_HIGH_BITS;
      PLANE_ADDR = BIT_PLANE_ADDR[PLANE_CTR];
      NEXT_WORD_ADDR[PLANE_CTR] = PLANE_ADDR + ((WORD_ADDR >> 5) << 2);
      BIT_OFFSETS[PLANE_CTR] = WORD_ADDR & 0x1F;
    }
#endif INTERPRETER
  /************************************************************************/
  /* Now, the heap has the word addresses and bit offsets for the next    */
  /* site. So go ahead and update the site.                               */
  /************************************************************************/
#ifndef INTERPRETER
  SimUpdateCode();
  .CALL_PROC [pcodGenUpdate];
  .NO_OP;
  .LDW_MEM iScanIndexReg;
  .SUBcc iXCtr, #1, iXCtr;
  .BR_NZ :lblSkip1;
  .NO_OP;
  .ADD %G0, #lSweepLength, iXCtr;
  .ADD_LABEL :lblSkip1;
  .ADD iScanIndexReg, #1, iScanIndexReg;
  .SUBcc iScanIndexReg, #(0xFFFFFF), iScratch;
  .BR_L :lblSkip2;
  .NO_OP;
  .OR %G0, %G0, iScanIndexReg;    
  .ADD_LABEL :lblSkip2;
  .SUBcc iSiteCtr, #1, iSiteCtr;
  .BR_NZ :lblMainLoop;
  .STW_MEM iScanIndexReg;
  LP("SimGeneralScan");
#else INTERPRETER
    SimUpdateCode();
    if ((--X_CTR) == 0)
      X_CTR = SWEEP_LENGTH;
    
    if ((++SCAN_INDEX_REG) > 0xFFFFFF)
      SCAN_INDEX_REG = 0;
    
    SITE_CTR--;
    ConstantSetAll(SIR, SCAN_INDEX_REG);
  LP("SimGeneralScan");
#endif INTERPRETER
#ifndef INTERPRETER
static void SimUpdateCode()
  CODEPTR pcodCurrent = pcodGenUpdate;
  EP("SimUpdateCode");
  NewBlock(&pcodCurrent);
  .ENTER_PROC;
  SimLoadPlaneWords();
  SimUpdateSite();
  .CALL_LEAF [pcodUpdateSite];
  .NO_OP;
  SimSavePlaneWords();
     
  .RETURN_PROC;
  EndBlock();
  LP("SimUpdateCode");
#else INTERPRETER
static void SimUpdateCode()
  EP("SimUpdateCode");
  SimLoadPlaneWords();
  SimUpdateSite();
  SimSavePlaneWords();
  LP("SimUpdateCode");
#endif INTERPRETER
#ifndef INTERPRETER
static void SimLoadPlaneWords()
  short i;
  const short iWordAddr = iTemp1;
  const short iBitOffset = iTemp1;
  const short iSaveBits = iTemp2;
  const short iScratch = iTemp3;
  EP("SimLoadPlaneWords");
  if (!IsSrcNeeded(SRC_SITE_DATA) && !IsSrcNeeded(SRC_GLUED_DATA) &&
      !IsDestUpdated(DEST_SITE_DATA)) {
    LP("SimLoadPlaneWords");
    return;
  .ADD %G0, #32, iScratch;
  for (i = 0; i < nNumPlanes; i++) {
    .LDW_IND %DS, #(offNextWordAddr+(i<<2)), iWordAddr;
    .LDW_IND iWordAddr, #0, (iPlaneWord+i);
    .LDW_IND %DS, #(offBitOffsets+(i<<2)), iBitOffset;
    .SUB iScratch, iBitOffset, iBitOffset;
    .SH_RIGHT (iPlaneWord+i), iBitOffset, iSaveBits;
    .SUB iScratch, iBitOffset, iBitOffset;
    .SH_LEFT (iPlaneWord+i), iBitOffset, (iPlaneWord+i);
    .OR (iPlaneWord+i), iSaveBits, (iPlaneWord+i);
  LP("SimLoadPlaneWords");
#else INTERPRETER
static void SimLoadPlaneWords()
  short i;
  LONG32 WORD_ADDR, BIT_OFFSET, SAVE_BITS;
  EP("SimLoadPlaneWords");
  if (!IsSrcNeeded(SRC_SITE_DATA) && !IsSrcNeeded(SRC_GLUED_DATA) &&
      !IsDestUpdated(DEST_SITE_DATA)) {
    LP("SimLoadPlaneWords");
    return;
  for (i = 0; i < nNumPlanes; i++) {
    WORD_ADDR = NEXT_WORD_ADDR[i];
    PLANE_WORD[i] = *((LONG32 *) WORD_ADDR);
    BIT_OFFSET = BIT_OFFSETS[i];
    SAVE_BITS = PLANE_WORD[i] >> (32 - BIT_OFFSET);
    PLANE_WORD[i] <<= BIT_OFFSET;
    PLANE_WORD[i] |= SAVE_BITS;
    PLANE_WORD[i] = (*((LONG32 *) NEXT_WORD_ADDR[i]) << BIT_OFFSETS[i]) |
                    (*((LONG32 *) NEXT_WORD_ADDR[i]) >> (32 - BIT_OFFSETS[i]));
  LP("SimLoadPlaneWords");
#endif INTERPRETER
#ifndef INTERPRETER
static void SimSavePlaneWords()
  short i;
  const short iWordAddr = iTemp1;
  const short iBitOffset = iTemp1;
  const short iSaveBits = iTemp2;
  const short iScratch = iTemp3;
  EP("SimSavePlaneWords");
  if (!IsDestUpdated(DEST_SITE_DATA)) {
    LP("SimSavePlaneWords");
    return;
  .ADD %G0, #31, iScratch;
  for (i = 0; i < nNumPlanes; i++) {
    .LDW_IND %DS, #(offBitOffsets+(i<<2)), iBitOffset;
    .SUB iScratch, iBitOffset, iBitOffset;
    .SH_LEFT (iPlaneWord+i), iBitOffset, iSaveBits;
    .SUB iScratch, iBitOffset, iBitOffset;
    .ADD iBitOffset, #1, iBitOffset;
    .SH_RIGHT (iPlaneWord+i), iBitOffset, (iPlaneWord+i);
    .OR (iPlaneWord+i), iSaveBits, (iPlaneWord+i);
    .LDW_IND %DS, #(offNextWordAddr+(i<<2)), iWordAddr;
    .STW_IND iWordAddr, #0, (iPlaneWord+i);
  LP("SimSavePlaneWords");
}     
#else INTERPRETER
static void SimSavePlaneWords()
  short i;
  LONG32 WORD_ADDR, BIT_OFFSET, SAVE_BITS;
  EP("SimSavePlaneWords");
  if (!IsDestUpdated(DEST_SITE_DATA)) {
    LP("SimSavePlaneWords");
    return;
  for (i = 0; i < nNumPlanes; i++) {
    BIT_OFFSET = BIT_OFFSETS[i];
    SAVE_BITS = PLANE_WORD[i] << (31 - BIT_OFFSET);
    PLANE_WORD[i] >>= (BIT_OFFSET + 1);
    PLANE_WORD[i] |= SAVE_BITS;
    WORD_ADDR = NEXT_WORD_ADDR[i];
    *((LONG32 *) WORD_ADDR) = PLANE_WORD[i];
    PLANE_WORD[i] = (PLANE_WORD[i] >> (BIT_OFFSETS[i] + 1)) |
                    (PLANE_WORD[i] << (31 - BIT_OFFSETS[i]));
    *((LONG32 *) NEXT_WORD_ADDR[i]) = PLANE_WORD[i];
  LP("SimSavePlaneWords");
}     
#endif INTERPRETER
/*****************************************************************************/
/*                                                                           */
/* simGen.h:	modifications to original code made by Harris L. Gilliam     */
/*		March 1994 - June 1995					     */
/*                                                                           */
/*****************************************************************************/
/*                                                                           */
/* Author	: Milan Shah						     */
/* Program	: Cam8Sim						     */
/* Date		: February 18, 1992					     */
/* Module	: compileGen.h - compile code for the general case, allowing */
/*		  permutation in all bits of the scan index register	     */
/*                                                                           */
/*****************************************************************************/
#ifndef _SIM_GEN_
#define _SIM_GEN_
#ifndef INTERPRETER
extern CODEPTR	pcodGenUpdate;
void SimGeneralScan(CODEHANDLE hcodCurrent);
#else INTERPRETER
void SimGeneralScan();
#endif INTERPRETER
#endif
/*****************************************************************************/
/*                                                                           */
/* simUpdateSite.c:	modifications to original code made by		     */
/*			Harris L. Gilliam March 1994 - June 1995	     */
/*                                                                           */
/*****************************************************************************/
/*                                                                           */
/* Author       : Milan Shah                                                 */
/* Program      : Cam8Sim                                                    */
/* Date         : February 6, 1992                                           */
/* Module       : compileNoPerm.c - generate code for no scan index          */
/*                permutation case.                                          */
/*                                                                           */
/*****************************************************************************/
#include <CAM/CAM.h>
#include <CAM/CAM_instr.h>
#include "sim.h"
#include "global.h"
#include "errmgr.h"
#include "memmgr.h"
#include "heap.h"
#include "utils.h"
#ifndef INTERPRETER
#include "regmgr.h"
#include "icode.h"
#endif
#include "simUpdateSiteP.h"
#include "decode_steplist.h"
#define MODULE_NAME     "SimUpdateSite"
#ifndef INTERPRETER
void SimUpdateSite()
  short i;
  CODEPTR pcodCurrent = pcodUpdateSite;
  EP("SimUpdateSite");
#ifdef _INCREMENTAL_COMPILE_     
  if (!(bSourceRegChange || bDestChange)) {
    LP("SimUpdateSite");
    return;
  else {
    bSourceRegChange = FALSE;
    bDestChange = FALSE;
#endif
  NewBlock(&pcodCurrent);
Emit(ENTER_LEAF, NULL_OP, 0, NULL_OP, 0, NULL_OP, 0);
ASCODE("  .ENTER_LEAF,   ");
#else INTERPRETER
void SimUpdateSite()
  short i;
  LONG32 SiteDataSrc = UNGLUE_DATA;
  EP("SimUpdateSite");
#endif INTERPRETER
#ifndef INTERPRETER
  if (IsSrcNeeded(SRC_TBUS) &&
      ((CAM8State.WhyScan != RFINDEX(REG_SIOR)) || (!CAM8State.bReadMode))) {
    if (!CAM8State.bImmediate) {
      if (CAM8State.bByteMode) {
Emit(LDUB_IND, VAR_OP, iTbusAddr, CONST_OP, 0, VAR_OP, iTbusData);
ASCODE("	.LDUB_IND   iTbusAddr, #0, iTbusData;");
Emit(ADD, VAR_OP, iTbusAddr, CONST_OP, 1, VAR_OP, iTbusAddr);
ASCODE("	.ADD iTbusAddr, #1, iTbusAddr;");
      } 
      
      else {
Emit(LDHW_IND, VAR_OP, iTbusAddr, CONST_OP, 0, VAR_OP, iTbusData);
ASCODE("	.LDHW_IND iTbusAddr, #0, iTbusData;");
Emit(ADD, VAR_OP, iTbusAddr, CONST_OP, 2, VAR_OP, iTbusAddr);
ASCODE("	.ADD iTbusAddr, #2, iTbusAddr;");
      }
    }
#else INTERPRETER
  if (IsSrcNeeded(SRC_TBUS) &&
      ((CAM8State.WhyScan != RFINDEX(REG_SIOR)) || (!CAM8State.bReadMode))) {
    if (!CAM8State.bImmediate) {
      if (CAM8State.bByteMode) {
	TBUS_DATA = *((BYTE *) TBUS_ADDR);
	TBUS_ADDR += 1;
      }
      
      else {
	TBUS_DATA = *((INT16 *) TBUS_ADDR);
	TBUS_ADDR += 2;
      } /* else */
    } /* if (!CAM8State.bImmediate) */
#endif INTERPRETER
#ifndef INTERPRETER
  if (IsSrcNeeded(SRC_SITE_DATA)) {
Emit(OR, REG_OP, REG_G0, REG_OP, REG_G0, VAR_OP, iUnGlueData);
ASCODE("    .OR %G0, %G0, iUnGlueData;");
    for (i = nNumPlanes-1; i >= 0; i--) {      
Emit(ADDcc, VAR_OP, (iPlaneWord+i), VAR_OP, (iPlaneWord+i), VAR_OP, (iPlaneWord+i));
ASCODE("      .ADDcc (iPlaneWord+i), (iPlaneWord+i), (iPlaneWord+i);");
Emit(ADDX, VAR_OP, iUnGlueData, VAR_OP, iUnGlueData, VAR_OP, iUnGlueData);
ASCODE("      .ADDX iUnGlueData, iUnGlueData, iUnGlueData;");
    }
  }  
#else INTERPRETER
  if (IsSrcNeeded(SRC_SITE_DATA)) {
    UNGLUE_DATA = 0;
    for (i = nNumPlanes-1; i >= 0; i--) {
      bit = HIGHB(PLANE_WORD[i]);
      PLANE_WORD[i] <<= 1; 
      UNGLUE_DATA = (UNGLUE_DATA << 1) | bit;
    }
#endif INTERPRETER
#ifndef INTERPRETER
  /* For Now glued and unglued data are the same */
  if (IsSrcNeeded(SRC_GLUED_DATA)) {
    if (!IsSrcNeeded(SRC_SITE_DATA)) {
Emit(OR, REG_OP, REG_G0, REG_OP, REG_G0, VAR_OP, iGlueData);
ASCODE("      .OR %G0, %G0, iGlueData;");
      for (i = nNumPlanes-1; i >= 0; i--) {      
Emit(ADDcc, VAR_OP, (iPlaneWord+i), VAR_OP, (iPlaneWord+i), VAR_OP, (iPlaneWord+i));
ASCODE("	.ADDcc (iPlaneWord+i), (iPlaneWord+i), (iPlaneWord+i);");
Emit(ADDX, VAR_OP, iGlueData, VAR_OP, iGlueData, VAR_OP, iGlueData);
ASCODE("	.ADDX iGlueData, iGlueData, iGlueData;");
      }
    }
    else {
Emit(OR, REG_OP, REG_G0, VAR_OP, iUnGlueData, VAR_OP, iGlueData);
ASCODE("      .OR %G0, iUnGlueData, iGlueData;");
    }
#else INTERPRETER
  /* For Now glued and unglued data are the same */
  if (IsSrcNeeded(SRC_GLUED_DATA)) {
    if (!IsSrcNeeded(SRC_SITE_DATA)) {
      GLUE_DATA = 0;
      for (i = nNumPlanes-1; i >= 0; i--) {
	bit = HIGHB(PLANE_WORD[i]);
	PLANE_WORD[i] <<= 1; 
	GLUE_DATA = (GLUE_DATA << 1) | bit;
      }
    }
    else
      GLUE_DATA = UNGLUE_DATA;
#endif INTERPRETER
#ifndef INTERPRETER
  if (IsSrcNeeded(SRC_LUT)) {
Emit(OR, REG_OP, REG_G0, REG_OP, REG_G0, VAR_OP, iLutData);
ASCODE("    .OR   %G0, %G0, iLutData;");
    if (IsSrcSame(DEST_LUT))
      BuildDest(DEST_LUT, iLutData, LAS[0], LAM[0]);            
    else
      BuildBitwiseDest(DEST_LUT, iLutData, LAS, LAM);
Emit(SH_LEFT, VAR_OP, iLutData, CONST_OP, 1, VAR_OP, iLutData);
ASCODE("    .SH_LEFT      iLutData, #1, iLutData;");
Emit(LDHW_IND, VAR_OP, iLutAddr, VAR_OP, iLutData, VAR_OP, iLutData);
ASCODE("    .LDHW_IND     iLutAddr, iLutData, iLutData;");
#else INTERPRETER
  if (IsSrcNeeded(SRC_LUT)) {
    LUT_DATA = 0;
    if (IsSrcSame(DEST_LUT))
      BuildDest(DEST_LUT, &LUT_DATA, LAS[0], LAM[0]);           
    else
      BuildBitwiseDest(DEST_LUT, &LUT_DATA, LAS, LAM);
    LUT_DATA = (LONG32) (((INT16 *) LUT_ADDR)[LUT_DATA]);
#endif INTERPRETER
  /************************************************************************/
  /*                                                                      */
  /* All the sources needed to update all the destinations should now be  */
  /* in place. Update all the destinations in the following order : EC,   */
  /* Display (ie, scan io reads), and Site Data. Note that Site data      */
  /* must be updated last, because it destroys the Site Data register,    */
  /* which is one of the possible Sources (unglued data).                 */
  /*                                                                      */
  /************************************************************************/
#ifndef INTERPRETER
  if (IsDestUpdated(DEST_DISPLAY)) {
    if (IsSrcSame(DEST_DISPLAY))
      BuildDest(DEST_DISPLAY, iTemp1, DDS[0], DDM[0]);
    else
      BuildBitwiseDest(DEST_DISPLAY, iTemp1, DDS, DDM);
#ifdef _FRAMEBUFFER_
Emit(STUB_IND, VAR_OP, iFrame, CONST_OP, 0, VAR_OP, iTemp1);
ASCODE("    .STUB_IND iFrame, #0, iTemp1;");
Emit(ADD, VAR_OP, iFrame, CONST_OP, 1, VAR_OP, iFrame);
ASCODE("    .ADD iFrame, #1, iFrame;");
#endif
#else INTERPRETER
  if (IsDestUpdated(DEST_DISPLAY)) {
    if (IsSrcSame(DEST_DISPLAY))
      BuildDest(DEST_DISPLAY, &DISP_DATA, DDS[0], DDM[0]);
    else
      BuildBitwiseDest(DEST_DISPLAY, &DISP_DATA, DDS, DDM);
#ifdef _FRAMEBUFFER_
    *((BYTE *) FRAME_ADDR) = DISP_DATA;
    FRAME_ADDR += 1;
#endif
    
#endif INTERPRETER
#ifndef INTERPRETER
  /* SCAN-IO READ */
  if ((CAM8State.WhyScan == RFINDEX(REG_SIOR)) && CAM8State.bReadMode) {
    if (CAM8State.bByteMode) {
Emit(STUB_IND, VAR_OP, iSIOR, CONST_OP, 0, VAR_OP, iTemp1);
ASCODE("      .STUB_IND iSIOR, #0, iTemp1;");
Emit(ADD, VAR_OP, iSIOR, CONST_OP, 1, VAR_OP, iSIOR);
ASCODE("      .ADD iSIOR, #1, iSIOR;");
      }
    else {
Emit(STHW_IND, VAR_OP, iSIOR, CONST_OP, 0, VAR_OP, iTemp1);
ASCODE("      .STHW_IND iSIOR, #0, iTemp1;");
Emit(ADD, VAR_OP, iSIOR, CONST_OP, 2, VAR_OP, iSIOR);
ASCODE("      .ADD iSIOR, #2, iSIOR;");
    }
#else INTERPRETER
  /* SCAN-IO READ */
  if ((CAM8State.WhyScan == RFINDEX(REG_SIOR)) && CAM8State.bReadMode) {
    if (CAM8State.bByteMode) {
      *((BYTE *) SIOR) = (BYTE) DISP_DATA;
      SIOR += 1;
    }
    else {
      *((INT16 *) SIOR) = (INT16) DISP_DATA;
      SIOR += 2;
    }
#endif INTERPRETER
#ifndef INTERPRETER
  if (IsDestUpdated(DEST_EVENT_CT)) {
    if (IsSrcSame(DEST_EVENT_CT))
      BuildDest(DEST_EVENT_CT, iTemp1, ECS[0], ECM[0]);
    else
      BuildBitwiseDest(DEST_EVENT_CT, iTemp1, ECS, ECM);
    
Emit(SH_LEFT, VAR_OP, iTemp1, CONST_OP, (32 - nNumPlanes), VAR_OP, iTemp1);
ASCODE("    .SH_LEFT iTemp1, #(32 - nNumPlanes), iTemp1;");
    for (i = nNumPlanes-1; i >= 0; i--) {
Emit(LDW_IND, REG_OP, REG_DS, CONST_OP, (offEventCount+(i<<2)), VAR_OP, iTemp2);
ASCODE("      .LDW_IND %DS, #(offEventCount+(i<<2)), iTemp2;");
Emit(ADDcc, VAR_OP, iTemp1, VAR_OP, iTemp1, VAR_OP, iTemp1);
ASCODE("      .ADDcc iTemp1, iTemp1, iTemp1;");
Emit(ADDX, VAR_OP, iTemp2, CONST_OP, 0, VAR_OP, iTemp2);
ASCODE("      .ADDX iTemp2, #0, iTemp2;");
Emit(STW_IND, REG_OP, REG_DS, CONST_OP, (offEventCount+(i<<2)), VAR_OP, iTemp2);
ASCODE("      .STW_IND %DS, #(offEventCount+(i<<2)), iTemp2;");
    }
#else INTERPRETER
  if (IsDestUpdated(DEST_EVENT_CT)) {
    if (IsSrcSame(DEST_EVENT_CT))
      BuildDest(DEST_EVENT_CT, &TEMP1, ECS[0], ECM[0]);
    else
      BuildBitwiseDest(DEST_EVENT_CT, &TEMP1, ECS, ECM);
    
    TEMP1 <<= (32 - nNumPlanes);
    for (i = nNumPlanes-1; i >= 0; i--) {
      EVENT_COUNT[i] += ((TEMP1 & 0x80000000) ? 0x1 : 0x0);
      TEMP1 <<= 1;
    }
#endif INTERPRETER
#ifndef INTERPRETER
  if (IsDestUpdated(DEST_SITE_DATA)) {
    if (IsSrcSame(DEST_SITE_DATA)) {
      if (SDM[0] == MAP_S) {
	switch(SDS[0]) {
	case SRC_SITE_DATA: {
Emit(OR, REG_OP, REG_G0, VAR_OP, iUnGlueData, VAR_OP, iSiteDataSrc);
ASCODE("	  .OR %G0, iUnGlueData, iSiteDataSrc;");
	  break;
	case SRC_TBUS: {
Emit(OR, REG_OP, REG_G0, VAR_OP, iTbusData, VAR_OP, iSiteDataSrc);
ASCODE("	  .OR %G0, iTbusData, iSiteDataSrc;");
	  break;
	case SRC_LUT: {
Emit(OR, REG_OP, REG_G0, VAR_OP, iLutData, VAR_OP, iSiteDataSrc);
ASCODE("	  .OR %G0, iLutData, iSiteDataSrc;");
	  break;
	default: {
Emit(OR, REG_OP, REG_G0, VAR_OP, iTemp1, VAR_OP, iSiteDataSrc);
ASCODE("	  .OR %G0, iTemp1, iSiteDataSrc;");
	  break;
      }
      else
	BuildDest(DEST_SITE_DATA, iSiteDataSrc, SDS[0], SDM[0]);
    }    
    else
      BuildBitwiseDest(DEST_SITE_DATA, iSiteDataSrc, SDS, SDM);
Emit(SH_LEFT, VAR_OP, iSiteDataSrc, CONST_OP, (32 - nNumPlanes), VAR_OP, iSiteDataSrc);
ASCODE("    .SH_LEFT iSiteDataSrc, #(32 - nNumPlanes), iSiteDataSrc;");
    for (i = nNumPlanes - 1; i >= 0; i--) {                                
Emit(ADDcc, VAR_OP, iSiteDataSrc, VAR_OP, iSiteDataSrc, VAR_OP, iSiteDataSrc);
ASCODE("      .ADDcc iSiteDataSrc, iSiteDataSrc, iSiteDataSrc;");
      
      if ((IsSrcNeeded(SRC_SITE_DATA)) || (IsSrcNeeded(SRC_GLUED_DATA))) {
Emit(ADDX, VAR_OP, (iPlaneWord+i), CONST_OP, 0, VAR_OP, (iPlaneWord+i));
ASCODE("	.ADDX (iPlaneWord+i), #0, (iPlaneWord+i);");
      }
      else {
Emit(ADDX, VAR_OP, (iPlaneWord+i), VAR_OP, (iPlaneWord+i), VAR_OP, (iPlaneWord+i));
ASCODE("	.ADDX (iPlaneWord+i), (iPlaneWord+i), (iPlaneWord+i);");
      }
    }
Emit(RETURN_LEAF, NULL_OP, 0, NULL_OP, 0, NULL_OP, 0);
ASCODE("  .RETURN_LEAF;");
    
  EndBlock();
  LP("SimUpdateSite");
#else INTERPRETER
  if (IsDestUpdated(DEST_SITE_DATA)) {
    if (IsSrcSame(DEST_SITE_DATA)) {
      if (SDM[0] == MAP_S) {
	SiteDataSrc = (SDS[0] == SRC_SITE_DATA ? UNGLUE_DATA :
		       SDS[0] == SRC_TBUS ? TBUS_DATA :
		       SDS[0] == SRC_LUT ? LUT_DATA : TEMP1);
      }
      
      else {
	BuildDest(DEST_SITE_DATA, &SITE_DATA, SDS[0], SDM[0]);
	SiteDataSrc = SITE_DATA;
      }
    }
    
    else {
      BuildBitwiseDest(DEST_SITE_DATA, &SITE_DATA, SDS, SDM);
      SiteDataSrc = SITE_DATA;
    }
    
    SiteDataSrc <<= (32 - nNumPlanes);
    for (i = nNumPlanes - 1; i >= 0; i--) {                                
      bit = HIGHB(SiteDataSrc);
      SiteDataSrc <<= 1;
      
      if ((IsSrcNeeded(SRC_SITE_DATA)) || (IsSrcNeeded(SRC_GLUED_DATA)))
	PLANE_WORD[i] |= bit;
      else
	PLANE_WORD[i] = (PLANE_WORD[i] << 1) | bit;
    }
  LP("SimUpdateSite");
#endif INTERPRETER
/*****************************************************************************/
/*                                                                           */
/* simGenP.h:	modifications to original code made by Harris L. Gilliam     */
/*		March 1994 - June 1995					     */
/*                                                                           */
/*****************************************************************************/
/*                                                                           */
/* Author	: Milan Shah						     */
/* Program	: Cam8Sim						     */
/* Date		: 4/16/92						     */
/* Module	: compileGenP.h - private header for general scan compiler   */
/*                                                                           */
/*****************************************************************************/
#ifndef _SIM_GEN_P_
#define _SIM_GEN_P_
#include "global.h"
#ifndef INTERPRETER
static void SimUpdateCode();
static void SimLoadPlaneWords();
static void SimSavePlaneWords();
#else INTERPRETER
static void SimUpdateCode();
static void SimLoadPlaneWords();
static void SimSavePlaneWords();
#endif INTERPRETER
#endif
/*****************************************************************************/
/*                                                                           */
/* simNoPerm.c:	modifications to original code made by Harris L. Gilliam     */
/*		March 1994 - June 1995					     */
/*                                                                           */
/*****************************************************************************/
/*                                                                           */
/* Author       : Milan Shah                                                 */
/* Program      : Cam8Sim                                                    */
/* Date         : February 6, 1992                                           */
/* Module       : compileNoPerm.c - generate code for no scan index          */
/*                permutation case.                                          */
/*                                                                           */
/*****************************************************************************/
#include "global.h"
#include "errmgr.h"
#include "memmgr.h"
#include "heap.h"
#include "utils.h"
#ifndef INTERPRETER
#include "regmgr.h"
#include "icode.h"
#endif INTERPRETER
#include "simNoPerm.h"
#include "simNoPermP.h"
#include "decode_steplist.h"
#define MODULE_NAME "SimNoPerm"
#ifndef INTERPRETER
static void SimSweepCode();
#else INTERPRETER
static void SimSweepCode();
#endif INTERPRETER
#ifndef INTERPRETER
void SimScanNoPerm(CODEHANDLE hcodCurrent)
  LONG32 lTemp1, lTemp2;
  CODELABEL lblYLoop, lblAddrLoop, lblSkip;
  const short iPlaneCtr = iTemp1,
  iHeapOffset = iTemp2,
  iWordAddr = iTemp3,
  iHighBit = iTemp4;
  EP("SimScanNoPerm");
  lblSkip = NewLabel();
  lblYLoop = NewLabel();
  lblAddrLoop = NewLabel();
  /************************************************************************/
  /* Sim assuming the scan index is not permuted. This implies that   */
  /* bits to be updated during this scan are all consecutive.             */
  /************************************************************************/
#else INTERPRETER
void SimScanNoPerm()
  LONG32 PLANE_CTR, WORD_ADDR, HIGH_BIT;
  EP("SimScanNoPerm");
#endif INTERPRETER
  /************************************************************************/
  /* compute HIGH_BIT_MASK and X_HIGH_BIT_MASK				  */
  /************************************************************************/
  HIGH_BIT_MASK = lDCMRHighBit >> 3;
  X_HIGH_BIT_MASK = lDCMRLowBit >> 3;
  /************************************************************************/
  /* SITE_CTR is set to how many sweeps are to be done. X_BYTE_LENGTH is  */
  /* set to how many bytes will be updated per sweep                      */
  /************************************************************************/
  if (ESC[0] < lNumXBits) {
    SITE_CTR = 1;
    X_BYTE_LENGTH = 1 << (ESC[0] - 3);
  else {
    SITE_CTR = ScanLength() >> lNumXBits;                                  
    X_BYTE_LENGTH = lDCMRLowBit >> 2;
  nNumPlanes = CalcNumPlanes();
#ifdef INTERPRETER
  if (nNumPlanes == 0) {
    LP("SimScanNoPerm");
    return;
#endif INTERPRETER
  /************************************************************************/
  /* Code starts here                                                     */
  /************************************************************************/
#ifndef INTERPRETER
  .LDW_MEM iSiteCtr;
  .ADD_LABEL :lblYLoop;
  SimSweepCode();
  .CALL_PROC [pcodSweep];
  .NO_OP;
  .ADD %DS, #offNextWordAddr, iHeapOffset;
  .LDW_MEM iHighBitMask;
  .LDW_MEM iXByteLength;
  .ADD %G0, #0, iPlaneCtr;
  .ADD_LABEL :lblAddrLoop;
  .SUBcc iPlaneCtr, #(nNumPlanes*4), %G0;
  .BR_GRE :lblSkip;
  .LDW_IND iHeapOffset, iPlaneCtr, iWordAddr;
  .AND iHighBitMask, iWordAddr, iHighBit;
  .XNOR iHighBitMask, %G0, iHighBitMask;
  .AND iHighBitMask, iWordAddr, iWordAddr;
  .ADD iXByteLength, iWordAddr, iWordAddr;
  .XOR iHighBit, iWordAddr, iWordAddr;
  .STW_IND iHeapOffset, iPlaneCtr, iWordAddr;
  .ADD iPlaneCtr, #4, iPlaneCtr;
  .BRANCH :lblAddrLoop;
  .XNOR iHighBitMask, %G0, iHighBitMask;
  .ADD_LABEL :lblSkip;
  .SH_LEFT iXByteLength, #3, iTemp1;
  .LDW_MEM iScanIndexReg;
  .ADD iScanIndexReg, iTemp1, iScanIndexReg;
  .SUBcc iScanIndexReg, #0xFFFFFF, iTemp1;
  .BR_L :lblSkip;
  .NO_OP;
  .OR %G0, %G0, iScanIndexReg;
  .ADD_LABEL :lblSkip;
  .SUBcc iSiteCtr, #1, iSiteCtr;
  .BR_NZ :lblYLoop;
  .STW_MEM iScanIndexReg;
  LP("SimScanNoPerm");
#else INTERPRETER
  while (SITE_CTR != 0) {
    SimSweepCode();
    for(PLANE_CTR = 0; PLANE_CTR < nNumPlanes; PLANE_CTR++) {  
      WORD_ADDR = NEXT_WORD_ADDR[PLANE_CTR];
      HIGH_BIT = WORD_ADDR & HIGH_BIT_MASK;
      WORD_ADDR &= (~ HIGH_BIT_MASK);
      WORD_ADDR += X_BYTE_LENGTH;
      WORD_ADDR ^= HIGH_BIT;
      NEXT_WORD_ADDR[PLANE_CTR] = WORD_ADDR;
      /*
      NEXT_WORD_ADDR[PLANE_CTR] =
	(((NEXT_WORD_ADDR[PLANE_CTR] & (~ HIGH_BIT_MASK)) + X_BYTE_LENGTH) ^
	 (NEXT_WORD_ADDR[PLANE_CTR] & HIGH_BIT_MASK));
	 */
    }
    SCAN_INDEX_REG += (X_BYTE_LENGTH << 3);
    if (SCAN_INDEX_REG > 0xFFFFFF)
      SCAN_INDEX_REG = 0;
    SITE_CTR--;
    ConstantSetAll(SIR, SCAN_INDEX_REG);
  LP("SimScanNoPerm");
#endif INTERPRETER
#ifndef INTERPRETER
void SimSweepCode()
  LONG32 xWordLength;
  CODELABEL lblXLoop;
  unsigned short nBitOffset[CHIPS_PER_MOD];
  short i, j;
  CODEPTR pcodCurrent = pcodSweep;
  EP("SimSweepCode");
  lblXLoop = NewLabel();
#else INTERPRETER
void SimSweepCode()
  short i, j;
  LONG32 NBIT_OFFSET[CHIPS_PER_MOD], XWORD_LENGTH;
  EP("SimSweepCode");
#endif INTERPRETER
  /************************************************************************/
  /* We assume here that the scan index is not permuted to arrive at the  */
  /* site address; however, some bits of the site address could be fixed  */
  /* at constant 0 or 1 as indicated by SIPR. Here, the site address of   */
  /* the first site to be updated is computed.                            */
  /************************************************************************/
  SITE_ADDR = 0;
  for (i = SCAN_INDEX_LENGTH-1; i >= 0; i--) {
    
    SITE_ADDR <<= 1;
    if (SIPR[i][0] == PERM_CONST_1)
      SITE_ADDR |= 0x1;
    else if (SIPR[i][0] != PERM_CONST_0)
      SITE_ADDR |= (SIR[0] >> i) & 0x1;
  /************************************************************************/
  /* Now that we know the site address of the first site to be updated,   */
  /* we compute the address in sparc memory of the word that contains     */
  /* a bit of that site by adding the plane offset to the site address.   */
  /************************************************************************/
#ifndef INTERPRETER
  for (i = 0; i < nNumPlanes; i++) {
    NEXT_WORD_ADDR(i) = (AddSiteAddress(SITE_ADDR, OSR[i]) >> 5) << 2;
    NEXT_WORD_ADDR(i) += BIT_PLANE_ADDR(i);
    nBitOffset[i] = OSR[i] & 0x1F;
  xWordLength = X_BYTE_LENGTH >> 2;
  NewBlock(&pcodCurrent);
  .ENTER_PROC;
  SimLoadFirstWord(nBitOffset);
  if (IsSrcNeeded(SRC_SITE_ADDRESS)) {
    .LDW_MEM iScanIndexReg;
  if (IsSrcNeeded(SRC_LUT)) {
    .LDW_MEM iLutAddr;
  .LDW_MEM iUpdateSiteProc;
  .ADD %G0, #xWordLength, iXCtr;
  .ADD_LABEL :lblXLoop;
  SimUpdateSite();
  for (i = 0; i < 32; i++) {
    .CALL_LEAF_IND iUpdateSiteProc, #4;
    .INSTR *pcodUpdateSite;
    for (j = 0; j < nNumPlanes; j++) {
      if (nBitOffset[j] == (31 - i)) {
	SimGetNextWord(j);
      }
    }
  .SUBcc iXCtr, #1, iXCtr;
  .BR_NZ :lblXLoop;
  .NO_OP;
  SimSaveLastWord(nBitOffset);
  .RETURN_PROC;
  EndBlock();
  LP("SimSweepCode");
#else INTERPRETER
  for (i = 0; i < nNumPlanes; i++) {
    NEXT_WORD_ADDR[i] = (AddSiteAddress(SITE_ADDR, OSR[i]) >> 5) << 2;
    NEXT_WORD_ADDR[i] += BIT_PLANE_ADDR[i];
    NBIT_OFFSET[i] = OSR[i] & 0x1F;
  XWORD_LENGTH = X_BYTE_LENGTH >> 2;
  SimLoadFirstWord(NBIT_OFFSET);
  X_CTR = XWORD_LENGTH;
  do {
    for (i = 0; i < 32; i++) {
      SimUpdateSite();
      for (j = 0; j < nNumPlanes; j++) {
	if (NBIT_OFFSET[j] == (31 - i))
	  SimGetNextWord(j);
      }
    }
    X_CTR -= 1;
  } while (X_CTR);
  SimSaveLastWord(NBIT_OFFSET);
  LP("SimSweepCode");
#endif INTERPRETER
#ifndef INTERPRETER
void SimLoadFirstWord(unsigned short nBitOffset[])
  short i;
  const short iSaveBits = iTemp1;
  const short iWordAddr = iTemp1;
  EP("SimLoadFirstWord");
  for (i = 0; i < nNumPlanes; i++) {
    .LDW_IND %DS, #(offNextWordAddr+(i<<2)), iWordAddr;
    .LDW_IND iWordAddr, #0, (iPlaneWord+i);
    if (nBitOffset[i] != 0) {
      .SH_RIGHT (iPlaneWord+i), #(32 - nBitOffset[i]), iSaveBits;
      .SH_LEFT (iPlaneWord+i), #nBitOffset[i], (iPlaneWord+i);
      .OR (iPlaneWord+i), iSaveBits, (iPlaneWord+i);
    }
  LP("SimLoadFirstWord");
#else INTERPRETER
void SimLoadFirstWord(LONG32 NBIT_OFFSET[])
  short i;
  LONG32 SAVE_BITS, WORD_ADDR;
  EP("SimLoadFirstWord");
  for (i = 0; i < nNumPlanes; i++) {
    PLANE_WORD[i] = *((LONG32 *) NEXT_WORD_ADDR[i]);
    
    if (NBIT_OFFSET[i] != 0) {
      SAVE_BITS = PLANE_WORD[i] >> (32 - NBIT_OFFSET[i]);
      PLANE_WORD[i] <<= NBIT_OFFSET[i];
      PLANE_WORD[i] |= SAVE_BITS;
    }
  LP("SimLoadFirstWord");
#endif INTERPRETER
#ifndef INTERPRETER
void SimGetNextWord(unsigned short nPlane)
  const short iAddrHighBit = iTemp1;
  BOOL bWriteBack = FALSE;
  short i;
  EP("SimGetNextWord");
#else INTERPRETER
void SimGetNextWord(unsigned short nPlane)
  LONG32 ADDR_HIGH_BIT;
  BOOL bWriteBack = FALSE;
  short i;
  EP("SimGetNextWord");
#endif INTERPRETER
#ifndef INTERPRETER
  .ENTER_BASICBLK;
  if (IsDestUpdated(DEST_SITE_DATA)) {
    .STW_IND (iNextWordAddr+nPlane), #0, (iPlaneWord+nPlane);
  if (lNumXBits <= 5) {
    .RETURN_BASICBLK;
    LP("SimGetNextWord");
    return;
  .AND (iNextWordAddr+nPlane), iXHighBitMask, iAddrHighBit;
  .XNOR iXHighBitMask, %G0, iXHighBitMask;
  .AND (iNextWordAddr+nPlane), iXHighBitMask, (iNextWordAddr+nPlane);
  .ADD (iNextWordAddr+nPlane), #4, (iNextWordAddr+nPlane);
  .XOR iAddrHighBit, (iNextWordAddr+nPlane), iNextWordAddr+nPlane;
  .XNOR iXHighBitMask, %G0, iXHighBitMask;
  .LDW_IND (iNextWordAddr+nPlane), #0, (iPlaneWord+nPlane);
  .STW_MEM (iNextWordAddr+nPlane);
  .RETURN_BASICBLK;
  LP("SimGetNextWord");
#else INTERPRETER
  if (IsDestUpdated(DEST_SITE_DATA))
      *((LONG32 *) NEXT_WORD_ADDR[nPlane]) = PLANE_WORD[nPlane];
  if (lNumXBits <= 5) {
    LP("SimGetNextWord");
    return;
  ADDR_HIGH_BIT = NEXT_WORD_ADDR[nPlane] & X_HIGH_BIT_MASK;
  NEXT_WORD_ADDR[nPlane] &= (~ X_HIGH_BIT_MASK);
  NEXT_WORD_ADDR[nPlane] = (NEXT_WORD_ADDR[nPlane] + 4) ^ ADDR_HIGH_BIT;
  PLANE_WORD[nPlane] = *((LONG32 *) NEXT_WORD_ADDR[nPlane]);
  LP("SimGetNextWord");
#endif INTERPRETER
#ifndef INTERPRETER
void SimSaveLastWord(unsigned short nBitOffset[])
  short i;
  const short iSaveBits = iTemp1;
  EP("SimSaveLastWord");
#else INTERPRETER
void SimSaveLastWord(LONG32 NBIT_OFFSET[])
  short i;
  LONG32 SAVE_BITS;
  EP("SimSaveLastWord");
#endif INTERPRETER
#ifndef INTERPRETER
  if (IsDestUpdated(DEST_SITE_DATA)) {
    .ENTER_BASICBLK;
    for (i = 0; i < nNumPlanes; i++) {
      if (!nBitOffset[i])
	continue;
      .SH_RIGHT (iPlaneWord+i), #(nBitOffset[i]), iSaveBits;
      .SH_LEFT (iPlaneWord+i), #(32 - nBitOffset[i]), (iPlaneWord+i);
      .OR (iPlaneWord+i), iSaveBits, (iPlaneWord+i);
      .STW_IND (iNextWordAddr+i), #0, (iPlaneWord+i);
    }
    .RETURN_BASICBLK;
  LP("SimSaveLastWord");
#else INTERPRETER
  if (IsDestUpdated(DEST_SITE_DATA)) {
    for (i = 0; i < nNumPlanes; i++) {
      if (!NBIT_OFFSET[i])
	continue;
      SAVE_BITS = PLANE_WORD[i] >> NBIT_OFFSET[i];
      PLANE_WORD[i] <<= (32 - NBIT_OFFSET[i]);
      PLANE_WORD[i] |= SAVE_BITS;
      *((LONG32 *) NEXT_WORD_ADDR[i]) = PLANE_WORD[i];
    }
  LP("SimSaveLastWord");
#endif INTERPRETER
/*****************************************************************************/
/*                                                                           */
/* simNoPerm.h:	modifications to original code made by Harris L. Gilliam     */
/*		March 1994 - June 1995					     */
/*                                                                           */
/*****************************************************************************/
/*                                                                           */
/* Author 	: Milan Shah						     */
/* Program	: Cam8Sim						     */
/* Date		: February 5, 1992					     */
/* Module	: compileNoPerm.h - generate code for No scan index          */
/*		  permutation case.					     */
/*                                                                           */
/*****************************************************************************/
#ifndef _SIM_NO_PERM_
#define _SIM_NO_PERM_
#include "global.h"
#include "sim.h"
#ifndef INTERPRETER
extern CODE *pcodScanNoPerm;
void SimScanNoPerm(CODEHANDLE hcodCurrent);
#else INTERPRETER
void SimScanNoPerm();
#endif INTERPRETER
#endif
/*****************************************************************************/
/*                                                                           */
/* simBuildDest.c:	modifications to original code made by		     */
/*			Harris L. Gilliam March 1994 - June 1995	     */
/*                                                                           */
/*****************************************************************************/
/*                                                                           */
/* Author       : Milan Shah                                                 */
/* Program      : Cam8Sim                                                    */
/* Date         : February 6, 1992                                           */
/* Module       : compileNoPerm.c - generate code for no scan index          */
/*                permutation case.                                          */
/*                                                                           */
/*****************************************************************************/
#include "global.h"
#include "errmgr.h"
#include "memmgr.h"
#include "heap.h"
#include "utils.h"
#ifndef INTERPRETER
#include "regmgr.h"
#include "icode.h"
#endif INTERPRETER
#include "simBuildDestP.h"
#include "decode_steplist.h"
#define MODULE_NAME "SimBuildDest"
#ifndef INTERPRETER
short PermuteScanIndex()
#else INTERPRETER
LONG32 *PermuteScanIndex()
#endif INTERPRETER
  short i;
  BOOL bIsPermuted = FALSE;
  EP("PermuteScanIndex");
  for (i = nNumPlanes - 1; i >= 0; i--) {
    if (SABSR[i] != i) {
      bIsPermuted = TRUE;
      break;
    }
#ifndef INTERPRETER
  if (!bIsPermuted) {
    LP("PermuteScanIndex");
    return (iScanIndexReg);
#else INTERPRETER
  if (!bIsPermuted) {
    LP("PermuteScanIndex");
    return(&SCAN_INDEX_REG);
#endif INTERPRETER
#ifndef INTERPRETER
Emit(OR, REG_OP, REG_G0, REG_OP, REG_G0, VAR_OP, iTemp6);
ASCODE("  .OR %G0, %G0, iTemp6;");
  for (i = nNumPlanes-1; i >= 0; i--) {
    if (SABSR[i] < 24) {
Emit(SH_LEFT, VAR_OP, iScanIndexReg, CONST_OP, (31 - SABSR[i]), VAR_OP, iTemp5);
ASCODE("      .SH_LEFT iScanIndexReg, #(31 - SABSR[i]), iTemp5;");
Emit(ADDcc, VAR_OP, iTemp5, VAR_OP, iTemp5, VAR_OP, iTemp5);
ASCODE("      .ADDcc iTemp5, iTemp5, iTemp5;");
Emit(ADDXcc, VAR_OP, iTemp6, VAR_OP, iTemp6, VAR_OP, iTemp6);
ASCODE("      .ADDXcc iTemp6, iTemp6, iTemp6;");
    }
    else if (SABSR[i] == 31) {
Emit(SH_LEFT, VAR_OP, iTemp6, CONST_OP, 1, VAR_OP, iTemp6);
ASCODE("      .SH_LEFT iTemp6, #1, iTemp6;");
Emit(ADD, VAR_OP, iTemp6, CONST_OP, 1, VAR_OP, iTemp6);
ASCODE("      .ADD iTemp6, #1, iTemp6;");
    }
    else if (SABSR[i] == 30) {
Emit(SH_LEFT, VAR_OP, iTemp6, CONST_OP, 1, VAR_OP, iTemp6);
ASCODE("      .SH_LEFT iTemp6, #1, iTemp6;");
    }
    else {
      WARNING("Invalid SABSR value!", "PermuteScanIndex");
Emit(SH_LEFT, VAR_OP, iTemp6, CONST_OP, 1, VAR_OP, iTemp6);
ASCODE("      .SH_LEFT iTemp6, #1, iTemp6;");
    }
  LP("PermuteScanIndex");
  return (iTemp6);
#else INTERPRETER
  TEMP6 = 0;
  for (i = nNumPlanes-1; i >= 0; i--) {
    if (SABSR[i] < 24) {
      TEMP5 = SCAN_INDEX_REG << (31 - SABSR[i]);
      bit = HIGHB(TEMP6);
      TEMP6 = (TEMP6 << 1) | HIGHB(TEMP5);
      TEMP5 <<= 1;
    }
    else if (SABSR[i] == 31) {
      TEMP6 <<= 1;
      TEMP6 += 1;
    }
    else if (SABSR[i] == 30) {
      TEMP6 <<= 1;
    }
    else {
      WARNING("Invalid SABSR value!", "PermuteScanIndex");
      TEMP6 <<= 1;
    }
  LP("PermuteScanIndex");
  return (&TEMP6);
#endif INTERPRETER
#ifndef INTERPRETER
void MapFunction (short iSrcVar, short iDestVar, BYTE bMap)
#else INTERPRETER
void MapFunction (LONG32 *SrcVar, LONG32 *DestVar, BYTE bMap)
#endif INTERPRETER
  EP("MapFunction");
  switch (bMap) {
  case MAP_CONST_0: {
#ifndef INTERPRETER
Emit(OR, REG_OP, REG_G0, REG_OP, REG_G0, VAR_OP, iDestVar);
ASCODE("    .OR %G0, %G0, iDestVar;");
#else INTERPRETER
    *DestVar = 0;
#endif INTERPRETER
    break;
    
  case MAP_G_NOR_S: {
#ifndef INTERPRETER
    /* Surprizingly, SPARC does not have*/
    /* a native NOR instruction! ORN is */
    /* not NOR!!!                       */
Emit(OR, VAR_OP, iGlueData, VAR_OP, iSrcVar, VAR_OP, iDestVar);
ASCODE("    .OR iGlueData, iSrcVar, iDestVar;");
Emit(XNOR, REG_OP, REG_G0, VAR_OP, iDestVar, VAR_OP, iDestVar);
ASCODE("    .XNOR %G0, iDestVar, iDestVar;");
#else INTERPRETER
    *DestVar = ~ (GLUE_DATA | *SrcVar);
#endif INTERPRETER
    break;
}    
  case MAP_G_AND_S_BAR: {
#ifndef INTERPRETER
Emit(XNOR, REG_OP, REG_G0, VAR_OP, iSrcVar, VAR_OP, iDestVar);
ASCODE("    .XNOR %G0, iSrcVar, iDestVar;");
Emit(AND, VAR_OP, iGlueData, VAR_OP, iDestVar, VAR_OP, iDestVar);
ASCODE("    .AND iGlueData, iDestVar, iDestVar;");
#else INTERPRETER
    *DestVar = GLUE_DATA & (~ *SrcVar);
#endif INTERPRETER
    break;
    
  case MAP_S_BAR: {
#ifndef INTERPRETER
Emit(XNOR, REG_OP, REG_G0, VAR_OP, iSrcVar, VAR_OP, iDestVar);
ASCODE("    .XNOR %G0, iSrcVar, iDestVar;");
#else INTERPRETER
    *DestVar = ~ *SrcVar;
#endif INTERPRETER
    break;
    
  case MAP_G_BAR_AND_S: {
#ifndef INTERPRETER
Emit(XNOR, REG_OP, REG_G0, VAR_OP, iGlueData, VAR_OP, iDestVar);
ASCODE("    .XNOR %G0, iGlueData, iDestVar;");
Emit(AND, VAR_OP, iSrcVar, VAR_OP, iDestVar, VAR_OP, iDestVar);
ASCODE("    .AND iSrcVar, iDestVar, iDestVar;");
#else INTERPRETER
    *DestVar = (~ GLUE_DATA) & *SrcVar;
#endif INTERPRETER
    break;
    
  case MAP_G_BAR: {
#ifndef INTERPRETER
Emit(XNOR, REG_OP, REG_G0, VAR_OP, iGlueData, VAR_OP, iDestVar);
ASCODE("    .XNOR %G0, iGlueData, iDestVar;");
#else INTERPRETER
    *DestVar = ~ GLUE_DATA;
#endif INTERPRETER
    break;
    
  case MAP_G_XOR_S: {
#ifndef INTERPRETER
Emit(XOR, VAR_OP, iGlueData, VAR_OP, iSrcVar, VAR_OP, iDestVar);
ASCODE("    .XOR iGlueData, iSrcVar, iDestVar;");
#else INTERPRETER
    *DestVar = GLUE_DATA ^ *SrcVar;
#endif INTERPRETER
    break;
    
  case MAP_G_NAND_S: {
#ifndef INTERPRETER
    /* SPARC does not have a native NAND */
    /* instruction! ANDN is not NAND     */
Emit(AND, VAR_OP, iGlueData, VAR_OP, iSrcVar, VAR_OP, iDestVar);
ASCODE("    .AND iGlueData, iSrcVar, iDestVar;");
Emit(XNOR, REG_OP, REG_G0, VAR_OP, iDestVar, VAR_OP, iDestVar);
ASCODE("    .XNOR %G0, iDestVar, iDestVar;");
#else INTERPRETER
    *DestVar = ~ (GLUE_DATA & *SrcVar);
#endif INTERPRETER
    break;
    
  case MAP_G_AND_S: {
#ifndef INTERPRETER
Emit(AND, VAR_OP, iGlueData, VAR_OP, iSrcVar, VAR_OP, iDestVar);
ASCODE("    .AND iGlueData, iSrcVar, iDestVar;");
#else INTERPRETER
    *DestVar = GLUE_DATA & *SrcVar;
#endif INTERPRETER
    break;
    
  case MAP_G_EQ_S: {
#ifndef INTERPRETER
Emit(XNOR, VAR_OP, iGlueData, VAR_OP, iSrcVar, VAR_OP, iDestVar);
ASCODE("    .XNOR iGlueData, iSrcVar, iDestVar;");
#else INTERPRETER
    *DestVar = ~ (GLUE_DATA ^ *SrcVar);
#endif INTERPRETER
    break;
    
  case MAP_G: {
#ifndef INTERPRETER
Emit(XOR, REG_OP, REG_G0, VAR_OP, iGlueData, VAR_OP, iDestVar);
ASCODE("    .XOR %G0, iGlueData, iDestVar;");
#else INTERPRETER
    *DestVar = GLUE_DATA;
#endif INTERPRETER
    break;
    
  case MAP_G_OR_S_BAR: {
#ifndef INTERPRETER
Emit(XNOR, REG_OP, REG_G0, VAR_OP, iSrcVar, VAR_OP, iDestVar);
ASCODE("    .XNOR %G0, iSrcVar, iDestVar;");
Emit(OR, VAR_OP, iGlueData, VAR_OP, iDestVar, VAR_OP, iDestVar);
ASCODE("    .OR iGlueData, iDestVar, iDestVar;");
#else INTERPRETER
    *DestVar = GLUE_DATA | (~ *SrcVar);
#endif INTERPRETER
    break;
    
  case MAP_S: {
#ifndef INTERPRETER
Emit(XOR, REG_OP, REG_G0, VAR_OP, iSrcVar, VAR_OP, iDestVar);
ASCODE("    .XOR %G0, iSrcVar, iDestVar");
#else INTERPRETER
    *DestVar = *SrcVar;
#endif INTERPRETER
      break;
    
  case MAP_G_BAR_OR_S: {
#ifndef INTERPRETER
Emit(XNOR, REG_OP, REG_G0, VAR_OP, iGlueData, VAR_OP, iDestVar);
ASCODE("    .XNOR %G0, iGlueData, iDestVar;");
Emit(OR, VAR_OP, iSrcVar, VAR_OP, iDestVar, VAR_OP, iDestVar);
ASCODE("    .OR iSrcVar, iDestVar, iDestVar;");
#else INTERPRETER
    *DestVar = (~ GLUE_DATA) | *SrcVar;
#endif INTERPRETER
      break;
    
  case MAP_G_OR_S: {
#ifndef INTERPRETER
Emit(OR, VAR_OP, iGlueData, VAR_OP, iSrcVar, VAR_OP, iDestVar);
ASCODE("    .OR iGlueData, iSrcVar, iDestVar;");
#else INTERPRETER
    *DestVar = GLUE_DATA | *SrcVar;
#endif INTERPRETER
    break;
    
  case MAP_CONST_1: {
#ifndef INTERPRETER
Emit(XNOR, REG_OP, REG_G0, REG_OP, REG_G0, VAR_OP, iDestVar);
ASCODE("    .XNOR %G0, %G0, iDestVar;");
#else INTERPRETER
    *DestVar = 0xFFFFFFFF;
#endif INTERPRETER
    break;
  LP("MapFunction");
#ifndef INTERPRETER
void BuildDest(short nDest, short iDestVar, BYTE Src, BYTE Map)
  short iSrcVar;
#else INTERPRETER
void BuildDest(short nDest, LONG32 *DestVar, BYTE Src, BYTE Map)
  LONG32 *SrcVar;
#endif INTERPRETER
  EP("BuildDest");
#ifndef INTERPRETER
  if ((Map != MAP_G) && (Map != MAP_G_BAR)) {
    iSrcVar = (Src == SRC_SITE_DATA ? iUnGlueData :
	       Src == SRC_TBUS ? iTbusData :
	       Src == SRC_LUT ? iLutData : iTemp1);
    if ((nDest == DEST_LUT) && (Src == SRC_SITE_ADDRESS)) {
      iSrcVar = PermuteScanIndex();
    }
  MapFunction(iSrcVar, iDestVar, Map);
#else INTERPRETER
  if ((Map != MAP_G) && (Map != MAP_G_BAR)) {
    SrcVar = (Src == SRC_SITE_DATA ? &UNGLUE_DATA :
	      Src == SRC_TBUS ? &TBUS_DATA :
	      Src == SRC_LUT ? &LUT_DATA : &TEMP1);
    if ((nDest == DEST_LUT) && (Src == SRC_SITE_ADDRESS)) {
      SrcVar = PermuteScanIndex();
    }
  MapFunction(SrcVar, DestVar, Map);
#endif INTERPRETER
  LP("BuildDest");
#ifndef INTERPRETER
void BuildBitDest(short nDest, short iHoldReg, BYTE Src, BYTE Map,
		  unsigned short nPlane)
{                                                               
     
#else INTERPRETER
void BuildBitDest(short nDest, LONG32 *HoldReg, BYTE Src, BYTE Map,
		  unsigned short nPlane)
{                                                               
#endif INTERPRETER
  EP("BuildBitDest");
#ifndef INTERPRETER
  if ((nDest == DEST_LUT) && (Src == SRC_SITE_ADDRESS)) {
Emit(OR, REG_OP, REG_G0, REG_OP, REG_G0, VAR_OP, iTemp6);
ASCODE("    .OR           %G0, %G0, iTemp6;");
    
    if (SABSR[nPlane] < 24) {
Emit(SH_LEFT, VAR_OP, iScanIndexReg, CONST_OP, (31 - SABSR[nPlane]), VAR_OP, iTemp5);
ASCODE("      .SH_LEFT iScanIndexReg, #(31 - SABSR[nPlane]), iTemp5;");
Emit(ADDcc, VAR_OP, iTemp5, VAR_OP, iTemp5, VAR_OP, iTemp5);
ASCODE("      .ADDcc iTemp5, iTemp5, iTemp5;");
Emit(ADDXcc, VAR_OP, iTemp6, VAR_OP, iTemp6, VAR_OP, iTemp6);
ASCODE("      .ADDXcc iTemp6, iTemp6, iTemp6;");
Emit(SH_LEFT, VAR_OP, iTemp6, CONST_OP, nPlane, VAR_OP, iTemp6);
ASCODE("      .SH_LEFT iTemp6, #nPlane, iTemp6;");
    }
    else if (SABSR[nPlane] == 31) {
Emit(SH_LEFT, VAR_OP, iTemp6, CONST_OP, 1, VAR_OP, iTemp6);
ASCODE("      .SH_LEFT iTemp6, #1, iTemp6;");
Emit(ADD, VAR_OP, iTemp6, CONST_OP, 1, VAR_OP, iTemp6);
ASCODE("      .ADD iTemp6, #1, iTemp6;");
    }
    else if (SABSR[nPlane] == 30) {
Emit(SH_LEFT, VAR_OP, iTemp6, CONST_OP, 1, VAR_OP, iTemp6);
ASCODE("      .SH_LEFT iTemp6, #1, iTemp6;");
    }
    else {
      WARNING("Invalid SABSR value", "BuildBitDest");
Emit(SH_LEFT, VAR_OP, iTemp6, CONST_OP, 1, VAR_OP, iTemp6);
ASCODE("      .SH_LEFT iTemp6, #1, iTemp6;");
    }      
    MapFunction (iTemp6, iHoldReg, Map);
  else
    BuildDest(nDest, iHoldReg, Src, Map);
#else INTERPRETER
  if ((nDest == DEST_LUT) && (Src == SRC_SITE_ADDRESS)) {
    TEMP6 = 0;
    if (SABSR[nPlane] < 24) {
      TEMP5 = SCAN_INDEX_REG << (31 - SABSR[nPlane]);
      bit = HIGHB(TEMP6);
      TEMP6 = ((TEMP6 << 1) | HIGHB(TEMP5)) << nPlane;
      TEMP5 <<= 1;
    }
    else if (SABSR[nPlane] == 31)
      TEMP6 = (TEMP6 << 1) + 1;
    else if (SABSR[nPlane] == 30)
      TEMP6 <<= 1;
    else {
      WARNING("Invalid SABSR value", "BuildBitDest");
      TEMP6 <<= 1;
    }
    MapFunction (&TEMP6, HoldReg, Map);
  else
    BuildDest(nDest, HoldReg, Src, Map);
#endif INTERPRETER
  LP("BuildBitDest");
#ifndef INTERPRETER
void BuildBitwiseDest(short nDest, short iDestVar, BYTE Src[], BYTE Map[])
  short i;
  short iHoldReg = iTemp4;
#else INTERPRETER
void BuildBitwiseDest(short nDest, LONG32 *DestVar, BYTE Src[], BYTE Map[])
  short i;
  LONG32 *HoldReg = &TEMP4;
#endif INTERPRETER
  EP("BuildBitwiseDest");
#ifndef INTERPRETER
  for (i = nNumPlanes - 1; i >= 0; i--) {
    BuildBitDest(nDest, iHoldReg, Src[i], Map[i], i);
Emit(SH_LEFT, VAR_OP, iHoldReg, CONST_OP, (31 - i), VAR_OP, iHoldReg);
ASCODE("    .SH_LEFT iHoldReg, #(31 - i), iHoldReg;");
Emit(ADDcc, VAR_OP, iHoldReg, VAR_OP, iHoldReg, VAR_OP, iHoldReg);
ASCODE("    .ADDcc iHoldReg, iHoldReg, iHoldReg;");
Emit(ADDXcc, VAR_OP, iDestVar, VAR_OP, iDestVar, VAR_OP, iDestVar);
ASCODE("    .ADDXcc iDestVar, iDestVar, iDestVar;");
#else INTERPRETER
  for (i = nNumPlanes - 1; i >= 0; i--) {
    BuildBitDest(nDest, HoldReg, Src[i], Map[i], i);
    *HoldReg <<= (31 - i);
    bit = HIGHB(*DestVar);
    *DestVar = (*DestVar << 1) | HIGHB(*HoldReg);
    *HoldReg <<= 1;
#endif INTERPRETER
  LP("BuildBitwiseDest");
/*****************************************************************************/
/*                                                                           */
/* steplistr.c:	modifications to original code made by Harris L. Gilliam     */
/*		March 1994 - June 1995					     */
/*                                                                           */
/*                                                                           */
/* Modifications made by Harris L. Gilliam:                                  */
/*                                                                           */
/*   Corrected various simple bugs, including using ints for loop couters    */
/*   where shorts were improperly used. (LIOR code)                          */
/*                                                                           */
/*   Rewrote the routines that pack/unpack bits from steplists into the      */
/*   global CAM8State variable.                                              */
/*                                                                           */
/*****************************************************************************/
/*                                                                           */
/* Author       : Milan Shah                                                 */
/* Program      : Cam8Sim                                                    */
/* Date         : April 13, 1992                                             */
/* Module       : steplistr.c - module to execute read instructions in       */
/*                steplists.                                                 */
/*                                                                           */
/*****************************************************************************/
#include <stdio.h>
#ifdef _INSTRUMENTATION_
#include <sys/time.h>
#endif
#include <CAM/CAM.h>
#include <CAM/CAM_instr.h>
#include <CAM/CAM_util.h>
#include "global.h"
#include "heap.h"
#include "errmgr.h"
#include "utils.h"
#include "sim.h"
#include "steplist.h"
#include "steplistP.h"
#include "decode_steplist.h"
#include "hinterface.h"
#define MODULE_NAME "StepListR"
#ifdef _INSTRUMENTATION_
struct timeval tvStart, tvEnd;
struct timezone tzZone;
#endif
void SimReadInstr(INT16 *pnBuffer, LONG32 lInstr, LONG32 lData,
		      LONG32 lLength)
  BOOL bByteMode;
  short nRegister, i, imm;
  LONG32 pbuf[CHIPS_PER_MOD];
  bByteMode = (lInstr & BYTE_MODE_MASK) != 0;
  nRegister = lInstr & REGISTER_ADDR_MASK;
  imm = (lInstr & IMMEDIATE_DATA_MASK) != 0;
  switch (nRegister) {
    
  case RFINDEX(REG_MSR): {
    PackState(pnBuffer, RFINDEX(REG_MSR));
    break;
  }      
    
    
  case RFINDEX(REG_RMR): {
    PackState(pnBuffer, RFINDEX(FLD_SSM));
    PackState(pnBuffer, RFINDEX(FLD_RT));
    PackState(pnBuffer, RFINDEX(FLD_ECT));
    PackState(pnBuffer, RFINDEX(FLD_RPK));
    PackState(pnBuffer, RFINDEX(FLD_ALT));
    break;
    
    
  case RFINDEX(REG_KR): {
    PackState(pnBuffer, RFINDEX(FLD_KA));
    PackState(pnBuffer, RFINDEX(FLD_XKS));
    PackState(pnBuffer, RFINDEX(FLD_YKS));
    PackState(pnBuffer, RFINDEX(FLD_ZKS));
    PackState(pnBuffer, RFINDEX(FLD_XKMF));
    PackState(pnBuffer, RFINDEX(FLD_YKMF));
    PackState(pnBuffer, RFINDEX(FLD_ZKMF));
    break;
    
    
  case RFINDEX(REG_SABSR): {
    PackState(pnBuffer, RFINDEX(REG_SABSR));
    
    break;
    
    
  case RFINDEX(REG_LASR):
  case RFINDEX(REG_FOSR):
  case RFINDEX(REG_SDSR):
  case RFINDEX(REG_ECSR):
  case RFINDEX(REG_DSR): {
    PackState(pnBuffer, FLD_SELECT(nRegister));
    PackState(pnBuffer, FLD_MAP(nRegister));    
    break;
    
    
  case RFINDEX(REG_SSR): {
    *pnBuffer = 0xFFFF;
    
    break;
    
    
  case RFINDEX(REG_ECR): {
    int diff;
    if ((diff = ECL[0] - lLength) != 0){
      ConstantSetAll(RLIF, 1);
      if (diff < 0)
	Generate_Interrupt(CAM_CAM_INT_STATUS);
      else
	Generate_Interrupt(CAM_TIMEOUT_INT_STATUS);
    }
    
    else
      PackBits(pnBuffer, 0, lLength, (BYTE *) ECR, BIT32);
    
    break;
    
    
  case RFINDEX(REG_LIR): {
    PackState(pnBuffer, RFINDEX(REG_LIR));
    break;
    
    
  case RFINDEX(REG_LIPR): {
    PackState(pnBuffer, RFINDEX(REG_LIPR));
    break;
    
    
  case RFINDEX(REG_LIOR): {
    INT16 nLUTEntry, nLUTNextIndex;
    INT16 *pnLUT;
    int i, j;
    INT16 nImmediate[2];
    
    
    for (i = 0; i < lLength; i++) {
      nLUTNextIndex = 0;
      
      for (j = CHIPS_PER_MOD - 1; j >= 0; j--) {
	nLUTNextIndex <<= 1;
	if (LIPR[j] < 16)
	  nLUTNextIndex |= ((LIR[j] >> LIPR[j]) & 0x1);
	else if (LIPR[j] == 31)
	  nLUTNextIndex |= 0x1;
	LIR[j]++;
      }
      
      pnLUT = LIOR + nLUTNextIndex;                 
      
      *pnBuffer = *pnLUT;
      pnBuffer++;
    }
    
    break;
    
    
  case RFINDEX(REG_SIR): {
    PackState(pnBuffer, RFINDEX(REG_SIR));
    break;
    
    
  case RFINDEX(REG_SIPR): {
    int j;
    
    /* j counts which field of register */
    for(j = 0; j < SCAN_INDEX_LENGTH; j++)
      PackState(pnBuffer, RFINDEX(FLD_SSA(j)));
    break;
    
    
  case RFINDEX(REG_SIOR): {
    CAM8State.bByteMode = bByteMode;
    SIOR = (BYTE *) pnBuffer;
    
#ifndef INTERPRETER
	SIOREG = (LONG32) SIOR;
#endif INTERPRETER
    if (CAM8State.bReadMode !=  TRUE) {
      bDestChange = TRUE;
      CAM8State.bReadMode =  TRUE;
    }
    
    CAM8State.WhyScan = RFINDEX(REG_SIOR);
#ifndef INTERPRETER
    SimCompScan();
#ifndef _DRYRUN_                 
#ifdef _INSTRUMENTATION_
  gettimeofday(&tvStart, &tzZone);
#endif
    SimExecScan();
#ifdef _INSTRUMENTATION_
    gettimeofday(&tvEnd, &tzZone);
      
    fprintf(stderr, "Scan I/O Read took %d usecs\n",
	    (tvEnd.tv_sec - tvStart.tv_sec) * 1000000 +
	    (tvEnd.tv_usec - tvStart.tv_usec));
#endif _INSTRUMENTATION_
#endif _DRYRUN_
#else INTERPRETER
    SimExecScan();
#endif INTERPRETER
    
    break;
    
    
  case RFINDEX(REG_SFR): {
    PackState(pnBuffer, RFINDEX(FLD_SM));
    PackState(pnBuffer, RFINDEX(FLD_ESC));
    PackState(pnBuffer, RFINDEX(FLD_ESW));
    PackState(pnBuffer, RFINDEX(FLD_EST));
    PackState(pnBuffer, RFINDEX(FLD_SBRC));
    PackState(pnBuffer, RFINDEX(FLD_RCL));
    PackState(pnBuffer, RFINDEX(FLD_ECL));
    PackState(pnBuffer, RFINDEX(FLD_STM));
    
    break;
    
    
  case RFINDEX(REG_OSR): {
    PackState(pnBuffer, RFINDEX(REG_OSR));
    break;
    
    
  case RFINDEX(REG_DR): {
    PackState(pnBuffer, RFINDEX(FLD_DCM));
    PackState(pnBuffer, RFINDEX(FLD_XDCP));
    PackState(pnBuffer, RFINDEX(FLD_YDCP));
    PackState(pnBuffer, RFINDEX(FLD_ZDCP));
    
    break;
    
    
  case RFINDEX(REG_HER): {
    PackState(pnBuffer, RFINDEX(FLD_LPL));
    PackState(pnBuffer, RFINDEX(FLD_FPL));
    PackState(pnBuffer, RFINDEX(FLD_DCS));
    PackState(pnBuffer, RFINDEX(FLD_TBD));
    PackState(pnBuffer, RFINDEX(FLD_TMS));
    PackState(pnBuffer, RFINDEX(FLD_NBF));
    PackState(pnBuffer, RFINDEX(FLD_SRE));
    PackState(pnBuffer, RFINDEX(FLD_ALS));
    
    break;
    
    
  case RFINDEX(REG_MPCR): {
    PackState(pnBuffer, RFINDEX(FLD_MAFS));
    PackState(pnBuffer, RFINDEX(FLD_MBFS));
    
    break;
    
    
  case RFINDEX(REG_GPCR): {
    PackState(pnBuffer, RFINDEX(FLD_XMPC));
    PackState(pnBuffer, RFINDEX(FLD_XPPC));
    PackState(pnBuffer, RFINDEX(FLD_YMPC));
    PackState(pnBuffer, RFINDEX(FLD_YPPC));
    PackState(pnBuffer, RFINDEX(FLD_ZMPC));
    PackState(pnBuffer, RFINDEX(FLD_ZPPC));
    
    break;
    
    
  case RFINDEX(REG_MIDR): {
    PackState(pnBuffer, RFINDEX(REG_MIDR));
    
    break;
    
    
  case RFINDEX(REG_GIDR): {
    PackState(pnBuffer, RFINDEX(REG_GIDR));
    
    break;
    
    
  case RFINDEX(REG_IER): {
    PackState(pnBuffer, RFINDEX(FLD_BPIE));
    PackState(pnBuffer, RFINDEX(FLD_BCIE));
    PackState(pnBuffer, RFINDEX(FLD_GCIE));
    PackState(pnBuffer, RFINDEX(FLD_MAIE));
    PackState(pnBuffer, RFINDEX(FLD_MBIE));
    PackState(pnBuffer, RFINDEX(FLD_SSIE));
    PackState(pnBuffer, RFINDEX(FLD_XHIE));
    PackState(pnBuffer, RFINDEX(FLD_RLIE));
    PackState(pnBuffer, RFINDEX(FLD_URIE));
    PackState(pnBuffer, RFINDEX(FLD_ISIE));
    break;
    
    
  case RFINDEX(REG_IFR): {
    PackState(pnBuffer, RFINDEX(FLD_BPIF));
    PackState(pnBuffer, RFINDEX(FLD_BCIF));
    PackState(pnBuffer, RFINDEX(FLD_GCIF));
    PackState(pnBuffer, RFINDEX(FLD_MAIF));
    PackState(pnBuffer, RFINDEX(FLD_MBIF));
    PackState(pnBuffer, RFINDEX(FLD_SSIF));
    PackState(pnBuffer, RFINDEX(FLD_XHIF));
    PackState(pnBuffer, RFINDEX(FLD_RLIF));
    PackState(pnBuffer, RFINDEX(FLD_URIF));
    PackState(pnBuffer, RFINDEX(FLD_ISIF));
    
    break;
    
    
  case RFINDEX(REG_VWR): {
    PackState(pnBuffer, RFINDEX(FLD_VWE));
    PackState(pnBuffer, RFINDEX(FLD_VWIE));
    PackState(pnBuffer, RFINDEX(FLD_VWIF));
    break;
    
    
  case RFINDEX(REG_DOCR): {
    PackState(pnBuffer, RFINDEX(FLD_LDOC));
    PackState(pnBuffer, RFINDEX(FLD_HDOC));
    
    break;
    
    
  default: {
    
    fprintf(stderr, "Don't recognize register %d\n", nRegister);
    break;
/*****************************************************************************/
/*                                                                           */
/* simNoPermP.h:modifications to original code made by Harris L. Gilliam     */
/*		March 1994 - June 1995					     */
/*                                                                           */
/*****************************************************************************/
/*                                                                           */
/* Author	: Milan Shah						     */
/* Program	: Cam8Sim						     */
/* Date		: February 6, 1992					     */
/* Module	: compileNoPermP.h - generate code for no scan index 	     */
/*		  permutation case. Private interface.			     */
/*                                                                           */
/*****************************************************************************/
#ifndef _SIM_NO_PERM_P_
#define _SIM_NO_PERM_P_
#include "global.h"
#ifndef INTERPRETER
extern CODEPTR	pcodSweep, pcodUpdateSite;
void SimLoadFirstWord(unsigned short nBitOffset[]);
void SimGetNextWord(unsigned short nPlane);
void SimSaveLastWord(unsigned short nBitOffset[]);
#else INTERPRETER
void SimLoadFirstWord(LONG32 nBitOffset[]);
void SimGetNextWord(unsigned short nPlane);
void SimSaveLastWord(LONG32 nBitOffset[]);
#endif INTERPRETER
#endif
/*****************************************************************************/
/*                                                                           */
/* simUpdateSite.c:	modifications to original code made by		     */
/*			Harris L. Gilliam March 1994 - June 1995	     */
/*                                                                           */
/*****************************************************************************/
/*                                                                           */
/* Author       : Milan Shah                                                 */
/* Program      : Cam8Sim                                                    */
/* Date         : February 6, 1992                                           */
/* Module       : compileNoPerm.c - generate code for no scan index          */
/*                permutation case.                                          */
/*                                                                           */
/*****************************************************************************/
#include <CAM/CAM.h>
#include <CAM/CAM_instr.h>
#include "sim.h"
#include "global.h"
#include "errmgr.h"
#include "memmgr.h"
#include "heap.h"
#include "utils.h"
#ifndef INTERPRETER
#include "regmgr.h"
#include "icode.h"
#endif
#include "simUpdateSiteP.h"
#include "decode_steplist.h"
#define MODULE_NAME     "SimUpdateSite"
#ifndef INTERPRETER
void SimUpdateSite()
  short i;
  CODEPTR pcodCurrent = pcodUpdateSite;
  EP("SimUpdateSite");
#ifdef _INCREMENTAL_COMPILE_     
  if (!(bSourceRegChange || bDestChange)) {
    LP("SimUpdateSite");
    return;
  else {
    bSourceRegChange = FALSE;
    bDestChange = FALSE;
#endif
  NewBlock(&pcodCurrent);
  .ENTER_LEAF,   
#else INTERPRETER
void SimUpdateSite()
  short i;
  LONG32 SiteDataSrc = UNGLUE_DATA;
  EP("SimUpdateSite");
#endif INTERPRETER
#ifndef INTERPRETER
  if (IsSrcNeeded(SRC_TBUS) &&
      ((CAM8State.WhyScan != RFINDEX(REG_SIOR)) || (!CAM8State.bReadMode))) {
    if (!CAM8State.bImmediate) {
      if (CAM8State.bByteMode) {
	.LDUB_IND   iTbusAddr, #0, iTbusData;
	.ADD iTbusAddr, #1, iTbusAddr;
      } 
      
      else {
	.LDHW_IND iTbusAddr, #0, iTbusData;
	.ADD iTbusAddr, #2, iTbusAddr;
      }
    }
#else INTERPRETER
  if (IsSrcNeeded(SRC_TBUS) &&
      ((CAM8State.WhyScan != RFINDEX(REG_SIOR)) || (!CAM8State.bReadMode))) {
    if (!CAM8State.bImmediate) {
      if (CAM8State.bByteMode) {
	TBUS_DATA = *((BYTE *) TBUS_ADDR);
	TBUS_ADDR += 1;
      }
      
      else {
	TBUS_DATA = *((INT16 *) TBUS_ADDR);
	TBUS_ADDR += 2;
      } /* else */
    } /* if (!CAM8State.bImmediate) */
#endif INTERPRETER
#ifndef INTERPRETER
  if (IsSrcNeeded(SRC_SITE_DATA)) {
    .OR %G0, %G0, iUnGlueData;
    for (i = nNumPlanes-1; i >= 0; i--) {      
      .ADDcc (iPlaneWord+i), (iPlaneWord+i), (iPlaneWord+i);
      .ADDX iUnGlueData, iUnGlueData, iUnGlueData;
    }
  }  
#else INTERPRETER
  if (IsSrcNeeded(SRC_SITE_DATA)) {
    UNGLUE_DATA = 0;
    for (i = nNumPlanes-1; i >= 0; i--) {
      bit = HIGHB(PLANE_WORD[i]);
      PLANE_WORD[i] <<= 1; 
      UNGLUE_DATA = (UNGLUE_DATA << 1) | bit;
    }
#endif INTERPRETER
#ifndef INTERPRETER
  /* For Now glued and unglued data are the same */
  if (IsSrcNeeded(SRC_GLUED_DATA)) {
    if (!IsSrcNeeded(SRC_SITE_DATA)) {
      .OR %G0, %G0, iGlueData;
      for (i = nNumPlanes-1; i >= 0; i--) {      
	.ADDcc (iPlaneWord+i), (iPlaneWord+i), (iPlaneWord+i);
	.ADDX iGlueData, iGlueData, iGlueData;
      }
    }
    else {
      .OR %G0, iUnGlueData, iGlueData;
    }
#else INTERPRETER
  /* For Now glued and unglued data are the same */
  if (IsSrcNeeded(SRC_GLUED_DATA)) {
    if (!IsSrcNeeded(SRC_SITE_DATA)) {
      GLUE_DATA = 0;
      for (i = nNumPlanes-1; i >= 0; i--) {
	bit = HIGHB(PLANE_WORD[i]);
	PLANE_WORD[i] <<= 1; 
	GLUE_DATA = (GLUE_DATA << 1) | bit;
      }
    }
    else
      GLUE_DATA = UNGLUE_DATA;
#endif INTERPRETER
#ifndef INTERPRETER
  if (IsSrcNeeded(SRC_LUT)) {
    .OR   %G0, %G0, iLutData;
    if (IsSrcSame(DEST_LUT))
      BuildDest(DEST_LUT, iLutData, LAS[0], LAM[0]);            
    else
      BuildBitwiseDest(DEST_LUT, iLutData, LAS, LAM);
    .SH_LEFT      iLutData, #1, iLutData;
    .LDHW_IND     iLutAddr, iLutData, iLutData;
#else INTERPRETER
  if (IsSrcNeeded(SRC_LUT)) {
    LUT_DATA = 0;
    if (IsSrcSame(DEST_LUT))
      BuildDest(DEST_LUT, &LUT_DATA, LAS[0], LAM[0]);           
    else
      BuildBitwiseDest(DEST_LUT, &LUT_DATA, LAS, LAM);
    LUT_DATA = (LONG32) (((INT16 *) LUT_ADDR)[LUT_DATA]);
#endif INTERPRETER
  /************************************************************************/
  /*                                                                      */
  /* All the sources needed to update all the destinations should now be  */
  /* in place. Update all the destinations in the following order : EC,   */
  /* Display (ie, scan io reads), and Site Data. Note that Site data      */
  /* must be updated last, because it destroys the Site Data register,    */
  /* which is one of the possible Sources (unglued data).                 */
  /*                                                                      */
  /************************************************************************/
#ifndef INTERPRETER
  if (IsDestUpdated(DEST_DISPLAY)) {
    if (IsSrcSame(DEST_DISPLAY))
      BuildDest(DEST_DISPLAY, iTemp1, DDS[0], DDM[0]);
    else
      BuildBitwiseDest(DEST_DISPLAY, iTemp1, DDS, DDM);
#ifdef _FRAMEBUFFER_
    .STUB_IND iFrame, #0, iTemp1;
    .ADD iFrame, #1, iFrame;
#endif
#else INTERPRETER
  if (IsDestUpdated(DEST_DISPLAY)) {
    if (IsSrcSame(DEST_DISPLAY))
      BuildDest(DEST_DISPLAY, &DISP_DATA, DDS[0], DDM[0]);
    else
      BuildBitwiseDest(DEST_DISPLAY, &DISP_DATA, DDS, DDM);
#ifdef _FRAMEBUFFER_
    *((BYTE *) FRAME_ADDR) = DISP_DATA;
    FRAME_ADDR += 1;
#endif
    
#endif INTERPRETER
#ifndef INTERPRETER
  /* SCAN-IO READ */
  if ((CAM8State.WhyScan == RFINDEX(REG_SIOR)) && CAM8State.bReadMode) {
    if (CAM8State.bByteMode) {
      .STUB_IND iSIOR, #0, iTemp1;
      .ADD iSIOR, #1, iSIOR;
      }
    else {
      .STHW_IND iSIOR, #0, iTemp1;
      .ADD iSIOR, #2, iSIOR;
    }
#else INTERPRETER
  /* SCAN-IO READ */
  if ((CAM8State.WhyScan == RFINDEX(REG_SIOR)) && CAM8State.bReadMode) {
    if (CAM8State.bByteMode) {
      *((BYTE *) SIOR) = (BYTE) DISP_DATA;
      SIOR += 1;
    }
    else {
      *((INT16 *) SIOR) = (INT16) DISP_DATA;
      SIOR += 2;
    }
#endif INTERPRETER
#ifndef INTERPRETER
  if (IsDestUpdated(DEST_EVENT_CT)) {
    if (IsSrcSame(DEST_EVENT_CT))
      BuildDest(DEST_EVENT_CT, iTemp1, ECS[0], ECM[0]);
    else
      BuildBitwiseDest(DEST_EVENT_CT, iTemp1, ECS, ECM);
    
    .SH_LEFT iTemp1, #(32 - nNumPlanes), iTemp1;
    for (i = nNumPlanes-1; i >= 0; i--) {
      .LDW_IND %DS, #(offEventCount+(i<<2)), iTemp2;
      .ADDcc iTemp1, iTemp1, iTemp1;
      .ADDX iTemp2, #0, iTemp2;
      .STW_IND %DS, #(offEventCount+(i<<2)), iTemp2;
    }
#else INTERPRETER
  if (IsDestUpdated(DEST_EVENT_CT)) {
    if (IsSrcSame(DEST_EVENT_CT))
      BuildDest(DEST_EVENT_CT, &TEMP1, ECS[0], ECM[0]);
    else
      BuildBitwiseDest(DEST_EVENT_CT, &TEMP1, ECS, ECM);
    
    TEMP1 <<= (32 - nNumPlanes);
    for (i = nNumPlanes-1; i >= 0; i--) {
      EVENT_COUNT[i] += ((TEMP1 & 0x80000000) ? 0x1 : 0x0);
      TEMP1 <<= 1;
    }
#endif INTERPRETER
#ifndef INTERPRETER
  if (IsDestUpdated(DEST_SITE_DATA)) {
    if (IsSrcSame(DEST_SITE_DATA)) {
      if (SDM[0] == MAP_S) {
	switch(SDS[0]) {
	case SRC_SITE_DATA: {
	  .OR %G0, iUnGlueData, iSiteDataSrc;
	  break;
	case SRC_TBUS: {
	  .OR %G0, iTbusData, iSiteDataSrc;
	  break;
	case SRC_LUT: {
	  .OR %G0, iLutData, iSiteDataSrc;
	  break;
	default: {
	  .OR %G0, iTemp1, iSiteDataSrc;
	  break;
      }
      else
	BuildDest(DEST_SITE_DATA, iSiteDataSrc, SDS[0], SDM[0]);
    }    
    else
      BuildBitwiseDest(DEST_SITE_DATA, iSiteDataSrc, SDS, SDM);
    .SH_LEFT iSiteDataSrc, #(32 - nNumPlanes), iSiteDataSrc;
    for (i = nNumPlanes - 1; i >= 0; i--) {                                
      .ADDcc iSiteDataSrc, iSiteDataSrc, iSiteDataSrc;
      
      if ((IsSrcNeeded(SRC_SITE_DATA)) || (IsSrcNeeded(SRC_GLUED_DATA))) {
	.ADDX (iPlaneWord+i), #0, (iPlaneWord+i);
      }
      else {
	.ADDX (iPlaneWord+i), (iPlaneWord+i), (iPlaneWord+i);
      }
    }
  .RETURN_LEAF;
    
  EndBlock();
  LP("SimUpdateSite");
#else INTERPRETER
  if (IsDestUpdated(DEST_SITE_DATA)) {
    if (IsSrcSame(DEST_SITE_DATA)) {
      if (SDM[0] == MAP_S) {
	SiteDataSrc = (SDS[0] == SRC_SITE_DATA ? UNGLUE_DATA :
		       SDS[0] == SRC_TBUS ? TBUS_DATA :
		       SDS[0] == SRC_LUT ? LUT_DATA : TEMP1);
      }
      
      else {
	BuildDest(DEST_SITE_DATA, &SITE_DATA, SDS[0], SDM[0]);
	SiteDataSrc = SITE_DATA;
      }
    }
    
    else {
      BuildBitwiseDest(DEST_SITE_DATA, &SITE_DATA, SDS, SDM);
      SiteDataSrc = SITE_DATA;
    }
    
    SiteDataSrc <<= (32 - nNumPlanes);
    for (i = nNumPlanes - 1; i >= 0; i--) {                                
      bit = HIGHB(SiteDataSrc);
      SiteDataSrc <<= 1;
      
      if ((IsSrcNeeded(SRC_SITE_DATA)) || (IsSrcNeeded(SRC_GLUED_DATA)))
	PLANE_WORD[i] |= bit;
      else
	PLANE_WORD[i] = (PLANE_WORD[i] << 1) | bit;
    }
  LP("SimUpdateSite");
#endif INTERPRETER
/*****************************************************************************/
/*                                                                           */
/* simUpdateSiteP.h:	modifications to original code made by		     */
/*			Harris L. Gilliam March 1994 - June 1995	     */
/*                                                                           */
/*****************************************************************************/
/*                                                                           */
/* Author	: Milan Shah						     */
/* Program	: Cam8Sim						     */
/* Date		: February 6, 1992					     */
/* Module	: compileNoPermP.h - generate code for no scan index 	     */
/*		  permutation case. Private interface.			     */
/*                                                                           */
/*****************************************************************************/
#ifndef _SIM_UPDATE_SITE_P_
#define _SIM_UPDATE_SITE_P_
#include "global.h"
#ifndef INTERPRETER
extern CODEPTR	pcodSweep, pcodUpdateSite;
void SimUpdateSite();
#else INTERPRETER
void SimUpdateSite();
#endif INTERPRETER
#endif
/*****************************************************************************/
/*                                                                           */
/* Author 	: Milan Shah						     */
/* Program	: Cam8Sim						     */
/* Date		: February 6, 1992					     */
/* Module	: sparc_asm.h						     */
/* 	Header file that includes defines for generating SPARC assembly.     */
/*	Intended for use by C code that generates machine code and then	     */
/*	transfers control to it.					     */
/*                                                                           */
/*****************************************************************************/
#ifndef _SPARC_ASM_
#define _SPARC_ASM_
#include "regmgr.h"
#define OP_LDW		0x00L
#define OP_LDHW		0x02L
#define OP_LDUB		0x01L
#define OP_STW		0x04L
#define OP_STUB		0x05L
#define OP_STHW		0x06L
#define OP_ADD		0x00L
#define OP_ADDcc	0x10L
#define OP_ADDX		0x08L
#define OP_ADDXcc	0x18L
#define	OP_SUB		0x04L
#define OP_SUBcc	0x14L
#define OP_SUBX		0x0CL
#define OP_SUBXcc	0x1CL
#define OP_AND		0x01L
#define OP_ANDcc	0x11L
#define OP_ANDN		0x05L
#define OP_ANDNcc	0x15L
#define OP_OR		0x02L
#define OP_ORcc 	0x12L
#define OP_ORN		0x06L
#define OP_ORNcc	0x16L
#define OP_XOR		0x03L
#define OP_XORcc 	0x13L
#define OP_XNOR		0x07L
#define OP_XNORcc	0x17L
#define OP_SLL		0x25L
#define OP_SRL		0x26L
#define OP_SRA		0x27L
#define OP_SETHI	0x04L
#define OP_JMPL		0x38L
#define OP_SAVE		0x3CL
#define OP_RESTORE	0x3DL
#define IMMEDIATE	1
#define REG_SOURCE	0
#define FMT2_INST(op, opcode, k, rd) 	(((op) << 30) | \
					 ((opcode) << 22) | \
					 ((rd) << 25) | \
					 ((k) & 0x3fffffL))
#define FMT3_INST(op, opcode, rs1, i, rs2, rd) (((op) << 30) | \
						((rd) << 25) | \
						((opcode) << 19) | \
		       				((rs1) << 14) | \
						((i) << 13) | \
						((rs2) & 0x1FFFL))
#define SAVE_REG_IMM(rs1, k, rd)	(FMT3_INST(0x2L, OP_SAVE, (rs1), IMMEDIATE, (k), (rd)))
#define SAVE_REG_REG(rs1, rs2, rd)	(FMT3_INST(0x2L, OP_SAVE, (rs1), REG_SOURCE, (rs2), (rd)))
#define RESTORE				(FMT3_INST(0x2L, OP_RESTORE, REG_G0, REG_SOURCE, REG_G0, REG_G0))
#define RET				(FMT3_INST(0x2L, OP_JMPL, REG_I7, IMMEDIATE, 8, REG_G0))
#define RETL				(FMT3_INST(0x2L, OP_JMPL, REG_O7, IMMEDIATE, 8, REG_G0))
#define CALL_REG(r)			(FMT3_INST(0x2L, OP_JMPL, (r), IMMEDIATE, 0, REG_O7))
#define CALL_REG_IMM(r, k) 		(FMT3_INST(0x2L, OP_JMPL, (r), IMMEDIATE, (k), REG_O7))
#define CALL(disp)			((0x01 << 30) | (((unsigned long) (disp)) >> 2))
#define NOP				(FMT3_INST(0x2L, OP_OR, REG_G0, REG_SOURCE, REG_G0, REG_G0))
#define LDW_REG_IMM(rs1, k, rd) 	(FMT3_INST(0x3L, OP_LDW, rs1, IMMEDIATE, k, rd))
#define LDW_REG_REG(rs1, rs2, rd) 	(FMT3_INST(0x3L, OP_LDW, rs1, REG_SOURCE, rs2, rd))
#define LDHW_REG_IMM(rs1, k, rd) 	(FMT3_INST(0x3L, OP_LDHW, rs1, IMMEDIATE, k, rd))
#define LDHW_REG_REG(rs1, rs2, rd) 	(FMT3_INST(0x3L, OP_LDHW, rs1, REG_SOURCE, rs2, rd))
#define LDUB_REG_IMM(rs1, k, rd) 	(FMT3_INST(0x3L, OP_LDUB, rs1, IMMEDIATE, k, rd))
#define LDUB_REG_REG(rs1, rs2, rd) 	(FMT3_INST(0x3L, OP_LDUB, rs1, REG_SOURCE, rs2, rd))
#define STW_REG_IMM(rs1, k, rd) 	(FMT3_INST(0x3L, OP_STW, rs1, IMMEDIATE, k, rd))
#define STW_REG_REG(rs1, rs2, rd) 	(FMT3_INST(0x3L, OP_STW, rs1, REG_SOURCE, rs2, rd))
#define STHW_REG_IMM(rs1, k, rd) 	(FMT3_INST(0x3L, OP_STHW, rs1, IMMEDIATE, k, rd))
#define STHW_REG_REG(rs1, rs2, rd) 	(FMT3_INST(0x3L, OP_STHW, rs1, REG_SOURCE, rs2, rd))
#define STUB_REG_IMM(rs1, k, rd) 	(FMT3_INST(0x3L, OP_STUB, rs1, IMMEDIATE, k, rd))
#define STUB_REG_REG(rs1, rs2, rd) 	(FMT3_INST(0x3L, OP_STUB, rs1, REG_SOURCE, rs2, rd))
#define ADD_REG_IMM(rs1, k, rd) 	(FMT3_INST(0x2L, OP_ADD, rs1, IMMEDIATE, k, rd))
#define ADD_REG_REG(rs1, rs2, rd) 	(FMT3_INST(0x2L, OP_ADD, rs1, REG_SOURCE, rs2, rd))
#define ADDcc_REG_IMM(rs1, k, rd) 	(FMT3_INST(0x2L, OP_ADDcc, rs1, IMMEDIATE, k, rd))
#define ADDcc_REG_REG(rs1, rs2, rd) 	(FMT3_INST(0x2L, OP_ADDcc, rs1, REG_SOURCE, rs2, rd))
#define ADDX_REG_IMM(rs1, k, rd) 	(FMT3_INST(0x2L, OP_ADDX, rs1, IMMEDIATE, k, rd))
#define ADDX_REG_REG(rs1, rs2, rd) 	(FMT3_INST(0x2L, OP_ADDX, rs1, REG_SOURCE, rs2, rd))
#define ADDXcc_REG_IMM(rs1, k, rd) 	(FMT3_INST(0x2L, OP_ADDXcc, rs1, IMMEDIATE, k, rd))
#define ADDXcc_REG_REG(rs1, rs2, rd) 	(FMT3_INST(0x2L, OP_ADDXcc, rs1, REG_SOURCE, rs2, rd))
#define SUB_REG_IMM(rs1, k, rd) 	(FMT3_INST(0x2L, OP_SUB, rs1, IMMEDIATE, k, rd))
#define SUB_REG_REG(rs1, rs2, rd) 	(FMT3_INST(0x2L, OP_SUB, rs1, REG_SOURCE, rs2, rd))
#define SUBcc_REG_IMM(rs1, k, rd) 	(FMT3_INST(0x2L, OP_SUBcc, rs1, IMMEDIATE, k, rd))
#define SUBcc_REG_REG(rs1, rs2, rd) 	(FMT3_INST(0x2L, OP_SUBcc, rs1, REG_SOURCE, rs2, rd))
#define SUBX_REG_IMM(rs1, k, rd) 	(FMT3_INST(0x2L, OP_SUBX, rs1, IMMEDIATE, k, rd))
#define SUBX_REG_REG(rs1, rs2, rd) 	(FMT3_INST(0x2L, OP_SUBX, rs1, REG_SOURCE, rs2, rd))
#define SUBXcc_REG_IMM(rs1, k, rd) 	(FMT3_INST(0x2L, OP_SUBXcc, rs1, IMMEDIATE, k, rd))
#define SUBXcc_REG_REG(rs1, rs2, rd) 	(FMT3_INST(0x2L, OP_SUBXcc, rs1, REG_SOURCE, rs2, rd))
#define AND_REG_IMM(rs1, k, rd) 	(FMT3_INST(0x2L, OP_AND, rs1, IMMEDIATE, k, rd))
#define AND_REG_REG(rs1, rs2, rd) 	(FMT3_INST(0x2L, OP_AND, rs1, REG_SOURCE, rs2, rd))
#define OR_REG_IMM(rs1, k, rd) 		(FMT3_INST(0x2L, OP_OR, rs1, IMMEDIATE, k, rd))
#define OR_REG_REG(rs1, rs2, rd) 	(FMT3_INST(0x2L, OP_OR, rs1, REG_SOURCE, rs2, rd))
#define XOR_REG_IMM(rs1, k, rd) 	(FMT3_INST(0x2L, OP_XOR, rs1, IMMEDIATE, k, rd))
#define XOR_REG_REG(rs1, rs2, rd) 	(FMT3_INST(0x2L, OP_XOR, rs1, REG_SOURCE, rs2, rd))
#define XNOR_REG_IMM(rs1, k, rd) 	(FMT3_INST(0x2L, OP_XNOR, rs1, IMMEDIATE, k, rd))
#define XNOR_REG_REG(rs1, rs2, rd) 	(FMT3_INST(0x2L, OP_XNOR, rs1, REG_SOURCE, rs2, rd))
#define NOT_REG(r)			(XNOR_REG_REG(r, REG_G0, r))
#define SLL_REG_IMM(rs1, k, rd) 	(FMT3_INST(0x2L, OP_SLL, rs1, IMMEDIATE, k, rd))
#define SLL_REG_REG(rs1, rs2, rd) 	(FMT3_INST(0x2L, OP_SLL, rs1, REG_SOURCE, rs2, rd))
#define SRL_REG_IMM(rs1, k, rd) 	(FMT3_INST(0x2L, OP_SRL, rs1, IMMEDIATE, k, rd))
#define SRL_REG_REG(rs1, rs2, rd) 	(FMT3_INST(0x2L, OP_SRL, rs1, REG_SOURCE, rs2, rd))
#define HI22(k) 			((((unsigned long) (k)) >> 10) & 0x3fffffL)
#define LOW10(k) 			(((unsigned long) (k)) & 0x3ffL)
#define SETHI(k, rd) 			(FMT2_INST(0x0L, OP_SETHI, k, rd))
/******************************************************************************
 * The branch instructions.
 *****************************************************************************/
#define BRANCH_INST(annul, cond, disp)	(((annul) << 29) | ((cond) << 25) | (0x800000) | ((disp) & 0x3FFFFF))
#define BRA(disp)			(BRANCH_INST(0, 0x8, disp))
#define BRN(disp)			(BRANCH_INST(0, 0x0, disp))
#define BRNE(disp)			(BRANCH_INST(0, 0x9, disp))
#define BRE(disp)			(BRANCH_INST(0, 0x1, disp))
#define BRG(disp)			(BRANCH_INST(0, 0xA, disp))
#define BRLE(disp)			(BRANCH_INST(0, 0x2, disp))
#define BRGE(disp)			(BRANCH_INST(0, 0xB, disp))
#define BRL(disp)			(BRANCH_INST(0, 0x3, disp))
#define BRGU(disp)			(BRANCH_INST(0, 0xC, disp))
#define BRLEU(disp)			(BRANCH_INST(0, 0x4, disp))
#define BRCC(disp)			(BRANCH_INST(0, 0xD, disp))
#define BRCS(disp)			(BRANCH_INST(0, 0x5, disp))
#define BRPOS(disp)			(BRANCH_INST(0, 0xE, disp))
#define BRNEG(disp)			(BRANCH_INST(0, 0x6, disp))
#define BRVC(disp)			(BRANCH_INST(0, 0xF, disp))
#define BRVS(disp)			(BRANCH_INST(0, 0x7, disp))
#define BRNZ(disp)			(BRANCH_INST(0, 0x9, disp))
#define BRZ(disp)			(BRANCH_INST(0, 0x1, disp))
/*****************************************************************************/
/*                                                                           */
/* Macros to insert target instructions etc.				     */
/*                                                                           */
/*****************************************************************************/
#define EMIT(inst)			*pcodNext++ = (inst)
#define CURRENT_LOC			(pcodNext)
#define CURRENT_HANDLE			(&pcodNext)
#endif
/*****************************************************************************/
/*                                                                           */
/* steplist.c:	modifications to original code made by Harris L. Gilliam     */
/*		March 1994 - June 1995					     */
/*                                                                           */
/*                                                                           */
/*   Corrected various simple bugs, including using ints for loop couters    */
/*   where shorts were improperly used. (LIOR code)                          */
/*                                                                           */
/*   Rewrote the routines that pack/unpack bits from steplists into the      */
/*   global CAM8State variable.                                              */
/*                                                                           */
/*****************************************************************************/
/*                                                                           */
/* Author       : Milan Shah                                                 */
/* Program      : Cam8Sim                                                    */
/* Date         : February 24, 1992                                          */
/* Module       : steplist.c - module to read in step lists; essentially     */
/*                simulates the interface board                              */
/*                                                                           */
/*****************************************************************************/
#include <stdio.h>
#include <sys/mman.h>
#include <sys/types.h>
#include <sys/ipc.h>
#include <sys/shm.h>
#ifdef _INSTRUMENTATION_
#include <sys/time.h>
#endif
#include <CAM/CAM.h>
#include <CAM/CAM_instr.h>
#include <CAM/CAM_util.h>
#include "global.h"
#include "heap.h"
#include "memmgr.h"
#include "errmgr.h"
#include "utils.h"
#include "sim.h"
#include "steplist.h"
#include "steplistP.h"
#include "decode_steplist.h"
#include "hinterface.h"
#define MODULE_NAME "StepList"
void DoKick(short);
static int VWECHK = 0;
static LONG32 pbuf[CHIPS_PER_MOD];
#ifdef _INSTRUMENTATION_
struct timeval tvStart, tvEnd;
struct timezone tzZone;
#endif
void vwecheck(INT16 *base, int reg_fld, int imm)
  register int i;
  int f = 0, o;
  Bt bt;
  bt = base_type[reg_fld];
  if (VWECHK) {
    UnpackStateInto(base, reg_fld, imm, (BYTE *) pbuf, bt.type);
    for (i = 0; i < CHIPS_PER_MOD; i++) {
      o = bt.type * i;
      if (VWE[i]) {
	if (bcmp(bt.base + o, ((BYTE *) pbuf) + o, bt.type) != 0) {
	  f = 1;
	  VWIF[i] = 1;
      }
      else
	bcopy(((BYTE *) pbuf) + o, bt.base + o, bt.type);
    }
  else
    UnpackState(base, reg_fld, imm);
void SimStepList(LONG32 *plFirstInstr)
  LONG32 *plCurr = NULL, *plNext = NULL;
  LONG32 lData = 0, lLength;
  short nRegister, i, imm = FALSE;
  BOOL bHostJump, bHostWait, bByteMode, bReadMode;
  BOOL bDone = FALSE;
  LONG32 pbuf[CHIPS_PER_MOD];
  bHostJump = bHostWait = FALSE;
  for (plCurr = plFirstInstr; !bDone; plCurr = plNext) {
    bHostJump = (*plCurr & HOST_JUMP_MASK) != 0;
    bHostWait = (*plCurr & HOST_WAIT_MASK) != 0;
    bDone = bHostJump || bHostWait;
    bByteMode = (*plCurr & BYTE_MODE_MASK) != 0;
    bReadMode = (*plCurr & READ_CAM_MASK) != 0;
    
    cam8sim_iregs.PIP = cam8sim_iregs.CIP;
    cam8sim_iregs.CIP = (LONG32) plNext;
    if (*plCurr & RESET_CAM_MASK) {
      memset ((char *) &CAM8State, 0, sizeof(CAM8State));
      LIOR = LUT1;
      LUT_ADDR = (LONG32) LUT0;
      bSourceRegChange = bDestChange = TRUE;
      
#ifdef DEBUG
      fprintf(DEBUGFILE, "CAM Reset\n");
      fflush(DEBUGFILE);
#endif
    }
    
    
    nRegister = *plCurr & REGISTER_ADDR_MASK;
    imm = (*plCurr & IMMEDIATE_DATA_MASK) != 0;
    lData = *(plCurr + 1);
    lLength = *(plCurr + 2);
    
    plNext = (LONG32 *) (*(plCurr + 3));
    
    if ((*plCurr & READ_CAM_MASK) && (*plCurr & IMMEDIATE_DATA_MASK)) {
#ifdef DEBUG
      fprintf(DEBUGFILE, "NOOP\n");
#endif
      continue;
    }
    
    
#ifdef DEBUG
    fprintf(DEBUGFILE, "REG = %d (%s), ", nRegister, REGNAMES[nRegister]);
    if (imm)
      fprintf(DEBUGFILE, "IMMEDIATE DATA, ");
    fprintf(DEBUGFILE, "BYTEMODE = %d, READMODE = %d\n", bByteMode, bReadMode);
    fflush(DEBUGFILE);
#endif
    
    if ((*plCurr & READ_CAM_MASK) != 0) {
      INT16 *pnBuffer;
      
      CAM8State.bReadMode = TRUE;
      bDestChange = TRUE;
      
      pnBuffer = (INT16 *) lData;
      
      SimReadInstr(pnBuffer, *plCurr, lData, lLength);
      
      continue;
    }
    
    
    switch (nRegister) {
      
    case RFINDEX(REG_MSR): {
      vwecheck((INT16 *) lData, RFINDEX(REG_MSR), imm);
      break;
    }      
      
      
    case RFINDEX(REG_RMR): {
      vwecheck((INT16 *) lData, RFINDEX(FLD_SSM), imm);
      vwecheck((INT16 *) lData, RFINDEX(FLD_RT), imm);
      vwecheck((INT16 *

---------------------------------------------------------------------------

) lData, RFINDEX(FLD_ECT), imm);
      vwecheck((INT16 *) lData, RFINDEX(FLD_RPK), imm);
      vwecheck((INT16 *) lData, RFINDEX(FLD_ALT), imm);
      
#ifndef INTERPRETER
      for(i = 0; i < CHIPS_PER_MOD; i++) {
	if (ECT[i] == 1) {
          ECR[i] = EVENT_COUNT(i);
          EVENT_COUNT(i) = 0L;
        }
        if (RPK[i] == 1)
          DoKick(i);
      }
      
#else INTERPRETER
      for(i = 0; i < CHIPS_PER_MOD; i++) {
	if (ECT[i] == 1) {
          ECR[i] = EVENT_COUNT[i];
          EVENT_COUNT[i] = 0L;
        }
        if (RPK[i] == 1)
          DoKick(i);
      }
      
#endif INTERPRETER
      if (ALT[0] == 1) {
        INT16 *pnTemp;
        
        pnTemp = LIOR;
        LIOR = (INT16 *) LUT_ADDR;
        LUT_ADDR = (LONG32) pnTemp;
        
        for (i = 0; i < CHIPS_PER_MOD; i++)
	  ALS[i] ^= 1;
      }
      if (CAM8State.bReadMode != FALSE) {
	bDestChange = TRUE;
	CAM8State.bReadMode = FALSE;
      }
      if (SSM[0] != 0) {
	CAM8State.WhyScan = RFINDEX(REG_RMR);
#ifndef INTERPRETER
        SimCompScan();
        
#ifndef _DRYRUN_                 
#ifdef _INSTRUMENTATION_
	gettimeofday(&tvStart, &tzZone);
#endif
        SimExecScan();
#ifdef _INSTRUMENTATION_
	gettimeofday(&tvEnd, &tzZone);
      
	fprintf(stderr, "Regular Scan took %d usecs\n",
		(tvEnd.tv_sec - tvStart.tv_sec) * 1000000 +
		(tvEnd.tv_usec - tvStart.tv_usec));
#endif _INSTRUMENTATION_
#endif _DRYRUN_
#else INTERPRETER
	SimExecScan();
#endif INTERPRETER
      }
      
      break;
    }
      
      
    case RFINDEX(REG_KR): {
      vwecheck((INT16 *) lData, RFINDEX(FLD_KA), imm);
      vwecheck((INT16 *) lData, RFINDEX(FLD_XKS), imm);
      vwecheck((INT16 *) lData, RFINDEX(FLD_YKS), imm);
      vwecheck((INT16 *) lData, RFINDEX(FLD_ZKS), imm);
      vwecheck((INT16 *) lData, RFINDEX(FLD_XKMF), imm);
      vwecheck((INT16 *) lData, RFINDEX(FLD_YKMF), imm);
      vwecheck((INT16 *) lData, RFINDEX(FLD_ZKMF), imm);
      DoKick(-1);
      break;
    }
      
      
    case RFINDEX(REG_SABSR):
      {
	vwecheck((INT16 *) lData, RFINDEX(REG_SABSR), imm);
	break;
      }
    case RFINDEX(REG_LASR):
    case RFINDEX(REG_FOSR):
    case RFINDEX(REG_SDSR):
    case RFINDEX(REG_ECSR):
    case RFINDEX(REG_DSR): {
      vwecheck((INT16 *) lData, FLD_SELECT(nRegister), imm);
      vwecheck((INT16 *) lData, FLD_MAP(nRegister), imm);
      bSourceRegChange = TRUE;
      break;
    }
      
    case RFINDEX(REG_SSR): {
      vwecheck((INT16 *) lData, RFINDEX(REG_SSR), imm);
      
      break;
    }
      
      
    case RFINDEX(REG_ECR): {
      if (ECL[0] != lLength) {
	ConstantSetAll(RLIF, 1);
	Generate_Interrupt(CAM_CAM_INT_STATUS);
      }
      else {
	int i;
	UnpackBits((INT16 *) lData, 0, lLength, imm, (BYTE *) ECR, BIT32);
	for(i = 0; i < CHIPS_PER_MOD; i++)
#ifndef INTERPRETER
	  EVENT_COUNT(i) = ECR[i];
#else INTERPRETER
	  EVENT_COUNT[i] = ECR[i];
#endif INTERPRETER
      }
      break;
    }
      
      
    case RFINDEX(REG_LIR): {
      vwecheck((INT16 *) lData, RFINDEX(REG_LIR), imm);
      break;
    }
      
      
    case RFINDEX(REG_LIPR): {
      vwecheck((INT16 *) lData, RFINDEX(REG_LIPR), imm);
      
      break;
    }
      
      
    case RFINDEX(REG_LIOR): {
      INT16 nLUTEntry, nLUTNextIndex;
      INT16 *pnLUT, *pnSource;
      int i, j;
      INT16 nImmediate[2];
      
      if (imm) {
        nImmediate[0] = (INT16) lData >> 16;
        nImmediate[1] = (INT16) lData & 0xFF;
        pnSource = &nImmediate[0];
      }
      
      else
        pnSource = (INT16 *) lData;
      
      for (i = 0; i < lLength; i++) {
        nLUTNextIndex = 0;
        for (j = CHIPS_PER_MOD - 1; j >= 0; j--) {
          nLUTNextIndex <<= 1;
          if (LIPR[j] < 16)
            nLUTNextIndex |= ((LIR[j] >> LIPR[j]) & 0x1);
          else if (LIPR[j] == 31)
            nLUTNextIndex |= 0x1;
	  LIR[j]++;
        }
        pnLUT = LIOR + nLUTNextIndex;                 
        
        if (imm) {
          *pnLUT = *pnSource;
          pnSource = &nImmediate[i % 2];
        } 
        
        else {
          *pnLUT = *pnSource;
          pnSource++;
        }
      }
      
      break;
    }
      
      
    case RFINDEX(REG_SIR): {
      vwecheck((INT16 *) lData, RFINDEX(REG_SIR), imm);
      
      SCAN_INDEX_REG = SIR[0];
      
      break;
    }
      
      
    case RFINDEX(REG_SIPR): {
      int j;
      
      for(j = 0; j < SCAN_INDEX_LENGTH; j++)
        vwecheck((INT16 *) lData, RFINDEX(FLD_SSA(j)), imm);
      
      break;
    }
      
      
    case RFINDEX(REG_SIOR): {
      if ((CAM8State.bByteMode != bByteMode) || 
          (CAM8State.bImmediate != imm)) {
        CAM8State.bByteMode = bByteMode;
        CAM8State.bImmediate = imm;
        bSourceRegChange = TRUE;
      }
      
      if (imm) {
        SIOR = (BYTE *) &lData;
        TBUS_DATA = lData;
#ifndef INTERPRETER
	SIOREG = (LONG32) SIOR;
#endif INTERPRETER
      }
      
      else {
        SIOR = (BYTE *) lData;
	TBUS_ADDR = lData;
#ifndef INTERPRETER
	SIOREG = (LONG32) SIOR;
#endif INTERPRETER
      }
      
      if (CAM8State.bReadMode != FALSE) {
        bDestChange = TRUE;
        CAM8State.bReadMode = FALSE;
      }
      
      CAM8State.WhyScan = RFINDEX(REG_SIOR);
#ifndef INTERPRETER
      SimCompScan();
#ifndef _DRYRUN_                 
#ifdef _INSTRUMENTATION_
      gettimeofday(&tvStart, &tzZone);
#endif
      SimExecScan();
#ifdef _INSTRUMENTATION_
      gettimeofday(&tvEnd, &tzZone);
      
      fprintf(stderr, "Scan I/O Write took %d usecs\n",
	      (tvEnd.tv_sec - tvStart.tv_sec) * 1000000 +
	      (tvEnd.tv_usec - tvStart.tv_usec));
#endif _INSTRUMENTATION_
#endif _DRYRUN_
      
#else INTERPRETER
      
      SimExecScan();      
#endif INTERPRETER
      break;
    }
      
      
    case RFINDEX(REG_SFR): {
      vwecheck((INT16 *) lData, RFINDEX(FLD_SM), imm);
      vwecheck((INT16 *) lData, RFINDEX(FLD_ESC), imm);
      vwecheck((INT16 *) lData, RFINDEX(FLD_ESW), imm);
      vwecheck((INT16 *) lData, RFINDEX(FLD_EST), imm);
      vwecheck((INT16 *) lData, RFINDEX(FLD_SBRC), imm);
      vwecheck((INT16 *) lData, RFINDEX(FLD_RCL), imm);
      vwecheck((INT16 *) lData, RFINDEX(FLD_ECL), imm);
      vwecheck((INT16 *) lData, RFINDEX(FLD_STM), imm);
      
      break;
    }
      
      
    case RFINDEX(REG_OSR): {
      vwecheck((INT16 *) lData, nRegister, imm);
      break;
    }
      
      
    case RFINDEX(REG_DR): {
      vwecheck((INT16 *) lData, RFINDEX(FLD_DCM), imm);
      vwecheck((INT16 *) lData, RFINDEX(FLD_XDCP), imm);
      vwecheck((INT16 *) lData, RFINDEX(FLD_YDCP), imm);
      vwecheck((INT16 *) lData, RFINDEX(FLD_ZDCP), imm);
      UpdateDCMR();
      
      break;
    }
      
      
    case RFINDEX(REG_HER): {
      vwecheck((INT16 *) lData, RFINDEX(FLD_LPL), imm);
      vwecheck((INT16 *) lData, RFINDEX(FLD_FPL), imm);
      vwecheck((INT16 *) lData, RFINDEX(FLD_DCS), imm);
      vwecheck((INT16 *) lData, RFINDEX(FLD_TBD), imm);
      vwecheck((INT16 *) lData, RFINDEX(FLD_TMS), imm);
      vwecheck((INT16 *) lData, RFINDEX(FLD_NBF), imm);
      vwecheck((INT16 *) lData, RFINDEX(FLD_SRE), imm);
      vwecheck((INT16 *) lData, RFINDEX(FLD_ALS), imm);
       
      if (ALS[0] == 1) {
        LIOR = (INT16*) LUT0;
        LUT_ADDR = (LONG32) LUT1;
      } 
      
      else {
        LIOR = (INT16 *) LUT1;
        LUT_ADDR = (LONG32) LUT0;
      }
      
      bSourceRegChange = TRUE;
      
      break;
    }
      
      
    case RFINDEX(REG_MPCR): {
      vwecheck((INT16 *) lData, RFINDEX(FLD_MAFS), imm);
      vwecheck((INT16 *) lData, RFINDEX(FLD_MBFS), imm);
      break;
    }
      
      
    case RFINDEX(REG_GPCR): {
      vwecheck((INT16 *) lData, RFINDEX(FLD_XMPC), imm);
      vwecheck((INT16 *) lData, RFINDEX(FLD_XPPC), imm);
      vwecheck((INT16 *) lData, RFINDEX(FLD_YMPC), imm);
      vwecheck((INT16 *) lData, RFINDEX(FLD_YPPC), imm);
      vwecheck((INT16 *) lData, RFINDEX(FLD_ZMPC), imm);
      vwecheck((INT16 *) lData, RFINDEX(FLD_ZPPC), imm);
      break;
    }
      
      
    case RFINDEX(REG_MIDR): {
      vwecheck((INT16 *) lData, RFINDEX(REG_MIDR), imm);
      break;
    }
      
      
    case RFINDEX(REG_GIDR): {
      vwecheck((INT16 *) lData, RFINDEX(REG_GIDR), imm);
      break;
    }
      
      
    case RFINDEX(REG_IER): {
      vwecheck((INT16 *) lData, RFINDEX(FLD_BPIE), imm);
      vwecheck((INT16 *) lData, RFINDEX(FLD_BCIE), imm);
      vwecheck((INT16 *) lData, RFINDEX(FLD_GCIE), imm);
      vwecheck((INT16 *) lData, RFINDEX(FLD_MAIE), imm);
      vwecheck((INT16 *) lData, RFINDEX(FLD_MBIE), imm);
      vwecheck((INT16 *) lData, RFINDEX(FLD_SSIE), imm);
      vwecheck((INT16 *) lData, RFINDEX(FLD_XHIE), imm);
      vwecheck((INT16 *) lData, RFINDEX(FLD_RLIE), imm);
      vwecheck((INT16 *) lData, RFINDEX(FLD_URIE), imm);
      vwecheck((INT16 *) lData, RFINDEX(FLD_ISIE), imm);
      break;
    }
      
      
    case RFINDEX(REG_IFR): {
      vwecheck((INT16 *) lData, RFINDEX(FLD_BPIF), imm);
      vwecheck((INT16 *) lData, RFINDEX(FLD_BCIF), imm);
      vwecheck((INT16 *) lData, RFINDEX(FLD_GCIF), imm);
      vwecheck((INT16 *) lData, RFINDEX(FLD_MAIF), imm);
      vwecheck((INT16 *) lData, RFINDEX(FLD_MBIF), imm);
      vwecheck((INT16 *) lData, RFINDEX(FLD_SSIF), imm);
      vwecheck((INT16 *) lData, RFINDEX(FLD_XHIF), imm);
      vwecheck((INT16 *) lData, RFINDEX(FLD_RLIF), imm);
      vwecheck((INT16 *) lData, RFINDEX(FLD_URIF), imm);
      vwecheck((INT16 *) lData, RFINDEX(FLD_ISIF), imm);
      break;
    }
      
      
    case RFINDEX(REG_VWR): {
      register int i;
      
      UnpackState((INT16 *) lData, RFINDEX(FLD_VWE), imm);
      UnpackState((INT16 *) lData, RFINDEX(FLD_VWIE), imm);
      UnpackState((INT16 *) lData, RFINDEX(FLD_VWIF), imm);
      VWECHK = 0;
      for (i = 0; i < CHIPS_PER_MOD; i++)
	if (VWE[i] == 1)
	  VWECHK = 1;
      
      break;
    }
      
      
    case RFINDEX(REG_DOCR): {
      vwecheck((INT16 *) lData, RFINDEX(FLD_LDOC), imm);
      vwecheck((INT16 *) lData, RFINDEX(FLD_HDOC), imm);
      
      break;
    }
      
      
    default: {
      
      fprintf(stderr, "Don't recognize register %d\n", nRegister);
      break;
    }
    }
    
    cam8sim_iregs.PIP = (LONG32) plCurr;
  } /*   for (plCurr = plFirstInstr; !bDone; plCurr = plNext;) */
  cam8sim_iregs.ISR |= CAM_NEWLIST_INT_STATUS;
void DoKick(short p)
  register int i, j;
  LONG32 lSignBitOffset, lSignBitKick, lLowBitsKick;
  LONG32 lDCM;
  LONG32 lKA;
  /************************************************************************/
  /* The kick and offset registers are two n-dimension-vectors, and the   */
  /* place where all dimensions end is determined by lDCMR. To subtract   */
  /* an n-dimension-kick from the corresponding offset, we first extract  */
  /* out the sign bits of both (by and-ing with lDCMR). Next, we set the  */
  /* most sig bits of every dimension in offset to 1, so that when we     */
  /* subtract out the kick, we don't borrow from the next higher          */
  /* dimension. Next, we subtract the value bits of kick (lowbits) from   */
  /* this offset. This will give the 'sign' bit of the new offset and its */
  /* value. The final sign bit of the offset is determined by :           */
  /*                                                                      */
  /*     sign bit = new sign bit xor (old sign bit xnor kick sign bit)    */
  /*                                                                      */
  /* To do the xnor operation, we simply store the inverse of the kick    */
  /* sign bit and then do an xor                                          */
  /*                                                                      */
  /* One easy way to derive this is to think of a sample dimension with   */
  /* 4 bits. Then, the bit positions have values  -8  4  2  1. The        */
  /* subtract operation as described above becomes (8 + 4*o.2 + 2*o.1 +   */
  /* 1*o.0 - 4*k.2 - 2*k.1 - 1*k.0) - 8 - 8*o.sign + 8.k.sign             */
  /* where o.X means the X'th bit of offset and k.X means the X'th bit of */
  /* kick. Since the final offset is of the form -8*o.sign + 4*o.2 +      */
  /* 2*o.1 + 1*o.o, we can express the sign bit as the above logical      */
  /* function of the three individual sign bits.                          */
  /*                                                                      */
  /************************************************************************/
  if (p == -1) {
    p = 0;
    j = CHIPS_PER_MOD;
  else
    j = p + 1;
  for(i = p; i < j; i++) {
    lSignBitOffset = OSR[i] & DCM[i];
    lSignBitKick = (~KA[i]) & DCM[i];
    OSR[i] |= DCM[i];
    lLowBitsKick =  KA[i] & (~ DCM[i]);
    
    OSR[i] -= lLowBitsKick;
    lSignBitOffset ^= lSignBitKick;
    OSR[i] ^= lSignBitOffset;
#ifndef _STEP_LIST_
#define _STEP_LIST_
#define FLD_SELECT(i)	(i)+32
#define FLD_MAP(i)	(i)+64
void InitStepList(void);
void ReadStepList(char *szStepFileName);
void SimStepList(LONG32 *plFirstInstr);
#endif
#ifndef _STEP_LIST_P_
#define _STEP_LIST_P_
void SimReadInstr(INT16 *pnBuffer, LONG32 lInstr, LONG32 lData, LONG32 lLength);
#define RESET_CAM_MASK		0x80000000					 /* These are bits of the control or */
#define READ_CAM_MASK		0x40000000					 /* first long word of every step    */
#define IMMEDIATE_DATA_MASK	0x20000000					 /* instruction 		     */
#define BYTE_MODE_MASK		0x10000000
#define HOST_JUMP_MASK		0x00008000
#define HOST_WAIT_MASK		0x00004000
#define SOFT_INT_MASK		0x00002000
#define WAIT_EOS_MASK		0x00001000
#define REGISTER_ADDR_MASK	0x0000003F
#define ACTIVE_LUT_SELECT	0x8000						 /* bit in Hardware Env Reg (HER)    */
#endif
/*****************************************************************************/
/*                                                                           */
/* Author	: Milan Shah						     */
/* Program	: test_modules						     */
/* Date		: February 18, 1992					     */
/* Module	: t_printasm.c - print a block of memory as sparc asm.	     */
/*                                                                           */
/*****************************************************************************/
#include <stdio.h>
#include "global.h"
#include "heap.h"
#include "sparc_asm.h"
#include "t_printasm.h"
typedef unsigned long INSTRUCTION;
const char *szRegName[] = {
  "%g0", "%g1", "%g2", "%g3", "%g4", "%g5", "%g6", "%g7",
  "%o0", "%o1", "%o2", "%o3", "%o4", "%o5", "%sp", "%tp",
  "%l0", "%l1", "%l2", "%l3", "%l4", "%l5", "%l6", "%l7",
  "%i0", "%i1", "%i2", "%i3", "%i4", "%i5", "%ds", "%ra"
  };
const char *szCCName[] = {
  "NEVER", "EQ", "LE", "L", "LEU", "CS", "NEG", "VS",
  "ALWAYS", "NEQ", "G", "GE", "GU", "CC", "POS", "VC"
  };
void Fmt1Instr(INSTRUCTION instr, FILE *fOut)
  fprintf(fOut, "CALL \t%x\n", (instr & 0x3FFFFFFFL));
void Fmt2Instr(INSTRUCTION instr, FILE *fOut)
  unsigned short op2, cc, rd;
  signed long disp;
  op2 = (instr >> 22) & 0x7L;
  if (op2 == 4) {								 /* SETHI 			     */
    unsigned long hi22;
    hi22 = (instr << 10);
    rd = (instr >> 25) & 0x1FL;
    fprintf(fOut,"SETHI \t%s, \t%x (%x)\n", szRegName[rd],
	    (instr & 0x003FFFFFL), hi22);
  } else if (op2 == 2) {							 /* BRANCH 			     */
    cc = (instr >> 25) & 0xFL;
    if (instr & 0x00200000L) {
      disp = instr | 0xFFC00000L;
    } else {
      disp = instr & 0x1FFFFF;
    }
    fprintf(fOut,"BR%s \t%d\n", szCCName[cc], disp);
  } else {
    fprintf(fOut,"UNIMP BR : %x\n", instr);
void Fmt3Instr(INSTRUCTION instr, FILE *fOut)
  unsigned short majorOp, opcode, imm, rs1, rs2, rd;
  signed long lConst;
  majorOp = (instr >> 30) & 0x3L;
  opcode = (instr >> 19) & 0x3FL;
  rd = (instr >> 25) & 0x1FL;
  rs1 = (instr >> 14) & 0x1FL;
  rs2 = instr & 0x1FL;
  imm = (instr >> 13) & 0x1L;
  if (imm) {
    if (instr & 0x00001000L) {
      lConst = (instr | 0xFFFFF000L);
    } else {
      lConst = (instr & 0xFFFL);
    }
  if (majorOp == 3) {							 /* LOAD-STORE 			     */
    switch (opcode) {
    case OP_LDW:
      fprintf(fOut,"LDW ");
      break;
    case OP_LDHW:
      fprintf(fOut,"LDHW ");
      break;
    case OP_LDUB:
      fprintf(fOut,"LDUB ");
      break;
    case OP_STW:
      fprintf(fOut,"STW ");
      break;
    case OP_STUB:
      fprintf(fOut,"STUB ");
      break;
      
    default:
      fprintf(fOut,"UNIMP LOAD-STORE : %x\n", instr);
      return;
      break;
    };
  } else {									 /* ARITHMETIC 			     */
    switch (opcode) {
    case OP_ADD:
      fprintf(fOut,"ADD ");
      break;
    case OP_ADDcc:
      fprintf(fOut,"ADDcc ");
      break;
    case OP_ADDX:
      fprintf(fOut,"ADDX ");
      break;
    case OP_ADDXcc:
      fprintf(fOut,"ADDXcc ");
      break;
      
    case OP_SUB:
      fprintf(fOut,"SUB ");
      break;
    case OP_SUBcc:
      fprintf(fOut,"SUBcc ");
      break;
    case OP_SUBX:
      fprintf(fOut,"SUBX ");
      break;
    case OP_SUBXcc:
      fprintf(fOut,"SUBXcc ");
      break;
      
    case OP_AND:							 /* LOGICAL 			     */
      fprintf(fOut,"AND ");
      break;
    case OP_ANDcc:
      fprintf(fOut,"ANDcc ");
      break;
    case OP_ANDN:
      fprintf(fOut,"ANDN ");
      break;
    case OP_ANDNcc:
      fprintf(fOut,"ANDNcc ");
      break;
      
    case OP_OR:
      fprintf(fOut,"OR ");
      break;
    case OP_ORcc:
      fprintf(fOut,"ORcc ");
      break;
    case OP_ORN:
      fprintf(fOut,"ORN ");
      break;
    case OP_ORNcc:
      fprintf(fOut,"ORNcc ");
      break;
      
    case OP_XOR:
      fprintf(fOut,"XOR ");
      break;
    case OP_XORcc:
      fprintf(fOut,"XORcc ");
      break;
    case OP_XNOR:
      fprintf(fOut,"XNOR ");
      break;
    case OP_XNORcc:
      fprintf(fOut,"XNORcc ");
      break;
      
      
    case OP_SLL:
      fprintf(fOut,"SLL ");
      break;
    case OP_SRL:
      fprintf(fOut,"SRL ");
      break;
    case OP_SRA:
      fprintf(fOut,"SRA ");
      break;
      
    case OP_JMPL:							 /* CONTROL TRANSFER 		     */
      fprintf(fOut,"JMPL ");
      break;
    case OP_SAVE:
      fprintf(fOut,"SAVE ");
      break;
    case OP_RESTORE:
      fprintf(fOut,"RESTOR");
      break;
      
    default:
      fprintf(fOut,"UNIMP LOGICAL-ARITH : %x\n", instr);
      return;
      break;
    };
  if (imm) {
    fprintf(fOut,"\t%s \t%d \t%s\n", szRegName[rs1], lConst, szRegName[rd]);
  } else {
    fprintf(fOut,"\t%s \t%s \t%s\n", szRegName[rs1], szRegName[rs2],
	    szRegName[rd]);
void PrintAsm(CODEPTR pcodSource, FILE *fOut)
  CODEPTR pcod;
  unsigned short op;
  for (pcod = pcodSource; *pcod != 0; pcod++) {
    
    fprintf(fOut, "0x%x: ", pcod);
    
    op = (*pcod >> 30) & 0x3L;
    switch (op) {
    case 0:
      Fmt2Instr(*pcod, fOut);
      break;
      
    case 1:
      Fmt1Instr(*pcod, fOut);
      break;
      
    case 2:
    case 3:
      Fmt3Instr(*pcod, fOut);
      break;
    }
/*****************************************************************************/
/*                                                                           */
/* Author	: Milan Shah						     */
/* Program	: test modules						     */
/* Date		: February 18, 1992					     */
/* Module	: t_printasm.h - header file to print out a block of sparc   */
/*		  assembly code in mnemonic fashion.			     */
/*                                                                           */
/*****************************************************************************/
#ifndef _T_PRINTASM_
#define _T_PRINTASM_
#include "global.h"
void PrintAsm(CODEPTR pcodSource, FILE *fOut);
#endif
#include "global.h"
#include "errmgr.h"
#include "utils.h"
#define MODULE_NAME     "utils"
LONG32 lDCMRHighBit;
LONG32 lDCMRLowBit;
LONG32 lNumXBits;
/*****************************************************************************/
/*                                                                           */
/* This routine adds two longs breaking the carries at positions indicated   */
/* by the Dimension Cut Mask Register (DCMR). The DCMR has a 1 bit at every  */
/* bit position where the carry needs to be cut.                             */
/*                                                                           */
/*****************************************************************************/
LONG32 AddSiteAddress(LONG32 lSrc1, LONG32 lSrc2)
  LONG32 lHighBits1, lHighBits2;
  lHighBits1 = lSrc1 & DCM[0];
  lHighBits2 = lSrc2 & DCM[0];
  lSrc1 &= (~DCM[0]);
  lSrc2 &= (~DCM[0]);
  return( (lSrc1 + lSrc2) ^ lHighBits1 ^ lHighBits2 );
LONG32 SubSiteAddress(LONG32 lSrc1, LONG32 lSrc2)
  LONG32 lSignBitOffset, lSignBitKick, lLowBitsKick;
  lSignBitOffset = lSrc1 & DCM[0];
  lSignBitKick = (~lSrc2) & DCM[0];
  lSrc1 |= DCM[0];
  lLowBitsKick = lSrc2 & (~ DCM[0]);
  lSrc1 -= lLowBitsKick;
  lSignBitOffset = lSignBitOffset ^ lSignBitKick;
  lSrc1 ^= lSignBitOffset;
/*****************************************************************************/
/*                                                                           */
/* Compute the Scan length - the number of sites that will be updated in     */
/* the current scan. Basically, it should be 2^ESCP, but we need to correct  */
/* for the fact that the SIR low-order bits might not be all zero            */
/*                                                                           */
/*****************************************************************************/
LONG32 ScanLength()
  LONG32 lCarryOVFBit, lScanLength, lSIRBits;
  lCarryOVFBit = ESC[0];
  lScanLength = (1 << lCarryOVFBit);                                  
  lSIRBits = SIR[0] & (lScanLength - 1);
  lScanLength -= lSIRBits;
  return (lScanLength);
/*****************************************************************************/
/*                                                                           */
/* Determine the sweep length. The sweep length is given by either the low   */
/* bit of the DCMR or the ESCP (End-of-Scan-pointer) or the SFR register.    */
/* This is because the scan could update many lines of the lowest (X) dimen- */
/* sion, or could update just part of 1 line in the X dimension.             */
/*                                                                           */
/*****************************************************************************/
LONG32 SweepLength(LONG32 *lFirstSweep)
  LONG32 lCarryOVFBit, lSweepLength;
  lCarryOVFBit = MIN(ESW[0], lNumXBits);
  lSweepLength = (1 << lCarryOVFBit);
  *lFirstSweep = (SIR[0] & (lSweepLength - 1));
  *lFirstSweep = lSweepLength - *lFirstSweep;
  return (lSweepLength);
/*****************************************************************************/
/*                                                                           */
/* DCMRHighBit returns a long with exactly one of the 32 bits set to 1. This */
/* bit position corresponds to the highest bit in the DCMR that has a 1.     */
/*                                                                           */
/*****************************************************************************/
static LONG32 DCMRHighBit()
  LONG32 lTemp1, lTemp2;                                                      
  lTemp1 = DCM[0];
  lTemp2 = 1;
  while (lTemp1 > 1) {
    lTemp1 >>= 1;
    lTemp2 <<= 1;
  return (lTemp2);
/*****************************************************************************/
/*                                                                           */
/* DCMRLowBit returns a long with exactly one of the 32 bits set to 1. This  */
/* bit position corresponds to the lowest bit in the DCMR that has a 1. We   */
/* refer to this lowest dimension generically as the X dimension.            */
/*                                                                           */
/*****************************************************************************/
static LONG32 DCMRLowBit()
  LONG32 lTemp1, lTemp2;
  lTemp1 = DCM[0];
  lTemp2 = 1;
  lNumXBits = 1;
  while ((lTemp1 != 0) && ((lTemp1 & 0x01) == 0)) {
    lTemp1 >>= 1;
    lTemp2 <<= 1;
    lNumXBits++;
  return (lTemp2);
void UpdateDCMR()
  lDCMRHighBit = DCMRHighBit();
  lDCMRLowBit = DCMRLowBit();
/*****************************************************************************/
/*                                                                           */
/* The following are general purpose routines that conveniently answer       */
/* queries about the sources and destinations that need to be updated        */
/*                                                                           */
/*****************************************************************************/
BOOL bDestSrcMatrix [CHIPS_PER_MOD][NUM_DEST][NUM_SRC];
/*****************************************************************************/
/*                                                                           */
/* Is a particular source needed? Only checks those planes that will be      */
/* updated or used during the next scan.                                     */
/*                                                                           */
/*****************************************************************************/
BOOL IsSrcNeeded(short nSrc)
  short i, j;
  short nLastDest;
  nLastDest = (nSrc == SRC_TBUS ? DEST_LUT : DEST_DISPLAY);
  for (i = nNumPlanes - 1; i >= 0; i--) {
    for (j = DEST_SITE_DATA; j <= nLastDest; j++) {
      if (bDestSrcMatrix[i][j][nSrc]) {
	return TRUE;
      }
    }
  return FALSE;
/*****************************************************************************/
/*                                                                           */
/* Checks to see if the source/map is the same for all planes for the given  */
/* destination.                                                              */
/*                                                                           */
/*****************************************************************************/
BOOL IsSrcSame(short nDest)
  short i;
  BYTE *src, *map;
  switch (nDest) {
  case DEST_SITE_DATA:
    src = SDS;
    map = SDM;
    break;
  case DEST_EVENT_CT:
    src = ECS;
    map = ECM;
    break;
  case DEST_DISPLAY:
    src = DDS;
    map = DDM;
    break;
  case DEST_LUT:
    src = LAS;
    map = LAM;
    break;
  default:
    return FALSE;
    break;
  for(i = 1; i < nNumPlanes; i++)
    if ((src[0] != src[i]) || (map[0] != map[i]))
      return FALSE;
  return TRUE;
/*****************************************************************************/
/*                                                                           */
/* See if a particular destination will be changed during the current scan   */
/*                                                                           */
/*****************************************************************************/
BOOL IsDestUpdated(short nDest)
  short i, j;
  for (i = nNumPlanes-1; i >= 0; i--)
    for ( j = SRC_SITE_DATA; j <= SRC_CONST_DATA; j++)
      if (bDestSrcMatrix[i][nDest][j])
	return(TRUE);
  return(FALSE);
/*****************************************************************************/
/*                                                                           */
/* Calculate the number of planes that will be updated or used in the next   */
/* scan.                                                                     */
/*                                                                           */
/*****************************************************************************/
unsigned short CalcNumPlanes()
  BOOL       bPlaneUsed[CHIPS_PER_MOD];
  short      i, j;
  memset ((char *) bPlaneUsed, 0, CHIPS_PER_MOD * sizeof(BOOL));
  UpdateDestSrcMatrix();
  for (i = CHIPS_PER_MOD-1; i >= 0; i--) {
    for (j = DEST_SITE_DATA; j <= DEST_DISPLAY; j++) {
      if ( bDestSrcMatrix[i][j][SRC_SITE_DATA] || 
	  bDestSrcMatrix[i][j][SRC_GLUED_DATA] ) {
	bPlaneUsed[i] = TRUE;
      }
    }
    
    if (!bPlaneUsed[i]) {
      for (j = SRC_TBUS; j <= SRC_CONST_DATA; j++) {
	if (bDestSrcMatrix[i][DEST_SITE_DATA][j]) {
	  bPlaneUsed[i] = TRUE;
      }
    }
    if (bPlaneUsed[i])
      break;
  }  
  return ((unsigned short) i + 1);
/*****************************************************************************/
/*                                                                           */
/* Updates a matrix of sources and destinations. There are 5 sources, 4 dest */
/* and 16 planes. In addition, there is a bit per destination indicating     */
/* whether the map field selects an inverse function or just the function.   */
/* Thus, the SrcDestMatrix is a 6x4x16 matrix.                               */
/*                                                                           */
/*****************************************************************************/
void UpdateDestSrcMatrix()
  short      i;
  char       *szFuncName = "UpdateDestSrcMatrix";    
  memset((char *) bDestSrcMatrix, 0, CHIPS_PER_MOD*NUM_SRC*NUM_DEST);
  for (i = 0; i < CHIPS_PER_MOD; i++) {
    
    /*
     * If the source for the site is the site then don't bother to generate
     * code for this.  If the map selects only the glue lines then the source
     * selection is irrelevant.  If the map selects MAP_G then this is
     * effectively the same as selecting site as the source.  If the map
     * selects CONST_0 or CONST_1 then we handle this as a special case.
     */
    if (SDS[i] != SRC_SITE_DATA)
      bDestSrcMatrix[i][DEST_SITE_DATA][SDS[i]] = TRUE;
    if ((SDM[i] != MAP_S) && (SDM[i] != MAP_S_BAR)) {
      if (SDM[i] != MAP_G)
	bDestSrcMatrix[i][DEST_SITE_DATA][SRC_GLUED_DATA] = TRUE;
      if ((SDM[i] == MAP_CONST_0) || (SDM[i] == MAP_CONST_1)) {
	bDestSrcMatrix[i][DEST_SITE_DATA][SRC_CONST_DATA] = TRUE;
	bDestSrcMatrix[i][DEST_SITE_DATA][SRC_GLUED_DATA] = FALSE;
	bDestSrcMatrix[i][DEST_SITE_DATA][SDS[i]] = FALSE;
      }
      if ((SDM[i] == MAP_G) || (SDM[i] == MAP_G_BAR))
	bDestSrcMatrix[i][DEST_SITE_DATA][SDS[i]] = FALSE;
    }
    /*
     * If the source for the event counter is constant zero then don't bother
     * to generate code for this.  If the map selects only the glue lines then
     * the source selection is irrelevant.
     */
    bDestSrcMatrix[i][DEST_EVENT_CT][ECS[i]] = TRUE;
    if ((ECM[i] != MAP_S) && (ECM[i] != MAP_S_BAR)) {
      bDestSrcMatrix[i][DEST_EVENT_CT][SRC_GLUED_DATA] = TRUE;
      if ((ECM[i] == MAP_CONST_0) || (ECM[i] == MAP_CONST_1)) {
	if (ECM[i] == MAP_CONST_1)
	  bDestSrcMatrix[i][DEST_EVENT_CT][SRC_CONST_DATA] = TRUE;
	bDestSrcMatrix[i][DEST_EVENT_CT][SRC_GLUED_DATA] = FALSE;
	bDestSrcMatrix[i][DEST_EVENT_CT][ECS[i]] = FALSE;
      }
      if ((ECM[i] == MAP_G) || (ECM[i] == MAP_G_BAR))
 	bDestSrcMatrix[i][DEST_EVENT_CT][ECS[i]] = FALSE;
    }
    /*
     * If the source for the display is the host (tbus) then don't bother to
     * generate code for this.  If the map selects only the glue lines then
     * the source selection is irrelevant.
     */
    if ((DDS[i] != SRC_TBUS))
      bDestSrcMatrix[i][DEST_DISPLAY][DDS[i]] = TRUE;
    if ((DDM[i] != MAP_S) && (DDM[i] != MAP_S_BAR)) {
      bDestSrcMatrix[i][DEST_DISPLAY][SRC_GLUED_DATA] = TRUE;
      if ((DDM[i] == MAP_CONST_0) || (DDM[i] == MAP_CONST_1)) {
	bDestSrcMatrix[i][DEST_DISPLAY][SRC_CONST_DATA] = TRUE;
	bDestSrcMatrix[i][DEST_DISPLAY][SRC_GLUED_DATA] = FALSE;
	bDestSrcMatrix[i][DEST_DISPLAY][DDS[i]] = FALSE;
      }
      if ((DDM[i] == MAP_G) || (DDM[i] == MAP_G_BAR)) {
	bDestSrcMatrix[i][DEST_DISPLAY][DDS[i]] = FALSE;
      }
    }
    /*
     * If the map selects only the glue lines then the source selection is
     * irrelevant.
     */
    bDestSrcMatrix[i][DEST_LUT][LAS[i]] = TRUE;
    if ((LAM[i] != MAP_S) && (LAM[i] != MAP_S_BAR)) {
      bDestSrcMatrix[i][DEST_LUT][SRC_GLUED_DATA] = TRUE;
      if ((LAM[i] == MAP_CONST_0) || (LAM[i] == MAP_CONST_1)) {
	bDestSrcMatrix[i][DEST_LUT][SRC_CONST_DATA] = TRUE;
	bDestSrcMatrix[i][DEST_LUT][SRC_GLUED_DATA] = FALSE;
	bDestSrcMatrix[i][DEST_LUT][LAS[i]] = FALSE;
      }
      if ((LAM[i] == MAP_G) || (LAM[i] == MAP_G_BAR)) {
	bDestSrcMatrix[i][DEST_LUT][LAS[i]] = FALSE;
      }
    }
/*****************************************************************************/
/*                                                                           */
/* utils.h:	modifications to original code made by Harris L. Gilliam     */
/*		March 1994 - June 1995					     */
/*                                                                           */
/*****************************************************************************/
/*                                                                           */
/* Author	: Milan Shah						     */
/* Program	: Cam8Sim						     */
/* Date		: February 28, 1992					     */
/* Module	: utils.h - general purpose utilities to query cam8 state    */
/*                                                                           */
/*****************************************************************************/
#ifndef _UTILS_
#define _UTILS_
#include "global.h"
extern LONG32 lDCMRHighBit;
extern LONG32 lDCMRLowBit;
extern LONG32 lNumXBits;
#ifndef MIN
#define MIN(x, y) 	((x) < (y) ? (x) : (y))
#endif
LONG32 AddSiteAddress(LONG32 lSrc1, LONG32 lSrc2);
LONG32 SubSiteAddress(LONG32 lSrc1, LONG32 lSrc2);
LONG32 ScanLength(void);
LONG32 SweepLength(LONG32 *lFirstSweep);
void UpdateDCMR(void);
BOOL IsSrcNeeded(short nSrc);
BOOL IsSrcSame(short nDest);
BOOL IsDestUpdated(short nDest);
unsigned short CalcNumPlanes(void);
void  UpdateDestSrcMatrix(void);
#define NUM_DEST	4
#define NUM_SRC		6
extern BOOL bDestSrcMatrix [CHIPS_PER_MOD][NUM_DEST][NUM_SRC];
#define SRC_SITE_DATA			0
#define SRC_TBUS			1
#define SRC_FLYWHEEL			2
#define SRC_LUT				3
#define SRC_SITE_ADDRESS		3
#define SRC_GLUED_DATA			4
#define SRC_CONST_DATA			5
#define DEST_SITE_DATA			0
#define DEST_EVENT_CT			1
#define DEST_LUT			2
#define DEST_DISPLAY			3
#define MAP_CONST_0			0
#define MAP_G_NOR_S			1
#define MAP_G_AND_S_BAR			2
#define MAP_S_BAR			3
#define MAP_G_BAR_AND_S			4
#define MAP_G_BAR			5
#define MAP_G_XOR_S			6
#define MAP_G_NAND_S			7
#define MAP_G_AND_S			8
#define MAP_G_EQ_S			9
#define MAP_G				10
#define MAP_G_OR_S_BAR			11
#define MAP_S				12
#define MAP_G_BAR_OR_S			13
#define MAP_G_OR_S			14
#define MAP_CONST_1			15
#endif
/*****************************************************************************/
/*                                                                           */
/* Author 	: Milan Shah						     */
/* Program	: Cam8Sim						     */
/* Date		: February 6, 1992					     */
/* Module	: memmgr.c - memory manager interface with error reporting   */
/*                                                                           */
/*****************************************************************************/
#include <stdio.h>
#include <fcntl.h>
#include <malloc.h>
#include <sys/types.h>
#include <sys/mman.h>
#include <sys/ipc.h>
#include <sys/shm.h>
#include "memmgr.h"
#include "memmgrP.h"
void *mmpMemAlign(unsigned nAlignment,
		  unsigned nSize,
		  char *szModule,
		  char *szFunction)
     void *pRet;
     char *memalign(unsigned, unsigned);
     
     if ( !(pRet = (void *) memalign(nAlignment, nSize)) ) {
	  fprintf(stderr,
		  "Error Allocating memory in %s : %s \n",
		  szModule, szFunction);
	  exit(2);
     }
     return (pRet);
void *mmpValloc(unsigned nSize, char *szModule, char *szFunction)
     void *pRet;
     char *valloc(unsigned size);
     if ( !(pRet = (void *) valloc(nSize)) ) {
	  fprintf(stderr,
		  "Error Allocating memory in %s : %s \n",
		  szModule, szFunction);
	  exit(2);
     }
     return (pRet);
void *mmpMalloc(unsigned nSize, char *szModule, char *szFunction)
     void *pRet;
     if ( !(pRet = malloc(nSize)) ) {
	  fprintf(stderr,
		  "Error Allocating memory in %s : %s \n",
		  szModule, szFunction);
	  exit(2);
     }
     return (pRet);
void *mmpRealloc(void *ptr, unsigned nSize, char *szModule, char *szFunction)
     void *pRet;
     if ( !(pRet = realloc(ptr, nSize)) ) {
	  fprintf(stderr,
		  "Error Reallocating memory in %s : %s \n",
		  szModule, szFunction);
	  exit(2);
     }
     return (pRet);
int mmpFree(void *ptr, char *szModule, char *szFunction)
     int ret;
     
     if (!(ret = free(ptr))) {
	  fprintf(stderr,
		  "Error Freeing memory in %s : %s \n",
		  szModule, szFunction);
	  exit(2);
     }
     return (ret);
int mmpCreateShared(unsigned len, char *szModule, char *szFunction)
     int shmid;
     if ((shmid = shmget(IPC_PRIVATE, len, 0666 | IPC_CREAT)) == -1) {
	  fprintf(stderr,
		  "Error creating shared memory segment in %s : %s \n",
		  szModule, szFunction);
	  exit(2);
     }
     return (shmid);
void *mmpAllocShared(int shmid, unsigned len,
		     char *szModule, char *szFunction)
     void *pRet;
     
     if ((pRet = (void *) shmat(shmid, 0, 0)) == (char *) -1) {
	  fprintf(stderr,
		  "Error mapping shared memory segment in %s : %s \n",
		  szModule, szFunction);
	  exit(2);
     }
     
     return (pRet);
void mmpFreeShared(void *addr,
		   char *szModule, char *szFunction)
     if (shmdt(addr) != 0) {
	  fprintf(stderr,
		  "Error un-mapping shared memory segment in %s : %s \n",
		  szModule, szFunction);
	  exit(2);
     }
     
void mmpDestroyShared(int shmid, char *szModule, char *szFunction)
     if (shmctl(shmid, IPC_RMID, NULL)) {
	  fprintf(stderr,
		  "Error deleting shared memory segment in %s : %s \n",
		  szModule, szFunction);
     }

---------------------------------------------------------------------------

#include <stdio.h>
#include <fcntl.h>
#include <sys/types.h>
#include <sys/ipc.h>
#include <sys/shm.h>
#include <setjmp.h>
#include "global.h"
#include "errmgr.h"
#include "memmgr.h"
#include "steplist.h"
#include "hinterface.h"
#include "hinterfaceP.h"
#include <CAM/CAM.h>
#include <CAM/CAM_pipecomm.h>
#define MODULE_NAME	"Host Interface"
typedef struct {
  char *ker, *ifc;
  int len;
} MapEntry;
static MapEntry MapTable[8192];
static int MapCnt = 0;
static int retv[2];								/* Return value			     */
static jmp_buf exception;							/* Execution frame for exceptions    */
static char *madr = NULL;
static int mlen = 0;
INTERFACE_REGS iregs;								/* CAM8 Interface registers	     */
int sim_infd = 0;								/* File desc to read commands from   */
int sim_outfd = 1;								/* File desc to write replies to     */
int sim_camfd = -1;								/* File desc to do mmaps on	     */
static Cmdt simcmds[] = {
  { "madr", MAPADDR },
  { "mlen", MAPLEN },
  { "mbuf", MAPBUF },
  { "ciom", SIMCIOMAP },
  { "rdR0", READR0 },
  { "rdR1", READR1 },
  { "rdR2", READR2 },
  { "rdR3", READR3 },
  { "wrR0", WRITER0 },
  { "wrR1", WRITER1 },
  { "wrR2", WRITER2 },
  { "wrR3", WRITER3 },
  { "quit", QUIT }
static int qflag = 0;
static int retv[2];
void ResetInterface(void)
  /* Zero everything out to start off */
  bzero((char *) &iregs, sizeof(iregs));
  /* Enable all interrupts and exceptions */
  iregs.RER = CAM_ENABLE_NEWLIST_INT | CAM_ENABLE_TIMEOUT_INT |
              CAM_ENABLE_SBUS_INT | CAM_ENABLE_CAM_INT |
	      CAM_ENABLE_SOFT_INT | CAM_ENABLE_TIMEOUT_EXC |
	      CAM_ENABLE_CAMINT_EXC;
  /* Mark all interrupts as enabled */
  iregs.ISR = CAM_ENABLE_NEWLIST_INT | CAM_ENABLE_TIMEOUT_INT |
              CAM_ENABLE_SBUS_INT | CAM_ENABLE_CAM_INT |
	      CAM_ENABLE_SOFT_INT;
  /* Put us in wait-for-host mode */
  iregs.NLP |= CAM_WAIT_FOR_HOST;
void Generate_Interrupt(int type)
  iregs.ISR |= type;
  switch(type) {
  case CAM_CAM_INT_STATUS: {
    if ((iregs.RER & CAM_ENABLE_CAMINT_EXC) && !(iregs.RER & CAM_DISABLE_CAMINT_EXC)) {
      iregs.NLP |= CAM_EXCEPTION_STATUS;
      longjmp(exception, 1);
    }
    break;
  case CAM_TIMEOUT_INT_STATUS: {
    if ((iregs.RER & CAM_ENABLE_TIMEOUT_EXC) && !(iregs.RER & CAM_DISABLE_TIMEOUT_EXC)) {
      iregs.NLP |= CAM_EXCEPTION_STATUS;
      longjmp(exception, 1);
    }
    break;
void InitInterface(void)
  ResetInterface();
  CAM_SetPipeCmdTable(simcmds);
  CAM_SetPipeMode(CAM_PIPEALL|CAM_PIPESILENT|CAM_PIPEFDPLX);
int ReadInterfaceRegs(void)
  int rv;
  if ((rv = CAM_ParsePipeMesg(sim_infd, sim_outfd, NULL)) < CAM_PIPEALL) {			/* There has been a fatal error	     */
    retv[0] = FATAL;
    CAM_SendPipeMesg(sim_outfd, (char *) retv);
    fprintf(stderr, "CAM8SIM: Fatal error, exiting\n");
    return(-1);
  return(qflag);
/* PipeComm routines */
unsigned char *MAPADDR(char *appdata, unsigned char *o, unsigned char *d)
  retv[0] = NOERR;
  retv[1] = NOERR;
  madr = *((char **) d);
  return((unsigned char *) retv);
unsigned char *MAPLEN(char *appdata, unsigned char *o, unsigned char *d)
  retv[0] = NOERR;
  retv[1] = NOERR;
  mlen = *((int *) d);
  return((unsigned char *) retv);
unsigned char *MAPBUF(char *appdata, unsigned char *o, unsigned char *d)
  retv[0] = -3;
  retv[1] = NOERR;
  if (madr && mlen) {
    if ((retv[1] = (int) mmap(NULL, mlen, PROT_READ|PROT_WRITE, MAP_SHARED,
			 sim_camfd, madr)) == -1)
      retv[0] = -2;
    else {
      MapTable[MapCnt].ker = madr;
      MapTable[MapCnt].len = mlen;
      MapTable[MapCnt++].ifc = (char *) retv[1];
      retv[0] = NOERR;
    }
  return((unsigned char *) retv);
unsigned char *SIMCIOMAP(char *appdata, unsigned char *o, unsigned char *d)
  int i;
  int off;
  char *ifc = *((char **) d);
  retv[0] = -5;
  for (i = 0; i < MapCnt; i++)
    if ((MapTable[i].ifc <= ifc) &&
	((MapTable[i].ifc + MapTable[i].len) > ifc)) {
      off = ifc - MapTable[i].ifc;
      retv[0] = NOERR;
      retv[1] = (int) MapTable[i].ker + off;
      break;
    }
  return((unsigned char *) retv);
unsigned char *READR0(char *appdata, unsigned char *o, unsigned char *d)
  retv[0] = NOERR;
  retv[1] = iregs.NLP;
  return((unsigned char *) retv);
unsigned char *READR1(char *appdata, unsigned char *o, unsigned char *d)
  retv[0] = NOERR;
  retv[1] = iregs.ISR;
  /* Turn off interrupt flags and unused bits, leave enables the same */
  iregs.ISR &= 0x00001F00;
  return((unsigned char *) retv);
unsigned char *READR2(char *appdata, unsigned char *o, unsigned char *d)
  retv[0] = NOERR;
  retv[1] = iregs.CIP;
  return((unsigned char *) retv);
unsigned char *READR3(char *appdata, unsigned char *o, unsigned char *d)
  retv[0] = NOERR;
  retv[1] = iregs.PIP;
  return((unsigned char *) retv);
unsigned char *WRITER0(char *appdata, unsigned char *o, unsigned char *d)
  LONG32 tmp = iregs.NLP & 0xF;
  if (!(iregs.NLP & CAM_EXCEPTION_STATUS)) {
    iregs.NLP = tmp | (*((int *) d) & 0xFFFFFFF0);
    /* Step list has been scheduled... Execute it */
    SimStepList((LONG32 *) (iregs.NLP & 0xFFFFFFF0));
  setjmp(exception);
  retv[0] = NOERR;
  return((unsigned char *) retv);
unsigned char *WRITER1(char *appdata, unsigned char *o, unsigned char *d)
  iregs.RER = *((int *) d);
  if (iregs.RER & CAM_RESET_INTERFACE) {
    ResetInterface();
  if (iregs.RER & CAM_HALT_INTERFACE)
    iregs.NLP |= CAM_INTERFACE_HALTED;
  if (iregs.RER & CAM_ENABLE_TIMEOUT_EXC)
    iregs.NLP &= ~(CAM_EXCEPTION_STATUS);
  /*  This is supposed to also resume after error ack, whatever that is
  if (iregs.RER & CAM_ENABLE_CAMINT_EXC)
  */
  if (iregs.RER & CAM_ENABLE_NEWLIST_INT)
    iregs.ISR |= CAM_ENABLE_NEWLIST_INT;
  if (iregs.RER & CAM_ENABLE_TIMEOUT_INT)
    iregs.ISR |= CAM_ENABLE_TIMEOUT_INT;
  if (iregs.RER & CAM_ENABLE_SBUS_INT)
    iregs.ISR |= CAM_ENABLE_SBUS_INT;
  if (iregs.RER & CAM_ENABLE_CAM_INT)
    iregs.ISR |= CAM_ENABLE_CAM_INT;
  if (iregs.RER & CAM_ENABLE_SOFT_INT)
    iregs.ISR |= CAM_ENABLE_SOFT_INT;
  if (iregs.RER & CAM_DISABLE_NEWLIST_INT)
    iregs.ISR &= ~(CAM_ENABLE_NEWLIST_INT);
  if (iregs.RER & CAM_DISABLE_TIMEOUT_INT)
    iregs.ISR &= ~(CAM_ENABLE_TIMEOUT_INT);
  if (iregs.RER & CAM_DISABLE_SBUS_INT)
    iregs.ISR &= ~(CAM_ENABLE_SBUS_INT);
  if (iregs.RER & CAM_DISABLE_CAM_INT)
    iregs.ISR &= ~(CAM_ENABLE_CAM_INT);
  if (iregs.RER & CAM_ENABLE_SOFT_INT)
    iregs.ISR |= CAM_ENABLE_SOFT_INT;
  retv[0] = NOERR;
  return((unsigned char *) retv);
unsigned char *WRITER2(char *appdata, unsigned char *o, unsigned char *d)
  iregs.DSL = *((int *) d);
  retv[0] = NOERR;
  return((unsigned char *) retv);
unsigned char *WRITER3(char *appdata, unsigned char *o, unsigned char *d)
  iregs.DBL = *((int *) d);
  retv[0] = NOERR;
  return((unsigned char *) retv);
unsigned char *QUIT(char *appdata, unsigned char *o, unsigned char *d)
  retv[0] = NOERR;
  qflag = -1;
  return((unsigned char *) retv);
#ifndef _H_INTERFACE_
#define _H_INTERFACE_
#include "global.h"
void InitInterface(void);
int ReadInterfaceRegs(void);
void Generate_Interrupt(int);
typedef struct interface_registers {
    
  LONG32 NLP;                          /* Next List Pointer            */
  LONG32 ISR;                          /* Reset/Interrupt Register     */
  LONG32 CIP;                          /* Current Instruction Pointer  */
  LONG32 PIP;                          /* Previous Instruction Pointer */
    
  LONG32 RER;                          /* Reset/Enable Register        */
  LONG32 DSL;                          /* Display Scan Length          */
  LONG32 DBL;                          /* Display Blank Length         */
} INTERFACE_REGS;
extern INTERFACE_REGS iregs;
extern int sim_infd, sim_outfd;
/* NLP/NLP */
#define CAM_INTERFACE_HALTED    0x00000008 /* Interface Halted?            */
#define CAM_WAIT_FOR_HOST       0x00000004 /* CAM waiting for host? status */
#define CAM_EXCEPTION_STATUS    0x00000002 /* Interface Exception status   */
#define CAM_NLP_WRITTEN         0x00000001 /* CAM NLP written? status      */
/* ISR/RER */
#define CAM_INT_PENDING_STATUS  0x0000001F /* Status of all Interrupt Bits */
#define CAM_NEWLIST_INT_STATUS  0x00000010 /* Status new-list interrupt    */
#define CAM_TIMEOUT_INT_STATUS  0x00000008 /* Status timeout interrupt     */
#define CAM_SBUS_INT_STATUS     0x00000004 /* Status Sbus interrupt        */
#define CAM_CAM_INT_STATUS      0x00000002 /* Status CAM interrupt         */
#define CAM_SOFT_INT_STATUS     0x00000001 /* Status interrupt             */
#define CAM_RESET_INTERFACE     0x80000000 /* Reset the interface          */
#define CAM_HALT_INTERFACE      0x00008000 /* Halt the interface           */
#define CAM_CLEAR_EXCEPTION     0x00004000 /* Clear exceptions (enable     */
					   /* exceptions caused by timeout)*/
#define CAM_ENABLE_TIMEOUT_EXC  0x00004000 /* enable exceptions caused     */
					   /* by timeout (clear exceptions)*/
#define CAM_RESUME_AFTER_ERR    0x00002000 /* Resume after error ack       */
					   /* (enable exceptions by CAM    */
					   /* interrupt)                   */
#define CAM_ENABLE_CAMINT_EXC   0x00002000 /* enable exceptions by CAM     */
					   /* interrupt (resume after      */
					   /* error ack)                   */
#define CAM_ENABLE_NEWLIST_INT  0x00001000 /* Enable new-list interrupt    */
#define CAM_ENABLE_TIMEOUT_INT  0x00000800 /* Enable timeout interrupt     */
#define CAM_ENABLE_SBUS_INT     0x00000400 /* Enable Sbus interrupt        */
#define CAM_ENABLE_CAM_INT      0x00000200 /* Enable CAM interrupt         */
#define CAM_ENABLE_SOFT_INT     0x00000100 /* Enable soft interrupt        */
#define CAM_DISABLE_TIMEOUT_EXC 0x00000040 /* Disable new-list interrupt   */
#define CAM_DISABLE_CAMINT_EXC  0x00000020 /* Disable timeout interrupt    */
#define CAM_DISABLE_NEWLIST_INT 0x00000010 /* Disable new-list interrupt   */
#define CAM_DISABLE_TIMEOUT_INT 0x00000008 /* Disable timeout interrupt    */
#define CAM_DISABLE_SBUS_INT    0x00000004 /* Disable Sbus interrupt       */
#define CAM_DISABLE_CAM_INT     0x00000002 /* Disable CAM interrupt        */
#define CAM_DISABLE_SOFT_INT    0x00000001 /* Disable soft interrupt       */
/* CIP/DSL */
#define CAM_TRANSFER_WAITING   0x00000008  /* Is CAM waiting to transfer?  */
#define CAM_DONE_STATUS        0x00000004  /* CAM Done status              */
#define CAM_PARTIAL_WRITE      0x00000002  /* Partial write after Sbus err?*/
#define CAM_FSM_SUSPENDED      0x00000001  /* Is Sbus FSM suspended?       */
/* PIP/DBL */
#define CAM_INTRFC_RESET_PNDNG 0x00000008  /* Interface reset pending?     */
#define CAM_SS2                0x00000004  /* CAM SS2 mode set?            */
#define CAM_SCANNING_STATUS    0x00000002  /* CAM scanning status          */
#define CAM_INTERRUPT_STATUS   0x00000001  /* CAM interrupt status         */
#define NOERR		0
#define FATAL		-1
#define BADSHMID	-2
#define TABLEFULL	-3
#endif
/*****************************************************************************/
/*                                                                           */
/* steplist.c:	modifications to original code made by Harris L. Gilliam     */
/*		March 1994 - June 1995					     */
/*                                                                           */
/*                                                                           */
/*   Corrected various simple bugs, including using ints for loop couters    */
/*   where shorts were improperly used. (LIOR code)                          */
/*                                                                           */
/*   Rewrote the routines that pack/unpack bits from steplists into the      */
/*   global CAM8State variable.                                              */
/*                                                                           */
/*****************************************************************************/
/*                                                                           */
/* Author       : Milan Shah                                                 */
/* Program      : Cam8Sim                                                    */
/* Date         : February 24, 1992                                          */
/* Module       : steplist.c - module to read in step lists; essentially     */
/*                simulates the interface board                              */
/*                                                                           */
/*****************************************************************************/
#include <stdio.h>
#include <sys/mman.h>
#include <sys/types.h>
#include <sys/ipc.h>
#include <sys/shm.h>
#ifdef _INSTRUMENTATION_
#include <sys/time.h>
#endif
#include <CAM/CAM.h>
#include <CAM/CAM_instr.h>
#include <CAM/CAM_util.h>
#include "global.h"
#include "heap.h"
#include "memmgr.h"
#include "errmgr.h"
#include "utils.h"
#include "sim.h"
#include "steplist.h"
#include "steplistP.h"
#include "decode_steplist.h"
#include "hinterface.h"
#define MODULE_NAME "StepList"
void DoKick(short);
static int VWECHK = 0;
static LONG32 pbuf[CHIPS_PER_MOD];
#ifdef _INSTRUMENTATION_
struct timeval tvStart, tvEnd;
struct timezone tzZone;
#endif
void vwecheck(INT16 *base, int reg_fld, int imm)
  register int i;
  int f = 0, o;
  Bt bt;
  bt = base_type[reg_fld];
  if (VWECHK) {
    UnpackStateInto(base, reg_fld, imm, (BYTE *) pbuf, bt.type);
    for (i = 0; i < CHIPS_PER_MOD; i++) {
      o = bt.type * i;
      if (VWE[i]) {
	if (bcmp(bt.base + o, ((BYTE *) pbuf) + o, bt.type) != 0) {
	  f = 1;
	  VWIF[i] = 1;
      }
      else
	bcopy(((BYTE *) pbuf) + o, bt.base + o, bt.type);
    }
  else
    UnpackState(base, reg_fld, imm);
void SimStepList(LONG32 *plFirstInstr)
  LONG32 *plCurr = NULL, *plNext = NULL;
  LONG32 lData = 0, lLength;
  short nRegister, i, imm = FALSE;
  BOOL bHostJump, bHostWait, bByteMode, bReadMode;
  BOOL bDone = FALSE;
  LONG32 pbuf[CHIPS_PER_MOD];
  bHostJump = bHostWait = FALSE;
  for (plCurr = plFirstInstr; !bDone; plCurr = plNext) {
    bHostJump = (*plCurr & HOST_JUMP_MASK) != 0;
    bHostWait = (*plCurr & HOST_WAIT_MASK) != 0;
    bDone = bHostJump || bHostWait;
    bByteMode = (*plCurr & BYTE_MODE_MASK) != 0;
    bReadMode = (*plCurr & READ_CAM_MASK) != 0;
    
    iregs.PIP = iregs.CIP;
    iregs.CIP = (LONG32) plNext;
    if (*plCurr & RESET_CAM_MASK) {
      memset ((char *) &CAM8State, 0, sizeof(CAM8State));
      LIOR = LUT1;
      LUT_ADDR = (LONG32) LUT0;
      bSourceRegChange = bDestChange = TRUE;
      
#ifdef DEBUG
      fprintf(DEBUGFILE, "CAM Reset\n");
      fflush(DEBUGFILE);
#endif
    }
    
    
    nRegister = *plCurr & REGISTER_ADDR_MASK;
    imm = (*plCurr & IMMEDIATE_DATA_MASK) != 0;
    lData = *(plCurr + 1);
    lLength = *(plCurr + 2);
    
    plNext = (LONG32 *) (*(plCurr + 3));
    
    if ((*plCurr & READ_CAM_MASK) && (*plCurr & IMMEDIATE_DATA_MASK)) {
#ifdef DEBUG
      fprintf(DEBUGFILE, "NOOP\n");
#endif
      continue;
    }
    
    
#ifdef DEBUG
    fprintf(DEBUGFILE, "REG = %d (%s), ", nRegister, REGNAMES[nRegister]);
    if (imm)
      fprintf(DEBUGFILE, "IMMEDIATE DATA, ");
    fprintf(DEBUGFILE, "BYTEMODE = %d, READMODE = %d\n", bByteMode, bReadMode);
    fflush(DEBUGFILE);
#endif
    
    if ((*plCurr & READ_CAM_MASK) != 0) {
      INT16 *pnBuffer;
      
      CAM8State.bReadMode = TRUE;
      bDestChange = TRUE;
      
      pnBuffer = (INT16 *) lData;
      
      SimReadInstr(pnBuffer, *plCurr, lData, lLength);
      
      continue;
    }
    
    
    switch (nRegister) {
      
    case RFINDEX(REG_MSR): {
      vwecheck((INT16 *) lData, RFINDEX(REG_MSR), imm);
      break;
    }      
      
      
    case RFINDEX(REG_RMR): {
      vwecheck((INT16 *) lData, RFINDEX(FLD_SSM), imm);
      vwecheck((INT16 *) lData, RFINDEX(FLD_RT), imm);
      vwecheck((INT16 *) lData, RFINDEX(FLD_ECT), imm);
      vwecheck((INT16 *) lData, RFINDEX(FLD_RPK), imm);
      vwecheck((INT16 *) lData, RFINDEX(FLD_ALT), imm);
      
#ifndef INTERPRETER
      for(i = 0; i < CHIPS_PER_MOD; i++) {
	if (ECT[i] == 1) {
          ECR[i] = EVENT_COUNT(i);
          EVENT_COUNT(i) = 0L;
        }
        if (RPK[i] == 1)
          DoKick(i);
      }
      
#else INTERPRETER
      for(i = 0; i < CHIPS_PER_MOD; i++) {
	if (ECT[i] == 1) {
          ECR[i] = EVENT_COUNT[i];
          EVENT_COUNT[i] = 0L;
        }
        if (RPK[i] == 1)
          DoKick(i);
      }
      
#endif INTERPRETER
      if (ALT[0] == 1) {
        INT16 *pnTemp;
        
        pnTemp = LIOR;
        LIOR = (INT16 *) LUT_ADDR;
        LUT_ADDR = (LONG32) pnTemp;
        
        for (i = 0; i < CHIPS_PER_MOD; i++)
	  ALS[i] ^= 1;
      }
      if (CAM8State.bReadMode != FALSE) {
	bDestChange = TRUE;
	CAM8State.bReadMode = FALSE;
      }
      if (SSM[0] != 0) {
	CAM8State.WhyScan = RFINDEX(REG_RMR);
#ifndef INTERPRETER
        SimCompScan();
        
#ifndef _DRYRUN_                 
#ifdef _INSTRUMENTATION_
	gettimeofday(&tvStart, &tzZone);
#endif
        SimExecScan();
#ifdef _INSTRUMENTATION_
	gettimeofday(&tvEnd, &tzZone);
      
	fprintf(stderr, "Regular Scan took %d usecs\n",
		(tvEnd.tv_sec - tvStart.tv_sec) * 1000000 +
		(tvEnd.tv_usec - tvStart.tv_usec));
#endif _INSTRUMENTATION_
#endif _DRYRUN_
#else INTERPRETER
	SimExecScan();
#endif INTERPRETER
      }
      
      break;
    }
      
      
    case RFINDEX(REG_KR): {
      vwecheck((INT16 *) lData, RFINDEX(FLD_KA), imm);
      vwecheck((INT16 *) lData, RFINDEX(FLD_XKS), imm);
      vwecheck((INT16 *) lData, RFINDEX(FLD_YKS), imm);
      vwecheck((INT16 *) lData, RFINDEX(FLD_ZKS), imm);
      vwecheck((INT16 *) lData, RFINDEX(FLD_XKMF), imm);
      vwecheck((INT16 *) lData, RFINDEX(FLD_YKMF), imm);
      vwecheck((INT16 *) lData, RFINDEX(FLD_ZKMF), imm);
      DoKick(-1);
      break;
    }
      
      
    case RFINDEX(REG_SABSR):
      {
	vwecheck((INT16 *) lData, RFINDEX(REG_SABSR), imm);
	break;
      }
    case RFINDEX(REG_LASR):
    case RFINDEX(REG_FOSR):
    case RFINDEX(REG_SDSR):
    case RFINDEX(REG_ECSR):
    case RFINDEX(REG_DSR): {
      vwecheck((INT16 *) lData, FLD_SELECT(nRegister), imm);
      vwecheck((INT16 *) lData, FLD_MAP(nRegister), imm);
      bSourceRegChange = TRUE;
      break;
    }
      
    case RFINDEX(REG_SSR): {
      vwecheck((INT16 *) lData, RFINDEX(REG_SSR), imm);
      
      break;
    }
      
      
    case RFINDEX(REG_ECR): {
      if (ECL[0] != lLength) {
	ConstantSetAll(RLIF, 1);
	Generate_Interrupt(CAM_CAM_INT_STATUS);
      }
      else {
	int i;
	UnpackBits((INT16 *) lData, 0, lLength, imm, (BYTE *) ECR, BIT32);
	for(i = 0; i < CHIPS_PER_MOD; i++)
#ifndef INTERPRETER
	  EVENT_COUNT(i) = ECR[i];
#else INTERPRETER
	  EVENT_COUNT[i] = ECR[i];
#endif INTERPRETER
      }
      break;
    }
      
      
    case RFINDEX(REG_LIR): {
      vwecheck((INT16 *) lData, RFINDEX(REG_LIR), imm);
      break;
    }
      
      
    case RFINDEX(REG_LIPR): {
      vwecheck((INT16 *) lData, RFINDEX(REG_LIPR), imm);
      
      break;
    }
      
      
    case RFINDEX(REG_LIOR): {
      INT16 nLUTEntry, nLUTNextIndex;
      INT16 *pnLUT, *pnSource;
      int i, j;
      INT16 nImmediate[2];
      
      if (imm) {
        nImmediate[0] = (INT16) lData >> 16;
        nImmediate[1] = (INT16) lData & 0xFF;
        pnSource = &nImmediate[0];
      }
      
      else
        pnSource = (INT16 *) lData;
      
      for (i = 0; i < lLength; i++) {
        nLUTNextIndex = 0;
        for (j = CHIPS_PER_MOD - 1; j >= 0; j--) {
          nLUTNextIndex <<= 1;
          if (LIPR[j] < 16)
            nLUTNextIndex |= ((LIR[j] >> LIPR[j]) & 0x1);
          else if (LIPR[j] == 31)
            nLUTNextIndex |= 0x1;
	  LIR[j]++;
        }
        pnLUT = LIOR + nLUTNextIndex;                 
        
        if (imm) {
          *pnLUT = *pnSource;
          pnSource = &nImmediate[i % 2];
        } 
        
        else {
          *pnLUT = *pnSource;
          pnSource++;
        }
      }
      
      break;
    }
      
      
    case RFINDEX(REG_SIR): {
      vwecheck((INT16 *) lData, RFINDEX(REG_SIR), imm);
      
      SCAN_INDEX_REG = SIR[0];
      
      break;
    }
      
      
    case RFINDEX(REG_SIPR): {
      int j;
      
      for(j = 0; j < SCAN_INDEX_LENGTH; j++)
        vwecheck((INT16 *) lData, RFINDEX(FLD_SSA(j)), imm);
      
      break;
    }
      
      
    case RFINDEX(REG_SIOR): {
      if ((CAM8State.bByteMode != bByteMode) || 
          (CAM8State.bImmediate != imm)) {
        CAM8State.bByteMode = bByteMode;
        CAM8State.bImmediate = imm;
        bSourceRegChange = TRUE;
      }
      
      if (imm) {
        SIOR = (BYTE *) &lData;
        TBUS_DATA = lData;
#ifndef INTERPRETER
	SIOREG = (LONG32) SIOR;
#endif INTERPRETER
      }
      
      else {
        SIOR = (BYTE *) lData;
	TBUS_ADDR = lData;
#ifndef INTERPRETER
	SIOREG = (LONG32) SIOR;
#endif INTERPRETER
      }
      
      if (CAM8State.bReadMode != FALSE) {
        bDestChange = TRUE;
        CAM8State.bReadMode = FALSE;
      }
      
      CAM8State.WhyScan = RFINDEX(REG_SIOR);
#ifndef INTERPRETER
      SimCompScan();
#ifndef _DRYRUN_                 
#ifdef _INSTRUMENTATION_
      gettimeofday(&tvStart, &tzZone);
#endif
      SimExecScan();
#ifdef _INSTRUMENTATION_
      gettimeofday(&tvEnd, &tzZone);
      
      fprintf(stderr, "Scan I/O Write took %d usecs\n",
	      (tvEnd.tv_sec - tvStart.tv_sec) * 1000000 +
	      (tvEnd.tv_usec - tvStart.tv_usec));
#endif _INSTRUMENTATION_
#endif _DRYRUN_
      
#else INTERPRETER
      
      SimExecScan();      
#endif INTERPRETER
      break;
    }
      
      
    case RFINDEX(REG_SFR): {
      vwecheck((INT16 *) lData, RFINDEX(FLD_SM), imm);
      vwecheck((INT16 *) lData, RFINDEX(FLD_ESC), imm);
      vwecheck((INT16 *) lData, RFINDEX(FLD_ESW), imm);
      vwecheck((INT16 *) lData, RFINDEX(FLD_EST), imm);
      vwecheck((INT16 *) lData, RFINDEX(FLD_SBRC), imm);
      vwecheck((INT16 *) lData, RFINDEX(FLD_RCL), imm);
      vwecheck((INT16 *) lData, RFINDEX(FLD_ECL), imm);
      vwecheck((INT16 *) lData, RFINDEX(FLD_STM), imm);
      
      break;
    }
      
      
    case RFINDEX(REG_OSR): {
      vwecheck((INT16 *) lData, nRegister, imm);
      break;
    }
      
      
    case RFINDEX(REG_DR): {
      vwecheck((INT16 *) lData, RFINDEX(FLD_DCM), imm);
      vwecheck((INT16 *) lData, RFINDEX(FLD_XDCP), imm);
      vwecheck((INT16 *) lData, RFINDEX(FLD_YDCP), imm);
      vwecheck((INT16 *) lData, RFINDEX(FLD_ZDCP), imm);
      UpdateDCMR();
      
      break;
    }
      
      
    case RFINDEX(REG_HER): {
      vwecheck((INT16 *) lData, RFINDEX(FLD_LPL), imm);
      vwecheck((INT16 *) lData, RFINDEX(FLD_FPL), imm);
      vwecheck((INT16 *) lData, RFINDEX(FLD_DCS), imm);
      vwecheck((INT16 *) lData, RFINDEX(FLD_TBD), imm);
      vwecheck((INT16 *) lData, RFINDEX(FLD_TMS), imm);
      vwecheck((INT16 *) lData, RFINDEX(FLD_NBF), imm);
      vwecheck((INT16 *) lData, RFINDEX(FLD_SRE), imm);
      vwecheck((INT16 *) lData, RFINDEX(FLD_ALS), imm);
       
      if (ALS[0] == 1) {
        LIOR = (INT16*) LUT0;
        LUT_ADDR = (LONG32) LUT1;
      } 
      
      else {
        LIOR = (INT16 *) LUT1;
        LUT_ADDR = (LONG32) LUT0;
      }
      
      bSourceRegChange = TRUE;
      
      break;
    }
      
      
    case RFINDEX(REG_MPCR): {
      vwecheck((INT16 *) lData, RFINDEX(FLD_MAFS), imm);
      vwecheck((INT16 *) lData, RFINDEX(FLD_MBFS), imm);
      break;
    }
      
      
    case RFINDEX(REG_GPCR): {
      vwecheck((INT16 *) lData, RFINDEX(FLD_XMPC), imm);
      vwecheck((INT16 *) lData, RFINDEX(FLD_XPPC), imm);
      vwecheck((INT16 *) lData, RFINDEX(FLD_YMPC), imm);
      vwecheck((INT16 *) lData, RFINDEX(FLD_YPPC), imm);
      vwecheck((INT16 *) lData, RFINDEX(FLD_ZMPC), imm);
      vwecheck((INT16 *) lData, RFINDEX(FLD_ZPPC), imm);
      break;
    }
      
      
    case RFINDEX(REG_MIDR): {
      vwecheck((INT16 *) lData, RFINDEX(REG_MIDR), imm);
      break;
    }
      
      
    case RFINDEX(REG_GIDR): {
      vwecheck((INT16 *) lData, RFINDEX(REG_GIDR), imm);
      break;
    }
      
      
    case RFINDEX(REG_IER): {
      vwecheck((INT16 *) lData, RFINDEX(FLD_BPIE), imm);
      vwecheck((INT16 *) lData, RFINDEX(FLD_BCIE), imm);
      vwecheck((INT16 *) lData, RFINDEX(FLD_GCIE), imm);
      vwecheck((INT16 *) lData, RFINDEX(FLD_MAIE), imm);
      vwecheck((INT16 *) lData, RFINDEX(FLD_MBIE), imm);
      vwecheck((INT16 *) lData, RFINDEX(FLD_SSIE), imm);
      vwecheck((INT16 *) lData, RFINDEX(FLD_XHIE), imm);
      vwecheck((INT16 *) lData, RFINDEX(FLD_RLIE), imm);
      vwecheck((INT16 *) lData, RFINDEX(FLD_URIE), imm);
      vwecheck((INT16 *) lData, RFINDEX(FLD_ISIE), imm);
      break;
    }
      
      
    case RFINDEX(REG_IFR): {
      vwecheck((INT16 *) lData, RFINDEX(FLD_BPIF), imm);
      vwecheck((INT16 *) lData, RFINDEX(FLD_BCIF), imm);
      vwecheck((INT16 *) lData, RFINDEX(FLD_GCIF), imm);
      vwecheck((INT16 *) lData, RFINDEX(FLD_MAIF), imm);
      vwecheck((INT16 *) lData, RFINDEX(FLD_MBIF), imm);
      vwecheck((INT16 *) lData, RFINDEX(FLD_SSIF), imm);
      vwecheck((INT16 *) lData, RFINDEX(FLD_XHIF), imm);
      vwecheck((INT16 *) lData, RFINDEX(FLD_RLIF), imm);
      vwecheck((INT16 *) lData, RFINDEX(FLD_URIF), imm);
      vwecheck((INT16 *) lData, RFINDEX(FLD_ISIF), imm);
      break;
    }
      
      
    case RFINDEX(REG_VWR): {
      register int i;
      
      UnpackState((INT16 *) lData, RFINDEX(FLD_VWE), imm);
      UnpackState((INT16 *) lData, RFINDEX(FLD_VWIE), imm);
      UnpackState((INT16 *) lData, RFINDEX(FLD_VWIF), imm);
      VWECHK = 0;
      for (i = 0; i < CHIPS_PER_MOD; i++)
	if (VWE[i] == 1)
	  VWECHK = 1;
      
      break;
    }
      
      
    case RFINDEX(REG_DOCR): {
      vwecheck((INT16 *) lData, RFINDEX(FLD_LDOC), imm);
      vwecheck((INT16 *) lData, RFINDEX(FLD_HDOC), imm);
      
      break;
    }
      
      
    default: {
      
      fprintf(stderr, "Don't recognize register %d\n", nRegister);
      break;
    }
    }
    
    iregs.PIP = (LONG32) plCurr;
  } /*   for (plCurr = plFirstInstr; !bDone; plCurr = plNext;) */
  iregs.ISR |= CAM_NEWLIST_INT_STATUS;
void DoKick(short p)
  register int i, j;
  LONG32 lSignBitOffset, lSignBitKick, lLowBitsKick;
  LONG32 lDCM;
  LONG32 lKA;
  /************************************************************************/
  /* The kick and offset registers are two n-dimension-vectors, and the   */
  /* place where all dimensions end is determined by lDCMR. To subtract   */
  /* an n-dimension-kick from the corresponding offset, we first extract  */
  /* out the sign bits of both (by and-ing with lDCMR). Next, we set the  */
  /* most sig bits of every dimension in offset to 1, so that when we     */
  /* subtract out the kick, we don't borrow from the next higher          */
  /* dimension. Next, we subtract the value bits of kick (lowbits) from   */
  /* this offset. This will give the 'sign' bit of the new offset and its */
  /* value. The final sign bit of the offset is determined by :           */
  /*                                                                      */
  /*     sign bit = new sign bit xor (old sign bit xnor kick sign bit)    */
  /*                                                                      */
  /* To do the xnor operation, we simply store the inverse of the kick    */
  /* sign bit and then do an xor                                          */
  /*                                                                      */
  /* One easy way to derive this is to think of a sample dimension with   */
  /* 4 bits. Then, the bit positions have values  -8  4  2  1. The        */
  /* subtract operation as described above becomes (8 + 4*o.2 + 2*o.1 +   */
  /* 1*o.0 - 4*k.2 - 2*k.1 - 1*k.0) - 8 - 8*o.sign + 8.k.sign             */
  /* where o.X means the X'th bit of offset and k.X means the X'th bit of */
  /* kick. Since the final offset is of the form -8*o.sign + 4*o.2 +      */
  /* 2*o.1 + 1*o.o, we can express the sign bit as the above logical      */
  /* function of the three individual sign bits.                          */
  /*                                                                      */
  /************************************************************************/
  if (p == -1) {
    p = 0;
    j = CHIPS_PER_MOD;
  else
    j = p + 1;
  for(i = p; i < j; i++) {
    lSignBitOffset = OSR[i] & DCM[i];
    lSignBitKick = (~KA[i]) & DCM[i];
    OSR[i] |= DCM[i];
    lLowBitsKick =  KA[i] & (~ DCM[i]);
    
    OSR[i] -= lLowBitsKick;
    lSignBitOffset ^= lSignBitKick;
    OSR[i] ^= lSignBitOffset;
/*****************************************************************************/
/*                                                                           */
/* main.c:	modifications to original code made by Harris L. Gilliam     */
/*		March 1994 - June 1995					     */
/*                                                                           */
/*****************************************************************************/
/*                                                                           */
/* Author	: Milan Shah						     */
/* Program	: Cam8Sim						     */
/* Date		: February 18, 1992					     */
/* Module	: main.c 						     */
/*                                                                           */
/*****************************************************************************/
#include <CAM/CAM.h>
#include <CAM/CAM_err.h>
#include <stdio.h>
#include <signal.h>
#include "global.h"
#include "errmgr.h"
#include "heap.h"
#include "sim.h"
#include "steplist.h"
#include "hinterface.h"
#define MODULE_NAME	"main"
void ReadCmdLine(int argc, char *argv[]);
void InitExitProcs(), InitStepList();
#ifdef DEBUG
FILE *DEBUGFILE = (FILE *) NULL;
char *REGNAMES[] = {
  "select", "run", "kick", "sa-bit", "lut-src", "fly-src", "site-src", "event-src", "display", "show-scan", "event",
  "lut-index", "lut-perm", "lut-io", "scan-index", "scan-perm", "scan-io", "scan-format", "offset", "dimension",
  "environment", "multi", "connect", "module-id", "group-id", "int-enable", "int-flags", "verify", "dram-count"
  };
#ifndef INTERPRETER
CODEPTR DASMADDR;
#endif INTERPRETER
#endif
void main(int argc, char *argv[])
#ifdef DEBUG
  int i;
#endif
#ifndef INTERPRETER
  InitSymbolTable();
#endif INTERPRETER
  InitExitProcs();
  InitHeap();
#ifndef INTERPRETER
  InitSim();
#endif INTERPRETER
  InitInterface();
  InitStepList();
  ReadCmdLine(argc, argv);
     
#ifdef DEBUG
  DEBUGFILE = fopen("./sim.log", "w");
#endif
  while (ReadInterfaceRegs() > -1) {}
  exit(0);
     
     
void ReadCmdLine(int argc, char *argv[])
  register int i;
  for(i = 1; i < argc; i++) {
    if (strcmp(argv[i], "-g") == 0) {
      bForceGeneralScan = TRUE;
      continue;
    }
    if (strcmp(argv[i], "-fd") == 0) {
      sim_camfd = atoi(argv[i+1]);
      i++;
      continue;
    }
    if (strcmp(argv[i], "-in") == 0) {
      sim_infd = atoi(argv[i+1]);
      i++;
      continue;
    }
    if (strcmp(argv[i], "-out") == 0) {
      sim_outfd = atoi(argv[i+1]);
      i++;
      continue;
    }
    
void InitExitProcs()
     void ExitSigProc();
     void ExitProc();
#ifdef sun
     on_exit(ExitProc);								 /* Make sure it gets called on exit */
#endif
     
     if ( (signal(SIGHUP, ExitSigProc) == BADSIG) ||
	  (signal(SIGINT, SIG_IGN) == BADSIG) ||
	  (signal(SIGQUIT, SIG_IGN) == BADSIG) ||
	  (signal(SIGILL, ExitSigProc) == BADSIG) ||
	  (signal(SIGFPE, ExitSigProc) == BADSIG) ||
	  (signal(SIGBUS, ExitSigProc) == BADSIG) ||
	  (signal(SIGSEGV, ExitSigProc) == BADSIG) ||
	  (signal(SIGSYS, ExitSigProc) == BADSIG) ||
	  (signal(SIGPIPE, ExitSigProc) == BADSIG) ||
	  (signal(SIGTERM, ExitSigProc) == BADSIG) ) {
	  WARNING("Could not install cleanup routines!", "InitExitProc");
     }
void ExitSigProc(int sig, int code, struct sigcontext *scp, char *addr)
  static char *pcSignalName[] = {
    "Unknown",
    "Hangup",
    "Interrupt",
    "Quit",
    "Illegal Instruction",
    "Trace Trap",
    "IO (Hardware) Trap",
    "Emulator Trap",
    "Floating Point Exception",
    "Kill",
    "Bus Error",
    "Segmentation Fault",
    "Bad Argument to system call",
    "Write to broken pipe",
    "Alarm",
    "Software Termination",
    "User1",
    "User2",
    "Child Termination",
    "Power down"
  };
  fprintf(stderr, "CAM8SIM: ");
     
  switch (sig) {
  case SIGHUP:
  case SIGSYS:
  case SIGPIPE:
    fprintf(stderr, "%s signal received - exiting.\n", pcSignalName[sig]);
    break;
    
  case SIGILL:
  case SIGFPE:
    fprintf(stderr, "Attempt to execute illegal instruction at 0x%x\n", addr);
    break;
  case SIGBUS:
  case SIGSEGV:
    fprintf(stderr, "Attempt to access invalid memory location 0x%x\n", addr);
    break;
  case SIGTERM:
    fprintf(stderr, "Termination signal received - exiting.\n");
    break;
  default:
    break;
#ifdef DEBUG
  fclose(DEBUGFILE);
#endif
  _exit(0);
void ExitProc()
#ifdef DEBUG
  fclose(DEBUGFILE);
#endif
#ifndef _H_INTERFACE_P_
#define _H_INTERFACE_P_
unsigned char *MAPADDR(char *, unsigned char *, unsigned char *);
unsigned char *MAPLEN(char *, unsigned char *, unsigned char *);
unsigned char *MAPBUF(char *, unsigned char *, unsigned char *);
unsigned char *SIMCIOMAP(char *, unsigned char *, unsigned char *);
unsigned char *READR0(char *, unsigned char *, unsigned char *);
unsigned char *READR1(char *, unsigned char *, unsigned char *);
unsigned char *READR2(char *, unsigned char *, unsigned char *);
unsigned char *READR3(char *, unsigned char *, unsigned char *);
unsigned char *WRITER0(char *, unsigned char *, unsigned char *);
unsigned char *WRITER1(char *, unsigned char *, unsigned char *);
unsigned char *WRITER2(char *, unsigned char *, unsigned char *);
unsigned char *WRITER3(char *, unsigned char *, unsigned char *);
unsigned char *QUIT(char *, unsigned char *, unsigned char *);
#endif
/*****************************************************************************/
/*                                                                           */
/* heap.c:	modifications to original code made by Harris L. Gilliam     */
/*		March 1994 - June 1995					     */
/*                                                                           */
/*****************************************************************************/
/*                                                                           */
/* Author	: Milan Shah						     */
/* Program	: Cam8Sim						     */
/* Date		: February 14, 1992					     */
/* Module	: heap.c - The symbol table interface, and heap init	     */
/*		  routines.						     */
/*                                                                           */
/*****************************************************************************/
#include <sys/types.h>
#include <sys/mman.h>
#include "global.h"
#include "errmgr.h"
#include "memmgr.h"
#include "heap.h"
#define MODULE_NAME	"Heap"
/* 0.5 Megabytes per plane and 64K x 16bit LUT */
const int lBitPlaneSize = 512 * 1024;
const int lLUTSize = 65536*2;
#ifndef INTERPRETER
BYTE *pcHeap = NULL;
#endif INTERPRETER
void InitHeap()
  short i;
     
#ifndef INTERPRETER
  if (!pcHeap) {
    pcHeap = (BYTE *) VALLOC(HeapSize, "InitHeap : Heap");
    madvise(pcHeap, HeapSize, MADV_RANDOM|MADV_WILLNEED);
  for (i = 0; i < CHIPS_PER_MOD; i++) {
    BIT_PLANE_ADDR(i) = (LONG32) MEMALIGN(lBitPlaneSize, lBitPlaneSize,
					  "InitHeap : Plane Memory");
    madvise(BIT_PLANE_ADDR(i), lBitPlaneSize, MADV_SEQUENTIAL|MADV_WILLNEED);
#else INTERPRETER
  for (i = 0; i < CHIPS_PER_MOD; i++) {
    BIT_PLANE_ADDR[i] = (LONG32) MEMALIGN(lBitPlaneSize, lBitPlaneSize,
					  "InitHeap : Plane Memory");
    madvise(BIT_PLANE_ADDR[i], lBitPlaneSize, MADV_SEQUENTIAL|MADV_WILLNEED);
#endif INTERPRETER
  LUT0 = (INT16 *) VALLOC(lLUTSize, "InitHeap : LUT0");
  madvise(LUT0, lLUTSize, MADV_SEQUENTIAL|MADV_WILLNEED);
#ifdef DEBUG
  printf("LUT0 = 0x%x\n", LUT0);
#endif
  LUT_ADDR = (LONG32) LUT0;
  LUT1 = (INT16 *) VALLOC(lLUTSize, "InitHeap : LUT1");
  madvise(LUT1, lLUTSize, MADV_SEQUENTIAL|MADV_WILLNEED);
#ifdef DEBUG
  printf("LUT1 = 0x%x\n", LUT1);
#endif
  LIOR = (INT16 *) LUT1;
#ifdef _FRAMEBUFFER_
  FRAMEb = (BYTE *) VALLOC(512 * 512, "InitHeap : FRAMEBUFFER");
  madvise(FRAMEb, 512 * 512, MADV_SEQUENTIAL|MADV_WILLNEED);
#endif
#ifndef INTERPRETER
const LONG32 iHighBitMask	= 1;						 /* Indexes Into Symboltable	     */
const LONG32 iXHighBitMask	= (offXHighBitMask/LONG32_SIZE + 1);		 /* Used As "Variable Names". 	     */
const LONG32 iXByteLength	= (offXByteLength/LONG32_SIZE	 + 1);				 
const LONG32 iXCtr		= (offXCtr/LONG32_SIZE + 1);
const LONG32 iSiteCtr		= (offSiteCtr/LONG32_SIZE + 1);
const LONG32 iOffsets		= (offOffsets/LONG32_SIZE + 1);			 /* Each Element Of Arrays Have Own  */
const LONG32 iBitOffsets	= (offBitOffsets/LONG32_SIZE + 1);		 /* Symbol Table Entry 		     */
const LONG32 iDcmr		= (offDcmr/LONG32_SIZE + 1);
const LONG32 iScanIndexReg	= (offScanIndexReg/LONG32_SIZE + 1);
const LONG32 iLutAddr		= (offLutAddr/LONG32_SIZE + 1);
const LONG32 iBitPlaneAddr	= (offBitPlaneAddr/LONG32_SIZE + 1);
const LONG32 iNextWordAddr	= (offNextWordAddr/LONG32_SIZE + 1);
const LONG32 iPlaneWord		= (offPlaneWord/LONG32_SIZE + 1);
const LONG32 iEventCount	= (offEventCount/LONG32_SIZE + 1);
const LONG32 iGlueData		= (offGlueData/LONG32_SIZE + 1);
const LONG32 iUnGlueData	= (offUnGlueData/LONG32_SIZE + 1);
const LONG32 iSiteDataSrc	= (offSiteDataSrc/LONG32_SIZE + 1);
const LONG32 iTbusData		= (offTbusData/LONG32_SIZE + 1);
const LONG32 iLutData		= (offLutData/LONG32_SIZE + 1);
const LONG32 iTbusAddr		= (offTbusAddr/LONG32_SIZE + 1);
const LONG32 iFrame		= (offFrame/LONG32_SIZE + 1);
const LONG32 iSIOR		= (offSIOR/LONG32_SIZE + 1);
const LONG32 iUpdateSiteProc	= (offUpdateSiteProc/LONG32_SIZE + 1);
const LONG32 iTemp1		= (offTemp1/LONG32_SIZE + 1);
const LONG32 iTemp2		= (offTemp2/LONG32_SIZE + 1);
const LONG32 iTemp3		= (offTemp3/LONG32_SIZE + 1);
const LONG32 iTemp4		= (offTemp4/LONG32_SIZE + 1);
const LONG32 iTemp5		= (offTemp5/LONG32_SIZE + 1);
const LONG32 iTemp6		= (offTemp6/LONG32_SIZE + 1);
const LONG32 iTemp7		= (offTemp7/LONG32_SIZE + 1);
const LONG32 iTemp8		= (offTemp8/LONG32_SIZE + 1);
const LONG32 iTemp9		= (offTemp9/LONG32_SIZE + 1);
const LONG32 iTemp10		= (offTemp10/LONG32_SIZE + 1);
struct tag_SymTableEntry SymbolTable[SymbolTableSize];				 /* The Symbol Table 		     */
     
#define ENTER(idx, pri, off, r)		SymbolTable[(idx)].nPriority = (pri); \
  					SymbolTable[(idx)].nHeapOffset = (off); \
  				        SymbolTable[(idx)].regLoc = (r);
#ifdef DEBUG
char SYMBOLS[SymbolTableSize][64];
#define SYM(idx, sym)			strcpy(SYMBOLS[idx], sym)
#endif
void InitSymbolTable()
  short i;
     
  ENTER( iHighBitMask, TEMP, offHighBitMask, 0);
  ENTER( iXHighBitMask, TEMP, offXHighBitMask, 0);
  ENTER( iXByteLength, TEMP,	offXByteLength,	0);
     
  ENTER( iXCtr, LOOP_CTR, offXCtr, 0);
  ENTER( iSiteCtr, LOOP_CTR,	offSiteCtr, 0);
  for (i = 0; i < CHIPS_PER_MOD; i++) {
    ENTER( iOffsets + i, TEMP, offOffsets + (4*i), 0);
  for (i = 0; i < CHIPS_PER_MOD; i++) {
    ENTER( iBitOffsets + i, TEMP, offBitOffsets + (4*i), 0);
  ENTER( iDcmr, TEMP, offDcmr, 0);
  ENTER( iScanIndexReg, TEMP, offScanIndexReg, 0);
     
  ENTER( iLutAddr, GLOBAL, offLutAddr, 0);
  for (i = 0; i < CHIPS_PER_MOD; i++) {
    ENTER( iBitPlaneAddr + i, TEMP, offBitPlaneAddr + (4*i), 0);
  for (i = 0; i < CHIPS_PER_MOD; i++) {
    ENTER( iNextWordAddr + i, TEMP, offNextWordAddr + (4*i), 0);
  for (i = 0; i < CHIPS_PER_MOD; i++) {
    ENTER( iPlaneWord + i, GLOBAL, offPlaneWord + (4*i), 0);
  for (i = 0; i < CHIPS_PER_MOD; i++) {
    ENTER( iEventCount + i, TEMP, offEventCount + (4*i), 0);
  } 
  ENTER( iGlueData, TEMP, offGlueData, 0);
  ENTER( iUnGlueData, TEMP, offUnGlueData, 0);
  ENTER( iSiteDataSrc, TEMP, offSiteDataSrc, 0);
  ENTER( iTbusData, TEMP, offTbusData, 0);
  ENTER( iLutData, TEMP, offTbusData, 0);
  ENTER( iTbusAddr, TEMP, offTbusAddr, 0);
  ENTER( iFrame, TEMP, offFrame, 0);
  ENTER( iSIOR, TEMP, offSIOR, 0);
  ENTER( iUpdateSiteProc, TEMP, offUpdateSiteProc, 0);
  for (i = 0; i < LAST_TEMP; i++) {
    ENTER( (iTemp1 + i), VOLATILE, (offTemp1 + (i * LONG32_SIZE)), 0);
#ifdef DEBUG
  SYM( iHighBitMask, "iHighBitMask" );
  SYM( iXHighBitMask, "iXHighBitMask" );
  SYM( iXByteLength, "iXByteLength" );
     
  SYM( iXCtr, "iXCtr" );
  SYM( iSiteCtr, "iSiteCtr" );
  for (i = 0; i < CHIPS_PER_MOD; i++) {
    char name[64];
    sprintf(name, "iOffsets[%d]", i);
    SYM( iOffsets + i, name );
  for (i = 0; i < CHIPS_PER_MOD; i++) {
    char name[64];
    sprintf(name, "iBitOffsets[%d]", i);
    SYM( iBitOffsets + i, name );
  SYM( iDcmr, "iDcmr" );
  SYM( iScanIndexReg, "iScanIndexReg" );
     
  SYM( iLutAddr, "iLutAddr" );
  for (i = 0; i < CHIPS_PER_MOD; i++) {
    char name[64];
    sprintf(name, "iBitPlaneAddr[%d]", i);
    SYM( iBitPlaneAddr + i, name );
  for (i = 0; i < CHIPS_PER_MOD; i++) {
    char name[64];
    sprintf(name, "iNextWordAddr[%d]", i);
    SYM( iNextWordAddr + i, name );
  for (i = 0; i < CHIPS_PER_MOD; i++) {
    char name[64];
    sprintf(name, "iPlaneWord[%d]", i);
    SYM( iPlaneWord + i, name );
  for (i = 0; i < CHIPS_PER_MOD; i++) {
    char name[64];
    sprintf(name, "iEventCount[%d]", i);
    SYM( iEventCount + i, name );
  } 
  SYM( iGlueData, "iGlueData" );
  SYM( iUnGlueData, "iUnGlueData" );
  SYM( iSiteDataSrc, "iSiteDataSrc" );
  SYM( iTbusData, "iTbusData" );
  SYM( iLutData, "iLutData" );
  SYM( iTbusAddr, "iTbusAddr" );
  SYM( iFrame, "iFrame" );
  SYM( iSIOR, "iSIOR" );
  SYM( iUpdateSiteProc, "iUpdateSiteProc" );
  for (i = 0; i < LAST_TEMP; i++) {
    char name[64];
    sprintf(name, "iTemp%d", i+1);
    SYM( iTemp1 + i, name );
#endif
#endif INTERPRETER

---------------------------------------------------------------------------

Eventually all of the CAM8 Simulator code will be rolled into the
CAMlib library.  Since we are transitioning to a C++ implementation
this code will have to be ported as well.  I will do this in stages
much the same way I am doing the CAMlib library.
1) Modify standalone cam8sim code and separate the host interface code
into "general" and "front end" parts.  This will capture the
specifics of the PipeComm interface to STEP in one file.  New
interface methods can be easily added by coding a new "front end"
file.
	1a) Package global variables into structres to prevent
	namespace pollution.  Add the code to the stage one CAMlib
	library.  Recode the cam8sim application to use the new
	structures. Recompile old CAMlib based applications and
	cam8sim to make sure nothing is broken.
2) Recompile the stage one CAMlib and cam8sim sources with a C++
compiler as a consistency check.  Recode the cam8sim code as C++
classes.
	2a) Convert the various structures and global/static variables
	into classes.  Make the routines methods.  We'll end up with
	one class (CAM8Simulator) for the CAM8 simulator abstraction.
	Include the memory management and error code.  The
	CAM8Simulator class will use a number of other classes.
	2b) Move the general interface code into a class
	(CAM8Sim_HostInterface).  Include the driver for steplist
	execution.  Recode all the "front end" stuff as	subclasses
	(CAM8Sim_PipeCommHostInterface).
	2c) Make an abstract class for the Just In Time compiler
	(CAM8Sim_JIT).  Eventually I will want to convert all the
	embedded Sparc assembly language macros to an abstract
	intermediate assembly format.  Subclasses of CAM8Sim_JIT will
	reimplement these methods and generate correct object code.
	This will make the simulator code platform independant and
	allow the same code to work for a new processor.  Recode the
	Sparc assembler macros as a subclass (CAM8Sim_SparcJIT) of
	CAM8Sim_JIT.  Include the register management code.

---------------------------------------------------------------------------

#ifndef _STEP_PIPE_INTERFACE_H_
#define _STEP_PIPE_INTERFACE_H_
#define NOERR		0
#define FATAL		-1
#define BADSHMID	-2
#define TABLEFULL	-3
#endif
#include <stdio.h>
#include <setjmp.h>
#include <sys/types.h>
#include <sys/ipc.h>
#include <sys/shm.h>
#include <sys/mman.h>
#include <CAM/CAM.h>
#include <CAM/CAM_pipecomm.h>
#include "STEP_pipe_interface.h"
#include "errmgr.h"
#include "hinterface.h"
typedef struct {
  char *ker, *ifc;
  int len;
} MapEntry;
static MapEntry MapTable[8192];
static int MapCnt = 0;
static int retv[2];								/* Return value			     */
static char *madr = NULL;
static int mlen = 0;
static int qflag = 0;
static int retv[2];
unsigned char *MAPADDR(char *, unsigned char *, unsigned char *);
unsigned char *MAPLEN(char *, unsigned char *, unsigned char *);
unsigned char *MAPBUF(char *, unsigned char *, unsigned char *);
unsigned char *SIMCIOMAP(char *, unsigned char *, unsigned char *);
unsigned char *READR0(char *, unsigned char *, unsigned char *);
unsigned char *READR1(char *, unsigned char *, unsigned char *);
unsigned char *READR2(char *, unsigned char *, unsigned char *);
unsigned char *READR3(char *, unsigned char *, unsigned char *);
unsigned char *WRITER0(char *, unsigned char *, unsigned char *);
unsigned char *WRITER1(char *, unsigned char *, unsigned char *);
unsigned char *WRITER2(char *, unsigned char *, unsigned char *);
unsigned char *WRITER3(char *, unsigned char *, unsigned char *);
unsigned char *QUIT(char *, unsigned char *, unsigned char *);
static Cmdt simcmds[] = {
  { "madr", MAPADDR },
  { "mlen", MAPLEN },
  { "mbuf", MAPBUF },
  { "ciom", SIMCIOMAP },
  { "rdR0", READR0 },
  { "rdR1", READR1 },
  { "rdR2", READR2 },
  { "rdR3", READR3 },
  { "wrR0", WRITER0 },
  { "wrR1", WRITER1 },
  { "wrR2", WRITER2 },
  { "wrR3", WRITER3 },
  { "quit", QUIT }
int sim_infd = 0;								/* File desc to read commands from   */
int sim_outfd = 1;								/* File desc to write replies to     */
int sim_camfd = -1;								/* File desc to do mmaps on	     */
extern INTERFACE_REGS cam8sim_iregs;						/* CAM8 Interface registers	     */
extern jmp_buf cam8sim_exception;						/* Execution frame for exceptions    */
void InitInterface(void)
  ResetInterface();
  CAM_SetPipeCmdTable(simcmds);
  CAM_SetPipeMode(CAM_PIPEALL|CAM_PIPESILENT|CAM_PIPEFDPLX);
int ReadInterfaceRegs(void)
  int rv;
  if ((rv = CAM_ParsePipeMesg(sim_infd, sim_outfd, NULL)) < CAM_PIPEALL) {	/* There has been a fatal error	     */
    retv[0] = FATAL;
    CAM_SendPipeMesg(sim_outfd, (char *) retv);
    fprintf(stderr, "CAM8SIM: Fatal error, exiting\n");
    return(-1);
  return(qflag);
/* PipeComm routines */
unsigned char *MAPADDR(char *appdata, unsigned char *o, unsigned char *d)
  retv[0] = NOERR;
  retv[1] = NOERR;
  madr = *((char **) d);
  return((unsigned char *) retv);
unsigned char *MAPLEN(char *appdata, unsigned char *o, unsigned char *d)
  retv[0] = NOERR;
  retv[1] = NOERR;
  mlen = *((int *) d);
  return((unsigned char *) retv);
unsigned char *MAPBUF(char *appdata, unsigned char *o, unsigned char *d)
  retv[0] = -3;
  retv[1] = NOERR;
  if (madr && mlen) {
    if ((retv[1] = (int) mmap(NULL, mlen, PROT_READ|PROT_WRITE, MAP_SHARED,
			 sim_camfd, (off_t) madr)) == -1)
      retv[0] = -2;
    else {
      MapTable[MapCnt].ker = madr;
      MapTable[MapCnt].len = mlen;
      MapTable[MapCnt++].ifc = (char *) retv[1];
      retv[0] = NOERR;
    }
  return((unsigned char *) retv);
unsigned char *SIMCIOMAP(char *appdata, unsigned char *o, unsigned char *d)
  int i;
  int off;
  char *ifc = *((char **) d);
  retv[0] = -5;
  for (i = 0; i < MapCnt; i++)
    if ((MapTable[i].ifc <= ifc) &&
	((MapTable[i].ifc + MapTable[i].len) > ifc)) {
      off = ifc - MapTable[i].ifc;
      retv[0] = NOERR;
      retv[1] = (int) MapTable[i].ker + off;
      break;
    }
  return((unsigned char *) retv);
unsigned char *READR0(char *appdata, unsigned char *o, unsigned char *d)
  retv[0] = NOERR;
  retv[1] = cam8sim_iregs.NLP;
  return((unsigned char *) retv);
unsigned char *READR1(char *appdata, unsigned char *o, unsigned char *d)
  retv[0] = NOERR;
  retv[1] = cam8sim_iregs.ISR;
  /* Turn off interrupt flags and unused bits, leave enables the same */
  cam8sim_iregs.ISR &= 0x00001F00;
  return((unsigned char *) retv);
unsigned char *READR2(char *appdata, unsigned char *o, unsigned char *d)
  retv[0] = NOERR;
  retv[1] = cam8sim_iregs.CIP;
  return((unsigned char *) retv);
unsigned char *READR3(char *appdata, unsigned char *o, unsigned char *d)
  retv[0] = NOERR;
  retv[1] = cam8sim_iregs.PIP;
  return((unsigned char *) retv);
unsigned char *WRITER0(char *appdata, unsigned char *o, unsigned char *d)
  LONG32 tmp = cam8sim_iregs.NLP & 0xF;
  if (setjmp(cam8sim_exception) == 0) {
    
    if (!(cam8sim_iregs.NLP & CAM_EXCEPTION_STATUS)) {
      cam8sim_iregs.NLP = tmp | (*((int *) d) & 0xFFFFFFF0);
      
      /* Step list has been scheduled... Execute it */
      SimStepList((LONG32 *) (cam8sim_iregs.NLP & 0xFFFFFFF0));
    }
  retv[0] = NOERR;
  return((unsigned char *) retv);
unsigned char *WRITER1(char *appdata, unsigned char *o, unsigned char *d)
  cam8sim_iregs.RER = *((int *) d);
  if (cam8sim_iregs.RER & CAM_RESET_INTERFACE) {
    ResetInterface();
  if (cam8sim_iregs.RER & CAM_HALT_INTERFACE)
    cam8sim_iregs.NLP |= CAM_INTERFACE_HALTED;
  if (cam8sim_iregs.RER & CAM_ENABLE_TIMEOUT_EXC)
    cam8sim_iregs.NLP &= ~(CAM_EXCEPTION_STATUS);
  /*  This is supposed to also resume after error ack, whatever that is
  if (cam8sim_iregs.RER & CAM_ENABLE_CAMINT_EXC)
  */
  if (cam8sim_iregs.RER & CAM_ENABLE_NEWLIST_INT)
    cam8sim_iregs.ISR |= CAM_ENABLE_NEWLIST_INT;
  if (cam8sim_iregs.RER & CAM_ENABLE_TIMEOUT_INT)
    cam8sim_iregs.ISR |= CAM_ENABLE_TIMEOUT_INT;
  if (cam8sim_iregs.RER & CAM_ENABLE_SBUS_INT)
    cam8sim_iregs.ISR |= CAM_ENABLE_SBUS_INT;
  if (cam8sim_iregs.RER & CAM_ENABLE_CAM_INT)
    cam8sim_iregs.ISR |= CAM_ENABLE_CAM_INT;
  if (cam8sim_iregs.RER & CAM_ENABLE_SOFT_INT)
    cam8sim_iregs.ISR |= CAM_ENABLE_SOFT_INT;
  if (cam8sim_iregs.RER & CAM_DISABLE_NEWLIST_INT)
    cam8sim_iregs.ISR &= ~(CAM_ENABLE_NEWLIST_INT);
  if (cam8sim_iregs.RER & CAM_DISABLE_TIMEOUT_INT)
    cam8sim_iregs.ISR &= ~(CAM_ENABLE_TIMEOUT_INT);
  if (cam8sim_iregs.RER & CAM_DISABLE_SBUS_INT)
    cam8sim_iregs.ISR &= ~(CAM_ENABLE_SBUS_INT);
  if (cam8sim_iregs.RER & CAM_DISABLE_CAM_INT)
    cam8sim_iregs.ISR &= ~(CAM_ENABLE_CAM_INT);
  if (cam8sim_iregs.RER & CAM_ENABLE_SOFT_INT)
    cam8sim_iregs.ISR |= CAM_ENABLE_SOFT_INT;
  retv[0] = NOERR;
  return((unsigned char *) retv);
unsigned char *WRITER2(char *appdata, unsigned char *o, unsigned char *d)
  cam8sim_iregs.DSL = *((int *) d);
  retv[0] = NOERR;
  return((unsigned char *) retv);
unsigned char *WRITER3(char *appdata, unsigned char *o, unsigned char *d)
  cam8sim_iregs.DBL = *((int *) d);
  retv[0] = NOERR;
  return((unsigned char *) retv);
unsigned char *QUIT(char *appdata, unsigned char *o, unsigned char *d)
  retv[0] = NOERR;
  qflag = -1;
  return((unsigned char *) retv);
#include <CAM/CAM.h>
#include <CAM/CAM_pipecomm.h>
#include "hinterface.h"
typedef struct {
  char *ker, *ifc;
  int len;
} MapEntry;
static MapEntry MapTable[8192];
static int MapCnt = 0;
static int retv[2];								/* Return value			     */
static char *madr = NULL;
static int mlen = 0;
static int qflag = 0;
static int retv[2];
unsigned char *MAPADDR(char *, unsigned char *, unsigned char *);
unsigned char *MAPLEN(char *, unsigned char *, unsigned char *);
unsigned char *MAPBUF(char *, unsigned char *, unsigned char *);
unsigned char *SIMCIOMAP(char *, unsigned char *, unsigned char *);
unsigned char *READR0(char *, unsigned char *, unsigned char *);
unsigned char *READR1(char *, unsigned char *, unsigned char *);
unsigned char *READR2(char *, unsigned char *, unsigned char *);
unsigned char *READR3(char *, unsigned char *, unsigned char *);
unsigned char *WRITER0(char *, unsigned char *, unsigned char *);
unsigned char *WRITER1(char *, unsigned char *, unsigned char *);
unsigned char *WRITER2(char *, unsigned char *, unsigned char *);
unsigned char *WRITER3(char *, unsigned char *, unsigned char *);
unsigned char *QUIT(char *, unsigned char *, unsigned char *);
static Cmdt simcmds[] = {
  { "madr", MAPADDR },
  { "mlen", MAPLEN },
  { "mbuf", MAPBUF },
  { "ciom", SIMCIOMAP },
  { "rdR0", READR0 },
  { "rdR1", READR1 },
  { "rdR2", READR2 },
  { "rdR3", READR3 },
  { "wrR0", WRITER0 },
  { "wrR1", WRITER1 },
  { "wrR2", WRITER2 },
  { "wrR3", WRITER3 },
  { "quit", QUIT }
static jmp_buf exception;							/* Execution frame for exceptions    */
int sim_infd = 0;								/* File desc to read commands from   */
int sim_outfd = 1;								/* File desc to write replies to     */
int sim_camfd = -1;								/* File desc to do mmaps on	     */
extern INTERFACE_REGS iregs;							/* CAM8 Interface registers	     */
void InitInterface(void)
  ResetInterface();
  CAM_SetPipeCmdTable(simcmds);
  CAM_SetPipeMode(CAM_PIPEALL|CAM_PIPESILENT|CAM_PIPEFDPLX);
int ReadInterfaceRegs(void)
  int rv;
  if ((rv = CAM_ParsePipeMesg(sim_infd, sim_outfd, NULL)) < CAM_PIPEALL) {	/* There has been a fatal error	     */
    retv[0] = FATAL;
    CAM_SendPipeMesg(sim_outfd, (char *) retv);
    fprintf(stderr, "CAM8SIM: Fatal error, exiting\n");
    return(-1);
  return(qflag);
/* PipeComm routines */
unsigned char *MAPADDR(char *appdata, unsigned char *o, unsigned char *d)
  retv[0] = NOERR;
  retv[1] = NOERR;
  madr = *((char **) d);
  return((unsigned char *) retv);
unsigned char *MAPLEN(char *appdata, unsigned char *o, unsigned char *d)
  retv[0] = NOERR;
  retv[1] = NOERR;
  mlen = *((int *) d);
  return((unsigned char *) retv);
unsigned char *MAPBUF(char *appdata, unsigned char *o, unsigned char *d)
  retv[0] = -3;
  retv[1] = NOERR;
  if (madr && mlen) {
    if ((retv[1] = (int) mmap(NULL, mlen, PROT_READ|PROT_WRITE, MAP_SHARED,
			 sim_camfd, madr)) == -1)
      retv[0] = -2;
    else {
      MapTable[MapCnt].ker = madr;
      MapTable[MapCnt].len = mlen;
      MapTable[MapCnt++].ifc = (char *) retv[1];
      retv[0] = NOERR;
    }
  return((unsigned char *) retv);
unsigned char *SIMCIOMAP(char *appdata, unsigned char *o, unsigned char *d)
  int i;
  int off;
  char *ifc = *((char **) d);
  retv[0] = -5;
  for (i = 0; i < MapCnt; i++)
    if ((MapTable[i].ifc <= ifc) &&
	((MapTable[i].ifc + MapTable[i].len) > ifc)) {
      off = ifc - MapTable[i].ifc;
      retv[0] = NOERR;
      retv[1] = (int) MapTable[i].ker + off;
      break;
    }
  return((unsigned char *) retv);
unsigned char *READR0(char *appdata, unsigned char *o, unsigned char *d)
  retv[0] = NOERR;
  retv[1] = iregs.NLP;
  return((unsigned char *) retv);
unsigned char *READR1(char *appdata, unsigned char *o, unsigned char *d)
  retv[0] = NOERR;
  retv[1] = iregs.ISR;
  /* Turn off interrupt flags and unused bits, leave enables the same */
  iregs.ISR &= 0x00001F00;
  return((unsigned char *) retv);
unsigned char *READR2(char *appdata, unsigned char *o, unsigned char *d)
  retv[0] = NOERR;
  retv[1] = iregs.CIP;
  return((unsigned char *) retv);
unsigned char *READR3(char *appdata, unsigned char *o, unsigned char *d)
  retv[0] = NOERR;
  retv[1] = iregs.PIP;
  return((unsigned char *) retv);
unsigned char *WRITER0(char *appdata, unsigned char *o, unsigned char *d)
  LONG32 tmp = iregs.NLP & 0xF;
  if (setjmp(exception) == 0) {
    
    if (!(iregs.NLP & CAM_EXCEPTION_STATUS)) {
      iregs.NLP = tmp | (*((int *) d) & 0xFFFFFFF0);
      
      /* Step list has been scheduled... Execute it */
      SimStepList((LONG32 *) (iregs.NLP & 0xFFFFFFF0));
    }
  retv[0] = NOERR;
  return((unsigned char *) retv);
unsigned char *WRITER1(char *appdata, unsigned char *o, unsigned char *d)
  iregs.RER = *((int *) d);
  if (iregs.RER & CAM_RESET_INTERFACE) {
    ResetInterface();
  if (iregs.RER & CAM_HALT_INTERFACE)
    iregs.NLP |= CAM_INTERFACE_HALTED;
  if (iregs.RER & CAM_ENABLE_TIMEOUT_EXC)
    iregs.NLP &= ~(CAM_EXCEPTION_STATUS);
  /*  This is supposed to also resume after error ack, whatever that is
  if (iregs.RER & CAM_ENABLE_CAMINT_EXC)
  */
  if (iregs.RER & CAM_ENABLE_NEWLIST_INT)
    iregs.ISR |= CAM_ENABLE_NEWLIST_INT;
  if (iregs.RER & CAM_ENABLE_TIMEOUT_INT)
    iregs.ISR |= CAM_ENABLE_TIMEOUT_INT;
  if (iregs.RER & CAM_ENABLE_SBUS_INT)
    iregs.ISR |= CAM_ENABLE_SBUS_INT;
  if (iregs.RER & CAM_ENABLE_CAM_INT)
    iregs.ISR |= CAM_ENABLE_CAM_INT;
  if (iregs.RER & CAM_ENABLE_SOFT_INT)
    iregs.ISR |= CAM_ENABLE_SOFT_INT;
  if (iregs.RER & CAM_DISABLE_NEWLIST_INT)
    iregs.ISR &= ~(CAM_ENABLE_NEWLIST_INT);
  if (iregs.RER & CAM_DISABLE_TIMEOUT_INT)
    iregs.ISR &= ~(CAM_ENABLE_TIMEOUT_INT);
  if (iregs.RER & CAM_DISABLE_SBUS_INT)
    iregs.ISR &= ~(CAM_ENABLE_SBUS_INT);
  if (iregs.RER & CAM_DISABLE_CAM_INT)
    iregs.ISR &= ~(CAM_ENABLE_CAM_INT);
  if (iregs.RER & CAM_ENABLE_SOFT_INT)
    iregs.ISR |= CAM_ENABLE_SOFT_INT;
  retv[0] = NOERR;
  return((unsigned char *) retv);
unsigned char *WRITER2(char *appdata, unsigned char *o, unsigned char *d)
  iregs.DSL = *((int *) d);
  retv[0] = NOERR;
  return((unsigned char *) retv);
unsigned char *WRITER3(char *appdata, unsigned char *o, unsigned char *d)
  iregs.DBL = *((int *) d);
  retv[0] = NOERR;
  return((unsigned char *) retv);
unsigned char *QUIT(char *appdata, unsigned char *o, unsigned char *d)
  retv[0] = NOERR;
  qflag = -1;
  return((unsigned char *) retv);
Eventually all of the CAM8 Simulator code will be rolled into the
CAMlib library.  Since we are transitioning to a C++ implementation
this code will have to be ported as well.  We will do this in stages
much the same way we are doing the CAMlib library.
/*****************************************************************************/
/*                                                                           */
/* global.h:	modifications to original code made by Harris L. Gilliam     */
/*		March 1994 - June 1995					     */
/*                                                                           */
/*****************************************************************************/
/*                                                                           */
/* Author  : Milan Shah                                                      */
/* Program : Cam8Sim                                                         */
/* Date    : 2/2/92                                                          */
/* Module  : Global.h : Defines the global state of the CAM-8 simulator      */
/*                                                                           */
/*****************************************************************************/
#ifndef _GLOBAL_
#define _GLOBAL_
#define SHARED_MEMORY_INTERFACE
#define CHIPS_PER_MOD           16
#define SCAN_INDEX_LENGTH       24
#define PERM_CONST_1            31                                               
#define PERM_CONST_0            30
#undef TRUE
#undef FLASE
#define TRUE                    1
#define FALSE                   0
#ifndef NULL
#define NULL                    0
#endif
#define LONG32_SIZE     (sizeof(LONG32))
#define INT16_SIZE      (sizeof(INT16))
typedef unsigned char   BYTE;
typedef unsigned char   BOOL;
typedef unsigned long   LONG32;
typedef unsigned short  INT16;
#ifndef INTERPRETER
typedef unsigned long   CODE;
typedef CODE            *CODEPTR;
typedef CODEPTR         *CODEHANDLE;
#endif INTERPRETER
#include "decode_steplist.h"
/*****************************************************************************/
/*                                                                           */
/* Definition of struct tag_CAM8State, the CAM module state structure.       */
/*                                                                           */
/*****************************************************************************/
typedef struct cam8state {
  /* CAM8 Registers */
  BYTE MSR[CHIPS_PER_MOD];
  BYTE SSM[CHIPS_PER_MOD];
  BYTE RT[CHIPS_PER_MOD];
  BYTE ECT[CHIPS_PER_MOD];
  BYTE RPK[CHIPS_PER_MOD];
  BYTE ALT[CHIPS_PER_MOD];
  LONG32 KA[CHIPS_PER_MOD];
  BYTE XKS[CHIPS_PER_MOD];
  BYTE YKS[CHIPS_PER_MOD];
  BYTE ZKS[CHIPS_PER_MOD];
  BYTE XKMF[CHIPS_PER_MOD];
  BYTE YKMF[CHIPS_PER_MOD];
  BYTE ZKMF[CHIPS_PER_MOD];
  BYTE SABSR[CHIPS_PER_MOD];
  BYTE LAS[CHIPS_PER_MOD];
  BYTE LAM[CHIPS_PER_MOD];
  BYTE FOS[CHIPS_PER_MOD];
  BYTE FOM[CHIPS_PER_MOD];
  BYTE SDS[CHIPS_PER_MOD];
  BYTE SDM[CHIPS_PER_MOD];
  BYTE ECS[CHIPS_PER_MOD];
  BYTE ECM[CHIPS_PER_MOD];
  BYTE DDS[CHIPS_PER_MOD];
  BYTE DDM[CHIPS_PER_MOD];
  BYTE SSR[CHIPS_PER_MOD];
  LONG32 ECR[CHIPS_PER_MOD];
  INT16 LIR[CHIPS_PER_MOD];
  BYTE LIPR[CHIPS_PER_MOD];
  INT16 *LIOR;
  LONG32 SIR[CHIPS_PER_MOD];
  BYTE SSA[24][CHIPS_PER_MOD];
  BYTE *SIOR;
  BYTE SM[CHIPS_PER_MOD];
  BYTE ESC[CHIPS_PER_MOD];
  BYTE ESW[CHIPS_PER_MOD];
  BYTE EST[CHIPS_PER_MOD];
  BYTE SBRC[CHIPS_PER_MOD];
  BYTE RCL[CHIPS_PER_MOD];
  BYTE ECL[CHIPS_PER_MOD];
  BYTE STM[CHIPS_PER_MOD];
  LONG32 OSR[CHIPS_PER_MOD];
  LONG32 DCM[CHIPS_PER_MOD];
  BYTE XDCP[CHIPS_PER_MOD];
  BYTE YDCP[CHIPS_PER_MOD];
  BYTE ZDCP[CHIPS_PER_MOD];
  BYTE LPL[CHIPS_PER_MOD];
  BYTE FPL[CHIPS_PER_MOD];
  BYTE DCS[CHIPS_PER_MOD];
  BYTE TBD[CHIPS_PER_MOD];
  BYTE TMS[CHIPS_PER_MOD];
  BYTE NBF[CHIPS_PER_MOD];
  BYTE SRE[CHIPS_PER_MOD];
  BYTE ALS[CHIPS_PER_MOD];
  BYTE MAFS[CHIPS_PER_MOD];
  BYTE MBFS[CHIPS_PER_MOD];
  BYTE XMPC[CHIPS_PER_MOD];
  BYTE XPPC[CHIPS_PER_MOD];
  BYTE YMPC[CHIPS_PER_MOD];
  BYTE YPPC[CHIPS_PER_MOD];
  BYTE ZMPC[CHIPS_PER_MOD];
  BYTE ZPPC[CHIPS_PER_MOD];
  BYTE MIDR[CHIPS_PER_MOD];
  BYTE GIDR[CHIPS_PER_MOD];
  BYTE BPIE[CHIPS_PER_MOD];
  BYTE BCIE[CHIPS_PER_MOD];
  BYTE GCIE[CHIPS_PER_MOD];
  BYTE MAIE[CHIPS_PER_MOD];
  BYTE MBIE[CHIPS_PER_MOD];
  BYTE SSIE[CHIPS_PER_MOD];
  BYTE XHIE[CHIPS_PER_MOD];
  BYTE RLIE[CHIPS_PER_MOD];
  BYTE URIE[CHIPS_PER_MOD];
  BYTE ISIE[CHIPS_PER_MOD];
  BYTE BPIF[CHIPS_PER_MOD];
  BYTE BCIF[CHIPS_PER_MOD];
  BYTE GCIF[CHIPS_PER_MOD];
  BYTE MAIF[CHIPS_PER_MOD];
  BYTE MBIF[CHIPS_PER_MOD];
  BYTE SSIF[CHIPS_PER_MOD];
  BYTE XHIF[CHIPS_PER_MOD];
  BYTE RLIF[CHIPS_PER_MOD];
  BYTE URIF[CHIPS_PER_MOD];
  BYTE ISIF[CHIPS_PER_MOD];
  BYTE VWE[CHIPS_PER_MOD];
  BYTE VWIE[CHIPS_PER_MOD];
  BYTE VWIF[CHIPS_PER_MOD];
  BYTE LDOC[CHIPS_PER_MOD];
  BYTE HDOC[CHIPS_PER_MOD];
  /* Not actual CAM8 Register but needed state info */
  BYTE WhyScan;
  BOOL bByteMode;
  BOOL bImmediate;
  BOOL bReadMode;
} CAM8STATE;
#define ConstantSetAll(r, v) \
{register int i;for(i=0;i<CHIPS_PER_MOD;i++) r[i]=v;}
#define SetAll(r, v) \
{register int i;for(i=0;i<CHIPS_PER_MOD;i++) r[i]=v[i];}
/*****************************************************************************/
/*                                                                           */
/* Global State Variables.                                                   */
/*                                                                           */
/*****************************************************************************/
#define MSR	CAM8State.MSR
#define SSM	CAM8State.SSM
#define RT	CAM8State.RT
#define ECT	CAM8State.ECT
#define RPK	CAM8State.RPK
#define ALT	CAM8State.ALT
#define KA	CAM8State.KA
#define XKS	CAM8State.XKS
#define YKS	CAM8State.YKS
#define ZKS	CAM8State.ZKS
#define XKMF	CAM8State.XKMF
#define YKMF	CAM8State.YKMF
#define ZKMF	CAM8State.ZKMF
#define SABSR	CAM8State.SABSR
#define LAS	CAM8State.LAS
#define LAM	CAM8State.LAM
#define FOS	CAM8State.FOS
#define FOM	CAM8State.FOM
#define SDS	CAM8State.SDS
#define SDM	CAM8State.SDM
#define ECS	CAM8State.ECS
#define ECM	CAM8State.ECM
#define DDS	CAM8State.DDS
#define DDM	CAM8State.DDM
#define SSR	CAM8State.SSR
#define ECR	CAM8State.ECR
#define LIR	CAM8State.LIR
#define LIPR	CAM8State.LIPR
#define LIOR	CAM8State.LIOR
#define SIR	CAM8State.SIR
#define SIPR	CAM8State.SSA
#define SSA0	CAM8State.SSA[0]
#define SSA1	CAM8State.SSA[1]
#define SSA2	CAM8State.SSA[2]
#define SSA3	CAM8State.SSA[3]
#define SSA4	CAM8State.SSA[4]
#define SSA5	CAM8State.SSA[5]
#define SSA6	CAM8State.SSA[6]
#define SSA7	CAM8State.SSA[7]
#define SSA8	CAM8State.SSA[8]
#define SSA9	CAM8State.SSA[9]
#define SSA10	CAM8State.SSA[10]
#define SSA11	CAM8State.SSA[11]
#define SSA12	CAM8State.SSA[12]
#define SSA13	CAM8State.SSA[13]
#define SSA14	CAM8State.SSA[14]
#define SSA15	CAM8State.SSA[15]
#define SSA16	CAM8State.SSA[16]
#define SSA17	CAM8State.SSA[17]
#define SSA18	CAM8State.SSA[18]
#define SSA19	CAM8State.SSA[19]
#define SSA20	CAM8State.SSA[20]
#define SSA21	CAM8State.SSA[21]
#define SSA22	CAM8State.SSA[22]
#define SSA23	CAM8State.SSA[23]
#define SIOR	CAM8State.SIOR
#define SM	CAM8State.SM
#define ESC	CAM8State.ESC
#define ESW	CAM8State.ESW
#define EST	CAM8State.EST
#define SBRC	CAM8State.SBRC
#define RCL	CAM8State.RCL
#define ECL	CAM8State.ECL
#define STM	CAM8State.STM
#define OSR	CAM8State.OSR
#define DCM	CAM8State.DCM
#define XDCP	CAM8State.XDCP
#define YDCP	CAM8State.YDCP
#define ZDCP	CAM8State.ZDCP
#define LPL	CAM8State.LPL
#define FPL	CAM8State.FPL
#define DCS	CAM8State.DCS
#define TBD	CAM8State.TBD
#define TMS	CAM8State.TMS
#define NBF	CAM8State.NBF
#define SRE	CAM8State.SRE
#define ALS	CAM8State.ALS
#define MAFS	CAM8State.MAFS
#define MBFS	CAM8State.MBFS
#define XMPC	CAM8State.XMPC
#define XPPC	CAM8State.XPPC
#define YMPC	CAM8State.YMPC
#define YPPC	CAM8State.YPPC
#define ZMPC	CAM8State.ZMPC
#define ZPPC	CAM8State.ZPPC
#define MIDR	CAM8State.MIDR
#define GIDR	CAM8State.GIDR
#define BPIE	CAM8State.BPIE
#define BCIE	CAM8State.BCIE
#define GCIE	CAM8State.GCIE
#define MAIE	CAM8State.MAIE
#define MBIE	CAM8State.MBIE
#define SSIE	CAM8State.SSIE
#define XHIE	CAM8State.XHIE
#define RLIE	CAM8State.RLIE
#define URIE	CAM8State.URIE
#define ISIE	CAM8State.ISIE
#define BPIF	CAM8State.BPIF
#define BCIF	CAM8State.BCIF
#define GCIF	CAM8State.GCIF
#define MAIF	CAM8State.MAIF
#define MBIF	CAM8State.MBIF
#define SSIF	CAM8State.SSIF
#define XHIF	CAM8State.XHIF
#define RLIF	CAM8State.RLIF
#define URIF	CAM8State.URIF
#define ISIF	CAM8State.ISIF
#define VWE	CAM8State.VWE
#define VWIE	CAM8State.VWIE
#define VWIF	CAM8State.VWIF
#define LDOC	CAM8State.LDOC
#define HDOC	CAM8State.HDOC
#define LUT0			LUTb[0]
#define LUT1			LUTb[1]
#ifdef INTERPRETER
#define HIGHB(x)		(((x) & 0x80000000) ? 0x1 : 0x0)
extern LONG32 bit;
extern LONG32 HIGH_BIT_MASK;
extern LONG32 X_HIGH_BIT_MASK;
extern LONG32 X_BYTE_LENGTH;
extern LONG32 X_CTR;
extern LONG32 SITE_CTR;
extern LONG32 OFFSETS[CHIPS_PER_MOD];
extern LONG32 BIT_OFFSETS[CHIPS_PER_MOD];
extern LONG32 DCMR;
extern LONG32 SCAN_INDEX_REG;
extern LONG32 LUT_ADDR;
extern LONG32 BIT_PLANE_ADDR[CHIPS_PER_MOD];
extern LONG32 NEXT_WORD_ADDR[CHIPS_PER_MOD];
extern LONG32 PLANE_WORD[CHIPS_PER_MOD];
extern LONG32 EVENT_COUNT[CHIPS_PER_MOD];
extern LONG32 UNGLUE_DATA;
extern LONG32 GLUE_DATA;
extern LONG32 SITE_DATA;
extern LONG32 TBUS_DATA;
extern LONG32 LUT_DATA;
extern LONG32 DISP_DATA;
extern LONG32 TBUS_ADDR;
extern LONG32 FRAME_ADDR;
extern LONG32 TEMP1;
extern LONG32 TEMP2;
extern LONG32 TEMP3;
extern LONG32 TEMP4;
extern LONG32 TEMP5;
extern LONG32 TEMP6;
extern LONG32 TEMP7;
extern LONG32 TEMP8;
extern LONG32 TEMP9;
extern LONG32 TEMP10;
#endif INTERPRETER
extern LONG32 SITE_ADDR;
extern CAM8STATE CAM8State;
extern unsigned short nNumPlanes;
extern int sim_camfd;
/* LUT buffers and FRAME buffer */
extern INT16 *LUTb[2];
#ifdef _FRAMEBUFFER_
extern BYTE *FRAMEb;
#endif _FRAMEBUFFER_
#ifdef DEBUG
  #include <stdio.h>
  extern FILE* DEBUGFILE;
  extern char *REGNAMES[];
  #define EP(name) fprintf(DEBUGFILE, "ENTER: %s\n", name)
  #define LP(name) fprintf(DEBUGFILE, "LEAVE: %s\n", name)
#ifndef INTERPRETER
  extern CODEPTR DASMADDR;
  #define ASCODE(c)  fprintf(DEBUGFILE, "\t0x%x: %s\n", DASMADDR, c); fflush(DEBUGFILE)
  #define ASNOTE(c)  fprintf(DEBUGFILE, "\t%s\n", c); fflush(DEBUGFILE)
#endif INTERPRETER
#else DEBUG
  #define EP(name)
  #define LP(name)
#ifndef INTERPRETER
  #define ASCODE(name)
  #define ASNOTE(c)
#endif INTERPRETER
#endif DEBUG
#endif
/*****************************************************************************/
/*                                                                           */
/* Author	: Milan Shah						     */
/* Program	: test_modules						     */
/* Date		: February 18, 1992					     */
/* Module	: t_printasm.c - print a block of memory as sparc asm.	     */
/*                                                                           */
/*****************************************************************************/
#include <stdio.h>
#include "global.h"
#include "heap.h"
#include "sparc_asm.h"
#include "t_printasm.h"
typedef unsigned long INSTR;
const char *szRegName[] = {
  "%g0", "%g1", "%g2", "%g3", "%g4", "%g5", "%g6", "%g7",
  "%o0", "%o1", "%o2", "%o3", "%o4", "%o5", "%sp", "%tp",
  "%l0", "%l1", "%l2", "%l3", "%l4", "%l5", "%l6", "%l7",
  "%i0", "%i1", "%i2", "%i3", "%i4", "%i5", "%ds", "%ra"
  };
const char *szCCName[] = {
  "NEVER", "EQ", "LE", "L", "LEU", "CS", "NEG", "VS",
  "ALWAYS", "NEQ", "G", "GE", "GU", "CC", "POS", "VC"
  };
void Fmt1Instr(INSTR instr, FILE *fOut)
  fprintf(fOut, "CALL \t%x\n", (instr & 0x3FFFFFFFL));
void Fmt2Instr(INSTR instr, FILE *fOut)
  unsigned short op2, cc, rd;
  signed long disp;
  op2 = (instr >> 22) & 0x7L;
  if (op2 == 4) {								 /* SETHI 			     */
    unsigned long hi22;
    hi22 = (instr << 10);
    rd = (instr >> 25) & 0x1FL;
    fprintf(fOut,"SETHI \t%s, \t%x (%x)\n", szRegName[rd],
	    (instr & 0x003FFFFFL), hi22);
  } else if (op2 == 2) {							 /* BRANCH 			     */
    cc = (instr >> 25) & 0xFL;
    if (instr & 0x00200000L) {
      disp = instr | 0xFFC00000L;
    } else {
      disp = instr & 0x1FFFFF;
    }
    fprintf(fOut,"BR%s \t%d\n", szCCName[cc], disp);
  } else {
    fprintf(fOut,"UNIMP BR : %x\n", instr);
void Fmt3Instr(INSTR instr, FILE *fOut)
  unsigned short majorOp, opcode, imm, rs1, rs2, rd;
  signed long lConst;
  majorOp = (instr >> 30) & 0x3L;
  opcode = (instr >> 19) & 0x3FL;
  rd = (instr >> 25) & 0x1FL;
  rs1 = (instr >> 14) & 0x1FL;
  rs2 = instr & 0x1FL;
  imm = (instr >> 13) & 0x1L;
  if (imm) {
    if (instr & 0x00001000L) {
      lConst = (instr | 0xFFFFF000L);
    } else {
      lConst = (instr & 0xFFFL);
    }
  if (majorOp == 3) {							 /* LOAD-STORE 			     */
    switch (opcode) {
    case OP_LDW:
      fprintf(fOut,"LDW ");
      break;
    case OP_LDHW:
      fprintf(fOut,"LDHW ");
      break;
    case OP_LDUB:
      fprintf(fOut,"LDUB ");
      break;
    case OP_STW:
      fprintf(fOut,"STW ");
      break;
    case OP_STUB:
      fprintf(fOut,"STUB ");
      break;
      
    default:
      fprintf(fOut,"UNIMP LOAD-STORE : %x\n", instr);
      return;
      break;
    };
  } else {									 /* ARITHMETIC 			     */
    switch (opcode) {
    case OP_ADD:
      fprintf(fOut,"ADD ");
      break;
    case OP_ADDcc:
      fprintf(fOut,"ADDcc ");
      break;
    case OP_ADDX:
      fprintf(fOut,"ADDX ");
      break;
    case OP_ADDXcc:
      fprintf(fOut,"ADDXcc ");
      break;
      
    case OP_SUB:
      fprintf(fOut,"SUB ");
      break;
    case OP_SUBcc:
      fprintf(fOut,"SUBcc ");
      break;
    case OP_SUBX:
      fprintf(fOut,"SUBX ");
      break;
    case OP_SUBXcc:
      fprintf(fOut,"SUBXcc ");
      break;
      
    case OP_AND:							 /* LOGICAL 			     */
      fprintf(fOut,"AND ");
      break;
    case OP_ANDcc:
      fprintf(fOut,"ANDcc ");
      break;
    case OP_ANDN:
      fprintf(fOut,"ANDN ");
      break;
    case OP_ANDNcc:
      fprintf(fOut,"ANDNcc ");
      break;
      
    case OP_OR:
      fprintf(fOut,"OR ");
      break;
    case OP_ORcc:
      fprintf(fOut,"ORcc ");
      break;
    case OP_ORN:
      fprintf(fOut,"ORN ");
      break;
    case OP_ORNcc:
      fprintf(fOut,"ORNcc ");
      break;
      
    case OP_XOR:
      fprintf(fOut,"XOR ");
      break;
    case OP_XORcc:
      fprintf(fOut,"XORcc ");
      break;
    case OP_XNOR:
      fprintf(fOut,"XNOR ");
      break;
    case OP_XNORcc:
      fprintf(fOut,"XNORcc ");
      break;
      
      
    case OP_SLL:
      fprintf(fOut,"SLL ");
      break;
    case OP_SRL:
      fprintf(fOut,"SRL ");
      break;
    case OP_SRA:
      fprintf(fOut,"SRA ");
      break;
      
    case OP_JMPL:							 /* CONTROL TRANSFER 		     */
      fprintf(fOut,"JMPL ");
      break;
    case OP_SAVE:
      fprintf(fOut,"SAVE ");
      break;
    case OP_RESTORE:
      fprintf(fOut,"RESTOR");
      break;
      
    default:
      fprintf(fOut,"UNIMP LOGICAL-ARITH : %x\n", instr);
      return;
      break;
    };
  if (imm) {
    fprintf(fOut,"\t%s \t%d \t%s\n", szRegName[rs1], lConst, szRegName[rd]);
  } else {
    fprintf(fOut,"\t%s \t%s \t%s\n", szRegName[rs1], szRegName[rs2],
	    szRegName[rd]);
void PrintAsm(CODEPTR pcodSource, FILE *fOut)
  CODEPTR pcod;
  unsigned short op;
  for (pcod = pcodSource; *pcod != 0; pcod++) {
    
    fprintf(fOut, "0x%x: ", pcod);
    
    op = (*pcod >> 30) & 0x3L;
    switch (op) {
    case 0:
      Fmt2Instr(*pcod, fOut);
      break;
      
    case 1:
      Fmt1Instr(*pcod, fOut);
      break;
      
    case 2:
    case 3:
      Fmt3Instr(*pcod, fOut);
      break;
    }

---------------------------------------------------------------------------

#ifndef _CAM8SIM_H_
#define _CAM8SIM_H_
#include <CamLib++.H>
#include <Cam8Core++.H>
#include <Cam8++.H>
#include <Cam8SimJIT++.H>
#include "std++.H"
/*****************************************************************************/
/********************************* DEFINES ***********************************/
/*****************************************************************************/
#define PERM_CONST_1            31                                               
#define PERM_CONST_0            30
#define LONG32_SIZE		(sizeof(LONG32))
#define INT16_SIZE		(sizeof(INT16))
#define ACTIVE_LUT_SELECT	0x8000	 /* bit in Hardware Env Reg (HER)    */
#define FLD_SELECT(i)		((i) + 32)
#define FLD_MAP(i)		((i) + 64)
#define NUM_DEST		4
#define NUM_SRC			6
#define SRC_SITE_DATA		0
#define SRC_TBUS		1
#define SRC_FLYWHEEL		2
#define SRC_LUT			3
#define SRC_SITE_ADDRESS	3
#define SRC_GLUED_DATA		4
#define SRC_CONST_DATA		5
#define DEST_SITE_DATA		0
#define DEST_EVENT_CT		1
#define DEST_LUT		2
#define DEST_DISPLAY		3
#define MAP_CONST_0		0
#define MAP_G_NOR_S		1
#define MAP_G_AND_S_BAR		2
#define MAP_S_BAR		3
#define MAP_G_BAR_AND_S		4
#define MAP_G_BAR		5
#define MAP_G_XOR_S		6
#define MAP_G_NAND_S		7
#define MAP_G_AND_S		8
#define MAP_G_EQ_S		9
#define MAP_G			10
#define MAP_G_OR_S_BAR		11
#define MAP_S			12
#define MAP_G_BAR_OR_S		13
#define MAP_G_OR_S		14
#define MAP_CONST_1		15
#ifndef INTERPRETER
#define SCANNER_CODE_SIZE       (1024 * LONG32_SIZE)
#define SWEEP_CODE_SIZE         (1024 * LONG32_SIZE)
#define UPDATE_CODE_SIZE        (1024 * LONG32_SIZE)
#else !INTERPRETER
#define HIGHB(x)		(((x) & 0x80000000) ? 0x1 : 0x0)
#endif !INTERPRETER
#ifdef DEBUG
#define EP(name) fprintf(DEBUGFILE, "ENTER: %s\n", name)
#define LP(name) fprintf(DEBUGFILE, "LEAVE: %s\n", name)
#ifndef INTERPRETER
#define ASCODE(c)  fprintf(DEBUGFILE, "\t0x%x: %s\n", DASMADDR, c); fflush(DEBUGFILE)
#define ASNOTE(c)  fprintf(DEBUGFILE, "\t%s\n", c); fflush(DEBUGFILE)
#endif !INTERPRETER
#else DEBUG
#define EP(name)
#define LP(name)
#ifndef INTERPRETER
#define ASCODE(name)
#define ASNOTE(c)
#endif !INTERPRETER
#endif DEBUG
#ifdef __cplusplus
/*****************************************************************************/
/******************************** TEMPLATES **********************************/
/*****************************************************************************/
/*****************************************************************************/
/*************************** CLASSES & TYPEDEFS ******************************/
/*****************************************************************************/
typedef struct {
  char *base;
  int type;
} Bt, *BT;
class Cam8Sim : public Cam8 {
public:
  int VWECHK = 0;
  Bt base_type[790];
  CAM8SimJIT *jit;
  /* CAM8 Registers */
  BYTE MSR[CHIPS_PER_MOD];
  BYTE SSM[CHIPS_PER_MOD];
  BYTE RT[CHIPS_PER_MOD];
  BYTE ECT[CHIPS_PER_MOD];
  BYTE RPK[CHIPS_PER_MOD];
  BYTE ALT[CHIPS_PER_MOD];
  LONG32 KA[CHIPS_PER_MOD];
  BYTE XKS[CHIPS_PER_MOD];
  BYTE YKS[CHIPS_PER_MOD];
  BYTE ZKS[CHIPS_PER_MOD];
  BYTE XKMF[CHIPS_PER_MOD];
  BYTE YKMF[CHIPS_PER_MOD];
  BYTE ZKMF[CHIPS_PER_MOD];
  BYTE SABSR[CHIPS_PER_MOD];
  BYTE LAS[CHIPS_PER_MOD];
  BYTE LAM[CHIPS_PER_MOD];
  BYTE FOS[CHIPS_PER_MOD];
  BYTE FOM[CHIPS_PER_MOD];
  BYTE SDS[CHIPS_PER_MOD];
  BYTE SDM[CHIPS_PER_MOD];
  BYTE ECS[CHIPS_PER_MOD];
  BYTE ECM[CHIPS_PER_MOD];
  BYTE DDS[CHIPS_PER_MOD];
  BYTE DDM[CHIPS_PER_MOD];
  BYTE SSR[CHIPS_PER_MOD];
  LONG32 ECR[CHIPS_PER_MOD];
  INT16 LIR[CHIPS_PER_MOD];
  BYTE LIPR[CHIPS_PER_MOD];
  INT16 *LIOR;
  LONG32 SIR[CHIPS_PER_MOD];
  BYTE SSA[24][CHIPS_PER_MOD];
  BYTE *SIOR;
  BYTE SM[CHIPS_PER_MOD];
  BYTE ESC[CHIPS_PER_MOD];
  BYTE ESW[CHIPS_PER_MOD];
  BYTE EST[CHIPS_PER_MOD];
  BYTE SBRC[CHIPS_PER_MOD];
  BYTE RCL[CHIPS_PER_MOD];
  BYTE ECL[CHIPS_PER_MOD];
  BYTE STM[CHIPS_PER_MOD];
  LONG32 OSR[CHIPS_PER_MOD];
  LONG32 DCM[CHIPS_PER_MOD];
  BYTE XDCP[CHIPS_PER_MOD];
  BYTE YDCP[CHIPS_PER_MOD];
  BYTE ZDCP[CHIPS_PER_MOD];
  BYTE LPL[CHIPS_PER_MOD];
  BYTE FPL[CHIPS_PER_MOD];
  BYTE DCS[CHIPS_PER_MOD];
  BYTE TBD[CHIPS_PER_MOD];
  BYTE TMS[CHIPS_PER_MOD];
  BYTE NBF[CHIPS_PER_MOD];
  BYTE SRE[CHIPS_PER_MOD];
  BYTE ALS[CHIPS_PER_MOD];
  BYTE MAFS[CHIPS_PER_MOD];
  BYTE MBFS[CHIPS_PER_MOD];
  BYTE XMPC[CHIPS_PER_MOD];
  BYTE XPPC[CHIPS_PER_MOD];
  BYTE YMPC[CHIPS_PER_MOD];
  BYTE YPPC[CHIPS_PER_MOD];
  BYTE ZMPC[CHIPS_PER_MOD];
  BYTE ZPPC[CHIPS_PER_MOD];
  BYTE MIDR[CHIPS_PER_MOD];
  BYTE GIDR[CHIPS_PER_MOD];
  BYTE BPIE[CHIPS_PER_MOD];
  BYTE BCIE[CHIPS_PER_MOD];
  BYTE GCIE[CHIPS_PER_MOD];
  BYTE MAIE[CHIPS_PER_MOD];
  BYTE MBIE[CHIPS_PER_MOD];
  BYTE SSIE[CHIPS_PER_MOD];
  BYTE XHIE[CHIPS_PER_MOD];
  BYTE RLIE[CHIPS_PER_MOD];
  BYTE URIE[CHIPS_PER_MOD];
  BYTE ISIE[CHIPS_PER_MOD];
  BYTE BPIF[CHIPS_PER_MOD];
  BYTE BCIF[CHIPS_PER_MOD];
  BYTE GCIF[CHIPS_PER_MOD];
  BYTE MAIF[CHIPS_PER_MOD];
  BYTE MBIF[CHIPS_PER_MOD];
  BYTE SSIF[CHIPS_PER_MOD];
  BYTE XHIF[CHIPS_PER_MOD];
  BYTE RLIF[CHIPS_PER_MOD];
  BYTE URIF[CHIPS_PER_MOD];
  BYTE ISIF[CHIPS_PER_MOD];
  BYTE VWE[CHIPS_PER_MOD];
  BYTE VWIE[CHIPS_PER_MOD];
  BYTE VWIF[CHIPS_PER_MOD];
  BYTE LDOC[CHIPS_PER_MOD];
  BYTE HDOC[CHIPS_PER_MOD];
  unsigned short nNumPlanes;
  BYTE WhyScan;
#ifdef _FRAMEBUFFER_
  BYTE *FRAMEb;							/* FRAME buffer */
#endif _FRAMEBUFFER_
  BOOL bDestSrcMatrix [CHIPS_PER_MOD][NUM_DEST][NUM_SRC];
  BOOL bSourceRegChange;
  BOOL bDestChange;
  BOOL bForceGeneralScan;
  BOOL bByteMode;
  BOOL bImmediate;
  BOOL bReadMode;
  INT16 *LUTb[2];						/* LUT buffers */
  LONG32 SITE_ADDR;
  LONG32 lDCMRHighBit;
  LONG32 lDCMRLowBit;
  LONG32 lNumXBits;
#ifndef INTERPRETER
  CODE *pcodScanNoPerm;
  CODEPTR pcodGenUpdate;
  CODEPTR pcodScanner;
  CODEPTR pcodSweep;
  CODEPTR pcodUpdateSite;
#else !INTERPRETER
  LONG32 bit;
  LONG32 HIGH_BIT_MASK;
  LONG32 X_HIGH_BIT_MASK;
  LONG32 X_BYTE_LENGTH;
  LONG32 X_CTR;
  LONG32 SITE_CTR;
  LONG32 OFFSETS[CHIPS_PER_MOD];
  LONG32 BIT_OFFSETS[CHIPS_PER_MOD];
  LONG32 DCMR;
  LONG32 SCAN_INDEX_REG;
  LONG32 LUT_ADDR;
  LONG32 BIT_PLANE_ADDR[CHIPS_PER_MOD];
  LONG32 NEXT_WORD_ADDR[CHIPS_PER_MOD];
  LONG32 PLANE_WORD[CHIPS_PER_MOD];
  LONG32 EVENT_COUNT[CHIPS_PER_MOD];
  LONG32 UNGLUE_DATA;
  LONG32 GLUE_DATA;
  LONG32 SITE_DATA;
  LONG32 TBUS_DATA;
  LONG32 LUT_DATA;
  LONG32 DISP_DATA;
  LONG32 TBUS_ADDR;
  LONG32 FRAME_ADDR;
  LONG32 TEMP1;
  LONG32 TEMP2;
  LONG32 TEMP3;
  LONG32 TEMP4;
  LONG32 TEMP5;
  LONG32 TEMP6;
  LONG32 TEMP7;
  LONG32 TEMP8;
  LONG32 TEMP9;
  LONG32 TEMP10;
#endif !INTERPRETER
#ifdef DEBUG
  FILE* DEBUGFILE;
#ifndef INTERPRETER
  CODEPTR DASMADDR;
#endif !INTERPRETER
#endif DEBUG
#ifdef _INSTRUMENTATION_
  struct timeval tvStart, tvEnd;
  struct timezone tzZone;
#endif
  Cam8Sim(void);
  DECL_COPYCONST(Cam8Sim);
  virtual ~Cam8Sim(void);
  DECL_OPEQ(Cam8Sim);
  DECL_BZERO(Cam8Sim);
  DECL_BCOPY(Cam8Sim);
  DECL_BCMP(Cam8Sim);
  void InitSimulator(Cam8Core *);
  void InitStepList(void);
  void InitExitProcs();
  void ExitSigProc();
  void ExitProc();
  void UnpackState(INT16 *, int, int);
  void UnpackStateInto(INT16 *, int, int, BYTE *, int);
  void PackState(INT16 *, int);
  void PackStateFrom(INT16 *, int, BYTE *, int);
#ifndef INTERPRETER
  void InitSim(void);
  void SimScanNoPerm(CODEHANDLE hcodCurrent);
  void SimGeneralScan(CODEHANDLE hcodCurrent);
  void SimPrologue(CODEHANDLE hcodCurrent);
  void SimEpilogue(CODEHANDLE hcodCurrent);
  void SimUpdateSite();
  void SimLoadFirstWord(unsigned short nBitOffset[]);
  void SimGetNextWord(unsigned short nPlane);
  void SimSaveLastWord(unsigned short nBitOffset[]);
  void CheckNoPerm(CODEHANDLE hcodCurrent);
  void SimUpdateCode();
  void SimLoadPlaneWords();
  void SimSavePlaneWords();
  void MapFunction (short iSrcVar, short iDestVar, BYTE bMap);
  void BuildDest(short nDest, short iDestVar, BYTE Src, BYTE Map);
  void BuildBitDest(short nDest, short iHoldReg, BYTE Src, BYTE Map, unsigned short nPlane);
  void BuildBitwiseDest(short nDest, short iDestVar, BYTE Src[], BYTE Map[]);
  short PermuteScanIndex();
#else !INTERPRETER
  void SimScanNoPerm();
  void SimGeneralScan();
  void SimUpdateSite();
  void CheckNoPerm();
  void SimLoadFirstWord(LONG32 nBitOffset[]);
  void SimGetNextWord(unsigned short nPlane);
  void SimSaveLastWord(LONG32 nBitOffset[]);
  void SimUpdateCode();
  void SimLoadPlaneWords();
  void SimSavePlaneWords();
  void MapFunction (LONG32 *SrcVar, LONG32 *DestVar, BYTE bMap);
  void BuildDest(short nDest, LONG32 *DestVar, BYTE Src, BYTE Map);
  void BuildBitDest(short nDest, LONG32 *HoldReg, BYTE Src, BYTE Map, unsigned short nPlane);
  void BuildBitwiseDest(short nDest, LONG32 *DestVar, BYTE Src[], BYTE Map[]);
  LONG32 *PermuteScanIndex();
#endif !INTERPRETER
  void InitModule(void);
  void SimStepList(LONG32 *plFirstInstr);
  void SimScan(void);
  void UpdateDCMR(void);
  void UpdateDestSrcMatrix(void);
  void UpdateDCMR();
  void UpdateDestSrcMatrix();
  unsigned short CalcNumPlanes();
  unsigned short CalcNumPlanes(void);
  BOOL IsSrcNeeded(short nSrc);
  BOOL IsSrcSame(short nDest);
  BOOL IsDestUpdated(short nDest);
  BOOL IsSrcNeeded(short nSrc);
  BOOL IsSrcSame(short nDest);
  BOOL IsDestUpdated(short nDest);
  LONG32 AddSiteAddress(LONG32 lSrc1, LONG32 lSrc2);
  LONG32 SubSiteAddress(LONG32 lSrc1, LONG32 lSrc2);
  LONG32 ScanLength(void);
  LONG32 SweepLength(LONG32 *lFirstSweep);
  LONG32 AddSiteAddress(LONG32 lSrc1, LONG32 lSrc2);
  LONG32 SubSiteAddress(LONG32 lSrc1, LONG32 lSrc2);
  LONG32 ScanLength();
  LONG32 SweepLength(LONG32 *lFirstSweep);
  LONG32 DCMRHighBit();
  LONG32 DCMRLowBit();
  inline void ConstantSetAll(BYTE r[], BYTE v);
  inline void ConstantSetAll(INT16 r[], INT16 v);
  inline void ConstantSetAll(LONG32 r[], LONG32 v);
  inline void SetAll(BYTE r[], BYTE v[]);
  inline void SetAll(INT16 r[], INT16 v[]);
  inline void SetAll(LONG32 r[], LONG32 v[]);
protected:
  inline void SENTER(int i, char *b, int t);
/*****************************************************************************/
/********************************* INLINES ***********************************/
/*****************************************************************************/
inline void Cam8Sim::SENTER(int i, char *b, int t)
  base_type[i].base = b;
  base_type[i].type = t;
inline void Cam8Sim::ConstantSetAll(BYTE r[], BYTE v)
  register int i;
  for(i = 0; i < CHIPS_PER_MOD; i++)
    r[i]=v;
inline void Cam8Sim::ConstantSetAll(INT16 r[], INT16 v)
  register int i;
  for(i = 0; i < CHIPS_PER_MOD; i++)
    r[i]=v;
inline void Cam8Sim::ConstantSetAll(LONG32 r[], LONG32 v)
  register int i;
  for(i = 0; i < CHIPS_PER_MOD; i++)
    r[i]=v;
inline void Cam8Sim::SetAll(BYTE r[], BYTE v[])
  memcpy(r, v, CHIPS_PER_MOD * sizeof(BYTE));
inline void Cam8Sim::SetAll(INT16 r[], INT16 v[])
  memcpy(r, v, CHIPS_PER_MOD * sizeof(BYTE));
inline void Cam8Sim::SetAll(LONG32 r[], LONG32 v[])
  memcpy(r, v, CHIPS_PER_MOD * sizeof(BYTE));
#endif
/*****************************************************************************/
/******************************* PROTOTYPES **********************************/
/*****************************************************************************/
/*****************************************************************************/
/********************************* GLOBALS ***********************************/
/*****************************************************************************/
#endif

---------------------------------------------------------------------------

#include <CaLibStream++.H>
#include <CaLibError++.H>
#include <CaLibTrace++.H>
#include <CamLib++.H>
#include <Cam8Core++.H>
#include <Cam8SimCore++.H>
#include "std++.H"
Cam8SimCore::Cam8SimCore(void)
Cam8SimCore::~Cam8SimCore(void)
STD_BZERO(Cam8SimCore)
STD_BCOPY(Cam8SimCore)
STD_BCMP(Cam8SimCore)
void Cam8SimCore::ResetInterface(void)
  CaLib_tb.ENTER("Cam8SimCore::ResetInterface");
  /* Zero everything out to start off */
  bzero((char *) &iregs, sizeof(iregs));
  /* Enable all interrupts and exceptions */
  iregs.RER = CAM_ENABLE_NEWLIST_INT | CAM_ENABLE_TIMEOUT_INT |
              CAM_ENABLE_SBUS_INT | CAM_ENABLE_CAM_INT |
	      CAM_ENABLE_SOFT_INT | CAM_ENABLE_TIMEOUT_EXC |
	      CAM_ENABLE_CAMINT_EXC;
  /* Mark all interrupts as enabled */
  iregs.ISR = CAM_ENABLE_NEWLIST_INT | CAM_ENABLE_TIMEOUT_INT |
              CAM_ENABLE_SBUS_INT | CAM_ENABLE_CAM_INT |
	      CAM_ENABLE_SOFT_INT;
  /* Put us in wait-for-host mode */
  iregs.NLP |= CAM_WAIT_FOR_HOST;
  CaLib_tb.LEAVE();
void Cam8SimCore::InitInterface(void)
  CaLib_tb.ENTER("Cam8SimCore::InitInterface");
  ResetInterface();
  CaLib_tb.LEAVE();
void Cam8SimCore::ExecuteSteplist(struct steplist_operation & slo)
  CaLib_tb.ENTER("Cam8SimCore::ExecuteSteplist");
  SimStepList((LONG32 *) slo.buf);
  CaLib_tb.LEAVE();
void Cam8SimCore::Generate_Interrupt(int type)
  CaLib_tb.ENTER("Cam8SimCore::Generate_Interrupt");
  iregs.ISR |= type;
  switch(type) {
  case CAM_CAM_INT_STATUS: {
    if ((iregs.RER & CAM_ENABLE_CAMINT_EXC) &&
	!(iregs.RER & CAM_DISABLE_CAMINT_EXC)) {
      iregs.NLP |= CAM_EXCEPTION_STATUS;
    }
    break;
  case CAM_TIMEOUT_INT_STATUS: {
    if ((iregs.RER & CAM_ENABLE_TIMEOUT_EXC) &&
	!(iregs.RER & CAM_DISABLE_TIMEOUT_EXC)) {
      iregs.NLP |= CAM_EXCEPTION_STATUS;
    }
    break;
  CaLib_tb.LEAVE();
void Cam8SimCore::Read_NLP(LONG32 *v)
  CaLib_tb.ENTER("Cam8SimCore::Read_NLP");
  CaLibAbort(!v, "NULL Pointer");
  *v = iregs.NLP;
  CaLib_tb.LEAVE();
void Cam8SimCore::Read_ISR(LONG32 *v)
  CaLib_tb.ENTER("Cam8SimCore::Read_ISR");
  CaLibAbort(!v, "NULL Pointer");
  *v = iregs.ISR;
  /* Turn off interrupt flags and unused bits, leave enables the same */
  iregs.ISR &= 0x00001F00;
  CaLib_tb.LEAVE();
void Cam8SimCore::Read_CIP(LONG32 *v)
  CaLib_tb.ENTER("Cam8SimCore::Read_CIP");
  CaLibAbort(!v, "NULL Pointer");
  *v = iregs.CIP;
  CaLib_tb.LEAVE();
void Cam8SimCore::Read_PIP(LONG32 *v)
  CaLib_tb.ENTER("Cam8SimCore::Read_PIP");
  CaLibAbort(!v, "NULL Pointer");
  *v = iregs.PIP;
  CaLib_tb.LEAVE();
void Cam8SimCore::Write_NLP(const LONG32 *v)
  LONG32 tmp = iregs.NLP & 0xF;
  CaLib_tb.ENTER("Cam8SimCore::Write_NLP");
  CaLibAbort(!v, "NULL Pointer");
  if (!(iregs.NLP & CAM_EXCEPTION_STATUS))
    iregs.NLP = tmp | (*v) & 0xFFFFFFF0);
  CaLib_tb.LEAVE();
void Cam8SimCore::Write_RER(const LONG32 *v)
  CaLib_tb.ENTER("Cam8SimCore::Write_RER");
  CaLibAbort(!v, "NULL Pointer");
  iregs.RER = *v;
  if (iregs.RER & CAM_RESET_INTERFACE) {
    ResetInterface();
  if (iregs.RER & CAM_HALT_INTERFACE)
    iregs.NLP |= CAM_INTERFACE_HALTED;
  if (iregs.RER & CAM_ENABLE_TIMEOUT_EXC)
    iregs.NLP &= ~(CAM_EXCEPTION_STATUS);
  /*  This is supposed to also resume after error ack, whatever that is
  if (iregs.RER & CAM_ENABLE_CAMINT_EXC)
  */
  if (iregs.RER & CAM_ENABLE_NEWLIST_INT)
    iregs.ISR |= CAM_ENABLE_NEWLIST_INT;
  if (iregs.RER & CAM_ENABLE_TIMEOUT_INT)
    iregs.ISR |= CAM_ENABLE_TIMEOUT_INT;
  if (iregs.RER & CAM_ENABLE_SBUS_INT)
    iregs.ISR |= CAM_ENABLE_SBUS_INT;
  if (iregs.RER & CAM_ENABLE_CAM_INT)
    iregs.ISR |= CAM_ENABLE_CAM_INT;
  if (iregs.RER & CAM_ENABLE_SOFT_INT)
    iregs.ISR |= CAM_ENABLE_SOFT_INT;
  if (iregs.RER & CAM_DISABLE_NEWLIST_INT)
    iregs.ISR &= ~(CAM_ENABLE_NEWLIST_INT);
  if (iregs.RER & CAM_DISABLE_TIMEOUT_INT)
    iregs.ISR &= ~(CAM_ENABLE_TIMEOUT_INT);
  if (iregs.RER & CAM_DISABLE_SBUS_INT)
    iregs.ISR &= ~(CAM_ENABLE_SBUS_INT);
  if (iregs.RER & CAM_DISABLE_CAM_INT)
    iregs.ISR &= ~(CAM_ENABLE_CAM_INT);
  if (iregs.RER & CAM_ENABLE_SOFT_INT)
    iregs.ISR |= CAM_ENABLE_SOFT_INT;
  CaLib_tb.LEAVE();
void Cam8SimCore::Write_DSL(const LONG32 *v)
  CaLib_tb.ENTER("Cam8SimCore::Write_DSL");
  CaLibAbort(!v, "NULL Pointer");
  iregs.DSL = *v;
  CaLib_tb.LEAVE();
void Cam8SimCore::Write_DBL(const LONG32 *v)
  CaLib_tb.ENTER("Cam8SimCore::Write_DBL");
  CaLibAbort(!v, "NULL Pointer");
  iregs.DBL = *v;
  CaLib_tb.LEAVE();
void Cam8SimCore::InitSimulator(void)
  CaLib_tb.ENTER("Cam8SimCore::InitSimulator");
  CaLibAbort(!co, "NULL core object pointer");
  core = co;
  InitStepList();
  if (debug) {
  /* Need to open a new file, set the CAMSTREAM dbug to it and turn on a flag */
  InitHeap();
  CaLib_tb.LEAVE();
void Cam8SimCore::InitStepList(void)
  CaLib_tb.ENTER("Cam8SimCore::InitStepList()");
  SENTER(RFINDEX(REG_MSR), MSR, BIT8);
  SENTER(RFINDEX(FLD_SSM), SSM, BIT8);
  SENTER(RFINDEX(FLD_RT), RT, BIT8);
  SENTER(RFINDEX(FLD_ECT), ECT, BIT8);
  SENTER(RFINDEX(FLD_RPK), RPK, BIT8);
  SENTER(RFINDEX(FLD_ALT), ALT, BIT8);
  SENTER(RFINDEX(FLD_KA), KA, BIT32);
  SENTER(RFINDEX(FLD_XKS), XKS, BIT8);
  SENTER(RFINDEX(FLD_YKS), YKS, BIT8);
  SENTER(RFINDEX(FLD_ZKS), ZKS, BIT8);
  SENTER(RFINDEX(FLD_XKMF), XKMF, BIT8);
  SENTER(RFINDEX(FLD_YKMF), YKMF, BIT8);
  SENTER(RFINDEX(FLD_ZKMF), ZKMF, BIT8);
  SENTER(RFINDEX(REG_SABSR), SABSR, BIT8);
  SENTER(RFINDEX(FLD_LAS), LAS, BIT8);
  SENTER(RFINDEX(FLD_LAM), LAM, BIT8);
  SENTER(RFINDEX(FLD_FOS), FOS, BIT8);
  SENTER(RFINDEX(FLD_FOM), FOM, BIT8);
  SENTER(RFINDEX(FLD_SDS), SDS, BIT8);
  SENTER(RFINDEX(FLD_SDM), SDM, BIT8);
  SENTER(RFINDEX(FLD_ECS), ECS, BIT8);
  SENTER(RFINDEX(FLD_ECM), ECM, BIT8);
  SENTER(RFINDEX(FLD_DDS), DDS, BIT8);
  SENTER(RFINDEX(FLD_DDM), DDM, BIT8);
  SENTER(RFINDEX(REG_SSR), SSR, BIT8);
  SENTER(RFINDEX(REG_ECR), ECR, BIT32);
  SENTER(RFINDEX(REG_LIR), LIR, BIT8);
  SENTER(RFINDEX(REG_LIPR), LIPR, BIT8);
  SENTER(RFINDEX(REG_SIR), SIR, BIT32);
  SENTER(RFINDEX(FLD_SSA0), SSA0, BIT8);
  SENTER(RFINDEX(FLD_SSA1), SSA1, BIT8);
  SENTER(RFINDEX(FLD_SSA2), SSA2, BIT8);
  SENTER(RFINDEX(FLD_SSA3), SSA3, BIT8);
  SENTER(RFINDEX(FLD_SSA4), SSA4, BIT8);
  SENTER(RFINDEX(FLD_SSA5), SSA5, BIT8);
  SENTER(RFINDEX(FLD_SSA6), SSA6, BIT8);
  SENTER(RFINDEX(FLD_SSA7), SSA7, BIT8);
  SENTER(RFINDEX(FLD_SSA8), SSA8, BIT8);
  SENTER(RFINDEX(FLD_SSA9), SSA9, BIT8);
  SENTER(RFINDEX(FLD_SSA10), SSA10, BIT8);
  SENTER(RFINDEX(FLD_SSA11), SSA11, BIT8);
  SENTER(RFINDEX(FLD_SSA12), SSA12, BIT8);
  SENTER(RFINDEX(FLD_SSA13), SSA13, BIT8);
  SENTER(RFINDEX(FLD_SSA14), SSA14, BIT8);
  SENTER(RFINDEX(FLD_SSA15), SSA15, BIT8);
  SENTER(RFINDEX(FLD_SSA16), SSA16, BIT8);
  SENTER(RFINDEX(FLD_SSA17), SSA17, BIT8);
  SENTER(RFINDEX(FLD_SSA18), SSA18, BIT8);
  SENTER(RFINDEX(FLD_SSA19), SSA19, BIT8);
  SENTER(RFINDEX(FLD_SSA20), SSA20, BIT8);
  SENTER(RFINDEX(FLD_SSA21), SSA21, BIT8);
  SENTER(RFINDEX(FLD_SSA22), SSA22, BIT8);
  SENTER(RFINDEX(FLD_SSA23), SSA23, BIT8);
  SENTER(RFINDEX(FLD_SM), SM, BIT8);
  SENTER(RFINDEX(FLD_ESC), ESC, BIT8);
  SENTER(RFINDEX(FLD_ESW), ESW, BIT8);
  SENTER(RFINDEX(FLD_EST), EST, BIT8);
  SENTER(RFINDEX(FLD_SBRC), SBRC, BIT8);
  SENTER(RFINDEX(FLD_RCL), RCL, BIT8);
  SENTER(RFINDEX(FLD_ECL), ECL, BIT8);
  SENTER(RFINDEX(FLD_STM), STM, BIT8);
  SENTER(RFINDEX(REG_OSR), OSR, BIT32);
  SENTER(RFINDEX(FLD_DCM), DCM, BIT32);
  SENTER(RFINDEX(FLD_XDCP), XDCP, BIT8);
  SENTER(RFINDEX(FLD_YDCP), YDCP, BIT8);
  SENTER(RFINDEX(FLD_ZDCP), ZDCP, BIT8);
  SENTER(RFINDEX(FLD_LPL), LPL, BIT8);
  SENTER(RFINDEX(FLD_FPL), FPL, BIT8);
  SENTER(RFINDEX(FLD_DCS), DCS, BIT8);
  SENTER(RFINDEX(FLD_TBD), TBD, BIT8);
  SENTER(RFINDEX(FLD_TMS), TMS, BIT8);
  SENTER(RFINDEX(FLD_NBF), NBF, BIT8);
  SENTER(RFINDEX(FLD_SRE), SRE, BIT8);
  SENTER(RFINDEX(FLD_ALS), ALS, BIT8);
  SENTER(RFINDEX(FLD_MAFS), MAFS, BIT8);
  SENTER(RFINDEX(FLD_MBFS), MBFS, BIT8);
  SENTER(RFINDEX(FLD_XMPC), XMPC, BIT8);
  SENTER(RFINDEX(FLD_XPPC), XPPC, BIT8);
  SENTER(RFINDEX(FLD_YMPC), YMPC, BIT8);
  SENTER(RFINDEX(FLD_YPPC), YPPC, BIT8);
  SENTER(RFINDEX(FLD_ZMPC), ZMPC, BIT8);
  SENTER(RFINDEX(FLD_ZPPC), ZPPC, BIT8);
  SENTER(RFINDEX(REG_MIDR), MIDR, BIT8);
  SENTER(RFINDEX(REG_GIDR), GIDR, BIT8);
  SENTER(RFINDEX(FLD_BPIE), BPIE, BIT8);
  SENTER(RFINDEX(FLD_BCIE), BCIE, BIT8);
  SENTER(RFINDEX(FLD_GCIE), GCIE, BIT8);
  SENTER(RFINDEX(FLD_MAIE), MAIE, BIT8);
  SENTER(RFINDEX(FLD_MBIE), MBIE, BIT8);
  SENTER(RFINDEX(FLD_SSIE), SSIE, BIT8);
  SENTER(RFINDEX(FLD_XHIE), XHIE, BIT8);
  SENTER(RFINDEX(FLD_RLIE), RLIE, BIT8);
  SENTER(RFINDEX(FLD_URIE), URIE, BIT8);
  SENTER(RFINDEX(FLD_ISIE), ISIE, BIT8);
  SENTER(RFINDEX(FLD_BPIF), BPIF, BIT8);
  SENTER(RFINDEX(FLD_BCIF), BCIF, BIT8);
  SENTER(RFINDEX(FLD_GCIF), GCIF, BIT8);
  SENTER(RFINDEX(FLD_MAIF), MAIF, BIT8);
  SENTER(RFINDEX(FLD_MBIF), MBIF, BIT8);
  SENTER(RFINDEX(FLD_SSIF), SSIF, BIT8);
  SENTER(RFINDEX(FLD_XHIF), XHIF, BIT8);
  SENTER(RFINDEX(FLD_RLIF), RLIF, BIT8);
  SENTER(RFINDEX(FLD_URIF), URIF, BIT8);
  SENTER(RFINDEX(FLD_ISIF), ISIF, BIT8);
  SENTER(RFINDEX(FLD_VWE), VWE, BIT8);
  SENTER(RFINDEX(FLD_VWIE), VWIE, BIT8);
  SENTER(RFINDEX(FLD_VWIF), VWIF, BIT8);
  SENTER(RFINDEX(FLD_LDOC), LDOC, BIT8);
  SENTER(RFINDEX(FLD_HDOC), HDOC, BIT8);
  CaLib_tb.LEAVE();
void Cam8SimCore::vwecheck(INT16 *base, int reg_fld, int imm)
  register int i;
  int f = 0, o;
  LONG32 pbuf[CHIPS_PER_MOD];
  Bt bt;
  CaLib_tb.ENTER("Cam8SimCore::vwecheck");
  bt = base_type[reg_fld];
  if (VWECHK) {
    UnpackStateInto(base, reg_fld, imm, (BYTE *) pbuf, bt.type);
    for (i = 0; i < CHIPS_PER_MOD; i++) {
      o = bt.type * i;
      if (VWE[i]) {
	if (bcmp(bt.base + o, ((BYTE *) pbuf) + o, bt.type) != 0) {
	  f = 1;
	  VWIF[i] = 1;
      }
      else
	bcopy(((BYTE *) pbuf) + o, bt.base + o, bt.type);
    }
  else
    UnpackState(base, reg_fld, imm);
  CaLib_tb.LEAVE();
void Cam8SimCore::SimStepList(LONG32 *plFirstInstr)
  LONG32 *plCurr = NULL, *plNext = NULL;
  LONG32 lData = 0, lLength;
  short nRegister, i, imm = FALSE;
  BOOL bHostJump, bHostWait, bByteMode, bReadMode;
  BOOL bDone = FALSE;
  LONG32 pbuf[CHIPS_PER_MOD];
  bHostJump = bHostWait = FALSE;
  CaLib_tb.ENTER("Cam8SimCore::SimStepList");
  for (plCurr = plFirstInstr; !bDone; plCurr = plNext) {
    bHostJump = (*plCurr & HOST_JUMP_MASK) != 0;
    bHostWait = (*plCurr & HOST_WAIT_MASK) != 0;
    bDone = bHostJump || bHostWait;
    bByteMode = (*plCurr & BYTE_MODE_MASK) != 0;
    bReadMode = (*plCurr & READ_CAM_MASK) != 0;
    
    cam8sim_iregs.PIP = cam8sim_iregs.CIP;
    cam8sim_iregs.CIP = (LONG32) plNext;
    if (*plCurr & RESET_CAM_MASK) {
      memset ((char *) &Cam8State, 0, sizeof(Cam8State));
      LIOR = LUT1;
      LUT_ADDR = (LONG32) LUT0;
      bSourceRegChange = bDestChange = TRUE;
      
      if (debug) {
	fprintf(DEBUGFILE, "CAM Reset\n");
	fflush(DEBUGFILE);
      }
    }
    
    
    nRegister = *plCurr & REGISTER_ADDR_MASK;
    imm = (*plCurr & IMMEDIATE_DATA_MASK) != 0;
    lData = *(plCurr + 1);
    lLength = *(plCurr + 2);
    
    plNext = (LONG32 *) (*(plCurr + 3));
    
    if ((*plCurr & READ_CAM_MASK) && (*plCurr & IMMEDIATE_DATA_MASK)) {
      if (debug)
	fprintf(DEBUGFILE, "NOOP\n");
      continue;
    }
    
    
    if (debug) {
      fprintf(DEBUGFILE, "REG = %d (%s), ", nRegister, REGNAMES[nRegister]);
      if (imm)
	fprintf(DEBUGFILE, "IMMEDIATE DATA, ");
      fprintf(DEBUGFILE, "BYTEMODE = %d, READMODE = %d\n",
	      bByteMode, bReadMode);
      fflush(DEBUGFILE);
    }
    
    if ((*plCurr & READ_CAM_MASK) != 0) {
      INT16 *pnBuffer;
      
      Cam8State.bReadMode = TRUE;
      bDestChange = TRUE;
      
      pnBuffer = (INT16 *) lData;
      
      SimReadInstr(pnBuffer, *plCurr, lData, lLength);
      
      continue;
    }
    
    
    switch (nRegister) {
      
    case RFINDEX(REG_MSR): {
      vwecheck((INT16 *) lData, RFINDEX(REG_MSR), imm);
      break;
    }      
      
      
    case RFINDEX(REG_RMR): {
      vwecheck((INT16 *) lData, RFINDEX(FLD_SSM), imm);
      vwecheck((INT16 *) lData, RFINDEX(FLD_RT), imm);
      vwecheck((INT16 *) lData, RFINDEX(FLD_ECT), imm);
      vwecheck((INT16 *) lData, RFINDEX(FLD_RPK), imm);
      vwecheck((INT16 *) lData, RFINDEX(FLD_ALT), imm);
      
      for(i = 0; i < CHIPS_PER_MOD; i++) {
	if (ECT[i] == 1) {
          ECR[i] = EVENT_COUNT[i];
          EVENT_COUNT[i] = 0L;
        }
        if (RPK[i] == 1)
          DoKick(i);
      }
      
      if (ALT[0] == 1) {
        INT16 *pnTemp;
        
        pnTemp = LIOR;
        LIOR = (INT16 *) LUT_ADDR;
        LUT_ADDR = (LONG32) pnTemp;
        
        for (i = 0; i < CHIPS_PER_MOD; i++)
	  ALS[i] ^= 1;
      }
      if (Cam8State.bReadMode != FALSE) {
	bDestChange = TRUE;
	Cam8State.bReadMode = FALSE;
      }
      if (SSM[0] != 0) {
	Cam8State.WhyScan = RFINDEX(REG_RMR);
	SimExecScan();
      }
      
      break;
    }
      
      
    case RFINDEX(REG_KR): {
      vwecheck((INT16 *) lData, RFINDEX(FLD_KA), imm);
      vwecheck((INT16 *) lData, RFINDEX(FLD_XKS), imm);
      vwecheck((INT16 *) lData, RFINDEX(FLD_YKS), imm);
      vwecheck((INT16 *) lData, RFINDEX(FLD_ZKS), imm);
      vwecheck((INT16 *) lData, RFINDEX(FLD_XKMF), imm);
      vwecheck((INT16 *) lData, RFINDEX(FLD_YKMF), imm);
      vwecheck((INT16 *) lData, RFINDEX(FLD_ZKMF), imm);
      DoKick(-1);
      break;
    }
      
      
    case RFINDEX(REG_SABSR):
      {
	vwecheck((INT16 *) lData, RFINDEX(REG_SABSR), imm);
	break;
      }
    case RFINDEX(REG_LASR):
    case RFINDEX(REG_FOSR):
    case RFINDEX(REG_SDSR):
    case RFINDEX(REG_ECSR):
    case RFINDEX(REG_DSR): {
      vwecheck((INT16 *) lData, FLD_SELECT(nRegister), imm);
      vwecheck((INT16 *) lData, FLD_MAP(nRegister), imm);
      bSourceRegChange = TRUE;
      break;
    }
      
    case RFINDEX(REG_SSR): {
      vwecheck((INT16 *) lData, RFINDEX(REG_SSR), imm);
      
      break;
    }
      
      
    case RFINDEX(REG_ECR): {
      if (ECL[0] != lLength) {
	ConstantSetAll(RLIF, 1);
	Generate_Interrupt(CAM_CAM_INT_STATUS);
      }
      else {
	int i;
	UnpackBits((INT16 *) lData, 0, lLength, imm, (BYTE *) ECR, BIT32);
	for(i = 0; i < CHIPS_PER_MOD; i++)
	  EVENT_COUNT[i] = ECR[i];
      }
      break;
    }
      
      
    case RFINDEX(REG_LIR): {
      vwecheck((INT16 *) lData, RFINDEX(REG_LIR), imm);
      break;
    }
      
      
    case RFINDEX(REG_LIPR): {
      vwecheck((INT16 *) lData, RFINDEX(REG_LIPR), imm);
      
      break;
    }
      
      
    case RFINDEX(REG_LIOR): {
      INT16 nLUTEntry, nLUTNextIndex;
      INT16 *pnLUT, *pnSource;
      int i, j;
      INT16 nImmediate[2];
      
      if (imm) {
        nImmediate[0] = (INT16) lData >> 16;
        nImmediate[1] = (INT16) lData & 0xFF;
        pnSource = &nImmediate[0];
      }
      
      else
        pnSource = (INT16 *) lData;
      
      for (i = 0; i < lLength; i++) {
        nLUTNextIndex = 0;
        for (j = CHIPS_PER_MOD - 1; j >= 0; j--) {
          nLUTNextIndex <<= 1;
          if (LIPR[j] < 16)
            nLUTNextIndex |= ((LIR[j] >> LIPR[j]) & 0x1);
          else if (LIPR[j] == 31)
            nLUTNextIndex |= 0x1;
	  LIR[j]++;
        }
        pnLUT = LIOR + nLUTNextIndex;                 
        
        if (imm) {
          *pnLUT = *pnSource;
          pnSource = &nImmediate[i % 2];
        } 
        
        else {
          *pnLUT = *pnSource;
          pnSource++;
        }
      }
      
      break;
    }
      
      
    case RFINDEX(REG_SIR): {
      vwecheck((INT16 *) lData, RFINDEX(REG_SIR), imm);
      
      SCAN_INDEX_REG = SIR[0];
      
      break;
    }
      
      
    case RFINDEX(REG_SIPR): {
      int j;
      
      for(j = 0; j < SCAN_INDEX_LENGTH; j++)
        vwecheck((INT16 *) lData, RFINDEX(FLD_SSA(j)), imm);
      
      break;
    }
      
      
    case RFINDEX(REG_SIOR): {
      if ((Cam8State.bByteMode != bByteMode) || 
          (Cam8State.bImmediate != imm)) {
        Cam8State.bByteMode = bByteMode;
        Cam8State.bImmediate = imm;
        bSourceRegChange = TRUE;
      }
      
      if (imm) {
        SIOR = (BYTE *) &lData;
        TBUS_DATA = lData;
      }
      
      else {
        SIOR = (BYTE *) lData;
	TBUS_ADDR = lData;
      }
      
      if (Cam8State.bReadMode != FALSE) {
        bDestChange = TRUE;
        Cam8State.bReadMode = FALSE;
      }
      
      Cam8State.WhyScan = RFINDEX(REG_SIOR);
      SimExecScan();      
      break;
    }
      
      
    case RFINDEX(REG_SFR): {
      vwecheck((INT16 *) lData, RFINDEX(FLD_SM), imm);
      vwecheck((INT16 *) lData, RFINDEX(FLD_ESC), imm);
      vwecheck((INT16 *) lData, RFINDEX(FLD_ESW), imm);
      vwecheck((INT16 *) lData, RFINDEX(FLD_EST), imm);
      vwecheck((INT16 *) lData, RFINDEX(FLD_SBRC), imm);
      vwecheck((INT16 *) lData, RFINDEX(FLD_RCL), imm);
      vwecheck((INT16 *) lData, RFINDEX(FLD_ECL), imm);
      vwecheck((INT16 *) lData, RFINDEX(FLD_STM), imm);
      
      break;
    }
      
      
    case RFINDEX(REG_OSR): {
      vwecheck((INT16 *) lData, nRegister, imm);
      break;
    }
      
      
    case RFINDEX(REG_DR): {
      vwecheck((INT16 *) lData, RFINDEX(FLD_DCM), imm);
      vwecheck((INT16 *) lData, RFINDEX(FLD_XDCP), imm);
      vwecheck((INT16 *) lData, RFINDEX(FLD_YDCP), imm);
      vwecheck((INT16 *) lData, RFINDEX(FLD_ZDCP), imm);
      UpdateDCMR();
      
      break;
    }
      
      
    case RFINDEX(REG_HER): {
      vwecheck((INT16 *) lData, RFINDEX(FLD_LPL), imm);
      vwecheck((INT16 *) lData, RFINDEX(FLD_FPL), imm);
      vwecheck((INT16 *) lData, RFINDEX(FLD_DCS), imm);
      vwecheck((INT16 *) lData, RFINDEX(FLD_TBD), imm);
      vwecheck((INT16 *) lData, RFINDEX(FLD_TMS), imm);
      vwecheck((INT16 *) lData, RFINDEX(FLD_NBF), imm);
      vwecheck((INT16 *) lData, RFINDEX(FLD_SRE), imm);
      vwecheck((INT16 *) lData, RFINDEX(FLD_ALS), imm);
       
      if (ALS[0] == 1) {
        LIOR = (INT16*) LUT0;
        LUT_ADDR = (LONG32) LUT1;
      } 
      
      else {
        LIOR = (INT16 *) LUT1;
        LUT_ADDR = (LONG32) LUT0;
      }
      
      bSourceRegChange = TRUE;
      
      break;
    }
      
      
    case RFINDEX(REG_MPCR): {
      vwecheck((INT16 *) lData, RFINDEX(FLD_MAFS), imm);
      vwecheck((INT16 *) lData, RFINDEX(FLD_MBFS), imm);
      break;
    }
      
      
    case RFINDEX(REG_GPCR): {
      vwecheck((INT16 *) lData, RFINDEX(FLD_XMPC), imm);
      vwecheck((INT16 *) lData, RFINDEX(FLD_XPPC), imm);
      vwecheck((INT16 *) lData, RFINDEX(FLD_YMPC), imm);
      vwecheck((INT16 *) lData, RFINDEX(FLD_YPPC), imm);
      vwecheck((INT16 *) lData, RFINDEX(FLD_ZMPC), imm);
      vwecheck((INT16 *) lData, RFINDEX(FLD_ZPPC), imm);
      break;
    }
      
      
    case RFINDEX(REG_MIDR): {
      vwecheck((INT16 *) lData, RFINDEX(REG_MIDR), imm);
      break;
    }
      
      
    case RFINDEX(REG_GIDR): {
      vwecheck((INT16 *) lData, RFINDEX(REG_GIDR), imm);
      break;
    }
      
      
    case RFINDEX(REG_IER): {
      vwecheck((INT16 *) lData, RFINDEX(FLD_BPIE), imm);
      vwecheck((INT16 *) lData, RFINDEX(FLD_BCIE), imm);
      vwecheck((INT16 *) lData, RFINDEX(FLD_GCIE), imm);
      vwecheck((INT16 *) lData, RFINDEX(FLD_MAIE), imm);
      vwecheck((INT16 *) lData, RFINDEX(FLD_MBIE), imm);
      vwecheck((INT16 *) lData, RFINDEX(FLD_SSIE), imm);
      vwecheck((INT16 *) lData, RFINDEX(FLD_XHIE), imm);
      vwecheck((INT16 *) lData, RFINDEX(FLD_RLIE), imm);
      vwecheck((INT16 *) lData, RFINDEX(FLD_URIE), imm);
      vwecheck((INT16 *) lData, RFINDEX(FLD_ISIE), imm);
      break;
    }
      
      
    case RFINDEX(REG_IFR): {
      vwecheck((INT16 *) lData, RFINDEX(FLD_BPIF), imm);
      vwecheck((INT16 *) lData, RFINDEX(FLD_BCIF), imm);
      vwecheck((INT16 *) lData, RFINDEX(FLD_GCIF), imm);
      vwecheck((INT16 *) lData, RFINDEX(FLD_MAIF), imm);
      vwecheck((INT16 *) lData, RFINDEX(FLD_MBIF), imm);
      vwecheck((INT16 *) lData, RFINDEX(FLD_SSIF), imm);
      vwecheck((INT16 *) lData, RFINDEX(FLD_XHIF), imm);
      vwecheck((INT16 *) lData, RFINDEX(FLD_RLIF), imm);
      vwecheck((INT16 *) lData, RFINDEX(FLD_URIF), imm);
      vwecheck((INT16 *) lData, RFINDEX(FLD_ISIF), imm);
      break;
    }
      
      
    case RFINDEX(REG_VWR): {
      register int i;
      
      UnpackState((INT16 *) lData, RFINDEX(FLD_VWE), imm);
      UnpackState((INT16 *) lData, RFINDEX(FLD_VWIE), imm);
      UnpackState((INT16 *) lData, RFINDEX(FLD_VWIF), imm);
      VWECHK = 0;
      for (i = 0; i < CHIPS_PER_MOD; i++)
	if (VWE[i] == 1)
	  VWECHK = 1;
      
      break;
    }
      
      
    case RFINDEX(REG_DOCR): {
      vwecheck((INT16 *) lData, RFINDEX(FLD_LDOC), imm);
      vwecheck((INT16 *) lData, RFINDEX(FLD_HDOC), imm);
      
      break;
    }
      
      
    default: {
      
      fprintf(stderr, "Don't recognize register %d\n", nRegister);
      break;
    }
    }
    
    cam8sim_iregs.PIP = (LONG32) plCurr;
  } /*   for (plCurr = plFirstInstr; !bDone; plCurr = plNext;) */
  cam8sim_iregs.ISR |= CAM_NEWLIST_INT_STATUS;
  CaLib_tb.LEAVE();
void Cam8SimCore::SimReadInstr(INT16 *pnBuffer, LONG32 lInstr, LONG32 lData,
			   LONG32 lLength)
  BOOL bByteMode;
  short nRegister, i, imm;
  LONG32 pbuf[CHIPS_PER_MOD];
  CaLib_tb.ENTER("Cam8SimCore::SimReadInstr");
  bByteMode = (lInstr & BYTE_MODE_MASK) != 0;
  nRegister = lInstr & REGISTER_ADDR_MASK;
  imm = (lInstr & IMMEDIATE_DATA_MASK) != 0;
  switch (nRegister) {
    
  case RFINDEX(REG_MSR): {
    PackState(pnBuffer, RFINDEX(REG_MSR));
    break;
  }      
    
    
  case RFINDEX(REG_RMR): {
    PackState(pnBuffer, RFINDEX(FLD_SSM));
    PackState(pnBuffer, RFINDEX(FLD_RT));
    PackState(pnBuffer, RFINDEX(FLD_ECT));
    PackState(pnBuffer, RFINDEX(FLD_RPK));
    PackState(pnBuffer, RFINDEX(FLD_ALT));
    break;
    
    
  case RFINDEX(REG_KR): {
    PackState(pnBuffer, RFINDEX(FLD_KA));
    PackState(pnBuffer, RFINDEX(FLD_XKS));
    PackState(pnBuffer, RFINDEX(FLD_YKS));
    PackState(pnBuffer, RFINDEX(FLD_ZKS));
    PackState(pnBuffer, RFINDEX(FLD_XKMF));
    PackState(pnBuffer, RFINDEX(FLD_YKMF));
    PackState(pnBuffer, RFINDEX(FLD_ZKMF));
    break;
    
    
  case RFINDEX(REG_SABSR): {
    PackState(pnBuffer, RFINDEX(REG_SABSR));
    
    break;
    
    
  case RFINDEX(REG_LASR):
  case RFINDEX(REG_FOSR):
  case RFINDEX(REG_SDSR):
  case RFINDEX(REG_ECSR):
  case RFINDEX(REG_DSR): {
    PackState(pnBuffer, FLD_SELECT(nRegister));
    PackState(pnBuffer, FLD_MAP(nRegister));    
    break;
    
    
  case RFINDEX(REG_SSR): {
    *pnBuffer = 0xFFFF;
    
    break;
    
    
  case RFINDEX(REG_ECR): {
    int diff;
    if ((diff = ECL[0] - lLength) != 0){
      ConstantSetAll(RLIF, 1);
      if (diff < 0)
	Generate_Interrupt(CAM_CAM_INT_STATUS);
      else
	Generate_Interrupt(CAM_TIMEOUT_INT_STATUS);
    }
    
    else
      PackBits(pnBuffer, 0, lLength, (BYTE *) ECR, BIT32);
    
    break;
    
    
  case RFINDEX(REG_LIR): {
    PackState(pnBuffer, RFINDEX(REG_LIR));
    break;
    
    
  case RFINDEX(REG_LIPR): {
    PackState(pnBuffer, RFINDEX(REG_LIPR));
    break;
    
    
  case RFINDEX(REG_LIOR): {
    INT16 nLUTEntry, nLUTNextIndex;
    INT16 *pnLUT;
    int i, j;
    INT16 nImmediate[2];
    
    
    for (i = 0; i < lLength; i++) {
      nLUTNextIndex = 0;
      
      for (j = CHIPS_PER_MOD - 1; j >= 0; j--) {
	nLUTNextIndex <<= 1;
	if (LIPR[j] < 16)
	  nLUTNextIndex |= ((LIR[j] >> LIPR[j]) & 0x1);
	else if (LIPR[j] == 31)
	  nLUTNextIndex |= 0x1;
	LIR[j]++;
      }
      
      pnLUT = LIOR + nLUTNextIndex;                 
      
      *pnBuffer = *pnLUT;
      pnBuffer++;
    }
    
    break;
    
    
  case RFINDEX(REG_SIR): {
    PackState(pnBuffer, RFINDEX(REG_SIR));
    break;
    
    
  case RFINDEX(REG_SIPR): {
    int j;
    
    /* j counts which field of register */
    for(j = 0; j < SCAN_INDEX_LENGTH; j++)
      PackState(pnBuffer, RFINDEX(FLD_SSA(j)));
    break;
    
    
  case RFINDEX(REG_SIOR): {
    Cam8State.bByteMode = bByteMode;
    SIOR = (BYTE *) pnBuffer;
    
    if (Cam8State.bReadMode !=  TRUE) {
      bDestChange = TRUE;
      Cam8State.bReadMode =  TRUE;
    }
    
    Cam8State.WhyScan = RFINDEX(REG_SIOR);
    SimExecScan();
    break;
    
    
  case RFINDEX(REG_SFR): {
    PackState(pnBuffer, RFINDEX(FLD_SM));
    PackState(pnBuffer, RFINDEX(FLD_ESC));
    PackState(pnBuffer, RFINDEX(FLD_ESW));
    PackState(pnBuffer, RFINDEX(FLD_EST));
    PackState(pnBuffer, RFINDEX(FLD_SBRC));
    PackState(pnBuffer, RFINDEX(FLD_RCL));
    PackState(pnBuffer, RFINDEX(FLD_ECL));
    PackState(pnBuffer, RFINDEX(FLD_STM));
    
    break;
    
    
  case RFINDEX(REG_OSR): {
    PackState(pnBuffer, RFINDEX(REG_OSR));
    break;
    
    
  case RFINDEX(REG_DR): {
    PackState(pnBuffer, RFINDEX(FLD_DCM));
    PackState(pnBuffer, RFINDEX(FLD_XDCP));
    PackState(pnBuffer, RFINDEX(FLD_YDCP));
    PackState(pnBuffer, RFINDEX(FLD_ZDCP));
    
    break;
    
    
  case RFINDEX(REG_HER): {
    PackState(pnBuffer, RFINDEX(FLD_LPL));
    PackState(pnBuffer, RFINDEX(FLD_FPL));
    PackState(pnBuffer, RFINDEX(FLD_DCS));
    PackState(pnBuffer, RFINDEX(FLD_TBD));
    PackState(pnBuffer, RFINDEX(FLD_TMS));
    PackState(pnBuffer, RFINDEX(FLD_NBF));
    PackState(pnBuffer, RFINDEX(FLD_SRE));
    PackState(pnBuffer, RFINDEX(FLD_ALS));
    
    break;
    
    
  case RFINDEX(REG_MPCR): {
    PackState(pnBuffer, RFINDEX(FLD_MAFS));
    PackState(pnBuffer, RFINDEX(FLD_MBFS));
    
    break;
    
    
  case RFINDEX(REG_GPCR): {
    PackState(pnBuffer, RFINDEX(FLD_XMPC));
    PackState(pnBuffer, RFINDEX(FLD_XPPC));
    PackState(pnBuffer, RFINDEX(FLD_YMPC));
    PackState(pnBuffer, RFINDEX(FLD_YPPC));
    PackState(pnBuffer, RFINDEX(FLD_ZMPC));
    PackState(pnBuffer, RFINDEX(FLD_ZPPC));
    
    break;
    
    
  case RFINDEX(REG_MIDR): {
    PackState(pnBuffer, RFINDEX(REG_MIDR));
    
    break;
    
    
  case RFINDEX(REG_GIDR): {
    PackState(pnBuffer, RFINDEX(REG_GIDR));
    
    break;
    
    
  case RFINDEX(REG_IER): {
    PackState(pnBuffer, RFINDEX(FLD_BPIE));
    PackState(pnBuffer, RFINDEX(FLD_BCIE));
    PackState(pnBuffer, RFINDEX(FLD_GCIE));
    PackState(pnBuffer, RFINDEX(FLD_MAIE));
    PackState(pnBuffer, RFINDEX(FLD_MBIE));
    PackState(pnBuffer, RFINDEX(FLD_SSIE));
    PackState(pnBuffer, RFINDEX(FLD_XHIE));
    PackState(pnBuffer, RFINDEX(FLD_RLIE));
    PackState(pnBuffer, RFINDEX(FLD_URIE));
    PackState(pnBuffer, RFINDEX(FLD_ISIE));
    break;
    
    
  case RFINDEX(REG_IFR): {
    PackState(pnBuffer, RFINDEX(FLD_BPIF));
    PackState(pnBuffer, RFINDEX(FLD_BCIF));
    PackState(pnBuffer, RFINDEX(FLD_GCIF));
    PackState(pnBuffer, RFINDEX(FLD_MAIF));
    PackState(pnBuffer, RFINDEX(FLD_MBIF));
    PackState(pnBuffer, RFINDEX(FLD_SSIF));
    PackState(pnBuffer, RFINDEX(FLD_XHIF));
    PackState(pnBuffer, RFINDEX(FLD_RLIF));
    PackState(pnBuffer, RFINDEX(FLD_URIF));
    PackState(pnBuffer, RFINDEX(FLD_ISIF));
    
    break;
    
    
  case RFINDEX(REG_VWR): {
    PackState(pnBuffer, RFINDEX(FLD_VWE));
    PackState(pnBuffer, RFINDEX(FLD_VWIE));
    PackState(pnBuffer, RFINDEX(FLD_VWIF));
    break;
    
    
  case RFINDEX(REG_DOCR): {
    PackState(pnBuffer, RFINDEX(FLD_LDOC));
    PackState(pnBuffer, RFINDEX(FLD_HDOC));
    
    break;
    
    
  default: {
    
    fprintf(stderr, "Don't recognize register %d\n", nRegister);
    break;
  CaLib_tb.LEAVE();
void Cam8SimCore::DoKick(short p)
  register int i, j;
  LONG32 lSignBitOffset, lSignBitKick, lLowBitsKick;
  LONG32 lDCM;
  LONG32 lKA;
  CaLib_tb.ENTER("Cam8SimCore::DoKick");
  /************************************************************************/
  /* The kick and offset registers are two n-dimension-vectors, and the   */
  /* place where all dimensions end is determined by lDCMR. To subtract   */
  /* an n-dimension-kick from the corresponding offset, we first extract  */
  /* out the sign bits of both (by and-ing with lDCMR). Next, we set the  */
  /* most sig bits of every dimension in offset to 1, so that when we     */
  /* subtract out the kick, we don't borrow from the next higher          */
  /* dimension. Next, we subtract the value bits of kick (lowbits) from   */
  /* this offset. This will give the 'sign' bit of the new offset and its */
  /* value. The final sign bit of the offset is determined by :           */
  /*                                                                      */
  /*     sign bit = new sign bit xor (old sign bit xnor kick sign bit)    */
  /*                                                                      */
  /* To do the xnor operation, we simply store the inverse of the kick    */
  /* sign bit and then do an xor                                          */
  /*                                                                      */
  /* One easy way to derive this is to think of a sample dimension with   */
  /* 4 bits. Then, the bit positions have values  -8  4  2  1. The        */
  /* subtract operation as described above becomes (8 + 4*o.2 + 2*o.1 +   */
  /* 1*o.0 - 4*k.2 - 2*k.1 - 1*k.0) - 8 - 8*o.sign + 8.k.sign             */
  /* where o.X means the X'th bit of offset and k.X means the X'th bit of */
  /* kick. Since the final offset is of the form -8*o.sign + 4*o.2 +      */
  /* 2*o.1 + 1*o.o, we can express the sign bit as the above logical      */
  /* function of the three individual sign bits.                          */
  /*                                                                      */
  /************************************************************************/
  if (p == -1) {
    p = 0;
    j = CHIPS_PER_MOD;
  else
    j = p + 1;
  for(i = p; i < j; i++) {
    lSignBitOffset = OSR[i] & DCM[i];
    lSignBitKick = (~KA[i]) & DCM[i];
    OSR[i] |= DCM[i];
    lLowBitsKick =  KA[i] & (~ DCM[i]);
    
    OSR[i] -= lLowBitsKick;
    lSignBitOffset ^= lSignBitKick;
    OSR[i] ^= lSignBitOffset;
  CaLib_tb.LEAVE();
void Cam8SimCore::SimExecScan(void)
  int i;
  BOOL bNoPerm = TRUE;
  BOOL bNoPermLast5 = TRUE;
  LONG32 lLogScanLength = ESC[0] + 1L;
  CaLib_tb.ENTER("SimExecScan");  
  /************************************************************************/
  /* First, parse down the tree to see that we are going to update atleast*/
  /* 32 sites and that the lowest dimension extends over 32 bits. This    */
  /* second requirement is necessary because the optimized code can only  */
  /* handle dimension wraparounds at word boundaries.                     */
  /************************************************************************/
  if (lLogScanLength < 5)
    bNoPerm = bNoPermLast5 = FALSE;
  else if (lNumXBits < 5)
    bNoPerm = bNoPermLast5 = FALSE;
  else
    bNoPerm = bNoPermLast5 = TRUE;
  /************************************************************************/
  /* Now, determine if there is any permutation of the scan index in the  */
  /* bits of the SIR that will be significant over this scan.             */
  /************************************************************************/
  for (i = 0; i < MIN(5, ESC[0]); i++) {
    if (SIPR[i][0] != i) {
      bNoPerm = bNoPermLast5 = FALSE;
      break;
    }
    
    lLogScanLength--;
    
    if (!lLogScanLength)
      break;
  for (i = 5; i < MIN(SCAN_INDEX_LENGTH, ESC[0]); i++) {
    if (SIPR[i][0] != i)
      bNoPerm = FALSE;
    lLogScanLength--;
    if (!lLogScanLength)
      break;
#ifdef _FRAMEBUFFER_
  FRAME_ADDR = (LONG32) FRAMEb;
#endif _FRAMEBUFFER_
  if (bNoPerm)
    CheckNoPerm();
  else if (bNoPermLast5)
    SimGeneralScan();
  else
    SimGeneralScan();
  if (SCAN_INDEX_REG > 0xFFFFFF)
    SCAN_INDEX_REG = 0;
  SIR[0] = SCAN_INDEX_REG;
  CaLib_tb.LEAVE();
/*****************************************************************************/
/*                                                                           */
/* CheckNoPerm is necessary for the following reason - suppose there is no   */
/* permutation of the Scan Index, but suppose the the bits that extend over  */
/* the lowest dimension (ie, the bits to the _right_ of the lowest bit of    */
/* DCMR) are not all zeros. Then, the first sweep will not scan a multiple-  */
/* of-two number of sites, and we cannot do an optimized scan.               */
/*                                                                           */
/*****************************************************************************/
void Cam8SimCore::CheckNoPerm(void)
  LONG32 lSIRSigBits, lSIR;
  CaLib_tb.ENTER("CheckNoPerm");
  lSIRSigBits = MIN(ESC[0], lNumXBits);
  lSIR = SIR[0] & ~((~0x0) << lSIRSigBits);
  if ((lSIR == 0) && (MIN(lNumXBits, ESC[0]) >= 2)) {
    if (bForceGeneralScan)
      SimGeneralScan();
    else
      SimScanNoPerm();
  else
    SimGeneralScan();
  CaLib_tb.LEAVE();
void Cam8SimCore::SimUpdateSite(void)
  short i;
  LONG32 SiteDataSrc = UNGLUE_DATA;
  CaLib_tb.ENTER("SimUpdateSite");
  if (IsSrcNeeded(SRC_TBUS) &&
      ((CAM8State.WhyScan != RFINDEX(REG_SIOR)) || (!CAM8State.bReadMode))) {
    if (!CAM8State.bImmediate) {
      if (CAM8State.bByteMode) {
	TBUS_DATA = *((BYTE *) TBUS_ADDR);
	TBUS_ADDR += 1;
      }
      
      else {
	TBUS_DATA = *((INT16 *) TBUS_ADDR);
	TBUS_ADDR += 2;
      } /* else */
    } /* if (!CAM8State.bImmediate) */
  if (IsSrcNeeded(SRC_SITE_DATA)) {
    UNGLUE_DATA = 0;
    for (i = nNumPlanes-1; i >= 0; i--) {
      bit = HIGHB(PLANE_WORD[i]);
      PLANE_WORD[i] <<= 1; 
      UNGLUE_DATA = (UNGLUE_DATA << 1) | bit;
    }
  /* For Now glued and unglued data are the same */
  if (IsSrcNeeded(SRC_GLUED_DATA)) {
    if (!IsSrcNeeded(SRC_SITE_DATA)) {
      GLUE_DATA = 0;
      for (i = nNumPlanes-1; i >= 0; i--) {
	bit = HIGHB(PLANE_WORD[i]);
	PLANE_WORD[i] <<= 1; 
	GLUE_DATA = (GLUE_DATA << 1) | bit;
      }
    }
    else
      GLUE_DATA = UNGLUE_DATA;
  if (IsSrcNeeded(SRC_LUT)) {
    LUT_DATA = 0;
    if (IsSrcSame(DEST_LUT))
      BuildDest(DEST_LUT, &LUT_DATA, LAS[0], LAM[0]);           
    else
      BuildBitwiseDest(DEST_LUT, &LUT_DATA, LAS, LAM);
    LUT_DATA = (LONG32) (((INT16 *) LUT_ADDR)[LUT_DATA]);
  /************************************************************************/
  /*                                                                      */
  /* All the sources needed to update all the destinations should now be  */
  /* in place. Update all the destinations in the following order : EC,   */
  /* Display (ie, scan io reads), and Site Data. Note that Site data      */
  /* must be updated last, because it destroys the Site Data register,    */
  /* which is one of the possible Sources (unglued data).                 */
  /*                                                                      */
  /************************************************************************/
  if (IsDestUpdated(DEST_DISPLAY)) {
    if (IsSrcSame(DEST_DISPLAY))
      BuildDest(DEST_DISPLAY, &DISP_DATA, DDS[0], DDM[0]);
    else
      BuildBitwiseDest(DEST_DISPLAY, &DISP_DATA, DDS, DDM);
#ifdef _FRAMEBUFFER_
    *((BYTE *) FRAME_ADDR) = DISP_DATA;
    FRAME_ADDR += 1;
#endif
    
  /* SCAN-IO READ */
  if ((CAM8State.WhyScan == RFINDEX(REG_SIOR)) && CAM8State.bReadMode) {
    if (CAM8State.bByteMode) {
      *((BYTE *) SIOR) = (BYTE) DISP_DATA;
      SIOR += 1;
    }
    else {
      *((INT16 *) SIOR) = (INT16) DISP_DATA;
      SIOR += 2;
    }
  if (IsDestUpdated(DEST_EVENT_CT)) {
    if (IsSrcSame(DEST_EVENT_CT))
      BuildDest(DEST_EVENT_CT, &TEMP1, ECS[0], ECM[0]);
    else
      BuildBitwiseDest(DEST_EVENT_CT, &TEMP1, ECS, ECM);
    
    TEMP1 <<= (32 - nNumPlanes);
    for (i = nNumPlanes-1; i >= 0; i--) {
      EVENT_COUNT[i] += ((TEMP1 & 0x80000000) ? 0x1 : 0x0);
      TEMP1 <<= 1;
    }
  if (IsDestUpdated(DEST_SITE_DATA)) {
    if (IsSrcSame(DEST_SITE_DATA)) {
      if (SDM[0] == MAP_S) {
	SiteDataSrc = (SDS[0] == SRC_SITE_DATA ? UNGLUE_DATA :
		       SDS[0] == SRC_TBUS ? TBUS_DATA :
		       SDS[0] == SRC_LUT ? LUT_DATA : TEMP1);
      }
      
      else {
	BuildDest(DEST_SITE_DATA, &SITE_DATA, SDS[0], SDM[0]);
	SiteDataSrc = SITE_DATA;
      }
    }
    
    else {
      BuildBitwiseDest(DEST_SITE_DATA, &SITE_DATA, SDS, SDM);
      SiteDataSrc = SITE_DATA;
    }
    
    SiteDataSrc <<= (32 - nNumPlanes);
    for (i = nNumPlanes - 1; i >= 0; i--) {                                
      bit = HIGHB(SiteDataSrc);
      SiteDataSrc <<= 1;
      
      if ((IsSrcNeeded(SRC_SITE_DATA)) || (IsSrcNeeded(SRC_GLUED_DATA)))
	PLANE_WORD[i] |= bit;
      else
	PLANE_WORD[i] = (PLANE_WORD[i] << 1) | bit;
    }
  CaLib_tb.LEAVE();
void Cam8SimCore::SimScanNoPerm(void)
  LONG32 PLANE_CTR, WORD_ADDR, HIGH_BIT;
  CaLib_tb.ENTER("SimScanNoPerm");
  /************************************************************************/
  /* compute HIGH_BIT_MASK and X_HIGH_BIT_MASK				  */
  /************************************************************************/
  HIGH_BIT_MASK = lDCMRHighBit >> 3;
  X_HIGH_BIT_MASK = lDCMRLowBit >> 3;
  /************************************************************************/
  /* SITE_CTR is set to how many sweeps are to be done. X_BYTE_LENGTH is  */
  /* set to how many bytes will be updated per sweep                      */
  /************************************************************************/
  if (ESC[0] < lNumXBits) {
    SITE_CTR = 1;
    X_BYTE_LENGTH = 1 << (ESC[0] - 3);
  else {
    SITE_CTR = ScanLength() >> lNumXBits;                                  
    X_BYTE_LENGTH = lDCMRLowBit >> 2;
  nNumPlanes = CalcNumPlanes();
  if (nNumPlanes == 0) {
    CaLib_tb.LEAVE();
    return;
  /************************************************************************/
  /* Code starts here                                                     */
  /************************************************************************/
  while (SITE_CTR != 0) {
    SimSweepCode();
    for(PLANE_CTR = 0; PLANE_CTR < nNumPlanes; PLANE_CTR++) {  
      WORD_ADDR = NEXT_WORD_ADDR[PLANE_CTR];
      HIGH_BIT = WORD_ADDR & HIGH_BIT_MASK;
      WORD_ADDR &= (~ HIGH_BIT_MASK);
      WORD_ADDR += X_BYTE_LENGTH;
      WORD_ADDR ^= HIGH_BIT;
      NEXT_WORD_ADDR[PLANE_CTR] = WORD_ADDR;
      /*
      NEXT_WORD_ADDR[PLANE_CTR] =
	(((NEXT_WORD_ADDR[PLANE_CTR] & (~ HIGH_BIT_MASK)) + X_BYTE_LENGTH) ^
	 (NEXT_WORD_ADDR[PLANE_CTR] & HIGH_BIT_MASK));
	 */
    }
    SCAN_INDEX_REG += (X_BYTE_LENGTH << 3);
    if (SCAN_INDEX_REG > 0xFFFFFF)
      SCAN_INDEX_REG = 0;
    SITE_CTR--;
    ConstantSetAll(SIR, SCAN_INDEX_REG);
  CaLib_tb.LEAVE();
void Cam8SimCore::SimSweepCode(void)
  short i, j;
  LONG32 NBIT_OFFSET[CHIPS_PER_MOD], XWORD_LENGTH;
  CaLib_tb.ENTER("SimSweepCode");
  /************************************************************************/
  /* We assume here that the scan index is not permuted to arrive at the  */
  /* site address; however, some bits of the site address could be fixed  */
  /* at constant 0 or 1 as indicated by SIPR. Here, the site address of   */
  /* the first site to be updated is computed.                            */
  /************************************************************************/
  SITE_ADDR = 0;
  for (i = SCAN_INDEX_LENGTH-1; i >= 0; i--) {
    
    SITE_ADDR <<= 1;
    if (SIPR[i][0] == PERM_CONST_1)
      SITE_ADDR |= 0x1;
    else if (SIPR[i][0] != PERM_CONST_0)
      SITE_ADDR |= (SIR[0] >> i) & 0x1;
  /************************************************************************/
  /* Now that we know the site address of the first site to be updated,   */
  /* we compute the address in sparc memory of the word that contains     */
  /* a bit of that site by adding the plane offset to the site address.   */
  /************************************************************************/
  for (i = 0; i < nNumPlanes; i++) {
    NEXT_WORD_ADDR[i] = (AddSiteAddress(SITE_ADDR, OSR[i]) >> 5) << 2;
    NEXT_WORD_ADDR[i] += BIT_PLANE_ADDR[i];
    NBIT_OFFSET[i] = OSR[i] & 0x1F;
  XWORD_LENGTH = X_BYTE_LENGTH >> 2;
  SimLoadFirstWord(NBIT_OFFSET);
  X_CTR = XWORD_LENGTH;
  do {
    for (i = 0; i < 32; i++) {
      SimUpdateSite();
      for (j = 0; j < nNumPlanes; j++) {
	if (NBIT_OFFSET[j] == (31 - i))
	  SimGetNextWord(j);
      }
    }
    X_CTR -= 1;
  } while (X_CTR);
  SimSaveLastWord(NBIT_OFFSET);
  CaLib_tb.LEAVE();
void Cam8SimCore::SimLoadFirstWord(LONG32 NBIT_OFFSET[])
  short i;
  LONG32 SAVE_BITS, WORD_ADDR;
  CaLib_tb.ENTER("SimLoadFirstWord");
  for (i = 0; i < nNumPlanes; i++) {
    PLANE_WORD[i] = *((LONG32 *) NEXT_WORD_ADDR[i]);
    
    if (NBIT_OFFSET[i] != 0) {
      SAVE_BITS = PLANE_WORD[i] >> (32 - NBIT_OFFSET[i]);
      PLANE_WORD[i] <<= NBIT_OFFSET[i];
      PLANE_WORD[i] |= SAVE_BITS;
    }
  CaLib_tb.LEAVE();
void Cam8SimCore::SimGetNextWord(unsigned short nPlane)
  LONG32 ADDR_HIGH_BIT;
  BOOL bWriteBack = FALSE;
  short i;
  CaLib_tb.ENTER("SimGetNextWord");
  if (IsDestUpdated(DEST_SITE_DATA))
      *((LONG32 *) NEXT_WORD_ADDR[nPlane]) = PLANE_WORD[nPlane];
  if (lNumXBits <= 5) {
    CaLib_tb.LEAVE();
    return;
  ADDR_HIGH_BIT = NEXT_WORD_ADDR[nPlane] & X_HIGH_BIT_MASK;
  NEXT_WORD_ADDR[nPlane] &= (~ X_HIGH_BIT_MASK);
  NEXT_WORD_ADDR[nPlane] = (NEXT_WORD_ADDR[nPlane] + 4) ^ ADDR_HIGH_BIT;
  PLANE_WORD[nPlane] = *((LONG32 *) NEXT_WORD_ADDR[nPlane]);
  CaLib_tb.LEAVE();
void Cam8SimCore::SimSaveLastWord(LONG32 NBIT_OFFSET[])
  short i;
  LONG32 SAVE_BITS;
  CaLib_tb.ENTER("SimSaveLastWord");
  if (IsDestUpdated(DEST_SITE_DATA)) {
    for (i = 0; i < nNumPlanes; i++) {
      if (!NBIT_OFFSET[i])
	continue;
      SAVE_BITS = PLANE_WORD[i] >> NBIT_OFFSET[i];
      PLANE_WORD[i] <<= (32 - NBIT_OFFSET[i]);
      PLANE_WORD[i] |= SAVE_BITS;
      *((LONG32 *) NEXT_WORD_ADDR[i]) = PLANE_WORD[i];
    }
  CaLib_tb.LEAVE();
void Cam8SimCore::SimGeneralScan(void)
  short i;
  LONG32 PLANE_CTR;
  LONG32 SA_HIGH_BITS, OFF_HIGH_BITS, SCRATCH, PLANE_ADDR;
  LONG32 SWEEP_LENGTH, SA_OR_MASK, SA_AND_MASK, WORD_ADDR;
  nNumPlanes = CalcNumPlanes();
  CaLib_tb.ENTER("SimGeneralScan");
  if (nNumPlanes == 0) {
    CaLib_tb.LEAVE();
    return;
  /************************************************************************/
  /* First, update things in the heap from where they can be accessed     */
  /* by the compiled code.                                                */
  /************************************************************************/
  /************************************************************************/
  /* Update heap copy of DCMR.						  */
  /************************************************************************/
  DCMR = DCM[0];
  /************************************************************************/
  /* Update heap copy of OFFSETS					  */
  /************************************************************************/
  for(i = 0 ; i < CHIPS_PER_MOD; i++)
    OFFSETS[i] = OSR[i];
  /************************************************************************/
  /* Figure out the site address of the first site to be updated. This is */
  /* needed to update SITE_ADDR for display purposes. Also,               */
  /* compute the SAAndMask and SAOrMask which will be used to do the      */
  /* permutation at execution time.                                       */
  /************************************************************************/
  SITE_ADDR = 0;
  SA_OR_MASK = SA_AND_MASK = 0;
  for (i = SCAN_INDEX_LENGTH-1; i >= 0; i--) {
    
    SITE_ADDR <<= 1;
    SA_OR_MASK <<= 1;
    SA_AND_MASK <<= 1;
    
    if (SIPR[i][0] < SCAN_INDEX_LENGTH) {
      
	/* Get the correct bit of scan indx */
      SITE_ADDR |= (SIR[0] >> SIPR[i][0]) & 0x1;
      
      if (SIPR[i][0] == i)
	SA_AND_MASK |= 1;
    }
    
    /* Constant of 1 */
    else if (SIPR[i][0] == PERM_CONST_1) {
      SA_OR_MASK |= 1;
      SITE_ADDR |= 1;
    }
      
    else if (SIPR[i][0] != PERM_CONST_0)
      WARNING("Invalid SIPR value", "SimGenScan");
  /************************************************************************/
  /* Figure out how many sites will be updated, and how many sites/sweep  */
  /************************************************************************/
  SITE_CTR = ScanLength();
  SWEEP_LENGTH = SweepLength(&X_CTR);
  /************************************************************************/
  /* Next, generate the code. First, permute the scan index register to   */
  /* get the site address.                                                */
  /************************************************************************/
  while (SITE_CTR != 0) {
    SITE_ADDR = SCAN_INDEX_REG & SA_AND_MASK;
    SITE_ADDR |= SA_OR_MASK;
    
    for (i = SCAN_INDEX_LENGTH-1; i >= 0; i--) {
      if ((SIPR[i][0] < SCAN_INDEX_LENGTH) && (SIPR[i][0] != i)) {
	SCRATCH = SCAN_INDEX_REG << (31 - SIPR[i][0]);
	bit = HIGHB(SCRATCH);
	SITE_ADDR |= (bit << i);
      }
    }
    
    /************************************************************************/
    /* Now, add site address to the offset to get the DRAM address. The     */
    /* addition must break the carries at the dimension cuts. Also, DRAM    */
    /* address must be broken into a SPARC word address and a 5 bit offset  */
    /* into the word                                                        */
    /************************************************************************/
    
    SA_HIGH_BITS = SITE_ADDR & DCMR;
    SITE_ADDR = SITE_ADDR & (~ DCMR); 
    SITE_ADDR = (SITE_ADDR & (~ DCMR)) & SITE_ADDR_MASK;
    for(PLANE_CTR = 0; PLANE_CTR < nNumPlanes; PLANE_CTR++) {
      WORD_ADDR = OFFSETS[PLANE_CTR];
      OFF_HIGH_BITS = WORD_ADDR & DCMR;
      WORD_ADDR = SITE_ADDR + (WORD_ADDR & (~ DCMR));
      WORD_ADDR = (WORD_ADDR ^ OFF_HIGH_BITS) ^ SA_HIGH_BITS;
      PLANE_ADDR = BIT_PLANE_ADDR[PLANE_CTR];
      NEXT_WORD_ADDR[PLANE_CTR] = PLANE_ADDR + ((WORD_ADDR >> 5) << 2);
      BIT_OFFSETS[PLANE_CTR] = WORD_ADDR & 0x1F;
    }
  /************************************************************************/
  /* Now, the heap has the word addresses and bit offsets for the next    */
  /* site. So go ahead and update the site.                               */
  /************************************************************************/
    SimUpdateCode();
    if ((--X_CTR) == 0)
      X_CTR = SWEEP_LENGTH;
    
    if ((++SCAN_INDEX_REG) > 0xFFFFFF)
      SCAN_INDEX_REG = 0;
    
    SITE_CTR--;
    ConstantSetAll(SIR, SCAN_INDEX_REG);
  CaLib_tb.LEAVE();
void Cam8SimCore::SimUpdateCode(void)
  CaLib_tb.ENTER("SimUpdateCode");
  SimLoadPlaneWords();
  SimUpdateSite();
  SimSavePlaneWords();
  CaLib_tb.LEAVE();
void Cam8SimCore::SimLoadPlaneWords(void)
  short i;
  LONG32 WORD_ADDR, BIT_OFFSET, SAVE_BITS;
  CaLib_tb.ENTER("SimLoadPlaneWords");
  if (!IsSrcNeeded(SRC_SITE_DATA) && !IsSrcNeeded(SRC_GLUED_DATA) &&
      !IsDestUpdated(DEST_SITE_DATA)) {
    CaLib_tb.LEAVE();
    return;
  for (i = 0; i < nNumPlanes; i++) {
    WORD_ADDR = NEXT_WORD_ADDR[i];
    PLANE_WORD[i] = *((LONG32 *) WORD_ADDR);
    BIT_OFFSET = BIT_OFFSETS[i];
    SAVE_BITS = PLANE_WORD[i] >> (32 - BIT_OFFSET);
    PLANE_WORD[i] <<= BIT_OFFSET;
    PLANE_WORD[i] |= SAVE_BITS;
    PLANE_WORD[i] = (*((LONG32 *) NEXT_WORD_ADDR[i]) << BIT_OFFSETS[i]) |
                    (*((LONG32 *) NEXT_WORD_ADDR[i]) >> (32 - BIT_OFFSETS[i]));
  CaLib_tb.LEAVE();
void Cam8SimCore::SimSavePlaneWords(void)
  short i;
  LONG32 WORD_ADDR, BIT_OFFSET, SAVE_BITS;
  CaLib_tb.ENTER("SimSavePlaneWords");
  if (!IsDestUpdated(DEST_SITE_DATA)) {
    CaLib_tb.LEAVE();
    return;
  for (i = 0; i < nNumPlanes; i++) {
    BIT_OFFSET = BIT_OFFSETS[i];
    SAVE_BITS = PLANE_WORD[i] << (31 - BIT_OFFSET);
    PLANE_WORD[i] >>= (BIT_OFFSET + 1);
    PLANE_WORD[i] |= SAVE_BITS;
    WORD_ADDR = NEXT_WORD_ADDR[i];
    *((LONG32 *) WORD_ADDR) = PLANE_WORD[i];
    PLANE_WOR
D[i] = (PLANE_WORD[i] >> (BIT_OFFSETS[i] + 1)) |
                    (PLANE_WORD[i] << (31 - BIT_OFFSETS[i]));
    *((LONG32 *) NEXT_WORD_ADDR[i]) = PLANE_WORD[i];
  CaLib_tb.LEAVE();
}     
LONG32 * Cam8SimCore::PermuteScanIndex(void)
  short i;
  BOOL bIsPermuted = FALSE;
  CaLib_tb.ENTER("PermuteScanIndex");
  for (i = nNumPlanes - 1; i >= 0; i--) {
    if (SABSR[i] != i) {
      bIsPermuted = TRUE;
      break;
    }
  if (!bIsPermuted) {
    CaLib_tb.LEAVE();
    return(&SCAN_INDEX_REG);
  TEMP6 = 0;
  for (i = nNumPlanes-1; i >= 0; i--) {
    if (SABSR[i] < 24) {
      TEMP5 = SCAN_INDEX_REG << (31 - SABSR[i]);
      bit = HIGHB(TEMP6);
      TEMP6 = (TEMP6 << 1) | HIGHB(TEMP5);
      TEMP5 <<= 1;
    }
    else if (SABSR[i] == 31) {
      TEMP6 <<= 1;
      TEMP6 += 1;
    }
    else if (SABSR[i] == 30) {
      TEMP6 <<= 1;
    }
    else {
      WARNING("Invalid SABSR value!", "PermuteScanIndex");
      TEMP6 <<= 1;
    }
  CaLib_tb.LEAVE();
  return (&TEMP6);
void Cam8SimCore::MapFunction(LONG32 *SrcVar, LONG32 *DestVar, BYTE bMap)
  CaLib_tb.ENTER("MapFunction");
  switch (bMap) {
  case MAP_CONST_0: {
    *DestVar = 0;
    break;
    
  case MAP_G_NOR_S: {
    *DestVar = ~ (GLUE_DATA | *SrcVar);
    break;
}    
  case MAP_G_AND_S_BAR: {
    *DestVar = GLUE_DATA & (~ *SrcVar);
    break;
    
  case MAP_S_BAR: {
    *DestVar = ~ *SrcVar;
    break;
    
  case MAP_G_BAR_AND_S: {
    *DestVar = (~ GLUE_DATA) & *SrcVar;
    break;
    
  case MAP_G_BAR: {
    *DestVar = ~ GLUE_DATA;
    break;
    
  case MAP_G_XOR_S: {
    *DestVar = GLUE_DATA ^ *SrcVar;
    break;
    
  case MAP_G_NAND_S: {
    *DestVar = ~ (GLUE_DATA & *SrcVar);
    break;
    
  case MAP_G_AND_S: {
    *DestVar = GLUE_DATA & *SrcVar;
    break;
    
  case MAP_G_EQ_S: {
    *DestVar = ~ (GLUE_DATA ^ *SrcVar);
    break;
    
  case MAP_G: {
    *DestVar = GLUE_DATA;
    break;
    
  case MAP_G_OR_S_BAR: {
    *DestVar = GLUE_DATA | (~ *SrcVar);
    break;
    
  case MAP_S: {
    *DestVar = *SrcVar;
      break;
    
  case MAP_G_BAR_OR_S: {
    *DestVar = (~ GLUE_DATA) | *SrcVar;
      break;
    
  case MAP_G_OR_S: {
    *DestVar = GLUE_DATA | *SrcVar;
    break;
    
  case MAP_CONST_1: {
    *DestVar = 0xFFFFFFFF;
    break;
  CaLib_tb.LEAVE();
void Cam8SimCore::BuildDest(short nDest, LONG32 *DestVar, BYTE Src, BYTE Map)
  LONG32 *SrcVar;
  CaLib_tb.ENTER("BuildDest");
  if ((Map != MAP_G) && (Map != MAP_G_BAR)) {
    SrcVar = (Src == SRC_SITE_DATA ? &UNGLUE_DATA :
	      Src == SRC_TBUS ? &TBUS_DATA :
	      Src == SRC_LUT ? &LUT_DATA : &TEMP1);
    if ((nDest == DEST_LUT) && (Src == SRC_SITE_ADDRESS)) {
      SrcVar = PermuteScanIndex();
    }
  MapFunction(SrcVar, DestVar, Map);
  CaLib_tb.LEAVE();
void Cam8SimCore::BuildBitDest(short nDest, LONG32 *HoldReg, BYTE Src, BYTE Map,
		  unsigned short nPlane)
{                                                               
  CaLib_tb.ENTER("BuildBitDest");
  if ((nDest == DEST_LUT) && (Src == SRC_SITE_ADDRESS)) {
    TEMP6 = 0;
    if (SABSR[nPlane] < 24) {
      TEMP5 = SCAN_INDEX_REG << (31 - SABSR[nPlane]);
      bit = HIGHB(TEMP6);
      TEMP6 = ((TEMP6 << 1) | HIGHB(TEMP5)) << nPlane;
      TEMP5 <<= 1;
    }
    else if (SABSR[nPlane] == 31)
      TEMP6 = (TEMP6 << 1) + 1;
    else if (SABSR[nPlane] == 30)
      TEMP6 <<= 1;
    else {
      WARNING("Invalid SABSR value", "BuildBitDest");
      TEMP6 <<= 1;
    }
    MapFunction (&TEMP6, HoldReg, Map);
  else
    BuildDest(nDest, HoldReg, Src, Map);
  CaLib_tb.LEAVE();
void Cam8SimCore::BuildBitwiseDest(short nDest, LONG32 *DestVar, BYTE Src[], BYTE Map[])
  short i;
  LONG32 *HoldReg = &TEMP4;
  CaLib_tb.ENTER("BuildBitwiseDest");
  for (i = nNumPlanes - 1; i >= 0; i--) {
    BuildBitDest(nDest, HoldReg, Src[i], Map[i], i);
    *HoldReg <<= (31 - i);
    bit = HIGHB(*DestVar);
    *DestVar = (*DestVar << 1) | HIGHB(*HoldReg);
    *HoldReg <<= 1;
  CaLib_tb.LEAVE();
/*****************************************************************************/
/*                                                                           */
/* This routine adds two longs breaking the carries at positions indicated   */
/* by the Dimension Cut Mask Register (DCMR). The DCMR has a 1 bit at every  */
/* bit position where the carry needs to be cut.                             */
/*                                                                           */
/*****************************************************************************/
LONG32 Cam8SimCore::AddSiteAddress(LONG32 lSrc1, LONG32 lSrc2)
  LONG32 lHighBits1, lHighBits2;
  lHighBits1 = lSrc1 & DCM[0];
  lHighBits2 = lSrc2 & DCM[0];
  lSrc1 &= (~DCM[0]);
  lSrc2 &= (~DCM[0]);
  return( (lSrc1 + lSrc2) ^ lHighBits1 ^ lHighBits2 );
LONG32 Cam8SimCore::SubSiteAddress(LONG32 lSrc1, LONG32 lSrc2)
  LONG32 lSignBitOffset, lSignBitKick, lLowBitsKick;
  lSignBitOffset = lSrc1 & DCM[0];
  lSignBitKick = (~lSrc2) & DCM[0];
  lSrc1 |= DCM[0];
  lLowBitsKick = lSrc2 & (~ DCM[0]);
  lSrc1 -= lLowBitsKick;
  lSignBitOffset = lSignBitOffset ^ lSignBitKick;
  lSrc1 ^= lSignBitOffset;
/*****************************************************************************/
/*                                                                           */
/* Compute the Scan length - the number of sites that will be updated in     */
/* the current scan. Basically, it should be 2^ESCP, but we need to correct  */
/* for the fact that the SIR low-order bits might not be all zero            */
/*                                                                           */
/*****************************************************************************/
LONG32 Cam8SimCore::ScanLength(void)
  LONG32 lCarryOVFBit, lScanLength, lSIRBits;
  lCarryOVFBit = ESC[0];
  lScanLength = (1 << lCarryOVFBit);                                  
  lSIRBits = SIR[0] & (lScanLength - 1);
  lScanLength -= lSIRBits;
  return (lScanLength);
/*****************************************************************************/
/*                                                                           */
/* Determine the sweep length. The sweep length is given by either the low   */
/* bit of the DCMR or the ESCP (End-of-Scan-pointer) or the SFR register.    */
/* This is because the scan could update many lines of the lowest (X) dimen- */
/* sion, or could update just part of 1 line in the X dimension.             */
/*                                                                           */
/*****************************************************************************/
LONG32 Cam8SimCore::SweepLength(LONG32 *lFirstSweep)
  LONG32 lCarryOVFBit, lSweepLength;
  lCarryOVFBit = MIN(ESW[0], lNumXBits);
  lSweepLength = (1 << lCarryOVFBit);
  *lFirstSweep = (SIR[0] & (lSweepLength - 1));
  *lFirstSweep = lSweepLength - *lFirstSweep;
  return (lSweepLength);
/*****************************************************************************/
/*                                                                           */
/* DCMRHighBit returns a long with exactly one of the 32 bits set to 1. This */
/* bit position corresponds to the highest bit in the DCMR that has a 1.     */
/*                                                                           */
/*****************************************************************************/
LONG32 Cam8SimCore::DCMRHighBit(void)
  LONG32 lTemp1, lTemp2;                                                      
  lTemp1 = DCM[0];
  lTemp2 = 1;
  while (lTemp1 > 1) {
    lTemp1 >>= 1;
    lTemp2 <<= 1;
  return (lTemp2);
/*****************************************************************************/
/*                                                                           */
/* DCMRLowBit returns a long with exactly one of the 32 bits set to 1. This  */
/* bit position corresponds to the lowest bit in the DCMR that has a 1. We   */
/* refer to this lowest dimension generically as the X dimension.            */
/*                                                                           */
/*****************************************************************************/
LONG32 Cam8SimCore::DCMRLowBit(void)
  LONG32 lTemp1, lTemp2;
  lTemp1 = DCM[0];
  lTemp2 = 1;
  lNumXBits = 1;
  while ((lTemp1 != 0) && ((lTemp1 & 0x01) == 0)) {
    lTemp1 >>= 1;
    lTemp2 <<= 1;
    lNumXBits++;
  return (lTemp2);
void Cam8SimCore::UpdateDCMR(void)
  lDCMRHighBit = DCMRHighBit();
  lDCMRLowBit = DCMRLowBit();
/*****************************************************************************/
/*                                                                           */
/* The following are general purpose routines that conveniently answer       */
/* queries about the sources and destinations that need to be updated        */
/*                                                                           */
/*****************************************************************************/
/*****************************************************************************/
/*                                                                           */
/* Is a particular source needed? Only checks those planes that will be      */
/* updated or used during the next scan.                                     */
/*                                                                           */
/*****************************************************************************/
BOOL Cam8SimCore::IsSrcNeeded(short nSrc)
  short i, j;
  short nLastDest;
  nLastDest = (nSrc == SRC_TBUS ? DEST_LUT : DEST_DISPLAY);
  for (i = nNumPlanes - 1; i >= 0; i--) {
    for (j = DEST_SITE_DATA; j <= nLastDest; j++) {
      if (bDestSrcMatrix[i][j][nSrc]) {
	return TRUE;
      }
    }
  return FALSE;
/*****************************************************************************/
/*                                                                           */
/* Checks to see if the source/map is the same for all planes for the given  */
/* destination.                                                              */
/*                                                                           */
/*****************************************************************************/
BOOL Cam8SimCore::IsSrcSame(short nDest)
  short i;
  BYTE *src, *map;
  switch (nDest) {
  case DEST_SITE_DATA:
    src = SDS;
    map = SDM;
    break;
  case DEST_EVENT_CT:
    src = ECS;
    map = ECM;
    break;
  case DEST_DISPLAY:
    src = DDS;
    map = DDM;
    break;
  case DEST_LUT:
    src = LAS;
    map = LAM;
    break;
  default:
    return FALSE;
    break;
  for(i = 1; i < nNumPlanes; i++)
    if ((src[0] != src[i]) || (map[0] != map[i]))
      return FALSE;
  return TRUE;
/*****************************************************************************/
/*                                                                           */
/* See if a particular destination will be changed during the current scan   */
/*                                                                           */
/*****************************************************************************/
BOOL Cam8SimCore::IsDestUpdated(short nDest)
  short i, j;
  for (i = nNumPlanes-1; i >= 0; i--)
    for ( j = SRC_SITE_DATA; j <= SRC_CONST_DATA; j++)
      if (bDestSrcMatrix[i][nDest][j])
	return(TRUE);
  return(FALSE);
/*****************************************************************************/
/*                                                                           */
/* Calculate the number of planes that will be updated or used in the next   */
/* scan.                                                                     */
/*                                                                           */
/*****************************************************************************/
unsigned short Cam8SimCore::CalcNumPlanes(void)
  BOOL       bPlaneUsed[CHIPS_PER_MOD];
  short      i, j;
  memset ((char *) bPlaneUsed, 0, CHIPS_PER_MOD * sizeof(BOOL));
  UpdateDestSrcMatrix();
  for (i = CHIPS_PER_MOD-1; i >= 0; i--) {
    for (j = DEST_SITE_DATA; j <= DEST_DISPLAY; j++) {
      if ( bDestSrcMatrix[i][j][SRC_SITE_DATA] || 
	  bDestSrcMatrix[i][j][SRC_GLUED_DATA] ) {
	bPlaneUsed[i] = TRUE;
      }
    }
    
    if (!bPlaneUsed[i]) {
      for (j = SRC_TBUS; j <= SRC_CONST_DATA; j++) {
	if (bDestSrcMatrix[i][DEST_SITE_DATA][j]) {
	  bPlaneUsed[i] = TRUE;
      }
    }
    if (bPlaneUsed[i])
      break;
  }  
  return ((unsigned short) i + 1);
/*****************************************************************************/
/*                                                                           */
/* Updates a matrix of sources and destinations. There are 5 sources, 4 dest */
/* and 16 planes. In addition, there is a bit per destination indicating     */
/* whether the map field selects an inverse function or just the function.   */
/* Thus, the SrcDestMatrix is a 6x4x16 matrix.                               */
/*                                                                           */
/*****************************************************************************/
void Cam8SimCore::UpdateDestSrcMatrix(void)
  short      i;
  char       *szFuncName = "UpdateDestSrcMatrix";    
  memset((char *) bDestSrcMatrix, 0, CHIPS_PER_MOD*NUM_SRC*NUM_DEST);
  for (i = 0; i < CHIPS_PER_MOD; i++) {
    
    /*
     * If the source for the site is the site then don't bother to generate
     * code for this.  If the map selects only the glue lines then the source
     * selection is irrelevant.  If the map selects MAP_G then this is
     * effectively the same as selecting site as the source.  If the map
     * selects CONST_0 or CONST_1 then we handle this as a special case.
     */
    if (SDS[i] != SRC_SITE_DATA)
      bDestSrcMatrix[i][DEST_SITE_DATA][SDS[i]] = TRUE;
    if ((SDM[i] != MAP_S) && (SDM[i] != MAP_S_BAR)) {
      if (SDM[i] != MAP_G)
	bDestSrcMatrix[i][DEST_SITE_DATA][SRC_GLUED_DATA] = TRUE;
      if ((SDM[i] == MAP_CONST_0) || (SDM[i] == MAP_CONST_1)) {
	bDestSrcMatrix[i][DEST_SITE_DATA][SRC_CONST_DATA] = TRUE;
	bDestSrcMatrix[i][DEST_SITE_DATA][SRC_GLUED_DATA] = FALSE;
	bDestSrcMatrix[i][DEST_SITE_DATA][SDS[i]] = FALSE;
      }
      if ((SDM[i] == MAP_G) || (SDM[i] == MAP_G_BAR))
	bDestSrcMatrix[i][DEST_SITE_DATA][SDS[i]] = FALSE;
    }
    /*
     * If the source for the event counter is constant zero then don't bother
     * to generate code for this.  If the map selects only the glue lines then
     * the source selection is irrelevant.
     */
    bDestSrcMatrix[i][DEST_EVENT_CT][ECS[i]] = TRUE;
    if ((ECM[i] != MAP_S) && (ECM[i] != MAP_S_BAR)) {
      bDestSrcMatrix[i][DEST_EVENT_CT][SRC_GLUED_DATA] = TRUE;
      if ((ECM[i] == MAP_CONST_0) || (ECM[i] == MAP_CONST_1)) {
	if (ECM[i] == MAP_CONST_1)
	  bDestSrcMatrix[i][DEST_EVENT_CT][SRC_CONST_DATA] = TRUE;
	bDestSrcMatrix[i][DEST_EVENT_CT][SRC_GLUED_DATA] = FALSE;
	bDestSrcMatrix[i][DEST_EVENT_CT][ECS[i]] = FALSE;
      }
      if ((ECM[i] == MAP_G) || (ECM[i] == MAP_G_BAR))
 	bDestSrcMatrix[i][DEST_EVENT_CT][ECS[i]] = FALSE;
    }
    /*
     * If the source for the display is the host (tbus) then don't bother to
     * generate code for this.  If the map selects only the glue lines then
     * the source selection is irrelevant.
     */
    if ((DDS[i] != SRC_TBUS))
      bDestSrcMatrix[i][DEST_DISPLAY][DDS[i]] = TRUE;
    if ((DDM[i] != MAP_S) && (DDM[i] != MAP_S_BAR)) {
      bDestSrcMatrix[i][DEST_DISPLAY][SRC_GLUED_DATA] = TRUE;
      if ((DDM[i] == MAP_CONST_0) || (DDM[i] == MAP_CONST_1)) {
	bDestSrcMatrix[i][DEST_DISPLAY][SRC_CONST_DATA] = TRUE;
	bDestSrcMatrix[i][DEST_DISPLAY][SRC_GLUED_DATA] = FALSE;
	bDestSrcMatrix[i][DEST_DISPLAY][DDS[i]] = FALSE;
      }
      if ((DDM[i] == MAP_G) || (DDM[i] == MAP_G_BAR)) {
	bDestSrcMatrix[i][DEST_DISPLAY][DDS[i]] = FALSE;
      }
    }
    /*
     * If the map selects only the glue lines then the source selection is
     * irrelevant.
     */
    bDestSrcMatrix[i][D<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">

---------------------------------------------------------------------------

EST_LUT][LAS[i]] = TRUE;
    if ((LAM[i] != MAP_S) && (LAM[i] != MAP_S_BAR)) {
      bDestSrcMatrix[i][DEST_LUT][SRC_GLUED_DATA] = TRUE;
      if ((LAM[i] == MAP_CONST_0) || (LAM[i] == MAP_CONST_1)) {
	bDestSrcMatrix[i][DEST_LUT][SRC_CONST_DATA] = TRUE;
	bDestSrcMatrix[i][DEST_LUT][SRC_GLUED_DATA] = FALSE;
	bDestSrcMatrix[i][DEST_LUT][LAS[i]] = FALSE;
      }
      if ((LAM[i] == MAP_G) || (LAM[i] == MAP_G_BAR)) {
	bDestSrcMatrix[i][DEST_LUT][LAS[i]] = FALSE;
      }
    }
/* Unpack register of length < 32 bits or register field */
void Cam8SimCore::UnpackState(INT16 *base, int reg_fld, int imm)
  if (BITLEN(reg_fld) > 32) {
    WARNING("Can't unpack a register or field of len > 32", "UnpackState");
    UnpackBits(base, BITOFF(reg_fld), 32, imm, base_type[reg_fld].base,
	       base_type[reg_fld].type);
  else
    UnpackBits(base, BITOFF(reg_fld), BITLEN(reg_fld), imm,
	       base_type[reg_fld].base, base_type[reg_fld].type);
void Cam8SimCore::UnpackStateInto(INT16 *base, int reg_fld, int imm, BYTE *dest, int type)
  if (BITLEN(reg_fld) > 32) {
    WARNING("Can't unpack a register or field of len > 32", "UnpackStateInto");
    UnpackBits(base, BITOFF(reg_fld), 32, imm, dest, type);
  else
    UnpackBits(base, BITOFF(reg_fld), BITLEN(reg_fld), imm, dest, type);
/* Pack register of length < 32 bits or register field */
void Cam8SimCore::PackState(INT16 *base, int reg_fld)
  if (BITLEN(reg_fld) > 32) {
    WARNING("Can't pack a register or field of len > 32", "PackState");
    PackBits(base, BITOFF(reg_fld), 32, base_type[reg_fld].base,
	     base_type[reg_fld].type);
  else
    PackBits(base, BITOFF(reg_fld), BITLEN(reg_fld),
	     base_type[reg_fld].base, base_type[reg_fld].type);
void Cam8SimCore::PackStateFrom(INT16 *base, int reg_fld, BYTE *src, int type)
  if (BITLEN(reg_fld) > 32) {
    WARNING("Can't pack a register or field of len > 32", "PackStateFrom");
    PackBits(base, BITOFF(reg_fld), 32, src, type);
  else
    PackBits(base, BITOFF(reg_fld), BITLEN(reg_fld), src, type);

---------------------------------------------------------------------------

#include <CaLibStream++.H>
#include <CaLibError++.H>
#include <CaLibTrace++.H>
#include <CamLib++.H>
#include <Cam8SimJIT++.H>
#include "std++.H"
JIT_SymbolTable::JIT_SymbolTable(unsigned char *heapbase)
  CaLib_tb.ENTER("JIT_SymbolTable::JIT_SymbolTable");
  base = heapbase;
  cnt = 0;
  len = 64;
  tab = Calloc(len, sizeof(JIT_SymbolDetails));
  CaLib_tb.LEAVE();
JIT_SymbolTable::~JIT_SymbolTable(void)
unsigned long AddSymbol(unsigned long size, int priority, int regloc, char name[])
  unsigned long index;
  CaLib_tb.ENTER("JIT_SymbolTable::AddSymbol");
  if (len == cnt) {
    len *= 2;
    tab = Realloc(tab, len * sizeof(JIT_SymbolDetails));
  tab[cnt].priority = priority;
  tab[cnt].offset = (cnt == 0L ? 0L : tab[cnt - 1].offset + size);
  tab[cnt].regloc = regloc;
  tab[cnt].heapaddr = base + tab[cnt].offset;
  strncpy(tab[cnt].name, name, 64);
  index = cnt;
  cnt++;
  CaLib_tb.LEAVE();
  return(index);
unsigned long SymbolOffset(int index)
  CaLib_tb.ENTER("JIT_Sym

---------------------------------------------------------------------------

bolTable::SymbolOffset");
  CaLib_tb.LEAVE();
unsigned char *SymbolAddr(int index)
  CaLib_tb.ENTER("JIT_SymbolTable::SymbolAddr");
  CaLib_tb.LEAVE();
int SymbolPriority(int index)
  CaLib_tb.ENTER("JIT_SymbolTable::SymbolPriority");
  CaLib_tb.LEAVE();
int SymbolRegLoc(int index)
  CaLib_tb.ENTER("JIT_SymbolTable::SymbolRegLoc");
  CaLib_tb.LEAVE();
void NewBlock(CODEHANDLE hcodDest)
     void pushblk(void);
     
     /* save code block state */
     pushblk();
     /* point to new code block */
     hcodTarget = hcodDest;
     pcodNext = *hcodDest;
     lblNext = 0;
void EndBlock()
     void popblk(void);
     /* Free up all label records */
     FreeLabels();
     *pcodNext = 0L;
     /* Update caller's code handle */
     *hcodTarget = pcodNext;
     /* Restore previous block state */
     popblk(); 
CODELABEL NewLabel()
     return (lblNext++);
LABELREC *AddLabel(CODELABEL lblName, CODEPTR pcodLabelLoc, BOOL bValid)
     LABELREC	*plblrecNew;
     plblrecNew = (LABELREC *) MALLOC(sizeof(LABELREC), "AddLabel");
     plblrecNew->lblName = lblName;
     if ((plblrecNew->bValid = bValid) == TRUE) {
	  plblrecNew->lAddress = pcodLabelLoc;
     }
     plblrecNew->precNext = plblrecFirst;
     plblrecNew->prefFirst = NULL;
     plblrecFirst = plblrecNew;
     return (plblrecNew);
LABELREC *FindLabel(CODELABEL lblName)
     LABELREC *plblrecNext;
     for (plblrecNext = plblrecFirst;
	  (plblrecNext != NULL) && (plblrecNext->lblName != lblName);
	  plblrecNext = plblrecNext->precNext);
     return (plblrecNext);
CODEPTR GetLabelAddress(LABELREC *plblrec)
  if (plblrec->bValid)
    return (plblrec->lAddress);
  else
    return (NULL);
void AddLabelRef(LABELREC *plblrec, CODEPTR lAddress)
     LABELREF *prefNew;
     prefNew = (LABELREF *) MALLOC(sizeof(LABELREF), "AddLabelRef");
     prefNew->pcodRefLoc = lAddress;
     prefNew->prefNext = plblrec->prefFirst;
     plblrec->prefFirst = prefNew;
void FreeLabels()
     LABELREC *plblrec;
     while (plblrecFirst != NULL) {
	  plblrec = plblrecFirst;
	  plblrecFirst = plblrec->precNext;
	  FREE(plblrec, "FreeLabels");
     }
/*****************************************************************************/
/*                                                                           */
/* Simple stack manager for pushing and pop-ing code block states.	     */
/*                                                                           */
/*****************************************************************************/
void pushblk(void)
     CODEBLK *pNew;
     pNew = MALLOC(sizeof(CODEBLK), "icode : pushblk");
     pNew->hcodTarget = hcodTarget;
     pNew->pcodNext = pcodNext;
     pNew->lblNext = lblNext;
     pNew->plblrecFirst = plblrecFirst;
     
     pNew->pblkPrev = pblkTOS;
     pblkTOS = pNew;
     plblrecFirst = NULL;
void popblk(void)
     CODEBLK *pblkOld;
     if (!pblkTOS) {
	  CRITICAL_ERROR("I-Code Block stack underflow", "popblk");
     }
     hcodTarget = pblkTOS->hcodTarget;
     pcodNext = pblkTOS->pcodNext;
     lblNext = pblkTOS->lblNext;
     plblrecFirst = pblkTOS->plblrecFirst;
     pblkOld = pblkTOS;
     pblkTOS = pblkTOS->pblkPrev;
     FREE(pblkOld, "popblk");

---------------------------------------------------------------------------

#ifndef _CAM8SIMPICORE_H_
#define _CAM8SIMPICORE_H_
#include <CamLib++.H>
#include <Cam8Core++.H>
#include <PipeComm++.H>
#include "std++.H"
extern "C" {
#include <sys/types.h>
#include <sys/ipc.h>
#include <sys/shm.h>
#include <sys/mman.h>
/*****************************************************************************/
/********************************* DEFINES ***********************************/
/*****************************************************************************/
#ifdef __cplusplus
/*****************************************************************************/
/******************************** TEMPLATES **********************************/
/*****************************************************************************/
/*****************************************************************************/
/*************************** CLASSES & TYPEDEFS ******************************/
/*****************************************************************************/
struct interface_regs {
    
  LONG32 NLP;                          /* Next List Pointer            */
  LONG32 ISR;                          /* Reset/Interrupt Register     */
  LONG32 CIP;                          /* Current Instruction Pointer  */
  LONG32 PIP;                          /* Previous Instruction Pointer */
    
  LONG32 RER;                          /* Reset/Enable Register        */
  LONG32 DSL;                          /* Display Scan Length          */
  LONG32 DBL;                          /* Display Blank Length         */
typedef interface_regs *INTERFACE_REGS;
struct shm_details {
  key_t key;
  int id;
  unsigned char *buf;
class Cam8SimPICore : public Cam8Core {
public:
  interface_regs iregs;
  Cam8SimPICore(void);
  Cam8SimPICore(int, int, int);
  DECL_COPYCONST(Cam8SimPICore);
  virtual ~Cam8SimPICore(void);
  DECL_OPEQ(Cam8SimPICore);
  DECL_BZERO(Cam8SimPICore);
  DECL_BCOPY(Cam8SimPICore);
  DECL_BCMP(Cam8SimPICore);
  unsigned char * Malloc(int);
  unsigned char * Calloc(int, int);
  unsigned char * Realloc(unsigned char *, int);
  void ResetInterface(void);
  void InitInterface(void);
  void ExecuteSteplist(struct steplist_operation &);
  void Read_NLP(LONG32 *);
  void Read_ISR(LONG32 *);
  void Read_CIP(LONG32 *);
  void Read_PIP(LONG32 *);
  void Write_NLP(const LONG32 *);
  void Write_RER(const LONG32 *);
  void Write_DSL(const LONG32 *);
  void Write_DBL(const LONG32 *);
  inline void ReadCmdLine(int argc, char *argv[]);
  // These methods are used by the cam8sim subprocess
  void Generate_Interrupt(int);
  LONG32 * GetNextSteplist(void);
protected:
  static Cmdt simcmds[] = {
    { "smat", SHMAT },
    { "smdt", SHMDT },
    { "rdR0", READR0 },
    { "rdR1", READR1 },
    { "rdR2", READR2 },
    { "rdR3", READR3 },
    { "wrR0", WRITER0 },
    { "wrR1", WRITER1 },
    { "wrR2", WRITER2 },
    { "wrR3", WRITER3 },
    { "quit", QUIT }
  };
  PipeComm comm;
  int ShmCnt;
  int retv[2];
  int newsl;
  int sim_memfd;
  int sim_infd;
  int sim_outfd
  shm_details ShmTable[8192];
  int findidx(unsigned char *);
  unsigned char *SHMAT(char *, unsigned char *, unsigned char *);
  unsigned char *SHMDT(char *, unsigned char *, unsigned char *);
  unsigned char *READR0(char *, unsigned char *, unsigned char *);
  unsigned char *READR1(char *, unsigned char *, unsigned char *);
  unsigned char *READR2(char *, unsigned char *, unsigned char *);
  unsigned char *READR3(char *, unsigned char *, unsigned char *);
  unsigned char *WRITER0(char *, unsigned char *, unsigned char *);
  unsigned char *WRITER1(char *, unsigned char *, unsigned char *);
  unsigned char *WRITER2(char *, unsigned char *, unsigned char *);
  unsigned char *WRITER3(char *, unsigned char *, unsigned char *);
  unsigned char *QUIT(char *, unsigned char *, unsigned char *);
/*****************************************************************************/
/********************************* INLINES ***********************************/
/*****************************************************************************/
inline void Cam8SimPipeInterface::ReadCmdLine(int argc, char *argv[])
  register int i;
  for(i = 1; i < argc; i++) {
    if (strcmp(argv[i], "-fd") == 0) {
      sim_memfd = atoi(argv[i+1]);
      i++;
      continue;
    }
    if (strcmp(argv[i], "-in") == 0) {
      sim_infd = atoi(argv[i+1]);
      i++;
      continue;
    }
    if (strcmp(argv[i], "-out") == 0) {
      sim_outfd = atoi(argv[i+1]);
      i++;
      continue;
    }
    
#endif
/*****************************************************************************/
/******************************* PROTOTYPES **********************************/
/*****************************************************************************/
/*****************************************************************************/
/********************************* GLOBALS ***********************************/
/*****************************************************************************/
#endif
#include <CaLibStream++.H>
#include <CaLibError++.H>
#include <CaLibTrace++.H>
#include <CamLib++.H>
#include <Cam8Core++.H>
#include <Pipecomm++.H>
#include <Cam8SimPICore++.H>
#include "std++.H"
extern "C" {
#include <stdlib.h>
#include <string.h>
#include <sys/types.h>
#include <sys/ipc.h>
#include <sys/shm.h>
#include <sys/mman.h>
Cam8SimPICore::Cam8SimPICore(void)
  Bzero();
  ShmCnt = 0;
  InitInterface();
Cam8SimPICore::Cam8SimPICore(int mem, int in, int out)
  Bzero();
  ShmCnt = 0;
  sim_memfd = mem;
  sim_infd = in;
  sim_outfd = out;
  InitInterface();
Cam8SimPICore::~Cam8SimPICore(void)
STD_BZERO(Cam8SimPICore)
STD_BCOPY(Cam8SimPICore)
STD_BCMP(Cam8SimPICore)
int Cam8SimPICore::findidx(unsigned char *ptr)
  int i;
  if (ptr) {
    for (i = 0; i < ShmCnt; i++)
      if (ShmTable[i].buf == ptr)
	return(i);
    return(-1);
  else {
    for (i = 0; i < ShmCnt; i++)
      if (ShmTable[i].buf == NULL)
	return(i);
    
    if (ShmCnt == 8192)
      return(-1);
    else
      return(++ShmCnt);
unsigned char * Cam8SimPICore::Malloc(int size)
  int i;
  key_t key;
  int id;
  unsigned char *t;
  CaLib_tb.ENTER("Cam8SimPICore::Malloc");
  CaLibAbort((i = findidx(NULL)) < 0, "Shared memory table full");
  key = random();
  id = shmget(key, size, IPC_CREAT|IPC_EXCL|0777)
  CaLibAbort(id == -1, "shmget failed");
  t = (unsigned char *) shmat(id, NULL, 0);
  CaLibAbort(t == NULL, "shmat failed");
  ShmTable[i].key = key;
  ShmTable[i].id = id;
  ShmTable[i].buf = t;
  CaLib_tb.LEAVE();
  return(t);
unsigned char * Cam8SimPICore::Calloc(int num, int size)
  register unsigned char *t;
  CaLib_tb.ENTER("Cam8SimPICore::Calloc");
  t = Malloc(size * num);
  memset(t, 0, size * num);
  CaLib_tb.LEAVE();
  return(t);
unsigned char * Cam8SimPICore::Realloc(unsigned char *p, int size)
  register unsigned char *t;
  int i;
  CaLib_tb.ENTER("Cam8SimPICore::Realloc");
  CaLibWarning((i = findidx(p) < 0), "Unknown buffer");
  if (i >= 0) {
    CaLibWarning(shmdt(p) == -1, "shmdt failed");
    ShmTable[i].key = 0;
    ShmTable[i].id = 0;
    ShmTable[i].buf = NULL;
  t = Malloc(size);
  CaLib_tb.LEAVE();
  return(t);
void Cam8SimCore::ResetInterface(void)
  CaLib_tb.ENTER("Cam8SimCore::ResetInterface");
  /* Zero everything out to start off */
  bzero((char *) &iregs, sizeof(iregs));
  /* Enable all interrupts and exceptions */
  iregs.RER = CAM_ENABLE_NEWLIST_INT | CAM_ENABLE_TIMEOUT_INT |
              CAM_ENABLE_SBUS_INT | CAM_ENABLE_CAM_INT |
	      CAM_ENABLE_SOFT_INT | CAM_ENABLE_TIMEOUT_EXC |
	      CAM_ENABLE_CAMINT_EXC;
  /* Mark all interrupts as enabled */
  iregs.ISR = CAM_ENABLE_NEWLIST_INT | CAM_ENABLE_TIMEOUT_INT |
              CAM_ENABLE_SBUS_INT | CAM_ENABLE_CAM_INT |
	      CAM_ENABLE_SOFT_INT;
  /* Put us in wait-for-host mode */
  iregs.NLP |= CAM_WAIT_FOR_HOST;
  CaLib_tb.LEAVE();
void Cam8SimPICore::InitInterface(void)
  ResetInterface();
  comm.SetPipeDescriptors(sim_infd, sim_outfd);
  comm.SetPipeCmdTable(simcmds);
  comm.SetPipeMode(CAM_PIPEALL|CAM_PIPESILENT|CAM_PIPEFDPLX);
  newsl = FALSE;
void Cam8SimPICore::Generate_Interrupt(int type)
  CaLib_tb.ENTER("Cam8SimCore::Generate_Interrupt");
  iregs.ISR |= type;
  switch(type) {
  case CAM_CAM_INT_STATUS: {
    if ((iregs.RER & CAM_ENABLE_CAMINT_EXC) &&
	!(iregs.RER & CAM_DISABLE_CAMINT_EXC)) {
      iregs.NLP |= CAM_EXCEPTION_STATUS;
    }
    break;
  case CAM_TIMEOUT_INT_STATUS: {
    if ((iregs.RER & CAM_ENABLE_TIMEOUT_EXC) &&
	!(iregs.RER & CAM_DISABLE_TIMEOUT_EXC)) {
      iregs.NLP |= CAM_EXCEPTION_STATUS;
    }
    break;
  CaLib_tb.LEAVE();
void Cam8SimPICore::ExecuteSteplist(struct steplist_operation & slo)
  CaLib_tb.ENTER("Cam8SimPICore::ExecuteSteplist");
  // Copy slo to local buffer, resizing if needed and then write to NLP
  CaLib_tb.LEAVE();
LONG32 * Cam8SimPICore::GetNextSteplist(void)
  int rv;
  CaLib_tb.ENTER("Cam8SimPICore::GetNextSteplist");
  while (! newsl) {
    if ((rv = comm.ParsePipeMesg(NULL)) < CAM_PIPEALL) {
      /* There has been a fatal error */
      retv[0] = FATAL;
      comm.SendPipeMesg((unsigned char *) retv);
      CaLibDie("exiting\n");
    }
  newsl = FALSE;
  CaLib_tb.LEAVE();
  return((LONG32 *) (iregs.NLP & 0xFFFFFFF0));
void Cam8SimPICore::Read_NLP(LONG32 *v)
  int ecode;
  CaLib_tb.ENTER("Cam8SimPICore::Read_NLP");
  CaLibAbort(!v, "NULL Pointer");
  ecode = comm.TwoWayPipeCmd(NULL, "rdR0", NULL, NULL, (unsigned char *) v);
  CaLibAbort(ecode < 0);
  CaLib_tb.LEAVE()
void Cam8SimPICore::Read_ISR(LONG32 *v)
  int ecode;
  CaLib_tb.ENTER("Cam8SimPICore::Read_ISR");
  CaLibAbort(!v, "NULL Pointer");
  ecode = comm.TwoWayPipeCmd(NULL, "rdR1", NULL, NULL, (unsigned char *) v);
  CaLibAbort(ecode < 0);
  CaLib_tb.LEAVE()
void Cam8SimPICore::Read_CIP(LONG32 *v)
  int ecode;
  CaLib_tb.ENTER("Cam8SimPICore::Read_CIP");
  CaLibAbort(!v, "NULL Pointer");
  ecode = comm.TwoWayPipeCmd(NULL, "rdR2", NULL, NULL, (unsigned char *) v);
  CaLibAbort(ecode < 0);
  CaLib_tb.LEAVE()
void Cam8SimPICore::Read_PIP(LONG32 *v)
  int ecode;
  CaLib_tb.ENTER("Cam8SimPICore::Read_PIP");
  CaLibAbort(!v, "NULL Pointer");
  ecode = comm.TwoWayPipeCmd(NULL, "rdR3", NULL, NULL, (unsigned char *) v);
  CaLibAbort(ecode < 0);
  CaLib_tb.LEAVE()
void Cam8SimPICore::Write_NLP(const LONG32 *v)
  int ecode;
  CaLib_tb.ENTER("Cam8SimPICore::Write_NLP");
  CaLibAbort(!v, "NULL Pointer");
  ecode = comm.TwoWayPipeCmd(NULL, "wrR0", NULL, NULL, (unsigned char *) v);
  CaLibAbort(ecode < 0);
  CaLib_tb.LEAVE()
void Cam8SimPICore::Write_RER(const LONG32 *v)
  int ecode;
  CaLib_tb.ENTER("Cam8SimPICore::Write_RER");
  CaLibAbort(!v, "NULL Pointer");
  ecode = comm.TwoWayPipeCmd(NULL, "wrR1", NULL, NULL, (unsigned char *) v);
  CaLibAbort(ecode < 0);
  CaLib_tb.LEAVE()
void Cam8SimPICore::Write_DSL(const LONG32 *v)
  int ecode;
  CaLib_tb.ENTER("Cam8SimPICore::Write_DSL");
  CaLibAbort(!v, "NULL Pointer");
  ecode = comm.TwoWayPipeCmd(NULL, "wrR2", NULL, NULL, (unsigned char *) v);
  CaLibAbort(ecode < 0);
  CaLib_tb.LEAVE()
void Cam8SimPICore::Write_DBL(const LONG32 *v)
  int ecode;
  CaLib_tb.ENTER("Cam8SimPICore::Write_DBL");
  CaLibAbort(!v, "NULL Pointer");
  ecode = comm.TwoWayPipeCmd(NULL, "wrR3", NULL, NULL, (unsigned char *) v);
  CaLibAbort(ecode < 0);
  CaLib_tb.LEAVE()
/* PipeComm routines */
unsigned char *SHMAT(char *appdata, unsigned char *o, unsigned char *d)
  int i, shmid = *((int *) d);
  retv[0] = NOERR;
  retv[1] = NOERR;
  CaLibAbort((i = finidx(NULL)) < 0, "Shared memory table full");
  if ((retv[1] = (int) shmat(shmid, (const void *) NULL, NULL)) != -1) {
    ShmTable[i].id = shmid;
    ShmTable[i].buf = (unsigned char *) retv[1];
  return((unsigned char *) retv);
unsigned char *SHMDT(char *appdata, unsigned char *o, unsigned char *d)
  int i;
  unsigned char *p = *((unsigned char **) d);
  retv[0] = NOERR;
  retv[1] = NOERR;
  i = findidx(p);
  if (i < 0) {
    CaLibWarning(TRUE, "Unknown buffer");
    retv[1] = -1;
  else {
    if ((retv[1] = shmdt(p)) != -1) {
      ShmTable[i].key = 0;
      ShmTable[i].id = 0;
      ShmTable[i].buf = NULL;
    }
    else
      CaLibWarning(TRUE, "shdt failed");
  return((unsigned char *) retv);
unsigned char *READR0(char *appdata, unsigned char *o, unsigned char *d)
  retv[0] = NOERR;
  retv[1] = iregs.NLP;
  return((unsigned char *) retv);
unsigned char *READR1(char *appdata, unsigned char *o, unsigned char *d)
  retv[0] = NOERR;
  retv[1] = iregs.ISR;
  /* Turn off interrupt flags and unused bits, leave enables the same */
  iregs.ISR &= 0x00001F00;
  return((unsigned char *) retv);
unsigned char *READR2(char *appdata, unsigned char *o, unsigned char *d)
  retv[0] = NOERR;
  retv[1] = iregs.CIP;
  return((unsigned char *) retv);
unsigned char *READR3(char *appdata, unsigned char *o, unsigned char *d)
  retv[0] = NOERR;
  retv[1] = iregs.PIP;
  return((unsigned char *) retv);
unsigned char *WRITER0(char *appdata, unsigned char *o, unsigned char *d)
  LONG32 tmp = iregs.NLP & 0xF;
  if (!(iregs.NLP & CAM_EXCEPTION_STATUS)) {
    iregs.NLP = tmp | (*((int *) d) & 0xFFFFFFF0);
    newsl = TRUE;
  retv[0] = NOERR;
  return((unsigned char *) retv);
unsigned char *WRITER1(char *appdata, unsigned char *o, unsigned char *d)
  iregs.RER = *((int *) d);
  if (iregs.RER & CAM_RESET_INTERFACE) {
    ResetInterface();
  if (iregs.RER & CAM_HALT_INTERFACE)
    iregs.NLP |= CAM_INTERFACE_HALTED;
  if (iregs.RER & CAM_ENABLE_TIMEOUT_EXC)
    iregs.NLP &= ~(CAM_EXCEPTION_STATUS);
  /*  This is supposed to also resume after error ack, whatever that is
  if (iregs.RER & CAM_ENABLE_CAMINT_EXC)
  */
  if (iregs.RER & CAM_ENABLE_NEWLIST_INT)
    iregs.ISR |= CAM_ENABLE_NEWLIST_INT;
  if (iregs.RER & CAM_ENABLE_TIMEOUT_INT)
    iregs.ISR |= CAM_ENABLE_TIMEOUT_INT;
  if (iregs.RER & CAM_ENABLE_SBUS_INT)
    iregs.ISR |= CAM_ENABLE_SBUS_INT;
  if (iregs.RER & CAM_ENABLE_CAM_INT)
    iregs.ISR |= CAM_ENABLE_CAM_INT;
  if (iregs.RER & CAM_ENABLE_SOFT_INT)
    iregs.ISR |= CAM_ENABLE_SOFT_INT;
  if (iregs.RER & CAM_DISABLE_NEWLIST_INT)
    iregs.ISR &= ~(CAM_ENABLE_NEWLIST_INT);
  if (iregs.RER & CAM_DISABLE_TIMEOUT_INT)
    iregs.ISR &= ~(CAM_ENABLE_TIMEOUT_INT);
  if (iregs.RER & CAM_DISABLE_SBUS_INT)
    iregs.ISR &= ~(CAM_ENABLE_SBUS_INT);
  if (iregs.RER & CAM_DISABLE_CAM_INT)
    iregs.ISR &= ~(CAM_ENABLE_CAM_INT);
  if (iregs.RER & CAM_ENABLE_SOFT_INT)
    iregs.ISR |= CAM_ENABLE_SOFT_INT;
  retv[0] = NOERR;
  return((unsigned char *) retv);
unsigned char *WRITER2(char *appdata, unsigned char *o, unsigned char *d)
  iregs.DSL = *((int *) d);
  retv[0] = NOERR;
  return((unsigned char *) retv);
unsigned char *WRITER3(char *appdata, unsigned char *o, unsigned char *d)
  iregs.DBL = *((int *) d);
  retv[0] = NOERR;
  return((unsigned char *) retv);
unsigned char *QUIT(char *appdata, unsigned char *o, unsigned char *d)
  retv[0] = NOERR;
  qflag = -1;
  return((unsigned char *) retv);
Cam8SimSPARCCore++.XC
0100664
0000764
0000764
00000067611
07165545051
014157
ustar  
gilliam
gilliam
#include <CaLibStream++.H>
#include <CaLibError++.H>
#include <CaLibTrace++.H>
#include <CamLib++.H>
#include <Cam8Core++.H>
#include <Cam8SimCore++.H>
#include <Cam8SimSPARCCore++.H>
#include "std++.H"
Cam8SimSPARCCore::Cam8SimSPARCCore(void)
Cam8SimSPARCCore::~Cam8SimSPARCCore(void)
STD_BZERO(Cam8SimSPARCCore)
STD_BCOPY(Cam8SimSPARCCore)
STD_BCMP(Cam8SimSPARCCore)
int SimCompScan(void)
  int i;
  BOOL bNoPerm = TRUE;
  BOOL bNoPermLast5 = TRUE;
  CODEPTR pcodCurrent;
  CODEHANDLE hcodCurrent;
  LONG32 lLogScanLength = ESC[0] + 1L;
  EP("SimCompScan");  
  /************************************************************************/
  /* First, parse down the tree to see that we are going to update atleast*/
  /* 32 sites and that the lowest dimension extends over 32 bits. This    */
  /* second requirement is necessary because the optimized code can only  */
  /* handle dimension wraparounds at word boundaries.                     */
  /************************************************************************/
  if (lLogScanLength < 5)
    bNoPerm = bNoPermLast5 = FALSE;
  else if (lNumXBits < 5)
    bNoPerm = bNoPermLast5 = FALSE;
  else
    bNoPerm = bNoPermLast5 = TRUE;
  /************************************************************************/
  /* Now, determine if there is any permutation of the scan index in the  */
  /* bits of the SIR that will be significant over this scan.             */
  /************************************************************************/

---------------------------------------------------------------------------

for (i = 0; i < MIN(5, ESC[0]); i++) {
    if (SIPR[i][0] != i) {
      bNoPerm = bNoPermLast5 = FALSE;
      break;
    }
    
    lLogScanLength--;
    
    if (!lLogScanLength)
      break;
  for (i = 5; i < MIN(SCAN_INDEX_LENGTH, ESC[0]); i++) {
    if (SIPR[i][0] != i)
      bNoPerm = FALSE;
    lLogScanLength--;
    if (!lLogScanLength)
      break;
#ifdef _FRAMEBUFFER_
  FRAME = (LONG32) FRAMEb;
#endif _FRAMEBUFFER_
  pcodCurrent = pcodScanner;
  hcodCurrent = &pcodCurrent;
  SimPrologue(hcodCurrent);
  if (bNoPerm)
    CheckNoPerm(hcodCurrent);
  else if (bNoPermLast5)
    SimGeneralScan(hcodCurrent);
  else
    SimGeneralScan(hcodCurrent);
  SimEpilogue(hcodCurrent);
  LP("SimCompScan");
/*****************************************************************************/
/*                                                                           */
/* CheckNoPerm is necessary for the following reason - suppose there is no   */
/* permutation of the Scan Index, but suppose the the bits that extend over  */
/* the lowest dimension (ie, the bits to the _right_ of the lowest bit of    */
/* DCMR) are not all zeros. Then, the first sweep will not scan a multiple-  */
/* of-two number of sites, and we cannot do an optimized scan.               */
/*                                                                           */
/*****************************************************************************/
void CheckNoPerm(CODEHANDLE hcodCurrent)
  LONG32 lSIRSigBits, lSIR;
  EP("CheckNoPerm");
  lSIRSigBits = MIN(ESC[0], lNumXBits);
  lSIR = SIR[0] & ~((~0x0) << lSIRSigBits);
  if ((lSIR == 0) && (MIN(lNumXBits, ESC[0]) >= 2)) {
    if (bForceGeneralScan)
      SimGeneralScan(hcodCurrent);
    else
      SimScanNoPerm(hcodCurrent);
  else
    SimGeneralScan(hcodCurrent);
  LP("CheckNoPerm");
void SimPrologue(CODEHANDLE hcodCurrent)
  EP("SimPrologue");
  NewBlock(hcodCurrent);
  .ENTER_PROC;
  LP("SimPrologue");
}     
void SimEpilogue(CODEHANDLE hcodCurrent)
  EP("SimEpilogue");
 .RETURN_PROC;
  EndBlock();
  LP("SimEpilogue");
void SimExecScan()
  void (*fScan)(void);
  fScan = (void (*)()) pcodScanner;
  (*fScan)();
  ConstantSetAll(SIR, SCAN_INDEX_REG);
void SimUpdateSite()
  short i;
  CODEPTR pcodCurrent = pcodUpdateSite;
  EP("SimUpdateSite");
#ifdef _INCREMENTAL_COMPILE_     
  if (!(bSourceRegChange || bDestChange)) {
    LP("SimUpdateSite");
    return;
  else {
    bSourceRegChange = FALSE;
    bDestChange = FALSE;
#endif
  NewBlock(&pcodCurrent);
  .ENTER_LEAF,   
  if (IsSrcNeeded(SRC_TBUS) &&
      ((CAM8State.WhyScan != RFINDEX(REG_SIOR)) || (!CAM8State.bReadMode))) {
    if (!CAM8State.bImmediate) {
      if (CAM8State.bByteMode) {
	.LDUB_IND   iTbusAddr, #0, iTbusData;
	.ADD iTbusAddr, #1, iTbusAddr;
      } 
      
      else {
	.LDHW_IND iTbusAddr, #0, iTbusData;
	.ADD iTbusAddr, #2, iTbusAddr;
      }
    }
  if (IsSrcNeeded(SRC_SITE_DATA)) {
    .OR %G0, %G0, iUnGlueData;
    for (i = nNumPlanes-1; i >= 0; i--) {      
      .ADDcc (iPlaneWord+i), (iPlaneWord+i), (iPlaneWord+i);
      .ADDX iUnGlueData, iUnGlueData, iUnGlueData;
    }
  }  
  /* For Now glued and unglued data are the same */
  if (IsSrcNeeded(SRC_GLUED_DATA)) {
    if (!IsSrcNeeded(SRC_SITE_DATA)) {
      .OR %G0, %G0, iGlueData;
      for (i = nNumPlanes-1; i >= 0; i--) {      
	.ADDcc (iPlaneWord+i), (iPlaneWord+i), (iPlaneWord+i);
	.ADDX iGlueData, iGlueData, iGlueData;
      }
    }
    else {
      .OR %G0, iUnGlueData, iGlueData;
    }
  if (IsSrcNeeded(SRC_LUT)) {
    .OR   %G0, %G0, iLutData;
    if (IsSrcSame(DEST_LUT))
      BuildDest(DEST_LUT, iLutData, LAS[0], LAM[0]);            
    else
      BuildBitwiseDest(DEST_LUT, iLutData, LAS, LAM);
    .SH_LEFT      iLutData, #1, iLutData;
    .LDHW_IND     iLutAddr, iLutData, iLutData;
  /************************************************************************/
  /*                                                                      */
  /* All the sources needed to update all the destinations should now be  */
  /* in place. Update all the destinations in the following order : EC,   */
  /* Display (ie, scan io reads), and Site Data. Note that Site data      */
  /* must be updated last, because it destroys the Site Data register,    */
  /* which is one of the possible Sources (unglued data).                 */
  /*                                                                      */
  /************************************************************************/
  if (IsDestUpdated(DEST_DISPLAY)) {
    if (IsSrcSame(DEST_DISPLAY))
      BuildDest(DEST_DISPLAY, iTemp1, DDS[0], DDM[0]);
    else
      BuildBitwiseDest(DEST_DISPLAY, iTemp1, DDS, DDM);
#ifdef _FRAMEBUFFER_
    .STUB_IND iFrame, #0, iTemp1;
    .ADD iFrame, #1, iFrame;
#endif
  /* SCAN-IO READ */
  if ((CAM8State.WhyScan == RFINDEX(REG_SIOR)) && CAM8State.bReadMode) {
    if (CAM8State.bByteMode) {
      .STUB_IND iSIOR, #0, iTemp1;
      .ADD iSIOR, #1, iSIOR;
      }
    else {
      .STHW_IND iSIOR, #0, iTemp1;
      .ADD iSIOR, #2, iSIOR;
    }
  if (IsDestUpdated(DEST_EVENT_CT)) {
    if (IsSrcSame(DEST_EVENT_CT))
      BuildDest(DEST_EVENT_CT, iTemp1, ECS[0], ECM[0]);
    else
      BuildBitwiseDest(DEST_EVENT_CT, iTemp1, ECS, ECM);
    
    .SH_LEFT iTemp1, #(32 - nNumPlanes), iTemp1;
    for (i = nNumPlanes-1; i >= 0; i--) {
      .LDW_IND %DS, #(offEventCount+(i<<2)), iTemp2;
      .ADDcc iTemp1, iTemp1, iTemp1;
      .ADDX iTemp2, #0, iTemp2;
      .STW_IND %DS, #(offEventCount+(i<<2)), iTemp2;
    }
  if (IsDestUpdated(DEST_SITE_DATA)) {
    if (IsSrcSame(DEST_SITE_DATA)) {
      if (SDM[0] == MAP_S) {
	switch(SDS[0]) {
	case SRC_SITE_DATA: {
	  .OR %G0, iUnGlueData, iSiteDataSrc;
	  break;
	case SRC_TBUS: {
	  .OR %G0, iTbusData, iSiteDataSrc;
	  break;
	case SRC_LUT: {
	  .OR %G0, iLutData, iSiteDataSrc;
	  break;
	default: {
	  .OR %G0, iTemp1, iSiteDataSrc;
	  break;
      }
      else
	BuildDest(DEST_SITE_DATA, iSiteDataSrc, SDS[0], SDM[0]);
    }    
    else
      BuildBitwiseDest(DEST_SITE_DATA, iSiteDataSrc, SDS, SDM);
    .SH_LEFT iSiteDataSrc, #(32 - nNumPlanes), iSiteDataSrc;
    for (i = nNumPlanes - 1; i >= 0; i--) {                                
      .ADDcc iSiteDataSrc, iSiteDataSrc, iSiteDataSrc;
      
      if ((IsSrcNeeded(SRC_SITE_DATA)) || (IsSrcNeeded(SRC_GLUED_DATA))) {
	.ADDX (iPlaneWord+i), #0, (iPlaneWord+i);
      }
      else {
	.ADDX (iPlaneWord+i), (iPlaneWord+i), (iPlaneWord+i);
      }
    }
  .RETURN_LEAF;
    
  EndBlock();
  LP("SimUpdateSite");
void SimScanNoPerm(CODEHANDLE hcodCurrent)
  LONG32 lTemp1, lTemp2;
  CODELABEL lblYLoop, lblAddrLoop, lblSkip;
  const short iPlaneCtr = iTemp1,
  iHeapOffset = iTemp2,
  iWordAddr = iTemp3,
  iHighBit = iTemp4;
  EP("SimScanNoPerm");
  lblSkip = NewLabel();
  lblYLoop = NewLabel();
  lblAddrLoop = NewLabel();
  /************************************************************************/
  /* Sim assuming the scan index is not permuted. This implies that   */
  /* bits to be updated during this scan are all consecutive.             */
  /************************************************************************/
  /************************************************************************/
  /* compute HIGH_BIT_MASK and X_HIGH_BIT_MASK				  */
  /************************************************************************/
  HIGH_BIT_MASK = lDCMRHighBit >> 3;
  X_HIGH_BIT_MASK = lDCMRLowBit >> 3;
  /************************************************************************/
  /* SITE_CTR is set to how many sweeps are to be done. X_BYTE_LENGTH is  */
  /* set to how many bytes will be updated per sweep                      */
  /************************************************************************/
  if (ESC[0] < lNumXBits) {
    SITE_CTR = 1;
    X_BYTE_LENGTH = 1 << (ESC[0] - 3);
  else {
    SITE_CTR = ScanLength() >> lNumXBits;                                  
    X_BYTE_LENGTH = lDCMRLowBit >> 2;
  nNumPlanes = CalcNumPlanes();
  /************************************************************************/
  /* Code starts here                                                     */
  /************************************************************************/
  .LDW_MEM iSiteCtr;
  .ADD_LABEL :lblYLoop;
  SimSweepCode();
  .CALL_PROC [pcodSweep];
  .NO_OP;
  .ADD %DS, #offNextWordAddr, iHeapOffset;
  .LDW_MEM iHighBitMask;
  .LDW_MEM iXByteLength;
  .ADD %G0, #0, iPlaneCtr;
  .ADD_LABEL :lblAddrLoop;
  .SUBcc iPlaneCtr, #(nNumPlanes*4), %G0;
  .BR_GRE :lblSkip;
  .LDW_IND iHeapOffset, iPlaneCtr, iWordAddr;
  .AND iHighBitMask, iWordAddr, iHighBit;
  .XNOR iHighBitMask, %G0, iHighBitMask;
  .AND iHighBitMask, iWordAddr, iWordAddr;
  .ADD iXByteLength, iWordAddr, iWordAddr;
  .XOR iHighBit, iWordAddr, iWordAddr;
  .STW_IND iHeapOffset, iPlaneCtr, iWordAddr;
  .ADD iPlaneCtr, #4, iPlaneCtr;
  .BRANCH :lblAddrLoop;
  .XNOR iHighBitMask, %G0, iHighBitMask;
  .ADD_LABEL :lblSkip;
  .SH_LEFT iXByteLength, #3, iTemp1;
  .LDW_MEM iScanIndexReg;
  .ADD iScanIndexReg, iTemp1, iScanIndexReg;
  .SUBcc iScanIndexReg, #0xFFFFFF, iTemp1;
  .BR_L :lblSkip;
  .NO_OP;
  .OR %G0, %G0, iScanIndexReg;
  .ADD_LABEL :lblSkip;
  .SUBcc iSiteCtr, #1, iSiteCtr;
  .BR_NZ :lblYLoop;
  .STW_MEM iScanIndexReg;
  LP("SimScanNoPerm");
void SimSweepCode()
  LONG32 xWordLength;
  CODELABEL lblXLoop;
  unsigned short nBitOffset[CHIPS_PER_MOD];
  short i, j;
  CODEPTR pcodCurrent = pcodSweep;
  EP("SimSweepCode");
  lblXLoop = NewLabel();
  /************************************************************************/
  /* We assume here that the scan index is not permuted to arrive at the  */
  /* site address; however, some bits of the site address could be fixed  */
  /* at constant 0 or 1 as indicated by SIPR. Here, the site address of   */
  /* the first site to be updated is computed.                            */
  /************************************************************************/
  SITE_ADDR = 0;
  for (i = SCAN_INDEX_LENGTH-1; i >= 0; i--) {
    
    SITE_ADDR <<= 1;
    if (SIPR[i][0] == PERM_CONST_1)
      SITE_ADDR |= 0x1;
    else if (SIPR[i][0] != PERM_CONST_0)
      SITE_ADDR |= (SIR[0] >> i) & 0x1;
  /************************************************************************/
  /* Now that we know the site address of the first site to be updated,   */
  /* we compute the address in sparc memory of the word that contains     */
  /* a bit of that site by adding the plane offset to the site address.   */
  /************************************************************************/
  for (i = 0; i < nNumPlanes; i++) {
    NEXT_WORD_ADDR(i) = (AddSiteAddress(SITE_ADDR, OSR[i]) >> 5) << 2;
    NEXT_WORD_ADDR(i) += BIT_PLANE_ADDR(i);
    nBitOffset[i] = OSR[i] & 0x1F;
  xWordLength = X_BYTE_LENGTH >> 2;
  NewBlock(&pcodCurrent);
  .ENTER_PROC;
  SimLoadFirstWord(nBitOffset);
  if (IsSrcNeeded(SRC_SITE_ADDRESS)) {
    .LDW_MEM iScanIndexReg;
  if (IsSrcNeeded(SRC_LUT)) {
    .LDW_MEM iLutAddr;
  .LDW_MEM iUpdateSiteProc;
  .ADD %G0, #xWordLength, iXCtr;
  .ADD_LABEL :lblXLoop;
  SimUpdateSite();
  for (i = 0; i < 32; i++) {
    .CALL_LEAF_IND iUpdateSiteProc, #4;
    .INSTR *pcodUpdateSite;
    for (j = 0; j < nNumPlanes; j++) {
      if (nBitOffset[j] == (31 - i)) {
	SimGetNextWord(j);
      }
    }
  .SUBcc iXCtr, #1, iXCtr;
  .BR_NZ :lblXLoop;
  .NO_OP;
  SimSaveLastWord(nBitOffset);
  .RETURN_PROC;
  EndBlock();
  LP("SimSweepCode");
void SimLoadFirstWord(unsigned short nBitOffset[])
  short i;
  const short iSaveBits = iTemp1;
  const short iWordAddr = iTemp1;
  EP("SimLoadFirstWord");
  for (i = 0; i < nNumPlanes; i++) {
    .LDW_IND %DS, #(offNextWordAddr+(i<<2)), iWordAddr;
    .LDW_IND iWordAddr, #0, (iPlaneWord+i);
    if (nBitOffset[i] != 0) {
      .SH_RIGHT (iPlaneWord+i), #(32 - nBitOffset[i]), iSaveBits;
      .SH_LEFT (iPlaneWord+i), #nBitOffset[i], (iPlaneWord+i);
      .OR (iPlaneWord+i), iSaveBits, (iPlaneWord+i);
    }
  LP("SimLoadFirstWord");
void SimGetNextWord(unsigned short nPlane)
  const short iAddrHighBit = iTemp1;
  BOOL bWriteBack = FALSE;
  short i;
  EP("SimGetNextWord");
  .ENTER_BASICBLK;
  if (IsDestUpdated(DEST_SITE_DATA)) {
    .STW_IND (iNextWordAddr+nPlane), #0, (iPlaneWord+nPlane);
  if (lNumXBits <= 5) {
    .RETURN_BASICBLK;
    LP("SimGetNextWord");
    return;
  .AND (iNextWordAddr+nPlane), iXHighBitMask, iAddrHighBit;
  .XNOR iXHighBitMask, %G0, iXHighBitMask;
  .AND (iNextWordAddr+nPlane), iXHighBitMask, (iNextWordAddr+nPlane);
  .ADD (iNextWordAddr+nPlane), #4, (iNextWordAddr+nPlane);
  .XOR iAddrHighBit, (iNextWordAddr+nPlane), iNextWordAddr+nPlane;
  .XNOR iXHighBitMask, %G0, iXHighBitMask;
  .LDW_IND (iNextWordAddr+nPlane), #0, (iPlaneWord+nPlane);
  .STW_MEM (iNextWordAddr+nPlane);
  .RETURN_BASICBLK;
  LP("SimGetNextWord");
void SimSaveLastWord(unsigned short nBitOffset[])
  short i;
  const short iSaveBits = iTemp1;
  EP("SimSaveLastWord");
  if (IsDestUpdated(DEST_SITE_DATA)) {
    .ENTER_BASICBLK;
    for (i = 0; i < nNumPlanes; i++) {
      if (!nBitOffset[i])
	continue;
      .SH_RIGHT (iPlaneWord+i), #(nBitOffset[i]), iSaveBits;
      .SH_LEFT (iPlaneWord+i), #(32 - nBitOffset[i]), (iPlaneWord+i);
      .OR (iPlaneWord+i), iSaveBits, (iPlaneWord+i);
      .STW_IND (iNextWordAddr+i), #0, (iPlaneWord+i);
    }
    .RETURN_BASICBLK;
  LP("SimSaveLastWord");
void SimGeneralScan(CODEHANDLE hcodCurrent)
  /************************************************************************/
  /* Sim making no assumptions - in particular, it is expected that   */
  /* the scan index will be permuted, so that updated sites will not be   */
  /* sequentially located in memory.                                      */
  /************************************************************************/
  short i;
  CODELABEL lblMainLoop, lblAddrLoop, lblSkip1, lblSkip2;
  const short iPlaneCtr = iTemp1, iOffset = iTemp2, iPlaneBases = iTemp3;
  const short iBitOffset = iTemp4, iNextWord = iTemp5, iWordAddr = iTemp6;
  const short iSiteAddress = iTemp7, iSAHighBits = iTemp8;
  const short iOffHighBits = iTemp9, iScratch = iTemp9, iPlaneAddr = iTemp10;
  const short iSAAndMask = iTemp1, iSAOrMask = iTemp2;
  LONG32 lSAAndMask, lSAOrMask;
  LONG32 lSweepLength;
  EP("SimGeneralScan");
  nNumPlanes = CalcNumPlanes();
  lblMainLoop = NewLabel();
  lblAddrLoop = NewLabel();
  lblSkip1 = NewLabel();
  lblSkip2 = NewLabel();
  /************************************************************************/
  /* First, update things in the heap from where they can be accessed     */
  /* by the compiled code.                                                */
  /************************************************************************/
  /************************************************************************/
  /* Update heap copy of DCMR.						  */
  /************************************************************************/
  DCMR = DCM[0];
  /************************************************************************/
  /* Update heap copy of OFFSETS					  */
  /************************************************************************/
  for(i = 0 ; i < CHIPS_PER_MOD; i++)
    OFFSETS(i) = OSR[i];
  /************************************************************************/
  /* Figure out the site address of the first site to be updated. This is */
  /* needed to update SITE_ADDR for display purposes. Also,               */
  /* compute the SAAndMask and SAOrMask which will be used to do the      */
  /* permutation at execution time.                                       */
  /************************************************************************/
  SITE_ADDR = 0;
  lSAOrMask = lSAAndMask = 0;
  for (i = SCAN_INDEX_LENGTH-1; i >= 0; i--) {
    
    SITE_ADDR <<= 1;
    lSAOrMask <<= 1;
    lSAAndMask <<= 1;
    
    if (SIPR[i][0] < SCAN_INDEX_LENGTH) {
      
      /* Get the correct bit of scan indx */
      SITE_ADDR |= (SIR[0] >> SIPR[i][0]) & 0x1;
      
      if (SIPR[i][0] == i)
	lSAA

---------------------------------------------------------------------------

#include <CAM/CAM8Sim++.H>
int main(int argc, char *argv[])
  CAM8Sim sim;
  CAM8SimInterface ifc;
  CAM8SimModule mod;
  sim.InitSimulator(&ifc, &mod);
  sim.main(argc, argv);
  ifc.InitInterface(&sim);
  ifc.main(argc, argv);
  mod.InitModule(&sim);
  mod.main(argc, argv);
void InitExitProcs()
#ifdef BADSIG
  const void * err = BADSIG;
#else
  const void * err = SIG_ERR;
#endif
  CaLib_tb.ENTER("InitExitProcs");
#ifdef sun
#if 0
  on_exit(ExitProc);								 /* Make sure it gets called on exit */
#else
  atexit(ExitProc);								 /* Make sure it gets called on exit */
#endif
#endif
     
  if ( (signal(SIGHUP, ExitSigProc) == err) ||
       (signal(SIGINT, SIG_IGN) == err) ||
       (signal(SIGQUIT, SIG_IGN) == err) ||
       (signal(SIGILL, ExitSigProc) == err) ||
       (signal(SIGFPE, ExitSigProc) == err) ||
       (signal(SIGBUS, ExitSigProc) == err) ||
       (signal(SIGSEGV, ExitSigProc) == err) ||
       (signal(SIGSYS, ExitSigProc) == err) ||
       (signal(SIGPIPE, ExitSigProc) == err) ||
       (signal(SIGTERM, ExitSigProc) == err) )
    CaLibWarning(TRUE, "Could not install cleanup routines!");
  CaLib_tb.LEAVE();
#ifdef BADSIG
void ExitSigProc(int sig, int code, struct sigcontext *scp, char *addr)
#else
void ExitSigProc(int sig)
#endif
  static char *pcSignalName[] = {
    "Unknown",
    "Hangup",
    "Interrupt",
    "Quit",
    "Illegal Instruction",
    "Trace Trap",
    "IO (Hardware) Trap",
    "Emulator Trap",
    "Floating Point Exception",
    "Kill",
    "Bus Error",
    "Segmentation Fault",
    "Bad Argument to system call",
    "Write to broken pipe",
    "Alarm",
    "Software Termination",
    "User1",
    "User2",
    "Child Termination",
    "Power down"
  };
  CaLib_tb.ENTER("ExitSigProc");
  CaLibDie.SetAppName("Cam8SIM");
     
  switch (sig) {
  case SIGHUP:
  case SIGSYS:
  case SIGPIPE:
    CaLibDie(TRUE, "%s signal received - exiting.\n", pcSignalName[sig]);
    break;
    
  case SIGILL:
  case SIGFPE:
#ifdef BADSIG
    CaLibDie(TRUE, "Attempt to execute illegal instruction at 0x%x\n", addr);
#else
    CaLibDie(TRUE, "Attempt to execute illegal instruction\n");
#endif
    break;
  case SIGBUS:
  case SIGSEGV:
#ifdef BADSIG
    CaLibDie(TRUE, "Attempt to access invalid memory location 0x%x\n", addr);
#else
    CaLibDie(TRUE, "Attempt to access invalid memory location\n");
#endif
    break;
  case SIGTERM:
    CaLibDie(TRUE, "Termination signal received - exiting.\n");
    break;
  default:
    break;
#ifdef DEBUG
  fclose(DEBUGFILE);
#endif
  Calib_tb.LEAVE();
  /*  _exit(0); */
void ExitProc()
#ifdef DEBUG
  fclose(DEBUGFILE);
#endif

---------------------------------------------------------------------------

ndMask |= 1;
    }
    
    /* Constant of 1 */
    else if (SIPR[i][0] == PERM_CONST_1) {
      lSAOrMask |= 1;
      SITE_ADDR |= 1;
    }
    
    else if (SIPR[i][0] != PERM_CONST_0)
      WARNING("Invalid SIPR value", "SimGenScan");
    
  /************************************************************************/
  /* Figure out how many sites will be updated, and how many sites/sweep  */
  /************************************************************************/
  SITE_CTR = ScanLength();
  lSweepLength = SweepLength(&X_CTR);
  /************************************************************************/
  /* Next, generate the code. First, permute the scan index register to   */
  /* get the site address.                                                */
  /************************************************************************/
    .LDW_MEM iSiteCtr;
    .LDW_MEM iXCtr;
    .LDW_MEM iXByteLength;
    
    .ADD_LABEL :lblMainLoop;
    
    .ENTER_BASICBLK;
    .LDW_MEM iScanIndexReg;
    
    .ADD %G0, #lSAAndMask, iSAAndMask;
    .ADD %G0, #lSAOrMask, iSAOrMask;
    
    .AND iScanIndexReg, iSAAndMask, iSiteAddress;
    .OR iSAOrMask, iSiteAddress, iSiteAddress;
    
    for (i = SCAN_INDEX_LENGTH-1; i >= 0; i--) {
      if ((SIPR[i][0] < SCAN_INDEX_LENGTH) && (SIPR[i][0] != i)) {
	.SH_LEFT iScanIndexReg, #(31 - SIPR[i][0]), iScratch;
	.ADDcc iScratch, iScratch, iScratch;
	.ADDX %G0, %G0, iTemp10;
	.SH_LEFT iTemp10, #i, iTemp10;
	.OR iTemp10, iSiteAddress, iSiteAddress;
      }
    }
      
    /************************************************************************/
    /* Now, add site address to the offset to get the DRAM address. The     */
    /* addition must break the carries at the dimension cuts. Also, DRAM    */
    /* address must be broken into a SPARC word address and a 5 bit offset  */
    /* into the word                                                        */
    /************************************************************************/
    
    .ADD %DS, #offOffsets, iOffset;
    .ADD %DS, #offBitPlaneAddr, iPlaneBases;
    .ADD %DS, #offBitOffsets, iBitOffset;
    .ADD %DS, #offNextWordAddr, iNextWord;
    
    .LDW_MEM iDcmr;
    .AND iDcmr, iSiteAddress, iSAHighBits;
    .XNOR %G0, iDcmr, iDcmr;
    .AND iDcmr, iSiteAddress, iSiteAddress;
    .AND iDcmr, iSiteAddress, iScratch;
    .AND iScratch, #(SITE_ADDR_MASK), iSiteAddress;
    .XNOR %G0, iDcmr, iDcmr;
    
    .ADD %G0, #0, iPlaneCtr;
    .ADD_LABEL :lblAddrLoop;
    
    .LDW_IND iOffset, iPlaneCtr, iWordAddr;
    .AND iDcmr,  iWordAddr, iOffHighBits;
    .XNOR %G0, iDcmr, iDcmr;
    .AND iDcmr,  iWordAddr, iWordAddr;
    .ADD iSiteAddress, iWordAddr, iWordAddr;
    .XOR iWordAddr, iOffHighBits, iWordAddr;
    .XOR iWordAddr, iSAHighBits, iWordAddr;
    
    .LDW_IND iPlaneBases, iPlaneCtr, iPlaneAddr;
    .SH_RIGHT iWordAddr, #5, iScratch;
    .SH_LEFT iScratch, #2, iScratch;
    .ADD iScratch, iPlaneAddr, iScratch;
    .STW_IND iNextWord, iPlaneCtr, iScratch;
    .AND iWordAddr, #0x1F, iWordAddr;
    .STW_IND iBitOffset, iPlaneCtr, iWordAddr;
    
    .ADD iPlaneCtr, #4, iPlaneCtr;
    .SUBcc iPlaneCtr, #(nNumPlanes * 4), %G0;
    .BR_L :lblAddrLoop;
    .XNOR %G0, iDcmr, iDcmr;
    
    .RETURN_BASICBLK;
    
  /************************************************************************/
  /* Now, the heap has the word addresses and bit offsets for the next    */
  /* site. So go ahead and update the site.                               */
  /************************************************************************/
  SimUpdateCode();
  .CALL_PROC [pcodGenUpdate];
  .NO_OP;
  .LDW_MEM iScanIndexReg;
  .SUBcc iXCtr, #1, iXCtr;
  .BR_NZ :lblSkip1;
  .NO_OP;
  .ADD %G0, #lSweepLength, iXCtr;
  .ADD_LABEL :lblSkip1;
  .ADD iScanIndexReg, #1, iScanIndexReg;
  .SUBcc iScanIndexReg, #(0xFFFFFF), iScratch;
  .BR_L :lblSkip2;
  .NO_OP;
  .OR %G0, %G0, iScanIndexReg;    
  .ADD_LABEL :lblSkip2;
  .SUBcc iSiteCtr, #1, iSiteCtr;
  .BR_NZ :lblMainLoop;
  .STW_MEM iScanIndexReg;
  LP("SimGeneralScan");
static void SimUpdateCode()
  CODEPTR pcodCurrent = pcodGenUpdate;
  EP("SimUpdateCode");
  NewBlock(&pcodCurrent);
  .ENTER_PROC;
  SimLoadPlaneWords();
  SimUpdateSite();
  .CALL_LEAF [pcodUpdateSite];
  .NO_OP;
  SimSavePlaneWords();
     
  .RETURN_PROC;
  EndBlock();
  LP("SimUpdateCode");
static void SimLoadPlaneWords()
  short i;
  const short iWordAddr = iTemp1;
  const short iBitOffset = iTemp1;
  const short iSaveBits = iTemp2;
  const short iScratch = iTemp3;
  EP("SimLoadPlaneWords");
  if (!IsSrcNeeded(SRC_SITE_DATA) && !IsSrcNeeded(SRC_GLUED_DATA) &&
      !IsDestUpdated(DEST_SITE_DATA)) {
    LP("SimLoadPlaneWords");
    return;
  .ADD %G0, #32, iScratch;
  for (i = 0; i < nNumPlanes; i++) {
    .LDW_IND %DS, #(offNextWordAddr+(i<<2)), iWordAddr;
    .LDW_IND iWordAddr, #0, (iPlaneWord+i);
    .LDW_IND %DS, #(offBitOffsets+(i<<2)), iBitOffset;
    .SUB iScratch, iBitOffset, iBitOffset;
    .SH_RIGHT (iPlaneWord+i), iBitOffset, iSaveBits;
    .SUB iScratch, iBitOffset, iBitOffset;
    .SH_LEFT (iPlaneWord+i), iBitOffset, (iPlaneWord+i);
    .OR (iPlaneWord+i), iSaveBits, (iPlaneWord+i);
  LP("SimLoadPlaneWords");
static void SimSavePlaneWords()
  short i;
  const short iWordAddr = iTemp1;
  const short iBitOffset = iTemp1;
  const short iSaveBits = iTemp2;
  const short iScratch = iTemp3;
  EP("SimSavePlaneWords");
  if (!IsDestUpdated(DEST_SITE_DATA)) {
    LP("SimSavePlaneWords");
    return;
  .ADD %G0, #31, iScratch;
  for (i = 0; i < nNumPlanes; i++) {
    .LDW_IND %DS, #(offBitOffsets+(i<<2)), iBitOffset;
    .SUB iScratch, iBitOffset, iBitOffset;
    .SH_LEFT (iPlaneWord+i), iBitOffset, iSaveBits;
    .SUB iScratch, iBitOffset, iBitOffset;
    .ADD iBitOffset, #1, iBitOffset;
    .SH_RIGHT (iPlaneWord+i), iBitOffset, (iPlaneWord+i);
    .OR (iPlaneWord+i), iSaveBits, (iPlaneWord+i);
    .LDW_IND %DS, #(offNextWordAddr+(i<<2)), iWordAddr;
    .STW_IND iWordAddr, #0, (iPlaneWord+i);
  LP("SimSavePlaneWords");
}     
short PermuteScanIndex()
  short i;
  BOOL bIsPermuted = FALSE;
  EP("PermuteScanIndex");
  for (i = nNumPlanes - 1; i >= 0; i--) {
    if (SABSR[i] != i) {
      bIsPermuted = TRUE;
      break;
    }
  if (!bIsPermuted) {
    LP("PermuteScanIndex");
    return (iScanIndexReg);
  .OR %G0, %G0, iTemp6;
  for (i = nNumPlanes-1; i >= 0; i--) {
    if (SABSR[i] < 24) {
      .SH_LEFT iScanIndexReg, #(31 - SABSR[i]), iTemp5;
      .ADDcc iTemp5, iTemp5, iTemp5;
      .ADDXcc iTemp6, iTemp6, iTemp6;
    }
    else if (SABSR[i] == 31) {
      .SH_LEFT iTemp6, #1, iTemp6;
      .ADD iTemp6, #1, iTemp6;
    }
    else if (SABSR[i] == 30) {
      .SH_LEFT iTemp6, #1, iTemp6;
    }
    else {
      WARNING("Invalid SABSR value!", "PermuteScanIndex");
      .SH_LEFT iTemp6, #1, iTemp6;
    }
  LP("PermuteScanIndex");
  return (iTemp6);
void MapFunction (short iSrcVar, short iDestVar, BYTE bMap)
  EP("MapFunction");
  switch (bMap) {
  case MAP_CONST_0: {
    .OR %G0, %G0, iDestVar;
    break;
    
  case MAP_G_NOR_S: {
    /* Surprizingly, SPARC does not have*/
    /* a native NOR instruction! ORN is */
    /* not NOR!!!                       */
    .OR iGlueData, iSrcVar, iDestVar;
    .XNOR %G0, iDestVar, iDestVar;
    break;
}    
  case MAP_G_AND_S_BAR: {
    .XNOR %G0, iSrcVar, iDestVar;
    .AND iGlueData, iDestVar, iDestVar;
    break;
    
  case MAP_S_BAR: {
    .XNOR %G0, iSrcVar, iDestVar;
    break;
    
  case MAP_G_BAR_AND_S: {
    .XNOR %G0, iGlueData, iDestVar;
    .AND iSrcVar, iDestVar, iDestVar;
    break;
    
  case MAP_G_BAR: {
    .XNOR %G0, iGlueData, iDestVar;
    break;
    
  case MAP_G_XOR_S: {
    .XOR iGlueData, iSrcVar, iDestVar;
    break;
    
  case MAP_G_NAND_S: {
    /* The SPARC does not have a native NAND */
    /* instruction! ANDN is not NAND */
    .AND iGlueData, iSrcVar, iDestVar;
    .XNOR %G0, iDestVar, iDestVar;
    break;
    
  case MAP_G_AND_S: {
    .AND iGlueData, iSrcVar, iDestVar;
    break;
    
  case MAP_G_EQ_S: {
    .XNOR iGlueData, iSrcVar, iDestVar;
    break;
    
  case MAP_G: {
    .XOR %G0, iGlueData, iDestVar;
    break;
    
  case MAP_G_OR_S_BAR: {
    .XNOR %G0, iSrcVar, iDestVar;
    .OR iGlueData, iDestVar, iDestVar;
    break;
    
  case MAP_S: {
    .XOR %G0, iSrcVar, iDestVar;
    break;
    
  case MAP_G_BAR_OR_S: {
    .XNOR %G0, iGlueData, iDestVar;
    .OR iSrcVar, iDestVar, iDestVar;
    break;
    
  case MAP_G_OR_S: {
    .OR iGlueData, iSrcVar, iDestVar;
    break;
    
  case MAP_CONST_1: {
    .XNOR %G0, %G0, iDestVar;
    break;
  LP("MapFunction");
void BuildDest(short nDest, short iDestVar, BYTE Src, BYTE Map)
  short iSrcVar;
  EP("BuildDest");
  if ((Map != MAP_G) && (Map != MAP_G_BAR)) {
    iSrcVar = (Src == SRC_SITE_DATA ? iUnGlueData :
	       Src == SRC_TBUS ? iTbusData :
	       Src == SRC_LUT ? iLutData : iTemp1);
    if ((nDest == DEST_LUT) && (Src == SRC_SITE_ADDRESS)) {
      iSrcVar = PermuteScanIndex();
    }
  MapFunction(iSrcVar, iDestVar, Map);
  LP("BuildDest");
void BuildBitDest(short nDest, short iHoldReg, BYTE Src, BYTE Map,
		  unsigned short nPlane)
{                                                               
     
  EP("BuildBitDest");
  if ((nDest == DEST_LUT) && (Src == SRC_SITE_ADDRESS)) {
    .OR           %G0, %G0, iTemp6;
    
    if (SABSR[nPlane] < 24) {
      .SH_LEFT iScanIndexReg, #(31 - SABSR[nPlane]), iTemp5;
      .ADDcc iTemp5, iTemp5, iTemp5;
      .ADDXcc iTemp6, iTemp6, iTemp6;
      .SH_LEFT iTemp6, #nPlane, iTemp6;
    }
    else if (SABSR[nPlane] == 31) {
      .SH_LEFT iTemp6, #1, iTemp6;
      .ADD iTemp6, #1, iTemp6;
    }
    else if (SABSR[nPlane] == 30) {
      .SH_LEFT iTemp6, #1, iTemp6;
    }
    else {
      WARNING("Invalid SABSR value", "BuildBitDest");
      .SH_LEFT iTemp6, #1, iTemp6;
    }      
    MapFunction (iTemp6, iHoldReg, Map);
  else
    BuildDest(nDest, iHoldReg, Src, Map);
  LP("BuildBitDest");
void BuildBitwiseDest(short nDest, short iDestVar, BYTE Src[], BYTE Map[])
  short i;
  short iHoldReg = iTemp4;
  EP("BuildBitwiseDest");
  for (i = nNumPlanes - 1; i >= 0; i--) {
    BuildBitDest(nDest, iHoldReg, Src[i], Map[i], i);
    .SH_LEFT iHoldReg, #(31 - i), iHoldReg;
    .ADDcc iHoldReg, iHoldReg, iHoldReg;
    .ADDXcc iDestVar, iDestVar, iDestVar;
  LP("BuildBitwiseDest");

---------------------------------------------------------------------------

#include <CaLibStream++.H>
#include <CaLibError++.H>
#include <CaLibTrace++.H>
#include <CamLib++.H>
#include <Cam8SimJIT++.H>
#include <Cam8SimSPARCJIT++.H>
#include "std++.H"
Cam8SimSPARCJIT::Cam8SimSPARCJIT(Cam8SimRegMgr *rm)
  regmgr = rm;
  hcodTarget = NULL;						 /* Handle to Target Code Location   */
  pcodNext = NULL;						 /* Pointer to location of next inst */
  lblNext = 0;							 /* Next Label 			     */
  pblkTOS = NULL;
Cam8SimSPARCJIT::~Cam8SimSPARCJIT(void)
/*****************************************************************************/
/*                                                                           */
/* Translate an intermediate instruction into target code. 		     */
/*                                                                           */
/*****************************************************************************/
void Emit(INT16 opcode,
	  BYTE op1Type, LONG32 op1,
	  BYTE op2Type, LONG32 op2,
	  BYTE destType, LONG32 dest)
     char *szFuncName = "Emit";
     
#ifdef DEBUG
     DASMADDR = pcodNext;
#endif
     if (opcode & NATIVE_OP) {							 /* NATIVE INSTRUCTION 		     */
	  REGISTER rs1, rs2, rd;						 
	  switch (op1Type) {							 /* Figure out rs1 		     */
	     case NULL_OP:
	       rs1 = REG_G0;
	       break;
	     case REG_OP:
	       rs1 = (REGISTER) op1;
	       break;
	     case VAR_OP:
	       rs1 = GetReg(op1, CURRENT_HANDLE, TRUE);
	       break;
	     default:
	       CRITICAL_ERROR("Invalid argument for rs1", szFuncName);
	       break;
	  }
	  switch (destType) {							 /* Figure out the dest register     */
	     case NULL_OP:
	       rs1 = REG_G0;
	       break;
	     case REG_OP:
	       rd = (REGISTER) dest;
	       break;
	     case VAR_OP:
	       rd = GetReg(dest, CURRENT_HANDLE, FALSE);
	       break;
	     default:
	       CRITICAL_ERROR("Invalid argument for rd", szFuncName);
	       break;
	  }
	  switch (op2Type) {							 /* Figure out rs2. This is done     */
	     case REG_OP:							 /* last because rs2 might be a      */
	       rs2 = (REGISTER) op2;						 /* constant > 13 bits, and we might */
	       break;								 /* have to preload it into the dest */
	     case VAR_OP:
	       rs2 = GetReg(op2, CURRENT_HANDLE, TRUE);
	       break;
	     case CONST_OP:
	       if (((signed long) op2) > 4095 ||				 /* if op2 will not fit in 13 bits   */
		   ((signed long) op2) < -4096) {
		    EMIT( SETHI(HI22(op2), rd) );
		    EMIT( OR_REG_IMM(rd, LOW10(op2), rd) );
		    op2Type = REG_OP;
		    rs2 = rd;
	       }
	       break;
	       
	     default:
	       CRITICAL_ERROR("Invalid argument for rs2", szFuncName);
	       break;
	  }
	  opcode = opcode & NATIVE_OP_MASK;					 /* extract the target's native op-  */
										 /* code... 			     */
	  if (op2Type == CONST_OP) {
	       *pcodNext++ = FMT3_INST(0x02L, opcode, rs1, IMMEDIATE, op2, rd);	 /* and emit the instruction 	     */
	  } else {
	       *pcodNext++ = FMT3_INST(0x02L, opcode, rs1, REG_SOURCE, rs2, rd);
	  }									 /* -------------------------------- */
     } else if (opcode & LD_ST_OP) {						 /* LOAD-STORE INSTRUCTION 	     */
	  REGISTER rs1, rs2, rd;
	  switch (opcode) {
	     case LDW_MEM:							 /* bring op1 into a register 	     */
	       if (op1Type == VAR_OP) {
		    rs1 = GetReg(op1, CURRENT_HANDLE, TRUE);
	       } else {
		    CRITICAL_ERROR("Invalid LDW_MEM argument",
				   szFuncName);
	       }
	       break;
	     case LDUB_IND:
	     case LDHW_IND:
	     case LDW_IND:							 /* load indirect : dest <- [op1+op2]*/
	       if (op1Type == VAR_OP) {
		    rs1 = GetReg(op1, CURRENT_HANDLE, TRUE);
	       } else if (op1Type == REG_OP) {
		    rs1 = (REGISTER) op1;
	       } else {
		    CRITICAL_ERROR("Invalid LDW_IND argument 1",
				   szFuncName);
	       }
	       if (op2Type == VAR_OP) {
		    rs2 = GetReg(op2, CURRENT_HANDLE, TRUE);
	       } else if (op2Type == REG_OP) {
		    rs2 = (REGISTER) op2;
	       } else if (op2Type == CONST_OP) {
		    /* do nothing */
	       } else {
		    CRITICAL_ERROR("Invalid LDW_IND argument 2",
				   szFuncName);
	       }
		    
	       if (destType == VAR_OP) {
		    rd = GetReg(dest, CURRENT_HANDLE, FALSE);
	       } else if (op2Type == REG_OP) {
		    rd = (REGISTER) dest;
	       } else {
		    CRITICAL_ERROR("Invalid LDW_IND argument",
				   szFuncName);
	       }
	       
	       if (opcode == LDW_IND) {
		    (op2Type == CONST_OP) ? (EMIT( LDW_REG_IMM(rs1, op2, rd) )) :
		      (EMIT( LDW_REG_REG(rs1, rs2, rd)));
	       } else if (opcode == LDHW_IND) {
		    (op2Type == CONST_OP) ? (EMIT( LDHW_REG_IMM(rs1, op2, rd) )) :
		      (EMIT( LDHW_REG_REG(rs1, rs2, rd)));	
	       } else {
		    (op2Type == CONST_OP) ? (EMIT( LDUB_REG_IMM(rs1, op2, rd) )) :
		      (EMIT( LDUB_REG_REG(rs1, rs2, rd) ));
	       }
	       break;
	       
	     case STW_MEM:							 /* flush op1 to memory 	     */
	       if (op1Type == VAR_OP) {
		    rs1 = GetReg(op1, CURRENT_HANDLE, TRUE);			 /* 	hopefully, op1 is already    */
		    FlushReg(rs1, CURRENT_HANDLE);				 /* 	in a register!		     */
	       } else {
		    CRITICAL_ERROR("Invalid STW_MEM argument",
				   szFuncName);
	       }
	       break;
	     case STUB_IND:
	     case STHW_IND:
	     case STW_IND:							 /* store indirect: [op1+op2] <- dest*/
	       if (op1Type == VAR_OP) {						 /* 	get op1 - var or reg 	     */
		    rs1 = GetReg(op1, CURRENT_HANDLE, TRUE);
	       } else if (op1Type == REG_OP) {
		    rs1 = (REGISTER) op1;
	       } else {
		    CRITICAL_ERROR("Invalid STW_IND argument",
				   szFuncName);
	       }
	       if (op2Type == VAR_OP) {						 /* 	get op2 - var, reg, or const */
		    rs2 = GetReg(op2, CURRENT_HANDLE, TRUE);
	       } else if (op2Type == REG_OP) {
		    rs2 = (REGISTER) op2;
	       } else if (op2Type == CONST_OP) {
		    /* do nothing */
	       } else {
		    CRITICAL_ERROR("Invalid LDW_IND argument 2",
				   szFuncName);
	       }
		    
	       if (destType == VAR_OP) {					 /* 	get dest - var or reg 	     */
		    rd = GetReg(dest, CURRENT_HANDLE, TRUE);
	       } else if (op2Type == REG_OP) {
		    rd = (REGISTER) dest;
	       } else {
		    CRITICAL_ERROR("Invalid STW_IND argument",
				   szFuncName);
	       }
	       if (opcode == STW_IND) {
		    (op2Type == CONST_OP) ? (EMIT( STW_REG_IMM(rs1, op2, rd))) :
		      (EMIT( STW_REG_REG(rs1, rs2, rd)));
	       } else if (opcode == STHW_IND) {
		    (op2Type == CONST_OP) ? (EMIT( STHW_REG_IMM(rs1, op2, rd))) :
		      (EMIT( STHW_REG_REG(rs1, rs2, rd)));
	       } else {
		    (op2Type == CONST_OP) ? (EMIT( STUB_REG_IMM(rs1, op2, rd))) :
		      (EMIT( STUB_REG_REG(rs1, rs2, rd)));
	       }
	       break;
	       
	     default:
	       CRITICAL_ERROR("Unknown Load Store operation",
			      szFuncName);
	       break;
	  }									 /* -------------------------------- */
     } else if (opcode & BRANCH_OP) {						 /* BRANCH INSTRUCTION 		     */
	  LABELREC	*plblrecBranch;
	  LONG32	lDisp;
	  opcode &= NATIVE_OP_MASK;						 /* extract the native branch code   */
	  if (op1Type == LABEL_OP) {
	       if ((plblrecBranch = FindLabel((CODELABEL) op1)) != NULL) {	 /* if label was encountered before  */
		    CODEPTR pcodBranchLoc = GetLabelAddress(plblrecBranch);	 /*     Get address of branch loc    */
		    if (!pcodBranchLoc) {					 /* 	if label's addrss is unknown */
			 AddLabelRef(plblrecBranch, CURRENT_LOC);		 /* 	   add a ref record. 	     */
			 lDisp = 0;						 /* 	   dummy disp 		     */
		    } else {							 /*     else label's addr is known   */
			 lDisp = pcodBranchLoc - CURRENT_LOC;			 /*        calculate displacement    */
		    }
		    EMIT( BRANCH_INST(0, opcode, lDisp) );			 /* 	Emit branch instruction      */
	       } else {								 /* Label was not encountered before */
		    plblrecBranch = AddLabel((CODELABEL) op1, 0, FALSE);	 /* 	So create new record 	     */
		    AddLabelRef(plblrecBranch, CURRENT_LOC);			 /* 	add a ref record to it 	     */
		    EMIT( BRANCH_INST(0, opcode, 0) );				 /* 	emit filler branch instr     */
	       }
	  } else {
	       CRITICAL_ERROR("Branch to a non-label", szFuncName);
	  }									 /* -------------------------------- */
     } else {									 /* PSEUDO INSTRUCTION 		     */
	  switch (opcode) {
	     case INSTR:							 /* op1 is a valid sparc instruction */
	       EMIT( op1 );							 /* 	simply insert it 	     */
	       break;								 /* 	useful to fill delay slots   */
	       
	     case ENTER_PROC:							 /* procedure entry prologue 	     */
	       PushRegWindow();							 /*     Inform register manager of   */
	       if (op1Type == CONST_OP) {					 /*     new register window 	     */
		    EMIT( SAVE_REG_IMM(REG_SP, -112-8-op1, REG_SP) );		 /* 	-112 is gcc's local frame    */
	       } else {								 /*     and we need 2 words to save  */
		    EMIT( SAVE_REG_IMM(REG_SP, -112-8, REG_SP) );		 /* 	our own fp and return addr   */
	       }								 /*     registers. 		     */
	       EMIT( STW_REG_IMM(REG_SP, 72, REG_G7) );				 /* 	sp+8 = our fp register       */
	       EMIT( STW_REG_IMM(REG_SP, 68, REG_RA) );				 /* 	sp+4 = our return address    */
	       EMIT( SETHI(HI22(pcHeap), REG_DS) );				 /* 	make ds point to heap base   */
	       if ( LOW10(pcHeap) != 0) {
		    EMIT( OR_REG_IMM(REG_DS, LOW10(pcHeap), REG_DS) );
	       }
	       break;
	       
	     case RETURN_PROC:							 /* return from procedure 	     */
	       PopRegWindow(CURRENT_HANDLE);					 /* 	restore reg. window 	     */
	       EMIT( LDW_REG_IMM(REG_SP, 72, REG_G7) );				 /* 	restore saved fp register    */
	       EMIT( LDW_REG_IMM(REG_SP, 68, REG_RA) );				 /* 	restore our return address   */
	       EMIT( RET );							 /* 	return from procedure	     */
	       EMIT( RESTORE );							 /* 	and restore the reg window   */
	       break;
	       
	     case CALL_PROC:							 /* call a procedure 		     */
	       if (op1Type == ADDR_OP) {
		    op1 -= (LONG32) pcodNext;
		    EMIT( CALL(op1) );						 /* 	call procedure at addr op1   */
	       } else {
		    CRITICAL_ERROR("Invalid procedure call", szFuncName);
	       }
	       break;
	     case ENTER_LEAF:							 /* leaf procedure entry 	     */
	       SaveRegState();							 /*     Save all the live registers  */
	       break;
	     case RETURN_LEAF:							 /* return from leaf procedure 	     */
	       RestoreRegState(CURRENT_HANDLE);					 /*  	Restore live registers	     */
	       EMIT( RETL );							 /*     return to caller 	     */
	       EMIT( NOP );							 /* 	delay slot 		     */
	       break;
	       
	     case CALL_LEAF:							 /* call a leaf procedure 	     */
	       if (op1Type == ADDR_OP) {
		    EMIT( SETHI(HI22(op1), REG_RA) );
		    EMIT( CALL_REG_IMM(REG_RA, LOW10(op1)) );
	       } else {
		    CRITICAL_ERROR("Invalid leaf procedure call",
				   szFuncName);
	       }
	       break;
	     case CALL_LEAF_IND: {
		  REGISTER rs1, rs2, rd;
		  
		  if (op1Type == VAR_OP) {
		       rs1 = GetReg(op1, CURRENT_HANDLE, TRUE);
		  } else {
		       CRITICAL_ERROR("Invalid op1 : indirect leaf procedure call",
				      szFuncName);
		  }
		  if (op2Type == CONST_OP) {
		       /* do nothing */
		  } else if (op2Type != NULL_OP) {
		       CRITICAL_ERROR("Invalid op2 : indirect leaf procedure call",
		       		      szFuncName);
		  } 
		  
		  EMIT( CALL_REG_IMM(rs1, op2) );
	       }
	       break;
		       
		       
	     case ENTER_BASICBLK:
	       SaveRegState();
	       break;
	     case RETURN_BASICBLK:
	       RestoreRegState(CURRENT_HANDLE);
	       break;
	       
	     case ADD_LABEL:							 /* define a label 		     */
	       if (op1Type == LABEL_OP) {
		    LABELREC *plblrec;
		    
		    if ((plblrec = FindLabel((CODELABEL) op1)) == NULL) {	 /* 	if first time seeing label   */
			 AddLabel((CODELABEL) op1, CURRENT_LOC, TRUE);		 /* 	   add a new label record    */
		    } else {							 /* 	else  			     */
			 ResolveRefs(plblrec, CURRENT_LOC);			 /* 	   resolve all refs to label */
		    }
	       } else {
		    CRITICAL_ERROR("Invalid operand to ADD_LABEL",		
				   szFuncName);
	       }
	       break;
	     case NO_OP:
	       EMIT( NOP );
	       break;
	       
	     default:
	       CRITICAL_ERROR("Unknown pseudo-op", szFuncName);
	       break;
     }
void ResolveRefs(LABELREC *plblrec, CODEPTR lAddress)
     if (plblrec->bValid == TRUE) {
	  WARNING("Possible redefinition of label", "ResolveRefs");
     } else {
	  LABELREF *prefNext;
	  CODEPTR pcodRefLoc;
	  LONG32 lDisp;
	  plblrec->bValid = TRUE;						 /* update label record for future   */
	  plblrec->lAddress = lAddress;						 /* reference resolutions 	     */
	  do {									 /* Now, update all references.      */
	       prefNext = plblrec->prefFirst;					 /* Assume at least one reference!   */
	       pcodRefLoc = prefNext->pcodRefLoc;				 
	       lDisp = lAddress - pcodRefLoc;					 /* calculate displacement 	     */
	       lDisp &= 0x3FFFFF;						 /* least sig 22 bits only 	     */
	       *pcodRefLoc |= lDisp;						 /* and patch the refering instruct  */
	       plblrec->prefFirst = prefNext->prefNext;
	       FREE(prefNext, "ResolveRefs");					 /* release the reference record     */
	  } while (plblrec->prefFirst != NULL);
     }
     
void PrintAsm(CODEPTR pcodSource, FILE *fOut)
  CODEPTR pcod;
  unsigned short op;
  for (pcod = pcodSource; *pcod != 0; pcod++) {
    
    fprintf(fOut, "0x%x: ", pcod);
    
    op = (*pcod >> 30) & 0x3L;
    switch (op) {
    case 0:
      Fmt2Instr(*pcod, fOut);
      break;
      
    case 1:
      Fmt1Instr(*pcod, fOut);
      break;
      
    case 2:
    case 3:
      Fmt3Instr(*pcod, fOut);
      break;
    }
void Fmt1Instr(INSTRUCTION instr, FILE *fOut)
  fprintf(fOut, "CALL \t%x\n", (instr & 0x3FFFFFFFL));
void Fmt2Instr(INSTRUCTION instr, FILE *fOut)
  unsigned short op2, cc, rd;
  signed long disp;
  op2 = (instr >> 22) & 0x7L;
  if (op2 == 4) {								 /* SETHI 			     */
    unsigned long hi22;
    hi22 = (instr << 10);
    rd = (instr >> 25) & 0x1FL;
    fprintf(fOut,"SETHI \t%s, \t%x (%x)\n", szRegName[rd],
	    (instr & 0x003FFFFFL), hi22);
  } else if (op2 == 2) {							 /* BRANCH 			     */
    cc = (instr >> 25) & 0xFL;
    if (instr & 0x00200000L) {
      disp = instr | 0xFFC00000L;
    } else {
      disp = instr & 0x1FFFFF;
    }
    fprintf(fOut,"BR%s \t%d\n", szCCName[cc], disp);
  } else {
    fprintf(fOut,"UNIMP BR : %x\n", instr);
void Fmt3Instr(INSTRUCTION instr, FILE *fOut)
  unsigned short majorOp, opcode, imm, rs1, rs2, rd;
  signed long lConst;
  majorOp = (instr >> 30) & 0x3L;
  opcode = (instr >> 19) & 0x3FL;
  rd = (instr >> 25) & 0x1FL;
  rs1 = (instr >> 14) & 0x1FL;
  rs2 = instr & 0x1FL;
  imm = (instr >> 13) & 0x1L;
  if (imm) {
    if (instr & 0x00001000L) {
      lConst = (instr | 0xFFFFF000L);
    } else {
      lConst = (instr & 0xFFFL);
    }
  if (majorOp == 3) {							 /* LOAD-STORE 			     */
    switch (opcode) {
    case OP_LDW:
      fprintf(fOut,"LDW ");
      break;
    case OP_LDHW:
      fprintf(fOut,"LDHW ");
      break;
    case OP_LDUB:
      fprintf(fOut,"LDUB ");
      break;
    case OP_STW:
      fprintf(fOut,"STW ");
      break;
    case OP_STUB:
      fprintf(fOut,"STUB ");
      break;
      
    default:
      fprintf(fOut,"UNIMP LOAD-STORE : %x\n", instr);
      return;
      break;
    };
  } else {									 /* ARITHMETIC 			     */
    switch (opcode) {
    case OP_ADD:
      fprintf(fOut,"ADD ");
      break;
    case OP_ADDcc:
      fprintf(fOut,"ADDcc ");
      break;
    case OP_ADDX:
      fprintf(fOut,"ADDX ");
      break;
    case OP_ADDXcc:
      fprintf(fOut,"ADDXcc ");
      break;
      
    case OP_SUB:
      fprintf(fOut,"SUB ");
      break;
    case OP_SUBcc:
      fprintf(fOut,"SUBcc ");
      break;
    case OP_SUBX:
      fprintf(fOut,"SUBX ");
      break;
    case OP_SUBXcc:
      fprintf(fOut,"SUBXcc ");
      break;
      
    case OP_AND:							 /* LOGICAL 			     */
      fprintf(fOut,"AND ");
      break;
    case OP_ANDcc:
      fprintf(fOut,"ANDcc ");
      break;
    case OP_ANDN:
      fprintf(fOut,"ANDN ");
      break;
    case OP_ANDNcc:
      fprintf(fOut,"ANDNcc ");
      break;
      
    case OP_OR:
      fprintf(fOut,"OR ");
      break;
    case OP_ORcc:
      fprintf(fOut,"ORcc ");
      break;
    case OP_ORN:
      fprintf(fOut,"ORN ");
      break;
    case OP_ORNcc:
      fprintf(fOut,"ORNcc ");
      break;
      
    case OP_XOR:
      fprintf(fOut,"XOR ");
      break;
    case OP_XORcc:
      fprintf(fOut,"XORcc ");
      break;
    case OP_XNOR:
      fprintf(fOut,"XNOR ");
      break;
    case OP_XNORcc:
      fprintf(fOut,"XNORcc ");
      break;
      
      
    case OP_SLL:
      fprintf(fOut,"SLL ");
      break;
    case OP_SRL:
      fprintf(fOut,"SRL ");
      break;
    case OP_SRA:
      fprintf(fOut,"SRA ");
      break;
      
    case OP_JMPL:							 /* CONTROL TRANSFER 		     */
      fprintf(fOut,"JMPL ");
      break;
    case OP_SAVE:
      fprintf(fOut,"SAVE ");
      break;
    case OP_RESTORE:
      fprintf(fOut,"RESTOR");
      break;
      
    default:
      fprintf(fOut,"UNIMP LOGICAL-ARITH : %x\n", instr);
      return;
      break;
    };
  if (imm) {
    fprintf(fOut,"\t%s \t%d \t%s\n", szRegName[rs1], lConst, szRegName[rd]);
  } else {
    fprintf(#include <CaLibStream++.H>
#include <CaLibError++.H>
#include <CaLibTrace++.H>
#include <CamLib++.H>
#include <Cam8Core++.H>
#include <Cam8SimCore++.H>
#include <Cam8SimSPARCCore++.H>
#include "std++.H"
Cam8SimSPARCCore::Cam8SimSPARCCore(void)
  precTOS = NULL;
Cam8SimSPARCCore::~Cam8SimSPARCCore(void)
  precTOS = NULL;
STD_BZERO(Cam8SimSPARCCore)
STD_BCOPY(Cam8SimSPARCCore)
STD_BCMP(Cam8SimSPARCCore)
int Cam8SimSPARCCore::SimCompScan(void)
  int i;
  bool bNoPerm = TRUE;
  bool bNoPermLast5 = TRUE;
  CODE pcodCurrent;
  CODEHANDLE hcodCurrent;
  long32 lLogScanLength = ESC[0] + 1L;
  CaLib_tb.ENTER("SimCompScan");  
  /************************************************************************/
  /* First, parse down the tree to see that we are going to update atleast*/
  /* 32 sites and that the lowest dimension extends over 32 bits. This    */
  /* second requirement is necessary because the optimized code can only  */
  /* handle dimension wraparounds at word boundaries.                     */
  /************************************************************************/
  if (lLogScanLength < 5)
    bNoPerm = bNoPermLast5 = FALSE;
  else if (lNumXBits < 5)
    bNoPerm = bNoPermLast5 = FALSE;
  else
    bNoPerm = bNoPermLast5 = TRUE;
  /************************************************************************/
  /* Now, determine if there is any permutation of the scan index in the  */
  /* bits of the SIR that will be significant over this scan.             */
  /************************************************************************/
  for (i = 0; i < MIN(5, ESC[0]); i++) {
    if (SIPR[i][0] != i) {
      bNoPerm = bNoPermLast5 = FALSE;
      break;
    }
    
    lLogScanLength--;
    
    if (!lLogScanLength)
      break;
  for (i = 5; i < MIN(SCAN_INDEX_LENGTH, ESC[0]); i++) {
    if (SIPR[i][0] != i)
      bNoPerm = FALSE;
    lLogScanLength--;
    if (!lLogScanLength)
      break;
#ifdef _FRAMEBUFFER_
  FRAME = (long32) FRAMEb;
#endif _FRAMEBUFFER_
  pcodCurrent = pcodScanner;
  hcodCurrent = &pcodCurrent;
  SimPrologue(hcodCurrent);
  if (bNoPerm)
    CheckNoPerm(hcodCurrent);
  else if (bNoPermLast5)
    SimGeneralScan(hcodCurrent);
  else
    SimGeneralScan(hcodCurrent);
  SimEpilogue(hcodCurrent);
  CaLib_tb.LEAVE();
/*****************************************************************************/
/*                                                                           */
/* CheckNoPerm is necessary for the following reason - suppose there is no   */
/* permutation of the Scan Index, but suppose the the bits that extend over  */
/* the lowest dimension (ie, the bits to the _right_ of the lowest bit of    */
/* DCMR) are not all zeros. Then, the first sweep will not scan a multiple-  */
/* of-two number of sites, and we cannot do an optimized scan.               */
/*                                                                           */
/*****************************************************************************/
void Cam8SimSPARCCore::CheckNoPerm(CODEHANDLE hcodCurrent)
  long32 lSIRSigBits, lSIR;
  CaLib_tb.ENTER("CheckNoPerm");
  lSIRSigBits = MIN(ESC[0], lNumXBits);
  lSIR = SIR[0] & ~((~0x0) << lSIRSigBits);
  if ((lSIR == 0) && (MIN(lNumXBits, ESC[0]) >= 2)) {
    if (bForceGeneralScan)
      SimGeneralScan(hcodCurrent);
    else
      SimScanNoPerm(hcodCurrent);
  else
    SimGeneralScan(hcodCurrent);
  CaLib_tb.LEAVE();
void Cam8SimSPARCCore::SimPrologue(CODEHANDLE hcodCurrent)
  CaLib_tb.ENTER("SimPrologue");
  NewBlock(hcodCurrent);
  .ENTER_PROC;
  CaLib_tb.LEAVE();
}     
void Cam8SimSPARCCore::SimEpilogue(CODEHANDLE hcodCurrent)
  CaLib_tb.ENTER("SimEpilogue");
 .RETURN_PROC;
  EndBlock();
  CaLib_tb.LEAVE();
void Cam8SimSPARCCore::SimExecScan(void)
  void (*fScan)(void);
  fScan = (void (*)()) pcodScanner;
  (*fScan)();
  ConstantSetAll(SIR, SCAN_INDEX_REG);
void Cam8SimSPARCCore::SimUpdateSite(void)
  short i;
  CODE pcodCurrent = pcodUpdateSite;
  CaLib_tb.ENTER("SimUpdateSite");
#ifdef _INCREMENTAL_COMPILE_     
  if (!(bSourceRegChange || bDestChange)) {
    CaLib_tb.LEAVE();
    return;
  else {
    bSourceRegChange = FALSE;
    bDestChange = FALSE;
#endif
  NewBlock(&pcodCurrent);
  .ENTER_LEAF,   
  if (IsSrcNeeded(SRC_TBUS) &&
      ((CAM8State.WhyScan != RFINDEX(REG_SIOR)) || (!CAM8State.bReadMode))) {
    if (!CAM8State.bImmediate) {
      if (CAM8State.bByteMode) {
	.LDUB_IND   iTbusAddr, #0, iTbusData;
	.ADD iTbusAddr, #1, iTbusAddr;
      } 
      
      else {
	.LDHW_IND iTbusAddr, #0, iTbusData;
	.ADD iTbusAddr, #2, iTbusAddr;
      }
    }
  if (IsSrcNeeded(SRC_SITE_DATA)) {
    .OR %G0, %G0, iUnGlueData;
    for (i = nNumPlanes-1; i >= 0; i--) {      
      .ADDcc (iPlaneWord+i), (iPlaneWord+i), (iPlaneWord+i);
      .ADDX iUnGlueData, iUnGlueData, iUnGlueData;
    }
  }  
  /* For Now glued and unglued data are the same */
  if (IsSrcNeeded(SRC_GLUED_DATA)) {
    if (!IsSrcNeeded(SRC_SITE_DATA)) {
      .OR %G0, %G0, iGlueData;
      for (i = nNumPlanes-1; i >= 0; i--) {      
	.ADDcc (iPlaneWord+i), (iPlaneWord+i), (iPlaneWord+i);
	.ADDX iGlueData, iGlueData, iGlueData;
      }
    }
    else {
      .OR %G0, iUnGlueData, iGlueData;
    }
  if (IsSrcNeeded(SRC_LUT)) {
    .OR   %G0, %G0, iLutData;
    if (IsSrcSame(DEST_LUT))
      BuildDest(DEST_LUT, iLutData, LAS[0], LAM[0]);            
    else
      BuildBitwiseDest(DEST_LUT, iLutData, LAS, LAM);
    .SH_LEFT      iLutData, #1, iLutData;
    .LDHW_IND     iLutAddr, iLutData, iLutData;
  /************************************************************************/
  /*                                                                      */
  /* All the sources needed to update all the destinations should now be  */
  /* in place. Update all the destinations in the following order : EC,   */
  /* Display (ie, scan io reads), and Site Data. Note that Site data      */
  /* must be updated last, because it destroys the Site Data register,    */
  /* which is one of the possible Sources (unglued data).                 */
  /*                                                                      */
  /************************************************************************/
  if (IsDestUpdated(DEST_DISPLAY)) {
    if (IsSrcSame(DEST_DISPLAY))
      BuildDest(DEST_DISPLAY, iTemp1, DDS[0], DDM[0]);
    else
      BuildBitwiseDest(DEST_DISPLAY, iTemp1, DDS, DDM);
#ifdef _FRAMEBUFFER_
    .STUB_IND iFrame, #0, iTemp1;
    .ADD iFrame, #1, iFrame;
#endif
  /* SCAN-IO READ */
  if ((CAM8State.WhyScan == RFINDEX(REG_SIOR)) && CAM8State.bReadMode) {
    if (CAM8State.bByteMode) {
      .STUB_IND iSIOR, #0, iTemp1;
      .ADD iSIOR, #1, iSIOR;
      }
    else {
      .STHW_IND iSIOR, #0, iTemp1;
      .ADD iSIOR, #2, iSIOR;
    }
  if (IsDestUpdated(DEST_EVENT_CT)) {
    if (IsSrcSame(DEST_EVENT_CT))
      BuildDest(DEST_EVENT_CT, iTemp1, ECS[0], ECM[0]);
    else
      BuildBitwiseDest(DEST_EVENT_CT, iTemp1, ECS, ECM);
    
    .SH_LEFT iTemp1, #(32 - nNumPlanes), iTemp1;
    for (i = nNumPlanes-1; i >= 0; i--) {
      .LDW_IND %DS, #(offEventCount+(i<<2)), iTemp2;
      .ADDcc iTemp1, iTemp1, iTemp1;
      .ADDX iTemp2, #0, iTemp2;
      .STW_IND %DS, #(offEventCount+(i<<2)), iTemp2;
    }
  if (IsDestUpdated(DEST_SITE_DATA)) {
    if (IsSrcSame(DEST_SITE_DATA)) {
      if (SDM[0] == MAP_S) {
	switch(SDS[0]) {
	case SRC_SITE_DATA: {
	  .OR %G0, iUnGlueData, iSiteDataSrc;
	  break;
	case SRC_TBUS: {
	  .OR %G0, iTbusData, iSiteDataSrc;
	  break;
	case SRC_LUT: {
	  .OR %G0, iLutData, iSiteDataSrc;
	  break;
	default: {
	  .OR %G0, iTemp1, iSiteDataSrc;
	  break;
      }
      else
	BuildDest(DEST_SITE_DATA, iSiteDataSrc, SDS[0], SDM[0]);
    }    
    else
      BuildBitwiseDest(DEST_SITE_DATA, iSiteDataSrc, SDS, SDM);
    .SH_LEFT iSiteDataSrc, #(32 - nNumPlanes), iSiteDataSrc;
    for (i = nNumPlanes - 1; i >= 0; i--) {                                
      .ADDcc iSiteDataSrc, iSiteDataSrc, iSiteDataSrc;
      
      if ((IsSrcNeeded(SRC_SITE_DATA)) || (IsSrcNeeded(SRC_GLUED_DATA))) {
	.ADDX (iPlaneWord+i), #0, (iPlaneWord+i);
      }
      else {
	.ADDX (iPlaneWord+i), (iPlaneWord+i), (iPlaneWord+i);
      }
    }
  .RETURN_LEAF;
    
  EndBlock();
  CaLib_tb.LEAVE();
void Cam8SimSPARCCore::SimScanNoPerm(CODEHANDLE hcodCurrent)
  long32 lTemp1, lTemp2;
  codelabel lblYLoop, lblAddrLoop, lblSkip;
  const short iPlaneCtr = iTemp1,
  iHeapOffset = iTemp2,
  iWordAddr = iTemp3,
  iHighBit = iTemp4;
  CaLib_tb.ENTER("SimScanNoPerm");
  lblSkip = NewLabel();
  lblYLoop = NewLabel();
  lblAddrLoop = NewLabel();
  /************************************************************************/
  /* Sim assuming the scan index is not permuted. This implies that   */
  /* bits to be updated during this scan are all consecutive.             */
  /************************************************************************/
  /************************************************************************/
  /* compute HIGH_BIT_MASK and X_HIGH_BIT_MASK				  */
  /************************************************************************/
  HIGH_BIT_MASK = lDCMRHighBit >> 3;
  X_HIGH_BIT_MASK = lDCMRLowBit >> 3;
  /************************************************************************/
  /* SITE_CTR is set to how many sweeps are to be done. X_byte_LENGTH is  */
  /* set to how many bytes will be updated per sweep                      */
  /************************************************************************/
  if (ESC[0] < lNumXBits) {
    SITE_CTR = 1;
    X_byte_LENGTH = 1 << (ESC[0] - 3);
  else {
    SITE_CTR = ScanLength() >> lNumXBits;                                  
    X_byte_LENGTH = lDCMRLowBit >> 2;
  nNumPlanes = CalcNumPlanes();
  /************************************************************************/
  /* Code starts here                                                     */
  /************************************************************************/
  .LDW_MEM iSiteCtr;
  .ADD_LABEL :lblYLoop;
  SimSweepCode();
  .CALL_PROC [pcodSweep];
  .NO_OP;
  .ADD %DS, #offNextWordAddr, iHeapOffset;
  .LDW_MEM iHighBitMask;
  .LDW_MEM iXByteLength;
  .ADD %G0, #0, iPlaneCtr;
  .ADD_LABEL :lblAddrLoop;
  .SUBcc iPlaneCtr, #(nNumPlanes*4), %G0;
  .BR_GRE :lblSkip;
  .LDW_IND iHeapOffset, iPlaneCtr, iWordAddr;
  .AND iHighBitMask, iWordAddr, iHighBit;
  .XNOR iHighBitMask, %G0, iHighBitMask;
  .AND iHighBitMask, iWordAddr, iWordAddr;
  .ADD iXByteLength, iWordAddr, iWordAddr;
  .XOR iHighBit, iWordAddr, iWordAddr;
  .STW_IND iHeapOffset, iPlaneCtr, iWordAddr;
  .ADD iPlaneCtr, #4, iPlaneCtr;
  .BRANCH :lblAddrLoop;
  .XNOR iHighBitMask, %G0, iHighBitMask;
  .ADD_LABEL :lblSkip;
  .SH_LEFT iXByteLength, #3, iTemp1;
  .LDW_MEM iScanIndexReg;
  .ADD iScanIndexReg, iTemp1, iScanIndexReg;
  .SUBcc iScanIndexReg, #0xFFFFFF, iTemp1;
  .BR_L :lblSkip;
  .NO_OP;
  .OR %G0, %G0, iScanIndexReg;
  .ADD_LABEL :lblSkip;
  .SUBcc iSiteCtr, #1, iSiteCtr;
  .BR_NZ :lblYLoop;
  .STW_MEM iScanIndexReg;
  CaLib_tb.LEAVE();
void Cam8SimSPARCCore::SimSweepCode(void)
  long32 xWordLength;
  codelabel lblXLoop;
  unsigned short nBitOffset[CHIPS_PER_MOD];
  short i, j;
  CODE pcodCurrent = pcodSweep;
  CaLib_tb.ENTER("SimSweepCode");
  lblXLoop = NewLabel();
  /************************************************************************/
  /* We assume here that the scan index is not permuted to arrive at the  */
  /* site address; however, some bits of the site address could be fixed  */
  /* at constant 0 or 1 as indicated by SIPR. Here, the site address of   */
  /* the first site to be updated is computed.                            */
  /************************************************************************/
  SITE_ADDR = 0;
  for (i = SCAN_INDEX_LENGTH-1; i >= 0; i--) {
    
    SITE_ADDR <<= 1;
    if (SIPR[i][0] == PERM_CONST_1)
      SITE_ADDR |= 0x1;
    else if (SIPR[i][0] != PERM_CONST_0)
      SITE_ADDR |= (SIR[0] >> i) & 0x1;
  /************************************************************************/
  /* Now that we know the site address of the first site to be updated,   */
  /* we compute the address in sparc memory of the word that contains     */
  /* a bit of that site by adding the plane offset to the site address.   */
  /************************************************************************/
  for (i = 0; i < nNumPlanes; i++) {
    NEXT_WORD_ADDR(i) = (AddSiteAddress(SITE_ADDR, OSR[i]) >> 5) << 2;
    NEXT_WORD_ADDR(i) += BIT_PLANE_ADDR(i);
    nBitOffset[i] = OSR[i] & 0x1F;
  xWordLength = X_byte_LENGTH >> 2;
  NewBlock(&pcodCurrent);
  .ENTER_PROC;
  SimLoadFirstWord(nBitOffset);
  if (IsSrcNeeded(SRC_SITE_ADDRESS)) {
    .LDW_MEM iScanIndexReg;
  if (IsSrcNeeded(SRC_LUT)) {
    .LDW_MEM iLutAddr;
  .LDW_MEM iUpdateSiteProc;
  .ADD %G0, #xWordLength, iXCtr;
  .ADD_LABEL :lblXLoop;
  SimUpdateSite();
  for (i = 0; i < 32; i++) {
    .CALL_LEAF_IND iUpdateSiteProc, #4;
    .INSTR *pcodUpdateSite;
    for (j = 0; j < nNumPlanes; j++) {
      if (nBitOffset[j] == (31 - i)) {
	SimGetNextWord(j);
      }
    }
  .SUBcc iXCtr, #1, iXCtr;
  .BR_NZ :lblXLoop;
  .NO_OP;
  SimSaveLastWord(nBitOffset);
  .RETURN_PROC;
  EndBlock();
  CaLib_tb.LEAVE();
void Cam8SimSPARCCore::SimLoadFirstWord(unsigned short nBitOffset[])
  short i;
  const short iSaveBits = iTemp1;
  const short iWordAddr = iTemp1;
  CaLib_tb.ENTER("SimLoadFirstWord");
  for (i = 0; i < nNumPlanes; i++) {
    .LDW_IND %DS, #(offNextWordAddr+(i<<2)), iWordAddr;
    .LDW_IND iWordAddr, #0, (iPlaneWord+i);
    if (nBitOffset[i] != 0) {
      .SH_RIGHT (iPlaneWord+i), #(32 - nBitOffset[i]), iSaveBits;
      .SH_LEFT (iPlaneWord+i), #nBitOffset[i], (iPlaneWord+i);
      .OR (iPlaneWord+i), iSaveBits, (iPlaneWord+i);
    }
  CaLib_tb.LEAVE();
void Cam8SimSPARCCore::SimGetNextWord(unsigned short nPlane)
  const short iAddrHighBit = iTemp1;
  bool bWriteBack = FALSE;
  short i;
  CaLib_tb.ENTER("SimGetNextWord");
  .ENTER_BASICBLK;
  if (IsDestUpdated(DEST_SITE_DATA)) {
    .STW_IND (iNextWordAddr+nPlane), #0, (iPlaneWord+nPlane);
  if (lNumXBits <= 5) {
    .RETURN_BASICBLK;
    CaLib_tb.LEAVE();
    return;
  .AND (iNextWordAddr+nPlane), iXHighBitMask, iAddrHighBit;
  .XNOR iXHighBitMask, %G0, iXHighBitMask;
  .AND (iNextWordAddr+nPlane), iXHighBitMask, (iNextWordAddr+nPlane);
  .ADD (iNextWordAddr+nPlane), #4, (iNextWordAddr+nPlane);
  .XOR iAddrHighBit, (iNextWordAddr+nPlane), iNextWordAddr+nPlane;
  .XNOR iXHighBitMask, %G0, iXHighBitMask;
  .LDW_IND (iNextWordAddr+nPlane), #0, (iPlaneWord+nPlane);
  .STW_MEM (iNextWordAddr+nPlane);
  .RETURN_BASICBLK;
  CaLib_tb.LEAVE();
void Cam8SimSPARCCore::SimSaveLastWord(unsigned short nBitOffset[])
  short i;
  const short iSaveBits = iTemp1;
  CaLib_tb.ENTER("SimSaveLastWord");
  if (IsDestUpdated(DEST_SITE_DATA)) {
    .ENTER_BASICBLK;
    for (i = 0; i < nNumPlanes; i++) {
      if (!nBitOffset[i])
	continue;
      .SH_RIGHT (iPlaneWord+i), #(nBitOffset[i]), iSaveBits;
      .SH_LEFT (iPlaneWord+i), #(32 - nBitOffset[i]), (iPlaneWord+i);
      .OR (iPlaneWord+i), iSaveBits, (iPlaneWord+i);
      .STW_IND (iNextWordAddr+i), #0, (iPlaneWord+i);
    }
    .RETURN_BASICBLK;
  CaLib_tb.LEAVE();
void Cam8SimSPARCCore::SimGeneralScan(CODEHANDLE hcodCurrent)
  /************************************************************************/
  /* Sim making no assumptions - in particular, it is expected that   */
  /* the scan index will be permuted, so that updated sites will not be   */
  /* sequentially located in memory.                                      */
  /************************************************************************/
  short i;
  codelabel lblMainLoop, lblAddrLoop, lblSkip1, lblSkip2;
  const short iPlaneCtr = iTemp1, iOffset = iTemp2, iPlaneBases = iTemp3;
  const short iBitOffset = iTemp4, iNextWord = iTemp5, iWordAddr = iTemp6;
  const short iSiteAddress = iTemp7, iSAHighBits = iTemp8;
  const short iOffHighBits = iTemp9, iScratch = iTemp9, iPlaneAddr = iTemp10;
  const short iSAAndMask = iTemp1, iSAOrMask = iTemp2;
  long32 lSAAndMask, lSAOrMask;
  long32 lSweepLength;
  CaLib_tb.ENTER("SimGeneralScan");
  nNumPlanes = CalcNumPlanes();
  lblMainLoop = NewLabel();
  lblAddrLoop = NewLabel();
  lblSkip1 = NewLabel();
  lblSkip2 = NewLabel();
  /************************************************************************/
  /* First, update things in the heap from where they can be accessed     */
  /* by the compiled code.                                                */
  /************************************************************************/
  /************************************************************************/
  /* Update heap copy of DCMR.						  */
  /************************************************************************/
  DCMR = DCM[0];
  /************************************************************************/
  /* Update heap copy of OFFSETS					  */
  /************************************************************************/
  for(i = 0 ; i < CHIPS_PER_MOD; i++)
    OFFSETS(i) = OSR[i];
  /************************************************************************/
  /* Figure out the site address of the first site to be updated. This is */
  /* needed to update SITE_ADDR for display purposes. Also,               */
  /* compute the SAAndMask and SAOrMask which will be used to do the      */
  /* permutation at execution time.                                       */
  /************************************************************************/
  SITE_ADDR = 0;
  lSAOrMask = lSAAndMask = 0;
  for (i = SCAN_INDEX_LENGTH-1; i >= 0; i--) {
    
    SITE_ADDR <<= 1;
    lSAOrMask <<= 1;
    lSAAndMask <<= 1;
    
    if (SIPR[i][0] < SCAN_INDEX_LENGTH) {
      
      /* Get the correct bit of scan indx */
      SITE_ADDR |= (SIR[0] >> SIPR[i][0]) & 0x1;
      
      if (SIPR[i][0] == i)
	lSAAndMask |= 1;
    }
    
    /* Constant of 1 */
    else if (SIPR[i][0] == PERM_CONST_1) {
      lSAOrMask |= 1;
      SITE_ADDR |= 1;
    }
    
    else if (SIPR[i][0] != PERM_CONST_0)
      WARNING("Invalid SIPR value", "SimGenScan");
    
  /************************************************************************/
  /* Figure out how many sites will be updated, and how many sites/sweep  */
  /************************************************************************/
  SITE_CTR = ScanLength();
  lSweepLength = SweepLength(&X_CTR);
  /************************************************************************/
  /* Next, generate the code. First, permute the scan index register to   */
  /* get the site address.                                                */
  /************************************************************************/
    .LDW_MEM iSiteCtr;
    .LDW_MEM iXCtr;
    .LDW_MEM iXByteLength;
    
    .ADD_LABEL :lblMainLoop;
    
    .ENTER_BASICBLK;
    .LDW_MEM iScanIndexReg;
    
    .ADD %G0, #lSAAndMask, iSAAndMask;
    .ADD %G0, #lSAOrMask, iSAOrMask;
    
    .AND iScanIndexReg, iSAAndMask, iSiteAddress;
    .OR iSAOrMask, iSiteAddress, iSiteAddress;
    
    for (i = SCAN_INDEX_LENGTH-1; i >= 0; i--) {
      if ((SIPR[i][0] < SCAN_INDEX_LENGTH) && (SIPR[i][0] != i)) {
	.SH_LEFT iScanIndexReg, #(31 - SIPR[i][0]), iScratch;
	.ADDcc iScratch, iScratch, iScratch;
	.ADDX %G0, %G0, iTemp10;
	.SH_LEFT iTemp10, #i, iTemp10;
	.OR iTemp10, iSiteAddress, iSiteAddress;
      }
    }
      
    /************************************************************************/
    /* Now, add site address to the offset to get the DRAM address. The     */
    /* addition must break the carries at the dimension cuts. Also, DRAM    */
    /* address must be broken into a SPARC word address and a 5 bit offset  */
    /* into the word                                                        */
    /************************************************************************/
    
    .ADD %DS, #offOffsets, iOffset;
    .ADD %DS, #offBitPlaneAddr, iPlaneBases;
    .ADD %DS, #offBitOffsets, iBitOffset;
    .ADD %DS, #offNextWordAddr, iNextWord;
    
    .LDW_MEM iDcmr;
    .AND iDcmr, iSiteAddress, iSAHighBits;
    .XNOR %G0, iDcmr, iDcmr;
    .AND iDcmr, iSiteAddress, iSiteAddress;
    .AND iDcmr, iSiteAddress, iScratch;
    .AND iScratch, #(SITE_ADDR_MASK), iSiteAddress;
    .XNOR %G0, iDcmr, iDcmr;
    
    .ADD %G0, #0, iPlaneCtr;
    .ADD_LABEL :lblAddrLoop;
    
    .LDW_IND iOffset, iPlaneCtr, iWordAddr;
    .AND iDcmr,  iWordAddr, iOffHighBits;
    .XNOR %G0, iDcmr, iDcmr;
    .AND iDcmr,  iWordAddr, iWordAddr;
    .ADD iSiteAddress, iWordAddr, iWordAddr;
    .XOR iWordAddr, iOffHighBits, iWordAddr;
    .XOR iWordAddr, iSAHighBits, iWordAddr;
    
    .LDW_IND iPlaneBases, iPlaneCtr, iPlaneAddr;
    .SH_RIGHT iWordAddr, #5, iScratch;
    .SH_LEFT iScratch, #2, iScratch;
    .ADD iScratch, iPlaneAddr, iScratch;
    .STW_IND iNextWord, iPlaneCtr, iScratch;
    .AND iWordAddr, #0x1F, iWordAddr;
    .STW_IND iBitOffset, iPlaneCtr, iWordAddr;
    
    .ADD iPlaneCtr, #4, iPlaneCtr;
    .SUBcc iPlaneCtr, #(nNumPlanes * 4), %G0;
    .BR_L :lblAddrLoop;
    .XNOR %G0, iDcmr, iDcmr;
    
    .RETURN_BASICBLK;
    
  /************************************************************************/
  /* Now, the heap has the word addresses and bit offsets for the next    */
  /* site. So go ahead and update the site.                               */
  /************************************************************************/
  SimUpdateCode();
  .CALL_PROC [pcodGenUpdate];
  .NO_OP;
  .LDW_MEM iScanIndexReg;
  .SUBcc iXCtr, #1, iXCtr;
  .BR_NZ :lblSkip1;
  .NO_OP;
  .ADD %G0, #lSweepLength, iXCtr;
  .ADD_LABEL :lblSkip1;
  .ADD iScanIndexReg, #1, iScanIndexReg;
  .SUBcc iScanIndexReg, #(0xFFFFFF), iScratch;
  .BR_L :lblSkip2;
  .NO_OP;
  .OR %G0, %G0, iScanIndexReg;    
  .ADD_LABEL :lblSkip2;
  .SUBcc iSiteCtr, #1, iSiteCtr;
  .BR_NZ :lblMainLoop;
  .STW_MEM iScanIndexReg;
  CaLib_tb.LEAVE();
void Cam8SimSPARCCore::SimUpdateCode()
  CODE pcodCurrent = pcodGenUpdate;
  CaLib_tb.ENTER("SimUpdateCode");
  NewBlock(&pcodCurrent);
  .ENTER_PROC;
  SimLoadPlaneWords();
  SimUpdateSite();
  .CALL_LEAF [pcodUpdateSite];
  .NO_OP;
  SimSavePlaneWords();
     
  .RETURN_PROC;
  EndBlock();
  CaLib_tb.LEAVE();
void Cam8SimSPARCCore::SimLoadPlaneWords(void)
  short i;
  const short iWordAddr = iTemp1;
  const short iBitOffset = iTemp1;
  const short iSaveBits = iTemp2;
  const short iScratch = iTemp3;
  CaLib_tb.ENTER("SimLoadPlaneWords");
  if (!IsSrcNeeded(SRC_SITE_DATA) && !IsSrcNeeded(SRC_GLUED_DATA) &&
      !IsDestUpdated(DEST_SITE_DATA)) {
    CaLib_tb.LEAVE();
    return;
  .ADD %G0, #32, iScratch;
  for (i = 0; i < nNumPlanes; i++) {
    .LDW_IND %DS, #(offNextWordAddr+(i<<2)), iWordAddr;
    .LDW_IND iWordAddr, #0, (iPlaneWord+i);
    .LDW_IND %DS, #(offBitOffsets+(i<<2)), iBitOffset;
    .SUB iScratch, iBitOffset, iBitOffset;
    .SH_RIGHT (iPlaneWord+i), iBitOffset, iSaveBits;
    .SUB iScratch, iBitOffset, iBitOffset;
    .SH_LEFT (iPlaneWord+i), iBitOffset, (iPlaneWord+i);
    .OR (iPlaneWord+i), iSaveBits, (iPlaneWord+i);
  CaLib_tb.LEAVE();
void Cam8SimSPARCCore::SimSavePlaneWords(void)
  short i;
  const short iWordAddr = iTemp1;
  const short iBitOffset = iTemp1;
  const short iSaveBits = iTemp2;
  const short iScratch = iTemp3;
  CaLib_tb.ENTER("SimSavePlaneWords");
  if (!IsDestUpdated(DEST_SITE_DATA)) {
    CaLib_tb.LEAVE();
    return;
  .ADD %G0, #31, iScratch;
  for (i = 0; i < nNumPlanes; i++) {
    .LDW_IND %DS, #(offBitOffsets+(i<<2)), iBitOffset;
    .SUB iScratch, iBitOffset, iBitOffset;
    .SH_LEFT (iPlaneWord+i), iBitOffset, iSaveBits;
    .SUB iScratch, iBitOffset, iBitOffset;
    .ADD iBitOffset, #1, iBitOffset;
    .SH_RIGHT (iPlaneWord+i), iBitOffset, (iPlaneWord+i);
    .OR (iPlaneWord+i), iSaveBits, (iPlaneWord+i);
    .LDW_IND %DS, #(offNextWordAddr+(i<<2)), iWordAddr;
    .STW_IND iWordAddr, #0, (iPlaneWord+i);
  CaLib_tb.LEAVE();
}     
short Cam8SimSPARCCore::PermuteScanIndex(void)
  short i;
  bool bIsPermuted = FALSE;
  CaLib_tb.ENTER("PermuteScanIndex");
  for (i = nNumPlanes - 1; i >= 0; i--) {
    if (SABSR[i] != i) {
      bIsPermuted = TRUE;
      break;
    }
  if (!bIsPermuted) {
    CaLib_tb.LEAVE();
    return (iScanIndexReg);
  .OR %G0, %G0, iTemp6;
  for (i = nNumPlanes-1; i >= 0; i--) {
    if (SABSR[i] < 24) {
      .SH_LEFT iScanIndexReg, #(31 - SABSR[i]), iTemp5;
      .ADDcc iTemp5, iTemp5, iTemp5;
      .ADDXcc iTemp6, iTemp6, iTemp6;
    }
    else if (SABSR[i] == 31) {
      .SH_LEFT iTemp6, #1, iTemp6;
      .ADD iTemp6, #1, iTemp6;
    }
    else if (SABSR[i] == 30) {
      .SH_LEFT iTemp6, #1, iTemp6;
    }
    else {
      WARNING("Invalid SABSR value!", "PermuteScanIndex");
      .SH_LEFT iTemp6, #1, iTemp6;
    }
  CaLib_tb.LEAVE();
  return (iTemp6);
void Cam8SimSPARCCore::MapFunction(short iSrcVar, short iDestVar, byte bMap)
  CaLib_tb.ENTER("MapFunction");
  switch (bMap) {
  case MAP_CONST_0: {
    .OR %G0, %G0, iDestVar;
    break;
    
  case MAP_G_NOR_S: {
    /* Surprizingly, SPARC does not have*/
    /* a native NOR instruction! ORN is */
    /* not NOR!!!                       */
    .OR iGlueData, iSrcVar, iDestVar;
    .XNOR %G0, iDestVar, iDestVar;
    break;
  }    
  case MAP_G_AND_S_BAR: {
    .XNOR %G0, iSrcVar, iDestVar;
    .AND iGlueData, iDestVar, iDestVar;
    break;
    
  case MAP_S_BAR: {
    .XNOR %G0, iSrcVar, iDestVar;
    break;
    
  case MAP_G_BAR_AND_S: {
    .XNOR %G0, iGlueData, iDestVar;
    .AND iSrcVar, iDestVar, iDestVar;
    break;
    
  case MAP_G_BAR: {
    .XNOR %G0, iGlueData, iDestVar;
    break;
    
  case MAP_G_XOR_S: {
    .XOR iGlueData, iSrcVar, iDestVar;
    break;
    
  case MAP_G_NAND_S: {
    /* The SPARC does not have a native NAND */
    /* instruction! ANDN is not NAND */
    .AND iGlueData, iSrcVar, iDestVar;
    .XNOR %G0, iDestVar, iDestVar;
    break;
    
  case MAP_G_AND_S: {
    .AND iGlueData, iSrcVar, iDestVar;
    break;
    
  case MAP_G_EQ_S: {
    .XNOR iGlueData, iSrcVar, iDestVar;
    break;
    
  case MAP_G: {
    .XOR %G0, iGlueData, iDestVar;
    break;
    
  case MAP_G_OR_S_BAR: {
    .XNOR %G0, iSrcVar, iDestVar;
    .OR iGlueData, iDestVar, iDestVar;
    break;
    
  case MAP_S: {
    .XOR %G0, iSrcVar, iDestVar;
    break;
    
  case MAP_G_BAR_OR_S: {
    .XNOR %G0, iGlueData, iDestVar;
    .OR iSrcVar, iDestVar, iDestVar;
    break;
    
  case MAP_G_OR_S: {
    .OR iGlueData, iSrcVar, iDestVar;
    break;
    
  case MAP_CONST_1: {
    .XNOR %G0, %G0, iDestVar;
    break;
  CaLib_tb.LEAVE();
void Cam8SimSPARCCore::BuildDest(short nDest, short iDestVar, byte Src, byte Map)
  short iSrcVar;
  CaLib_tb.ENTER("BuildDest");
  if ((Map != MAP_G) && (Map != MAP_G_BAR)) {
    iSrcVar = (Src == SRC_SITE_DATA ? iUnGlueData :
	       Src == SRC_TBUS ? iTbusData :
	       Src == SRC_LUT ? iLutData : iTemp1);
    if ((nDest == DEST_LUT) && (Src == SRC_SITE_ADDRESS)) {
      iSrcVar = PermuteScanIndex();
    }
  MapFunction(iSrcVar, iDestVar, Map);
  CaLib_tb.LEAVE();
void Cam8SimSPARCCore::BuildBitDest(short nDest, short iHoldReg, byte Src,
				    byte Map, unsigned short nPlane)
{                                                               
     
  CaLib_tb.ENTER("BuildBitDest");
  if ((nDest == DEST_LUT) && (Src == SRC_SITE_ADDRESS)) {
    .OR           %G0, %G0, iTemp6;
    
    if (SABSR[nPlane] < 24) {
      .SH_LEFT iScanIndexReg, #(31 - SABSR[nPlane]), iTemp5;
      .ADDcc iTemp5, iTemp5, iTemp5;
      .ADDXcc iTemp6, iTemp6, iTemp6;
      .SH_LEFT iTemp6, #nPlane, iTemp6;
    }
    else if (SABSR[nPlane] == 31) {
      .SH_LEFT iTemp6, #1, iTemp6;
      .ADD iTemp6, #1, iTemp6;
    }
    else if (SABSR[nPlane] == 30) {
      .SH_LEFT iTemp6, #1, iTemp6;
    }
    else {
      WARNING("Invalid SABSR value", "BuildBitDest");
      .SH_LEFT iTemp6, #1, iTemp6;
    }      
    MapFunction (iTemp6, iHoldReg, Map);
  else
    BuildDest(nDest, iHoldReg, Src, Map);
  CaLib_tb.LEAVE();
void Cam8SimSPARCCore::BuildBitwiseDest(short nDest, short iDestVar, byte Src[],
					byte Map[])
  short i;
  short iHoldReg = iTemp4;
  CaLib_tb.ENTER("BuildBitwiseDest");
  for (i = nNumPlanes - 1; i >= 0; i--) {
    BuildBitDest(nDest, iHoldReg, Src[i], Map[i], i);
    .SH_LEFT iHoldReg, #(31 - i), iHoldReg;
    .ADDcc iHoldReg, iHoldReg, iHoldReg;
    .ADDXcc iDestVar, iDestVar, iDestVar;
  CaLib_tb.LEAVE();
sregister Cam8SimSPARCCore::GetReg(int16 nVar, CODEHANDLE hcodCurrent, bool bLoad)
  sregister reg;
  CODE pcodNext;
  pcodNext = *hcodCurrent;
     
  if (SymbolTable[nVar].regLoc != 0) {					 /* if nVar is already in a register */
    return (SymbolTable[nVar].regLoc);					 /* 	return the register 	     */
  if (NumFreeRegs() != 0) {						 	 /* else if there is a free register */
    reg = GetFreeReg();							 /* 	get free register 	     */
  } else {
    reg = GetSpillable();							 /* else get a spillable register    */
#ifdef _INSTRUMENTATION_
    fprintf(stderr, "Spilling Register : Variable %x : Priority %x\n",
	    rCurrWindow[reg].nVar,
	    rCurrWindow[reg].nPriority);
#endif	  
    if (debug)
      fprintf(DEBUGFILE, "Spilling Register : Variable %s : Priority %x\n",
	      SYMBOLS[rCurrWindow[reg].nVar], rCurrWindow[reg].nPriority);
	  SymbolTable[rCurrWindow[reg].nVar].regLoc = 0;			 /* 	Unmark old var's reg alias   */
	  EMIT(STW_REG_IMM(REG_DS, rCurrWindow[reg].nHeapOffset, reg));		 /* 	spill the register 	     */
     }
     
     SymbolTable[nVar].regLoc = reg;						 /* Update SymbolTable	    	     */
     rCurrWindow[reg].nVar = nVar;						 /* and Current Reg Window recs      */
     rCurrWindow[reg].nHeapOffset = SymbolTable[nVar].nHeapOffset;		 
     rCurrWindow[reg].nPriority = SymbolTable[nVar].nPriority;
     if (rCurrWindow[reg].nPriority != VOLATILE) {				 /* if nVar is not a VOLATILE        */
	  if (bLoad) {
	       EMIT(LDW_REG_IMM(REG_DS, rCurrWindow[reg].nHeapOffset, reg));	 /*    load it into reg	  	     */
	  }
	  InsertSpillable(reg);							 /*    and mark it as spillable	     */
     }
     *hcodCurrent = pcodNext;							 /* Update caller's code handle      */
     if (debug) {
       fprintf(DEBUGFILE, "%s is in register %s\n", SYMBOLS[nVar],
	       REGISTERS[reg]);
       fflush(stderr);
     }
     return (reg);
     
void Cam8SimSPARCCore::FlushReg(sregister rFlush, CODEHANDLE hcodCurrent)
     CODE 	pcodNext = *hcodCurrent;
     if (rCurrWindow[rFlush].nPriority != VOLATILE) {
	  EMIT(STW_REG_IMM(REG_DS, rCurrWindow[rFlush].nHeapOffset, rFlush));	 /* Store rFlush back to heap 	     */
	  *hcodCurrent = pcodNext;
     }
     SymbolTable[rCurrWindow[rFlush].nVar].regLoc = 0;
     FreeReg(rFlush);
void Cam8SimSPARCCore::PushRegWindow()
     short i, j;
     SaveRegState();								 /* Save state of registers 	     */
     ResetFreeQue();
     ResetSpillQue();
     for (i = REG_L0; i <= REG_L7; i++) {					 /* Free all the new Local Registers */
	  SymbolTable[rCurrWindow[i].nVar].regLoc = 0;				 /* if nVar == 0, who cares? 	     */
	  FreeReg(i);
     }
     for (i = REG_O0, j = REG_I0; i <= REG_O5; i++, j++) {
	  SymbolTable[rCurrWindow[j].nVar].regLoc = 0;				 /* Vars in previous in register     */
										 /* become inaccessible 	     */
	  rCurrWindow[j] = rCurrWindow[i];					 /* Out registers become in regs     */
	  if (rCurrWindow[j].nVar != 0) {					 /* Update SymbolTable regLoc entries*/
	       SymbolTable[rCurrWindow[j].nVar].regLoc = j;			 /* for symbols in new In Registers  */
	       if (rCurrWindow[j].nPriority != VOLATILE) {			 /* if the var is also spillable,    */
		    InsertSpillable(j);						 /*    mark it as such 		     */
	       }
	  } else {								 /* If no symbol in new In Register, */
	       FreeReg(j);							 /* mark it as free 		     */
	  }
     }
     for (i = REG_O0; i <= REG_O5; i++) {					 /* Free all the new Out Registers,  */
	  SymbolTable[rCurrWindow[i].nVar].regLoc = 0;				 /* except SP and DS  		     */
	  FreeReg(i);
     }
     
     for (i = REG_G1; i <= REG_G6; i++) {					 /* Since we reset the free and spil */
	  if (rCurrWindow[i].nVar == 0) {					 /* queues, add unused global regs   */
	       FreeReg(i);							 /* to the appropriate queues 	     */
	  } else {
	       if (rCurrWindow[i].nPriority != VOLATILE) {
		    InsertSpillable(i);
	       }
	  }
     }
     
void Cam8SimSPARCCore::PopRegWindow(CODEHANDLE hcodCurrent)					 /* Reverse the action of PushRegWi. */
{										 /* This window's local and out regs */
     short i, j;								 /* will go out of scope, so store   */
     CODE pcodNext = *hcodCurrent;						 /* any vars in there back to heap   */
										 /* In regs of this window become out*/
     ResetFreeQue();								 /* regs of prev window 	     */
     ResetSpillQue();
     /* The following loop restores the local registers to the state of the  */
     /* parent's local registers. All vars in current local registers are    */
     /* stored back to heap, and their symbol table entries updated	     */
     for (i = REG_L0; i <= REG_L7; i++) {					 /* Restore local regs to state of   */
	  if (rCurrWindow[i].nVar != 0) {					 /* previous window 		     */
	       SymbolTable[rCurrWindow[i].nVar].regLoc = 0;
	       if (rCurrWindow[i].nPriority != VOLATILE) {			 /* if this window was using reg,    */
		    EMIT(STW_REG_IMM(REG_DS,					 /* update heap 		     */
				     rCurrWindow[i].nHeapOffset, i));
	       }
	  }
	  rCurrWindow[i] = precTOS->rWindow[i];					 /* Now, restore to state of prev    */
	  if (rCurrWindow[i].nVar != 0) {					 /* window 			     */
	       SymbolTable[rCurrWindow[i].nVar].regLoc = i;
	       if (rCurrWindow[i].nPriority != VOLATILE) {
		    InsertSpillable(i);
	       }
	  } else {
	       FreeReg(i);
	  }
     }
     /* The following loop stores all vars in OUT registers back to heap     */
     /* and updates their symbol table entries. At the end of this loop, all */
     /* OUT registers are marked as empty. 				     */
     for (i = REG_O0; i <= REG_O5; i++) {					 /* Store vars in OUT regs to heap   */
	  if (rCurrWindow[i].nVar != 0) {
	       SymbolTable[rCurrWindow[i].nVar].regLoc = 0;
	       if (rCurrWindow[i].nPriority != VOLATILE) {			 /* if this window was using reg,    */
		    EMIT(STW_REG_IMM(REG_DS,					 /* update heap 		     */
				     rCurrWindow[i].nHeapOffset, i));
	       }
	       rCurrWindow[i].nVar = 0;
	       rCurrWindow[i].nPriority = 0;
	       rCurrWindow[i].nHeapOffset = 0;
	  }
     }
     /* The following loop does two things: one, it restores the OUT reg     */
     /* to the parent's state; two, it leaves the IN registers empty. Since  */
     /* popping a reg window means that the current IN registers become the  */
     /* OUT registers, this loop must do both things simultaneously. Effect  */
     /* is that any vars in IN registers which are in the parent's OUT reg   */
     /* are simply marked to be in the OUT registers. Any vars in IN reg     */
     /* which are not in the the parent's OUT reg, are restored back to heap.*/
     /* At the end of this loop, the OUT regs are back to their parent's     */
     /* state, and all the IN regs are empty, either spilled or marked to    */
     /* to the OUT regs							     */
     for (i = REG_I0, j = REG_O0; i <= REG_I5; i++, j++) {
	  if (rCurrWindow[i].nVar == precTOS->rWindow[j].nVar) {		 /* if var in IN register was inh-   */
	       rCurrWindow[j] = rCurrWindow[i];					 /* erited from parent's OUT reg,    */
	       if (rCurrWindow[j].nPriority != VOLATILE) {			 /* restore it to out reg 	     */
		    InsertSpillable(j);
	       }
	       SymbolTable[rCurrWindow[j].nVar].regLoc = j;
	  } else {								 /* var not inherited from parent    */
	       if (rCurrWindow[i].nPriority != VOLATILE) {			 /* if var not volatile		     */
		    EMIT(STW_REG_IMM(REG_DS,					 /*    restore to heap 		     */
				     rCurrWindow[i].nHeapOffset, i));
	       }
	       SymbolTable[rCurrWindow[i].nVar].regLoc = 0;			 /* update symbol table 	     */
	       rCurrWindow[j] = precTOS->rWindow[j];				 /* restore parent's var 	     */
	       if (rCurrWindow[j].nVar != 0) {					 /* if parent had a var in reg 	     */
		    SymbolTable[rCurrWindow[i].nVar].regLoc = i;		 /*    update symbol table 	     */
		    if (rCurrWindow[i].nPriority != VOLATILE) {			 /*    and spill que 		     */
			 InsertSpillable(j);
		    }
	       } else {								 /* else parent had no var in reg    */
		    FreeReg(j);							 /*    so free it 		     */
	       }
	  }
	  rCurrWindow[i].nVar = 0;
	  rCurrWindow[i].nPriority = 0;
	  rCurrWindow[i].nHeapOffset = 0;
     }
     /* The following loop restores the IN regs to the state of the parents  */
     /* It assumes that all the IN regs are currently marked empty.	     */
     for (i = REG_I0; i <= REG_I5; i++) {					 /* Restore in registers to that of  */
	  rCurrWindow[i] = precTOS->rWindow[i];					 /* parent 			     */
	  if (rCurrWindow[i].nVar == 0) {
	       FreeReg(i);
	  } else {
	       if (rCurrWindow[i].nPriority != VOLATILE) {
		    InsertSpillable(i);
	       }
	       SymbolTable[rCurrWindow[i].nVar].regLoc = i;
	  }
     }
     
     for (i = REG_G1; i <= REG_G6; i++) {					 /* Since we reset the free and spil */
	  if (rCurrWindow[i].nVar == 0) {					 /* queues, add unused global regs   */
	       FreeReg(i);							 /* to the appropriate queues 	     */
	  } else {
	       if (rCurrWindow[i].nPriority != VOLATILE) {
		    InsertSpillable(i);
	       }
	  }
     }
     
     RestoreRegState(CURRENT_HANDLE);						 /* now, restore register state      */
     *hcodCurrent = pcodNext;
     
void Cam8SimSPARCCore::SaveRegState()								 /* Take a snapshot of register      */
{										 /* contents. 			     */
     REGREC precNew;
     precNew = (REGREC) MALLOC(sizeof(regrec), "SaveRegState");
     memcpy((char *)precNew, (char *)rCurrWindow, sizeof(regrec));		 /* Ok, so this is a litte flaky     */
     precNew->precPrev = precTOS;
     precTOS = precNew;
void Cam8SimSPARCCore::RestoreRegState(CODEHANDLE hcodCurrent)					 /* Restore state to snapshot. Only  */
{										 /* non-volatile priority registers  */
     CODE pcodNext = *hcodCurrent;						 /* are guaranteed to be restored.   */
     short i;
     REGREC precOld;
     /************************************************************************/
     /* First, save all the registers which have different variables than    */
     /* the parent.							     */
     /************************************************************************/
     
     for (i = REG_G1; i <= REG_I5; i++) {
	  if (rCurrWindow[i].nVar == 0) {
	       continue;
	  } else if (rCurrWindow[i].nVar != precTOS->rWindow[i].nVar) {
	       FlushReg(i, CURRENT_HANDLE);
	  }
     }
     /************************************************************************/
     /* Now, go through each register, and for all those registers which are */
     /* not in the same state as the parent, refresh the register	     */
     /************************************************************************/
     
     for (i = REG_G1; i <= REG_I5; i++) {
	  if (precTOS->rWindow[i].nVar == 0) {
	       continue;
	  } else if (    (precTOS->rWindow[i].nVar != rCurrWindow[i].nVar)
		      && (precTOS->rWindow[i].nPriority != VOLATILE)) {
	       EMIT( LDW_REG_IMM(REG_DS, precTOS->rWindow[i].nHeapOffset, i) );
	       rCurrWindow[i] = precTOS->rWindow[i];
	       SymbolTable[rCurrWindow[i].nVar].regLoc = i;
	  }
     }
	       
     /************************************************************************/
     /* Now, we need to refresh the state of the free and spill ques.	     */
     /************************************************************************/
     
     ResetFreeQue();
     ResetSpillQue();
     for (i = REG_L0; i <= REG_L7; i++) {
	  if (rCurrWindow[i].nVar == 0) {
	       FreeReg(i);
	  } else if (rCurrWindow[i].nPriority != VOLATILE) {
	       InsertSpillable(i);
	  }
     }
     for (i = REG_O0; i <= REG_O5; i++) {
	  if (rCurrWindow[i].nVar == 0) {
	       FreeReg(i);
	  } else if (rCurrWindow[i].nPriority != VOLATILE) {
	       InsertSpillable(i);
	  }
     }
     for (i = REG_I0; i <= REG_I5; i++) {
	  if (rCurrWindow[i].nVar == 0) {
	       FreeReg(i);
	  } else if (rCurrWindow[i].nPriority != VOLATILE) {
	       InsertSpillable(i);
	  }
     }
     for (i = REG_G1; i <= REG_G6; i++) {
	  if (rCurrWindow[i].nVar == 0) {
	       FreeReg(i);
	  } else if (rCurrWindow[i].nPriority != VOLATILE) {
	       InsertSpillable(i);
	  }
     }
     *hcodCurrent = pcodNext;
     precOld = precTOS;
     precTOS = precTOS->precPrev;
     FREE(precOld, "RestoreRegState");
}			 
void Cam8SimSPARCCore::InitRegMgr()
     short i;
     regentry rentNull = {0, 0, 0};
     REGREC precOld;
     for (i = 0; i < MREGS; i++) {						 /* Mark all register entries as     */
	  rCurrWindow[i] = rentNull;						 /* NULL 			     */
     }
     while (precTOS) {								 /* Free up stack of saved states    */
	  precOld = precTOS;
	  precTOS = precTOS->precPrev;
	  FREE(precOld, "InitRegMgr");
     }
     ResetFreeQue();
     ResetSpillQue();
     for (i = REG_L0; i <= REG_L7; i++) {
	  FreeReg(i);
     }
     for (i = REG_O0; i <= REG_O5; i++) {
	  FreeReg(i);
     }
     for (i = REG_I0; i <= REG_I5; i++) {
	  FreeReg(i);
     }
     for (i = REG_G1; i <= REG_G6; i++) {					 /* Free up all registers except     */
	  FreeReg(i);								 /* FP, RA, DS, and SP 		     */
     }
     
/*****************************************************************************/
/*                                                                           */
/* Routines to manipulate free registers				     */
/*                                                                           */
/*****************************************************************************/
byte Cam8SimSPARCCore::NumFreeRegs()
     return (NumQueElements(rqueFree));
sregister Cam8SimSPARCCore::GetFreeReg()
     return (GetQueElement(&rqueFree));
void Cam8SimSPARCCore::FreeReg(sregister reg)
     AddQueElement(&rqueFree, reg);
     rCurrWindow[reg].nVar = 0;
     rCurrWindow[reg].nPriority = VOLATILE;
     rCurrWindow[reg].nHeapOffset = 0;
void Cam8SimSPARCCore::ResetFreeQue()
     ResetQue(&rqueFree);
/*****************************************************************************/
/*                                                                           */
/* Routines to manipulate spillable registers.				     */
/*                                                                           */
/*****************************************************************************/
sregister Cam8SimSPARCCore::GetSpillable()
     if (NumQueElements(rqueSpillable[TEMP-1]) != 0) {				 /* Check for spillable register in  */
	  return (GetQueElement(&rqueSpillable[TEMP-1]));			 /* TEMP priority que, then LOOP_CTR,*/
     } else if (NumQueElements(rqueSpillable[LOOP_CTR-1]) != 0) {		 /* and last in GLOBAL priority que  */
	  return (GetQueElement(&rqueSpillable[LOOP_CTR-1]));
     } else if (NumQueElements(rqueSpillable[GLOBAL-1]) != 0) {
	  return (GetQueElement(&rqueSpillable[GLOBAL-1]));
     } else {
	  return (0);
     }
	   
void Cam8SimSPARCCore::InsertSpillable(sregister reg)
     short nPriority = rCurrWindow[reg].nPriority - 1;
     
     AddQueElement(&rqueSpillable[nPriority], reg);
void Cam8SimSPARCCore::ResetSpillQue()
     short i;
     
     for (i = 0; i < 4; i++) {
	  ResetQue(&rqueSpillable[i]);
     }
/*****************************************************************************/
/*                                                                           */
/* Implementation of queues of registers. Lists of Free registers and 	     */
/* registers containing different priority variables are organized as queues */
/*                                                                           */
/*****************************************************************************/
byte Cam8SimSPARCCore::NumQueElements(regque rque)
     return (rque.bNumElements);
sregister Cam8SimSPARCCore::GetQueElement(regque *prque)
     sregister reg;
     
     if (prque->bNumElements != 0) {
	  reg = prque->rRegQue[prque->bTail];
	  prque->bTail = (prque->bTail + 1) % MREGS;
	  prque->bNumElements--;
     } else {
	  reg = 0;
     }
     return (reg);
void Cam8SimSPARCCore::AddQueElement(regque *prque, sregister reg)
#ifdef _CAUTIOUS_
     if (prque->bNumElements < MREGS) {
#endif	  
	  prque->bNumElements++;
	  prque->rRegQue[prque->bHead] = reg;
	  prque->bHead = (prque->bHead + 1) % MREGS;
#ifdef _CAUTIOUS_	  
     } else {
	  CRITICAL_ERROR("Queue Overflow", "AddQueElement");
     }
#endif     
void Cam8SimSPARCCore::ResetQue(regque *prque)
     prque->bNumElements = 0;
     prque->bHead = 0;
     prque->bTail = 0;
TERPRETER
#ifndef INTERPRETER
short PermuteScanIndex()
#else INTERPRETER
LONG32 *PermuteScanIndex()
#endif INTERPRETER
  short i;
  BOOL bIsPermuted = FALSE;
  EP("PermuteScanIndex");
  for (i = nNumPlanes - 1; i >= 0; i--) {
    if (SABSR[i] != i) {
      bIsPermuted = TRUE;
      break;
    }
#ifndef INTERPRETER
  if (!bIsPermuted) {
    LP("PermuteScanIndex");
    return (iScanIndexReg);
#else INTERPRETER
  if (!bIsPermuted) {
    LP("PermuteScanIndex");
    return(&SCAN_INDEX_REG);
#endif INTERPRETER
#ifndef INTERPRETER
  .OR %G0, %G0, iTemp6;
  for (i = nNumPlanes-1; i >= 0; i--) {
    if (SABSR[i] < 24) {
      .SH_LEFT iScanIndexReg, #(31 - SABSR[i]), iTemp5;
      .ADDcc iTemp5, iTemp5, iTemp5;
      .ADDXcc iTemp6, iTemp6, iTemp6;
    }
    else if (SABSR[i] == 31) {
      .SH_LEFT iTemp6, #1, iTemp6;
      .ADD iTemp6, #1, iTemp6;
    }
    else if (SABSR[i] == 30) {
      .SH_LEFT iTemp6, #1, iTemp6;
    }
    else {
      WARNING("Invalid SABSR value!", "PermuteScanIndex");
      .SH_LEFT iTemp6, #1, iTemp6;
    }
  LP("PermuteScanIndex");
  return (iTemp6);
#else INTERPRETER
  TEMP6 = 0;
  for (i = nNumPlanes-1; i >= 0; i--) {
    if (SABSR[i] < 24) {
      TEMP5 = SCAN_INDEX_REG << (31 - SABSR[i]);
      bit = HIGHB(TEMP6);
      TEMP6 = (TEMP6 << 1) | HIGHB(TEMP5);
      TEMP5 <<= 1;
    }
    else if (SABSR[i] == 31) {
      TEMP6 <<= 1;
      TEMP6 += 1;
    }
    else if (SABSR[i] == 30) {
      TEMP6 <<= 1;
    }
    else {
      WARNING("Invalid SABSR value!", "PermuteScanIndex");
      TEMP6 <<= 1;
    }
  LP("PermuteScanIndex");
  return (&TEMP6);
#endif INTERPRETER
#ifndef INTERPRETER
void MapFunction (short iSrcVar, short iDestVar, BYTE bMap)
#else INTERPRETER
void MapFunction (LONG32 *SrcVar, LONG32 *DestVar, BYTE bMap)
#endif INTERPRETER
  EP("MapFunction");
  switch (bMap) {
  case MAP_CONST_0: {
#ifndef INTERPRETER
    .OR %G0, %G0, iDestVar;
#else INTERPRETER
    *DestVar = 0;
#endif INTERPRETER
    break;
    
  case MAP_G_NOR_S: {
#ifndef INTERPRETER
    /* Surprizingly, SPARC does not have*/
    /* a native NOR instruction! ORN is */
    /* not NOR!!!                       */
    .OR iGlueData, iSrcVar, iDestVar;
    .XNOR %G0, iDestVar, iDestVar;
#else INTERPRETER
    *DestVar = ~ (GLUE_DATA | *SrcVar);
#endif INTERPRETER
    break;
}    
  case MAP_G_AND_S_BAR: {
#ifndef INTERPRETER
    .XNOR %G0, iSrcVar, iDestVar;
    .AND iGlueData, iDestVar, iDestVar;
#else INTERPRETER
    *DestVar = GLUE_DATA & (~ *SrcVar);
#endif INTERPRETER
    break;
    
  case MAP_S_BAR: {
#ifndef INTERPRETER
    .XNOR %G0, iSrcVar, iDestVar;
#else INTERPRETER
    *DestVar = ~ *SrcVar;
#endif INTERPRETER
    break;
    
  case MAP_G_BAR_AND_S: {
#ifndef INTERPRETER
    .XNOR %G0, iGlueData, iDestVar;
    .AND iSrcVar, iDestVar, iDestVar;
#else INTERPRETER
    *DestVar = (~ GLUE_DATA) & *SrcVar;
#endif INTERPRETER
    break;
    
  case MAP_G_BAR: {
#ifndef INTERPRETER
    .XNOR %G0, iGlueData, iDestVar;
#else INTERPRETER
    *DestVar = ~ GLUE_DATA;
#endif INTERPRETER
    break;
    
  case MAP_G_XOR_S: {
#ifndef INTERPRETER
    .XOR iGlueData, iSrcVar, iDestVar;
#else INTERPRETER
    *DestVar = GLUE_DATA ^ *SrcVar;
#endif INTERPRETER
    break;
    
  case MAP_G_NAND_S: {
#ifndef INTERPRETER
    /* SPARC does not have a native NAND */
    /* instruction! ANDN is not NAND     */
    .AND iGlueData, iSrcVar, iDestVar;
    .XNOR %G0, iDestVar, iDestVar;
#else INTERPRETER
    *DestVar = ~ (GLUE_DATA & *SrcVar);
#endif INTERPRETER
    break;
    
  case MAP_G_AND_S: {
#ifndef INTERPRETER
    .AND iGlueData, iSrcVar, iDestVar;
#else INTERPRETER
    *DestVar = GLUE_DATA & *SrcVar;
#endif INTERPRETER
    break;
    
  case MAP_G_EQ_S: {
#ifndef INTERPRETER
    .XNOR iGlueData, iSrcVar, iDestVar;
#else INTERPRETER
    *DestVar = ~ (GLUE_DATA ^ *SrcVar);
#endif INTERPRETER
    break;
    
  case MAP_G: {
#ifndef INTERPRETER
    .XOR %G0, iGlueData, iDestVar;
#else INTERPRETER
    *DestVar = GLUE_DATA;
#endif INTERPRETER
    break;
    
  case MAP_G_OR_S_BAR: {
#ifndef INTERPRETER
    .XNOR %G0, iSrcVar, iDestVar;
    .OR iGlueData, iDestVar, iDestVar;
#else INTERPRETER
    *DestVar = GLUE_DATA | (~ *SrcVar);
#endif INTERPRETER
    break;
    
  case MAP_S: {
#ifndef INTERPRETER
    .XOR %G0, iSrcVar, iDestVar
#else INTERPRETER
    *DestVar = *SrcVar;
#endif INTERPRETER
      break;
    
  case MAP_G_BAR_OR_S: {
#ifndef INTERPRETER
    .XNOR %G0, iGlueData, iDestVar;
    .OR iSrcVar, iDestVar, iDestVar;
#else INTERPRETER
    *DestVar = (~ GLUE_DATA) | *SrcVar;
#endif INTERPRETER
      break;
    
  case MAP_G_OR_S: {
#ifndef INTERPRETER
    .OR iGlueData, iSrcVar, iDestVar;
#else INTERPRETER
    *DestVar = GLUE_DATA | *SrcVar;
#endif INTERPRETER
    break;
    
  case MAP_CONST_1: {
#ifndef INTERPRETER
    .XNOR %G0, %G0, iDestVar;
#else INTERPRETER
    *DestVar = 0xFFFFFFFF;
#endif INTERPRETER
    break;
  LP("MapFunction");
#ifndef INTERPRETER
void BuildDest(short nDest, short iDestVar, BYTE Src, BYTE Map)
  short iSrcVar;
#else INTERPRETER
void BuildDest(short nDest, LONG32 *DestVar, BYTE Src, BYTE Map)
  LONG32 *SrcVar;
#endif INTERPRETER
  EP("BuildDest");
#ifndef INTERPRETER
  if ((Map != MAP_G) && (Map != MAP_G_BAR)) {
    iSrcVar = (Src == SRC_SITE_DATA ? iUnGlueData :
	       Src == SRC_TBUS ? iTbusData :
	       Src == SRC_LUT ? iLutData : iTemp1);
    if ((nDest == DEST_LUT) && (Src == SRC_SITE_ADDRESS)) {
      iSrcVar = PermuteScanIndex();
    }
  MapFunction(iSrcVar, iDestVar, Map);
#else INTERPRETER
  if ((Map != MAP_G) && (Map != MAP_G_BAR)) {
    SrcVar = (Src == SRC_SITE_DATA ? &UNGLUE_DATA :
	      Src == SRC_TBUS ? &TBUS_DATA :
	      Src == SRC_LUT ? &LUT_DATA : &TEMP1);
    if ((nDest == DEST_LUT) && (Src == SRC_SITE_ADDRESS)) {
      SrcVar = PermuteScanIndex();
    }
  MapFunction(SrcVar, DestVar, Map);
#endif INTERPRETER
  LP("BuildDest");
#ifndef INTERPRETER
void BuildBitDest(short nDest, short iHoldReg, BYTE Src, BYTE Map,
		  unsigned short nPlane)
{                                                               
     
#else INTERPRETER
void BuildBitDest(short nDest, LONG32 *HoldReg, BYTE Src, BYTE Map,
		  unsigned short nPlane)
{                                                               
#endif INTERPRETER
  EP("BuildBitDest");
#ifndef INTERPRETER
  if ((nDest == DEST_LUT) && (Src == SRC_SITE_ADDRESS)) {
    .OR           %G0, %G0, iTemp6;
    
    if (SABSR[nPlane] < 24) {
      .SH_LEFT iScanIndexReg, #(31 - SABSR[nPlane]), iTemp5;
      .ADDcc iTemp5, iTemp5, iTemp5;
      .ADDXcc iTemp6, iTemp6, iTemp6;
      .SH_LEFT iTemp6, #nPlane, iTemp6;
    }
    else if (SABSR[nPlane] == 31) {
      .SH_LEFT iTemp6, #1, iTemp6;
      .ADD iTemp6, #1, iTemp6;
    }
    else if (SABSR[nPlane] == 30) {
      .SH_LEFT iTemp6, #1, iTemp6;
    }
    else {
      WARNING("Invalid SABSR value", "BuildBitDest");
      .SH_LEFT iTemp6, #1, iTemp6;
    }      
    MapFunction (iTemp6, iHoldReg, Map);
  else
    BuildDest(nDest, iHoldReg, Src, Map);
#else INTERPRETER
  if ((nDest == DEST_LUT) && (Src == SRC_SITE_ADDRESS)) {
    TEMP6 = 0;
    if (SABSR[nPlane] < 24) {
      TEMP5 = SCAN_INDEX_REG << (31 - SABSR[nPlane]);
      bit = HIGHB(TEMP6);
      TEMP6 = ((TEMP6 << 1) | HIGHB(TEMP5)) << nPlane;
      TEMP5 <<= 1;
    }
    else if (SABSR[nPlane] == 31)
      TEMP6 = (TEMP6 << 1) + 1;
    else if (SABSR[nPlane] == 30)
      TEMP6 <<= 1;
    else {
      WARNING("Invalid SABSR value", "BuildBitDest");
      TEMP6 <<= 1;
    }
    MapFunction (&TEMP6, HoldReg, Map);
  else
    BuildDest(nDest, HoldReg, Src, Map);
#endif INTERPRETER
  LP("BuildBitDest");
#ifndef INTERPRETER
void BuildBitwiseDest(short nDest, short iDestVar, BYTE Src[], BYTE Map[])
  short i;
  short iHoldReg = iTemp4;
#else INTERPRETER
void BuildBitwiseDest(short nDest, LONG32 *DestVar, BYTE Src[], BYTE Map[])
  short i;
  LONG32 *HoldReg = &TEMP4;
#endif INTERPRETER
  EP("BuildBitwiseDest");
#ifndef INTERPRETER
  for (i = nNumPlanes - 1; i >= 0; i--) {
    BuildBitDest(nDest, iHoldReg, Src[i], Map[i], i);
    .SH_LEFT iHoldReg, #(31 - i), iHoldReg;
    .ADDcc iHoldReg, iHoldReg, iHoldReg;
    .ADDXcc iDestVar, iDestVar, iDestVar;
#else INTERPRETER
  for (i = nNumPlanes - 1; i >= 0; i--) {
    BuildBitDest(nDest, HoldReg, Src[i], Map[i], i);
    *HoldReg <<= (31 - i);
    bit = HIGHB(*DestVar);
    *DestVar = (*DestVar << 1) | HIGHB(*HoldReg);
    *HoldReg <<= 1;
#endif INTERPRETER
  LP("BuildBitwiseDest");
/*****************************************************************************/
/*                                                                           */
/* This routine adds two longs breaking the carries at positions indicated   */
/* by the Dimension Cut Mask Register (DCMR). The DCMR has a 1 bit at every  */
/* bit position where the carry needs to be cut.                             */
/*                                                                           */
/*****************************************************************************/
LONG32 AddSiteAddress(LONG32 lSrc1, LONG32 lSrc2)
  LONG32 lHighBits1, lHighBits2;
  lHighBits1 = lSrc1 & DCM[0];
  lHighBits2 = lSrc2 & DCM[0];
  lSrc1 &= (~DCM[0]);
  lSrc2 &= (~DCM[0]);
  return( (lSrc1 + lSrc2) ^ lHighBits1 ^ lHighBits2 );
LONG32 SubSiteAddress(LONG32 lSrc1, LONG32 lSrc2)
  LONG32 lSignBitOffset, lSignBitKick, lLowBitsKick;
  lSignBitOffset = lSrc1 & DCM[0];
  lSignBitKick = (~lSrc2) & DCM[0];
  lSrc1 |= DCM[0];
  lLowBitsKick = lSrc2 & (~ DCM[0]);
  lSrc1 -= lLowBitsKick;
  lSignBitOffset = lSignBitOffset ^ lSignBitKick;
  lSrc1 ^= lSignBitOffset;
/*****************************************************************************/
/*                                                                           */
/* Compute the Scan length - the number of sites that will be updated in     */
/* the current scan. Basically, it should be 2^ESCP, but we need to correct  */
/* for the fact that the SIR low-order bits might not be all zero            */
/*                                                                           */
/*****************************************************************************/
LONG32 ScanLength()
  LONG32 lCarryOVFBit, lScanLength, lSIRBits;
  lCarryOVFBit = ESC[0];
  lScanLength = (1 << lCarryOVFBit);                                  
  lSIRBits = SIR[0] & (lScanLength - 1);
  lScanLength -= lSIRBits;
  return (lScanLength);
/*****************************************************************************/
/*                                                                           */
/* Determine the sweep length. The sweep length is given by either the low   */
/* bit of the DCMR or the ESCP (End-of-Scan-pointer) or the SFR register.    */
/* This is because the scan could update many lines of the lowest (X) dimen- */
/* sion, or could update just part of 1 line in the X dimension.             */
/*                                                                           */
/*****************************************************************************/
LONG32 SweepLength(LONG32 *lFirstSweep)
  LONG32 lCarryOVFBit, lSweepLength;
  lCarryOVFBit = MIN(ESW[0], lNumXBits);
  lSweepLength = (1 << lCarryOVFBit);
  *lFirstSweep = (SIR[0] & (lSweepLength - 1));
  *lFirstSweep = lSweepLength - *lFirstSweep;
  return (lSweepLength);
/*****************************************************************************/
/*                                                                           */
/* DCMRHighBit returns a long with exactly one of the 32 bits set to 1. This */
/* bit position corresponds to the highest bit in the DCMR that has a 1.     */
/*                                                                           */
/*****************************************************************************/
LONG32 DCMRHighBit()
  LONG32 lTemp1, lTemp2;                                                     W

---------------------------------------------------------------------------

#include <CAM/CALib++.H>
#include <CAM/CamStream++.H>
#include <CAM/CamError++.H>
#include <CAM/CamTrace++.H>
#include <CAM/CAM8SimJIT++.H>
#include <CAM/CAM8SimRegMgr++.H>
#include <CAM/CAM8SimSPARCRegMgr++.H>
#include "std++.H"
REGISTER GetReg(INT16 nVar, CODEHANDLE hcodCurrent, BOOL bLoad)
     REGISTER reg;
     CODEPTR pcodNext;
     pcodNext = *hcodCurrent;
     
     if (SymbolTable[nVar].regLoc != 0) {					 /* if nVar is already in a register */
	  return (SymbolTable[nVar].regLoc);					 /* 	return the register 	     */
     }
     if (NumFreeRegs() != 0) {						 	 /* else if there is a free register */
	  reg = GetFreeReg();							 /* 	get free register 	     */
     } else {
	  reg = GetSpillable();							 /* else get a spillable register    */
#ifdef _INSTRUMENTATION_
	  fprintf(stderr, "Spilling Register : Variable %x : Priority %x\n",
		  	  rCurrWindow[reg].nVar,
		  	  rCurrWindow[reg].nPriority);
#endif	  
#ifdef DEBUG
	  fprintf(DEBUGFILE, "Spilling Register : Variable %s : Priority %x\n",
		  	  SYMBOLS[rCurrWindow[reg].nVar],
		  	  rCurrWindow[reg].nPriority);
#endif
	  SymbolTable[rCurrWindow[reg].nVar].regLoc = 0;			 /* 	Unmark old var's reg alias   */
	  EMIT(STW_REG_IMM(REG_DS, rCurrWindow[reg].nHeapOffset, reg));		 /* 	spill the register 	     */
     }
     
     SymbolTable[nVar].regLoc = reg;						 /* Update SymbolTable	    	     */
     rCurrWindow[reg].nVar = nVar;						 /* and Current Reg Window recs      */
     rCurrWindow[reg].nHeapOffset = SymbolTable[nVar].nHeapOffset;		 
     rCurrWindow[reg].nPriority = SymbolTable[nVar].nPriority;
     if (rCurrWindow[reg].nPriority != VOLATILE) {				 /* if nVar is not a VOLATILE        */
	  if (bLoad) {
	       EMIT(LDW_REG_IMM(REG_DS, rCurrWindow[reg].nHeapOffset, reg));	 /*    load it into reg	  	     */
	  }
	  InsertSpillable(reg);							 /*    and mark it as spillable	     */
     }
     *hcodCurrent = pcodNext;							 /* Update caller's code handle      */
#ifdef DEBUG
     fprintf(DEBUGFILE, "%s is in register %s\n", SYMBOLS[nVar],
	     REGISTERS[reg]);
     fflush(stderr);
#endif
     return (reg);
     
void FlushReg(REGISTER rFlush, CODEHANDLE hcodCurrent)
     CODEPTR 	pcodNext = *hcodCurrent;
     if (rCurrWindow[rFlush].nPriority != VOLATILE) {
	  EMIT(STW_REG_IMM(REG_DS, rCurrWindow[rFlush].nHeapOffset, rFlush));	 /* Store rFlush back to heap 	     */
	  *hcodCurrent = pcodNext;
     }
     SymbolTable[rCurrWindow[rFlush].nVar].regLoc = 0;
     FreeReg(rFlush);
void PushRegWindow()
     short i, j;
     SaveRegState();								 /* Save state of registers 	     */
     ResetFreeQue();
     ResetSpillQue();
     for (i = REG_L0; i <= REG_L7; i++) {					 /* Free all the new Local Registers */
	  SymbolTable[rCurrWindow[i].nVar].regLoc = 0;				 /* if nVar == 0, who cares? 	     */
	  FreeReg(i);
     }
     for (i = REG_O0, j = REG_I0; i <= REG_O5; i++, j++) {
	  SymbolTable[rCurrWindow[j].nVar].regLoc = 0;				 /* Vars in previous in register     */
										 /* become inaccessible 	     */
	  rCurrWindow[j] = rCurrWindow[i];					 /* Out registers become in regs     */
	  if (rCurrWindow[j].nVar != 0) {					 /* Update SymbolTable regLoc entries*/
	       SymbolTable[rCurrWindow[j].nVar].regLoc = j;			 /* for symbols in new In Registers  */
	       if (rCurrWindow[j].nPriority != VOLATILE) {			 /* if the var is also spillable,    */
		    InsertSpillable(j);						 /*    mark it as such 		     */
	       }
	  } else {								 /* If no symbol in new In Register, */
	       FreeReg(j);							 /* mark it as free 		     */
	  }
     }
     for (i = REG_O0; i <= REG_O5; i++) {					 /* Free all the new Out Registers,  */
	  SymbolTable[rCurrWindow[i].nVar].regLoc = 0;				 /* except SP and DS  		     */
	  FreeReg(i);
     }
     
     for (i = REG_G1; i <= REG_G6; i++) {					 /* Since we reset the free and spil */
	  if (rCurrWindow[i].nVar == 0) {					 /* queues, add unused global regs   */
	       FreeReg(i);							 /* to the appropriate queues 	     */
	  } else {
	       if (rCurrWindow[i].nPriority != VOLATILE) {
		    InsertSpillable(i);
	       }
	  }
     }
     
struct tag_regRec {
     REGENTRY rWindow[MREGS];
     struct tag_regRec *precPrev;
typedef struct tag_regRec REGREC;
REGREC *precTOS = NULL;
void PopRegWindow(CODEHANDLE hcodCurrent)					 /* Reverse the action of PushRegWi. */
{										 /* This window's local and out regs */
     short i, j;								 /* will go out of scope, so store   */
     CODEPTR pcodNext = *hcodCurrent;						 /* any vars in there back to heap   */
										 /* In regs of this window become out*/
     ResetFreeQue();								 /* regs of prev window 	     */
     ResetSpillQue();
     /* The following loop restores the local registers to the state of the  */
     /* parent's local registers. All vars in current local registers are    */
     /* stored back to heap, and their symbol table entries updated	     */
     for (i = REG_L0; i <= REG_L7; i++) {					 /* Restore local regs to state of   */
	  if (rCurrWindow[i].nVar != 0) {					 /* previous window 		     */
	       SymbolTable[rCurrWindow[i].nVar].regLoc = 0;
	       if (rCurrWindow[i].nPriority != VOLATILE) {			 /* if this window was using reg,    */
		    EMIT(STW_REG_IMM(REG_DS,					 /* update heap 		     */
				     rCurrWindow[i].nHeapOffset, i));
	       }
	  }
	  rCurrWindow[i] = precTOS->rWindow[i];					 /* Now, restore to state of prev    */
	  if (rCurrWindow[i].nVar != 0) {					 /* window 			     */
	       SymbolTable[rCurrWindow[i].nVar].regLoc = i;
	       if (rCurrWindow[i].nPriority != VOLATILE) {
		    InsertSpillable(i);
	       }
	  } else {
	       FreeReg(i);
	  }
     }
     /* The following loop stores all vars in OUT registers back to heap     */
     /* and updates their symbol table entries. At the end of this loop, all */
     /* OUT registers are marked as empty. 				     */
     for (i = REG_O0; i <= REG_O5; i++) {					 /* Store vars in OUT regs to heap   */
	  if (rCurrWindow[i].nVar != 0) {
	       SymbolTable[rCurrWindow[i].nVar].regLoc = 0;
	       if (rCurrWindow[i].nPriority != VOLATILE) {			 /* if this window was using reg,    */
		    EMIT(STW_REG_IMM(REG_DS,					 /* update heap 		     */
				     rCurrWindow[i].nHeapOffset, i));
	       }
	       rCurrWindow[i].nVar = 0;
	       rCurrWindow[i].nPriority = 0;
	       rCurrWindow[i].nHeapOffset = 0;
	  }
     }
     /* The following loop does two things: one, it restores the OUT reg     */
     /* to the parent's state; two, it leaves the IN registers empty. Since  */
     /* popping a reg window means that the current IN registers become the  */
     /* OUT registers, this loop must do both things simultaneously. Effect  */
     /* is that any vars in IN registers which are in the parent's OUT reg   */
     /* are simply marked to be in the OUT registers. Any vars in IN reg     */
     /* which are not in the the parent's OUT reg, are restored back to heap.*/
     /* At the end of this loop, the OUT regs are back to their parent's     */
     /* state, and all the IN regs are empty, either spilled or marked to    */
     /* to the OUT regs							     */
     for (i = REG_I0, j = REG_O0; i <= REG_I5; i++, j++) {
	  if (rCurrWindow[i].nVar == precTOS->rWindow[j].nVar) {		 /* if var in IN register was inh-   */
	       rCurrWindow[j] = rCurrWindow[i];					 /* erited from parent's OUT reg,    */
	       if (rCurrWindow[j].nPriority != VOLATILE) {			 /* restore it to out reg 	     */
		    InsertSpillable(j);
	       }
	       SymbolTable[rCurrWindow[j].nVar].regLoc = j;
	  } else {								 /* var not inherited from parent    */
	       if (rCurrWindow[i].nPriority != VOLATILE) {			 /* if var not volatile		     */
		    EMIT(STW_REG_IMM(REG_DS,					 /*    restore to heap 		     */
				     rCurrWindow[i].nHeapOffset, i));
	       }
	       SymbolTable[rCurrWindow[i].nVar].regLoc = 0;			 /* update symbol table 	     */
	       rCurrWindow[j] = precTOS->rWindow[j];				 /* restore parent's var 	     */
	       if (rCurrWindow[j].nVar != 0) {					 /* if parent had a var in reg 	     */
		    SymbolTable[rCurrWindow[i].nVar].regLoc = i;		 /*    update symbol table 	     */
		    if (rCurrWindow[i].nPriority != VOLATILE) {			 /*    and spill que 		     */
			 InsertSpillable(j);
		    }
	       } else {								 /* else parent had no var in reg    */
		    FreeReg(j);							 /*    so free it 		     */
	       }
	  }
	  rCurrWindow[i].nVar = 0;
	  rCurrWindow[i].nPriority = 0;
	  rCurrWindow[i].nHeapOffset = 0;
     }
     /* The following loop restores the IN regs to the state of the parents  */
     /* It assumes that all the IN regs are currently marked empty.	     */
     for (i = REG_I0; i <= REG_I5; i++) {					 /* Restore in registers to that of  */
	  rCurrWindow[i] = precTOS->rWindow[i];					 /* parent 			     */
	  if (rCurrWindow[i].nVar == 0) {
	       FreeReg(i);
	  } else {
	       if (rCurrWindow[i].nPriority != VOLATILE) {
		    InsertSpillable(i);
	       }
	       SymbolTable[rCurrWindow[i].nVar].regLoc = i;
	  }
     }
     
     for (i = REG_G1; i <= REG_G6; i++) {					 /* Since we reset the free and spil */
	  if (rCurrWindow[i].nVar == 0) {					 /* queues, add unused global regs   */
	       FreeReg(i);							 /* to the appropriate queues 	     */
	  } else {
	       if (rCurrWindow[i].nPriority != VOLATILE) {
		    InsertSpillable(i);
	       }
	  }
     }
     
     RestoreRegState(CURRENT_HANDLE);						 /* now, restore register state      */
     *hcodCurrent = pcodNext;
     
void SaveRegState()								 /* Take a snapshot of register      */
{										 /* contents. 			     */
     REGREC *precNew;
     precNew = (REGREC *) MALLOC(sizeof(REGREC), "SaveRegState");
     memcpy((char *)precNew, (char *)rCurrWindow, sizeof(REGREC));		 /* Ok, so this is a litte flaky     */
     precNew->precPrev = precTOS;
     precTOS = precNew;
void RestoreRegState(CODEHANDLE hcodCurrent)					 /* Restore state to snapshot. Only  */
{										 /* non-volatile priority registers  */
     CODEPTR pcodNext = *hcodCurrent;						 /* are guaranteed to be restored.   */
     short i;
     REGREC *precOld;
     /************************************************************************/
     /* First, save all the registers which have different variables than    */
     /* the parent.							     */
     /************************************************************************/
     
     for (i = REG_G1; i <= REG_I5; i++) {
	  if (rCurrWindow[i].nVar == 0) {
	       continue;
	  } else if (rCurrWindow[i].nVar != precTOS->rWindow[i].nVar) {
	       FlushReg(i, CURRENT_HANDLE);
	  }
     }
     /************************************************************************/
     /* Now, go through each register, and for all those registers which are */
     /* not in the same state as the parent, refresh the register	     */
     /************************************************************************/
     
     for (i = REG_G1; i <= REG_I5; i++) {
	  if (precTOS->rWindow[i].nVar == 0) {
	       continue;
	  } else if (    (precTOS->rWindow[i].nVar != rCurrWindow[i].nVar)
		      && (precTOS->rWindow[i].nPriority != VOLATILE)) {
	       EMIT( LDW_REG_IMM(REG_DS, precTOS->rWindow[i].nHeapOffset, i) );
	       rCurrWindow[i] = precTOS->rWindow[i];
	       SymbolTable[rCurrWindow[i].nVar].regLoc = i;
	  }
     }
	       
     /************************************************************************/
     /* Now, we need to refresh the state of the free and spill ques.	     */
     /************************************************************************/
     
     ResetFreeQue();
     ResetSpillQue();
     for (i = REG_L0; i <= REG_L7; i++) {
	  if (rCurrWindow[i].nVar == 0) {
	       FreeReg(i);
	  } else if (rCurrWindow[i].nPriority != VOLATILE) {
	       InsertSpillable(i);
	  }
     }
     for (i = REG_O0; i <= REG_O5; i++) {
	  if (rCurrWindow[i].nVar == 0) {
	       FreeReg(i);
	  } else if (rCurrWindow[i].nPriority != VOLATILE) {
	       InsertSpillable(i);
	  }
     }
     for (i = REG_I0; i <= REG_I5; i++) {
	  if (rCurrWindow[i].nVar == 0) {
	       FreeReg(i);
	  } else if (rCurrWindow[i].nPriority != VOLATILE) {
	       InsertSpillable(i);
	  }
     }
     for (i = REG_G1; i <= REG_G6; i++) {
	  if (rCurrWindow[i].nVar == 0) {
	       FreeReg(i);
	  } else if (rCurrWindow[i].nPriority != VOLATILE) {
	       InsertSpillable(i);
	  }
     }
     *hcodCurrent = pcodNext;
     precOld = precTOS;
     precTOS = precTOS->precPrev;
     FREE(precOld, "RestoreRegState");
}			 
void InitRegMgr()
     short i;
     REGENTRY rentNull = {0, 0, 0};
     REGREC *precOld;
     for (i = 0; i < MREGS; i++) {						 /* Mark all register entries as     */
	  rCurrWindow[i] = rentNull;						 /* NULL 			     */
     }
     while (precTOS) {								 /* Free up stack of saved states    */
	  precOld = precTOS;
	  precTOS = precTOS->precPrev;
	  FREE(precOld, "InitRegMgr");
     }
     ResetFreeQue();
     ResetSpillQue();
     for (i = REG_L0; i <= REG_L7; i++) {
	  FreeReg(i);
     }
     for (i = REG_O0; i <= REG_O5; i++) {
	  FreeReg(i);
     }
     for (i = REG_I0; i <= REG_I5; i++) {
	  FreeReg(i);
     }
     for (i = REG_G1; i <= REG_G6; i++) {					 /* Free up all registers except     */
	  FreeReg(i);								 /* FP, RA, DS, and SP 		     */
     }
     
/*****************************************************************************/
/*                                                                           */
/* Routines to manipulate free registers				     */
/*                                                                           */
/*****************************************************************************/
BYTE NumFreeRegs()
     return (NumQueElements(rqueFree));
REGISTER GetFreeReg()
     return (GetQueElement(&rqueFree));
void FreeReg(REGISTER reg)
     AddQueElement(&rqueFree, reg);
     rCurrWindow[reg].nVar = 0;
     rCurrWindow[reg].nPriority = VOLATILE;
     rCurrWindow[reg].nHeapOffset = 0;
void ResetFreeQue()
     ResetQue(&rqueFree);
/*****************************************************************************/
/*                                                                           */
/* Routines to manipulate spillable registers.				     */
/*                                                                           */
/*****************************************************************************/
REGISTER GetSpillable()
     if (NumQueElements(rqueSpillable[TEMP-1]) != 0) {				 /* Check for spillable register in  */
	  return (GetQueElement(&rqueSpillable[TEMP-1]));			 /* TEMP priority que, then LOOP_CTR,*/
     } else if (NumQueElements(rqueSpillable[LOOP_CTR-1]) != 0) {		 /* and last in GLOBAL priority que  */
	  return (GetQueElement(&rqueSpillable[LOOP_CTR-1]));
     } else if (NumQueElements(rqueSpillable[GLOBAL-1]) != 0) {
	  return (GetQueElement(&rqueSpillable[GLOBAL-1]));
     } else {
	  return (0);
     }
	   
void InsertSpillable(REGISTER reg)
     short nPriority = rCurrWindow[reg].nPriority - 1;
     
     AddQueElement(&rqueSpillable[nPriority], reg);
void ResetSpillQue()
     short i;
     
     for (i = 0; i < 4; i++) {
	  ResetQue(&rqueSpillable[i]);
     }
/*****************************************************************************/
/*                                                                           */
/* Implementation of queues of registers. Lists of Free registers and 	     */
/* registers containing different priority variables are organized as queues */
/*                                                                           */
/*****************************************************************************/
BYTE NumQueElements(REGQUE rque)
     return (rque.bNumElements);
REGISTER GetQueElement(REGQUE *prque)
     REGISTER reg;
     
     if (prque->bNumElements != 0) {
	  reg = prque->rRegQue[prque->bTail];
	  prque->bTail = (prque->bTail + 1) % MREGS;
	  prque->bNumElements--;
     } else {
	  reg = 0;
     }
     return (reg);
void AddQueElement(REGQUE *prque, REGISTER reg)
#ifdef _CAUTIOUS_
     if (prque->bNumElements < MREGS) {
#endif	  
	  prque->bNumElements++;
	  prque->rRegQue[prque->bHead] = reg;
	  prque->bHead = (prque->bHead + 1) % MREGS;
#ifdef _CAUTIOUS_	  
     } else {
	  CRITICAL_ERROR("Queue Overflow", "AddQueElement");
     }
#endif     
void ResetQue(REGQUE *prque)
     prque->bNumElements = 0;
     prque->bHead = 0;
     prque->bTail = 0;


---------------------------------------------------------------------------

#ifndef _CAM8SIMCORE_H_
#define _CAM8SIMCORE_H_
#include <CamLib++.H>
#include <Cam8Core++.H>
#include "std++.H"
/*****************************************************************************/
/********************************* DEFINES ***********************************/
/*****************************************************************************/
#define PERM_CONST_1            31                                               
#define PERM_CONST_0            30
#define LONG32_SIZE		(sizeof(LONG32))
#define INT16_SIZE		(sizeof(INT16))
#define ACTIVE_LUT_SELECT	0x8000	 /* bit in Hardware Env Reg (HER)    */
#define FLD_SELECT(i)		((i) + 32)
#define FLD_MAP(i)		((i) + 64)
#define NUM_DEST		4
#define NUM_SRC			6
#define SRC_SITE_DATA		0
#define SRC_TBUS		1
#define SRC_FLYWHEEL		2
#define SRC_LUT			3
#define SRC_SITE_ADDRESS	3
#define SRC_GLUED_DATA		4
#define SRC_CONST_DATA		5
#define DEST_SITE_DATA		0
#define DEST_EVENT_CT		1
#define DEST_LUT		2
#define DEST_DISPLAY		3
#define MAP_CONST_0		0
#define MAP_G_NOR_S		1
#define MAP_G_AND_S_BAR		2
#define MAP_S_BAR		3
#define MAP_G_BAR_AND_S		4
#define MAP_G_BAR		5
#define MAP_G_XOR_S		6
#define MAP_G_NAND_S		7
#define MAP_G_AND_S		8
#define MAP_G_EQ_S		9
#define MAP_G			10
#define MAP_G_OR_S_BAR		11
#define MAP_S			12
#define MAP_G_BAR_OR_S		13
#define MAP_G_OR_S		14
#define MAP_CONST_1		15
#define HIGHB(x)		(((x) & 0x80000000) ? 0x1 : 0x0)
#ifdef DEBUG
#define EP(name) fprintf(DEBUGFILE, "ENTER: %s\n", name)
#define LP(name) fprintf(DEBUGFILE, "LEAVE: %s\n", name)
#else DEBUG
#define EP(name)
#define LP(name)
#endif DEBUG
#ifdef __cplusplus
/*****************************************************************************/
/******************************** TEMPLATES **********************************/
/*****************************************************************************/
/*****************************************************************************/
/*************************** CLASSES & TYPEDEFS ******************************/
/*****************************************************************************/
struct interface_regs {
    
  LONG32 NLP;                          /* Next List Pointer            */
  LONG32 ISR;                          /* Reset/Interrupt Register     */
  LONG32 CIP;                          /* Current Instruction Pointer  */
  LONG32 PIP;                          /* Previous Instruction Pointer */
    
  LONG32 RER;                          /* Reset/Enable Register        */
  LONG32 DSL;                          /* Display Scan Length          */
  LONG32 DBL;                          /* Display Blank Length         */
typedef interface_regs *INTERFACE_REGS;
struct Cam8SimModule {
  /* CAM8 Registers */
  BYTE MSR[CHIPS_PER_MOD];
  BYTE SSM[CHIPS_PER_MOD];
  BYTE RT[CHIPS_PER_MOD];
  BYTE ECT[CHIPS_PER_MOD];
  BYTE RPK[CHIPS_PER_MOD];
  BYTE ALT[CHIPS_PER_MOD];
  LONG32 KA[CHIPS_PER_MOD];
  BYTE XKS[CHIPS_PER_MOD];
  BYTE YKS[CHIPS_PER_MOD];
  BYTE ZKS[CHIPS_PER_MOD];
  BYTE XKMF[CHIPS_PER_MOD];
  BYTE YKMF[CHIPS_PER_MOD];
  BYTE ZKMF[CHIPS_PER_MOD];
  BYTE SABSR[CHIPS_PER_MOD];
  BYTE LAS[CHIPS_PER_MOD];
  BYTE LAM[CHIPS_PER_MOD];
  BYTE FOS[CHIPS_PER_MOD];
  BYTE FOM[CHIPS_PER_MOD];
  BYTE SDS[CHIPS_PER_MOD];
  BYTE SDM[CHIPS_PER_MOD];
  BYTE ECS[CHIPS_PER_MOD];
  BYTE ECM[CHIPS_PER_MOD];
  BYTE DDS[CHIPS_PER_MOD];
  BYTE DDM[CHIPS_PER_MOD];
  BYTE SSR[CHIPS_PER_MOD];
  LONG32 ECR[CHIPS_PER_MOD];
  INT16 LIR[CHIPS_PER_MOD];
  BYTE LIPR[CHIPS_PER_MOD];
  INT16 *LIOR;
  LONG32 SIR[CHIPS_PER_MOD];
  BYTE SSA[24][CHIPS_PER_MOD];
  BYTE *SIOR;
  BYTE SM[CHIPS_PER_MOD];
  BYTE ESC[CHIPS_PER_MOD];
  BYTE ESW[CHIPS_PER_MOD];
  BYTE EST[CHIPS_PER_MOD];
  BYTE SBRC[CHIPS_PER_MOD];
  BYTE RCL[CHIPS_PER_MOD];
  BYTE ECL[CHIPS_PER_MOD];
  BYTE STM[CHIPS_PER_MOD];
  LONG32 OSR[CHIPS_PER_MOD];
  LONG32 DCM[CHIPS_PER_MOD];
  BYTE XDCP[CHIPS_PER_MOD];
  BYTE YDCP[CHIPS_PER_MOD];
  BYTE ZDCP[CHIPS_PER_MOD];
  BYTE LPL[CHIPS_PER_MOD];
  BYTE FPL[CHIPS_PER_MOD];
  BYTE DCS[CHIPS_PER_MOD];
  BYTE TBD[CHIPS_PER_MOD];
  BYTE TMS[CHIPS_PER_MOD];
  BYTE NBF[CHIPS_PER_MOD];
  BYTE SRE[CHIPS_PER_MOD];
  BYTE ALS[CHIPS_PER_MOD];
  BYTE MAFS[CHIPS_PER_MOD];
  BYTE MBFS[CHIPS_PER_MOD];
  BYTE XMPC[CHIPS_PER_MOD];
  BYTE XPPC[CHIPS_PER_MOD];
  BYTE YMPC[CHIPS_PER_MOD];
  BYTE YPPC[CHIPS_PER_MOD];
  BYTE ZMPC[CHIPS_PER_MOD];
  BYTE ZPPC[CHIPS_PER_MOD];
  BYTE MIDR[CHIPS_PER_MOD];
  BYTE GIDR[CHIPS_PER_MOD];
  BYTE BPIE[CHIPS_PER_MOD];
  BYTE BCIE[CHIPS_PER_MOD];
  BYTE GCIE[CHIPS_PER_MOD];
  BYTE MAIE[CHIPS_PER_MOD];
  BYTE MBIE[CHIPS_PER_MOD];
  BYTE SSIE[CHIPS_PER_MOD];
  BYTE XHIE[CHIPS_PER_MOD];
  BYTE RLIE[CHIPS_PER_MOD];
  BYTE URIE[CHIPS_PER_MOD];
  BYTE ISIE[CHIPS_PER_MOD];
  BYTE BPIF[CHIPS_PER_MOD];
  BYTE BCIF[CHIPS_PER_MOD];
  BYTE GCIF[CHIPS_PER_MOD];
  BYTE MAIF[CHIPS_PER_MOD];
  BYTE MBIF[CHIPS_PER_MOD];
  BYTE SSIF[CHIPS_PER_MOD];
  BYTE XHIF[CHIPS_PER_MOD];
  BYTE RLIF[CHIPS_PER_MOD];
  BYTE URIF[CHIPS_PER_MOD];
  BYTE ISIF[CHIPS_PER_MOD];
  BYTE VWE[CHIPS_PER_MOD];
  BYTE VWIE[CHIPS_PER_MOD];
  BYTE VWIF[CHIPS_PER_MOD];
  BYTE LDOC[CHIPS_PER_MOD];
  BYTE HDOC[CHIPS_PER_MOD];
  BYTE *FRAMEb;							/* FRAME buffer */
  unsigned short nNumPlanes;
  BYTE WhyScan;
  BOOL bDestSrcMatrix [CHIPS_PER_MOD][NUM_DEST][NUM_SRC];
  BOOL bSourceRegChange;
  BOOL bDestChange;
  BOOL bForceGeneralScan;
  BOOL bByteMode;
  BOOL bImmediate;
  BOOL bReadMode;
typedef struct {
  char *base;
  int type;
} Bt, *BT;
class Cam8SimCore : public Cam8Core {
public:
  interface_regs iregs;
  int VWECHK;
  char debug;
  Bt base_type[790];
  BOOL bDestSrcMatrix [CHIPS_PER_MOD][NUM_DEST][NUM_SRC];
  BOOL bSourceRegChange;
  BOOL bDestChange;
  BOOL bForceGeneralScan;
  BOOL bByteMode;
  BOOL bImmediate;
  BOOL bReadMode;
  INT16 *LUTb[2];			/* LUT buffers */
  LONG32 SITE_ADDR;
  LONG32 lDCMRHighBit;
  LONG32 lDCMRLowBit;
  LONG32 lNumXBits;
  LONG32 bit;
  LONG32 HIGH_BIT_MASK;
  LONG32 X_HIGH_BIT_MASK;
  LONG32 X_BYTE_LENGTH;
  LONG32 X_CTR;
  LONG32 SITE_CTR;
  LONG32 OFFSETS[CHIPS_PER_MOD];
  LONG32 BIT_OFFSETS[CHIPS_PER_MOD];
  LONG32 DCMR;
  LONG32 SCAN_INDEX_REG;
  LONG32 LUT_ADDR;
  LONG32 BIT_PLANE_ADDR[CHIPS_PER_MOD];
  LONG32 NEXT_WORD_ADDR[CHIPS_PER_MOD];
  LONG32 PLANE_WORD[CHIPS_PER_MOD];
  LONG32 EVENT_COUNT[CHIPS_PER_MOD];
  LONG32 UNGLUE_DATA;
  LONG32 GLUE_DATA;
  LONG32 SITE_DATA;
  LONG32 TBUS_DATA;
  LONG32 LUT_DATA;
  LONG32 DISP_DATA;
  LONG32 TBUS_ADDR;
  LONG32 FRAME_ADDR;
  LONG32 TEMP1;
  LONG32 TEMP2;
  LONG32 TEMP3;
  LONG32 TEMP4;
  LONG32 TEMP5;
  LONG32 TEMP6;
  LONG32 TEMP7;
  LONG32 TEMP8;
  LONG32 TEMP9;
  LONG32 TEMP10;
  FILE* DEBUGFILE;
  struct timeval tvStart, tvEnd;
  struct timezone tzZone;
  Cam8SimCore(void);
  DECL_COPYCONST(Cam8SimCore);
  virtual ~Cam8SimCore(void);
  DECL_BZERO(Cam8SimCore);
  DECL_BCOPY(Cam8SimCore);
  DECL_BCMP(Cam8SimCore);
  // These are virtual from Cam8Core
  void ResetInterface(void);
  void InitInterface(void);
  void ExecuteSteplist(struct steplist_operation &);
  void Read_NLP(LONG32 *);
  void Read_ISR(LONG32 *);
  void Read_CIP(LONG32 *);
  void Read_PIP(LONG32 *);
  void Write_NLP(const LONG32 *);
  void Write_RER(const LONG32 *);
  void Write_DSL(const LONG32 *);
  void Write_DBL(const LONG32 *);
  void InitSimulator(Cam8Core *);
  void InitStepList(void);
  void UnpackState(INT16 *, int, int);
  void UnpackStateInto(INT16 *, int, int, BYTE *, int);
  void PackState(INT16 *, int);
  void PackStateFrom(INT16 *, int, BYTE *, int);
  void InitModule(void);
  void SimStepList(LONG32 *plFirstInstr);
  void SimScan(void);
  void UpdateDCMR(void);
  void UpdateDestSrcMatrix(void);
  void UpdateDCMR();
  void UpdateDestSrcMatrix();
  unsigned short CalcNumPlanes();
  unsigned short CalcNumPlanes(void);
  BOOL IsSrcNeeded(short nSrc);
  BOOL IsSrcSame(short nDest);
  BOOL IsDestUpdated(short nDest);
  BOOL IsSrcNeeded(short nSrc);
  BOOL IsSrcSame(short nDest);
  BOOL IsDestUpdated(short nDest);
  LONG32 AddSiteAddress(LONG32 lSrc1, LONG32 lSrc2);
  LONG32 SubSiteAddress(LONG32 lSrc1, LONG32 lSrc2);
  LONG32 ScanLength(void);
  LONG32 SweepLength(LONG32 *lFirstSweep);
  LONG32 AddSiteAddress(LONG32 lSrc1, LONG32 lSrc2);
  LONG32 SubSiteAddress(LONG32 lSrc1, LONG32 lSrc2);
  LONG32 ScanLength();
  LONG32 SweepLength(LONG32 *lFirstSweep);
  LONG32 DCMRHighBit();
  LONG32 DCMRLowBit();
  virtual void SimScanNoPerm(void);
  virtual void SimGeneralScan(void);
  virtual void SimUpdateSite(void);
  virtual void CheckNoPerm(void);
  virtual void SimLoadFirstWord(LONG32 nBitOffset[]);
  virtual void SimGetNextWord(unsigned short nPlane);
  virtual void SimSaaveLastWord(LONG32 nBitOffset[]);
  virtual void SimUpdateCode(void);
  virtual void SimLoadPlaneWords(void);
  virtual void SimSavePlaneWords(void);
  virtual void MapFunction(LONG32 *SrcVar, LONG32 *DestVar, BYTE bMap);
  virtual void BuildDest(short nDest, LONG32 *DestVar, BYTE Src, BYTE Map);
  virtual void BuildBitDest(short nDest, LONG32 *HoldReg, BYTE Src, BYTE Map, unsigned short nPlane);
  virtual void BuildBitwiseDest(short nDest, LONG32 *DestVar, BYTE Src[], BYTE Map[]);
  virtual LONG32 *PermuteScanIndex(void);
  inline void ReadCmdLine(int, char *[]);
  inline void ConstantSetAll(BYTE r[], BYTE v);
  inline void ConstantSetAll(INT16 r[], INT16 v);
  inline void ConstantSetAll(LONG32 r[], LONG32 v);
  inline void SetAll(BYTE r[], BYTE v[]);
  inline void SetAll(INT16 r[], INT16 v[]);
  inline void SetAll(LONG32 r[], LONG32 v[]);
protected:
  inline void SENTER(int i, char *b, int t);
/*****************************************************************************/
/********************************* INLINES ***********************************/
/*****************************************************************************/
inline void Cam8SimCore::ReadCmdLine(int argc, char *argv[])
  register int i;
  for(i = 1; i < argc; i++) {
    if (strcmp(argv[i], "-g") == 0) {
      bForceGeneralScan = TRUE;
      continue;
    }
inline void Cam8SimCore::SENTER(int i, char *b, int t)
  base_type[i].base = b;
  base_type[i].type = t;
inline void Cam8SimCore::ConstantSetAll(BYTE r[], BYTE v)
  register int i;
  for(i = 0; i < CHIPS_PER_MOD; i++)
    r[i]=v;
inline void Cam8SimCore::ConstantSetAll(INT16 r[], INT16 v)
  register int i;
  for(i = 0; i < CHIPS_PER_MOD; i++)
    r[i]=v;
inline void Cam8SimCore::ConstantSetAll(LONG32 r[], LONG32 v)
  register int i;
  for(i = 0; i < CHIPS_PER_MOD; i++)
    r[i]=v;
inline void Cam8SimCore::SetAll(BYTE r[], BYTE v[])
  memcpy(r, v, CHIPS_PER_MOD * sizeof(BYTE));
inline void Cam8SimCore::SetAll(INT16 r[], INT16 v[])
  memcpy(r, v, CHIPS_PER_MOD * sizeof(BYTE));
inline void Cam8SimCore::SetAll(LONG32 r[], LONG32 v[])
  memcpy(r, v, CHIPS_PER_MOD * sizeof(BYTE));
#endif
/*****************************************************************************/
/******************************* PROTOTYPES **********************************/
/*****************************************************************************/
/*****************************************************************************/
/********************************* GLOBALS ***********************************/
/*****************************************************************************/
#endif

---------------------------------------------------------------------------

#ifndef _CAM8SIMPICORE_H_
#define _CAM8SIMPICORE_H_
#include <CamLib++.H>
#include <Cam8Core++.H>
#include <PipeComm++.H>
#include "std++.H"
extern "C" {
#include <sys/types.h>
#include <sys/ipc.h>
#include <sys/shm.h>
#include <sys/mman.h>
/*****************************************************************************/
/********************************* DEFINES ***********************************/
/*****************************************************************************/
#ifdef __cplusplus
/*****************************************************************************/
/******************************** TEMPLATES **********************************/
/*****************************************************************************/
/*****************************************************************************/
/*************************** CLASSES & TYPEDEFS ******************************/
/*****************************************************************************/
struct interface_regs {
    
  LONG32 NLP;                          /* Next List Pointer            */
  LONG32 ISR;                          /* Reset/Interrupt Register     */
  LONG32 CIP;                          /* Current Instruction Pointer  */
  LONG32 PIP;                          /* Previous Instruction Pointer */
    
  LONG32 RER;                          /* Reset/Enable Register        */
  LONG32 DSL;                          /* Display Scan Length          */
  LONG32 DBL;                          /* Display Blank Length         */
typedef interface_regs *INTERFACE_REGS;
struct shm_details {
  key_t key;
  int id;
  unsigned char *buf;
class Cam8SimPICore : public Cam8Core {
public:
  interface_regs iregs;
  Cam8SimPICore(void);
  Cam8SimPICore(int, int, int);
  DECL_COPYCONST(Cam8SimPICore);
  virtual ~Cam8SimPICore(void);
  DECL_OPEQ(Cam8SimPICore);
  DECL_BZERO(Cam8SimPICore);
  DECL_BCOPY(Cam8SimPICore);
  DECL_BCMP(Cam8SimPICore);
  unsigned char * Malloc(int);
  unsigned char * Calloc(int, int);
  unsigned char * Realloc(unsigned char *, int);
  void ResetInterface(void);
  void InitInterface(void);
  void ExecuteSteplist(struct steplist_operation &);
  void Read_NLP(LONG32 *);
  void Read_ISR(LONG32 *);
  void Read_CIP(LONG32 *);
  void Read_PIP(LONG32 *);
  void Write_NLP(const LONG32 *);
  void Write_RER(const LONG32 *);
  void Write_DSL(const LONG32 *);
  void Write_DBL(const LONG32 *);
  inline void ReadCmdLine(int argc, char *argv[]);
  // These methods are used by the cam8sim subprocess
  void Generate_Interrupt(int);
  LONG32 * GetNextSteplist(void);
protected:
  static Cmdt simcmds[] = {
    { "smat", SHMAT },
    { "smdt", SHMDT },
    { "rdR0", READR0 },
    { "rdR1", READR1 },
    { "rdR2", READR2 },
    { "rdR3", READR3 },
    { "wrR0", WRITER0 },
    { "wrR1", WRITER1 },
    { "wrR2", WRITER2 },
    { "wrR3", WRITER3 },
    { "quit", QUIT }
  };
  PipeComm comm;
  int ShmCnt;
  int retv[2];
  int newsl;
  int sim_memfd;
  int sim_infd;
  int sim_outfd
  shm_details ShmTable[8192];
  int findidx(unsigned char *);
  unsigned char *SHMAT(char *, unsigned char *, unsigned char *);
  unsigned char *SHMDT(char *, unsigned char *, unsigned char *);
  unsigned char *READR0(char *, unsigned char *, unsigned char *);
  unsigned char *READR1(char *, unsigned char *, unsigned char *);
  unsigned char *READR2(char *, unsigned char *, unsigned char *);
  unsigned char *READR3(char *, unsigned char *, unsigned char *);
  unsigned char *WRITER0(char *, unsigned char *, unsigned char *);
  unsigned char *WRITER1(char *, unsigned char *, unsigned char *);
  unsigned char *WRITER2(char *, unsigned char *, unsigned char *);
  unsigned char *WRITER3(char *, unsigned char *, unsigned char *);
  unsigned char *QUIT(char *, unsigned char *, unsigned char *);
/*****************************************************************************/
/********************************* INLINES ***********************************/
/*****************************************************************************/
inline void Cam8SimPipeInterface::ReadCmdLine(int argc, char *argv[])
  register int i;
  for(i = 1; i < argc; i++) {
    if (strcmp(argv[i], "-fd") == 0) {
      sim_memfd = atoi(argv[i+1]);
      i++;
      continue;
    }
    if (strcmp(argv[i], "-in") == 0) {
      sim_infd = atoi(argv[i+1]);
      i++;
      continue;
    }
    if (strcmp(argv[i], "-out") == 0) {
      sim_outfd = atoi(argv[i+1]);
      i++;
      continue;
    }
    
#endif
/*****************************************************************************/
/******************************* PROTOTYPES **********************************/
/*****************************************************************************/
/*****************************************************************************/
/********************************* GLOBALS ***********************************/
/*****************************************************************************/
#endif

---------------------------------------------------------------------------

#ifndef _CAM8SIMSPARCCORE_H_
#define _CAM8SIMSPARCCORE_H_
#include <CamLib++.H>
#include <Cam8Core++.H>
#include <Cam8++.H>
#include <Cam8SimJIT++.H>
#include "std++.H"
/*****************************************************************************/
/********************************* DEFINES ***********************************/
/*****************************************************************************/
#define SCANNER_CODE_SIZE       (1024 * LONG32_SIZE)
#define SWEEP_CODE_SIZE         (1024 * LONG32_SIZE)
#define UPDATE_CODE_SIZE        (1024 * LONG32_SIZE)
#define MREGS	32
/*****************************************************************************/
/*                                                                           */
/* macros for convenient addressing of SPARC registers			     */
/*                                                                           */
/*****************************************************************************/
#define REG_G0	0L
#define REG_G1	1L
#define REG_G2	2L
#define REG_G3	3L
#define REG_G4	4L
#define REG_G5	5L
#define REG_G6	6L
#define REG_G7	7L
#define REG_O0	8L
#define REG_O1	9L
#define REG_O2	10L
#define REG_O3	11L
#define REG_O4	12L
#define REG_O5	13L
#define REG_O6	14L
#define REG_O7	15L
#define REG_L0	16L
#define REG_L1	17L
#define REG_L2	18L
#define REG_L3	19L
#define REG_L4	20L
#define REG_L5	21L
#define REG_L6	22L
#define REG_L7	23L
#define REG_I0	24L
#define REG_I1	25L
#define REG_I2	26L
#define REG_I3	27L
#define REG_I4	28L
#define REG_I5	29L
#define REG_I6	30L
#define REG_I7	31L
#define REG_SP	14L								 /* Stack Pointer 		     */
#define REG_TP	15L								 /* The Temp register 		     */
#define REG_DS	07L								 /* pointer to Heap base	     */
#define REG_FP	30L								 /* Frame Pointer 		     */
#define REG_RA	31L								 /* Return Address 		     */
/*****************************************************************************/
/*                                                                           */
/* operand types to use when calling Emit()				     */
/*                                                                           */
/*****************************************************************************/
#define NULL_OP		0
#define REG_OP		1
#define CONST_OP	2
#define ADDR_OP		3
#define VAR_OP		4
#define LABEL_OP	5
/*****************************************************************************/
/*                                                                           */
/* op codes for emit							     */
/*                                                                           */
/*****************************************************************************/
#define PSEUDO_OP	0x8000
#define NATIVE_OP	0x4000
#define LD_ST_OP	0x2000
#define BRANCH_OP	0x1000
#define NATIVE_OP_MASK	0x3F
#define INSTR		(PSEUDO_OP | 0xFF)
#define ENTER_PROC	(PSEUDO_OP | 0x01)
#define RETURN_PROC	(PSEUDO_OP | 0x02)
#define CALL_PROC	(PSEUDO_OP | 0x03)
#define ENTER_LEAF	(PSEUDO_OP | 0x04)
#define RETURN_LEAF	(PSEUDO_OP | 0x05)
#define CALL_LEAF	(PSEUDO_OP | 0x06)
#define CALL_LEAF_IND	(PSEUDO_OP | 0x07)
#define ENTER_BASICBLK	(PSEUDO_OP | 0x08)
#define RETURN_BASICBLK	(PSEUDO_OP | 0x09)
#define ADD_LABEL	(PSEUDO_OP | 0x0A)
#define NO_OP		(PSEUDO_OP | 0x0B)
#define LDW_MEM		(LD_ST_OP | 0x00)
#define LDW_IND		(LD_ST_OP | 0x01)
#define LDHW_IND	(LD_ST_OP | 0x02)
#define LDUB_IND	(LD_ST_OP | 0x03)
#define STW_MEM		(LD_ST_OP | 0x06)
#define STW_IND		(LD_ST_OP | 0x07)
#define STHW_IND	(LD_ST_OP | 0x08)
#define STUB_IND	(LD_ST_OP | 0x09)
#define ADD		(NATIVE_OP | 0x00)
#define ADDcc		(NATIVE_OP | 0x10)
#define ADDX		(NATIVE_OP | 0x08)
#define ADDXcc		(NATIVE_OP | 0x18)
#define	SUB		(NATIVE_OP | 0x04)
#define SUBcc		(NATIVE_OP | 0x14)
#define SUBX		(NATIVE_OP | 0x0C)
#define SUBXcc		(NATIVE_OP | 0x1C)
#define AND		(NATIVE_OP | 0x01)
#define ANDcc		(NATIVE_OP | 0x11)
#define ANDN		(NATIVE_OP | 0x05)
#define ANDNcc		(NATIVE_OP | 0x15)
#define OR		(NATIVE_OP | 0x02)
#define ORcc 		(NATIVE_OP | 0x12)
#define ORN		(NATIVE_OP | 0x06)
#define ORNcc		(NATIVE_OP | 0x16)
#define XOR		(NATIVE_OP | 0x03)
#define XORcc 		(NATIVE_OP | 0x13)
#define XNOR		(NATIVE_OP | 0x07)
#define XNORcc		(NATIVE_OP | 0x17)
#define SH_LEFT		(NATIVE_OP | 0x25)
#define SH_RIGHT	(NATIVE_OP | 0x26)
#define SH_RIGHT_ARITH	(NATIVE_OP | 0x27)
#define BRANCH		(BRANCH_OP | 0x08)
#define BR_NEVER	(BRANCH_OP | 0x00)
#define BR_NEQ		(BRANCH_OP | 0x09)
#define BR_EQ		(BRANCH_OP | 0x01)
#define BR_GR		(BRANCH_OP | 0x0A)
#define BR_LE		(BRANCH_OP | 0x02)
#define BR_GRE		(BRANCH_OP | 0x0B)
#define BR_L		(BRANCH_OP | 0x03)
#define BR_GU		(BRANCH_OP | 0x0C)
#define BR_LEU		(BRANCH_OP | 0x04)
#define BR_CC		(BRANCH_OP | 0x0D)
#define BR_CS		(BRANCH_OP | 0x05)
#define BR_POS		(BRANCH_OP | 0x0E)
#define BR_NEG		(BRANCH_OP | 0x06)
#define BR_VC		(BRANCH_OP | 0x0F)
#define BR_VS		(BRANCH_OP | 0x07)
#define BR_NZ		(BRANCH_OP | 0x09)
#define BR_Z		(BRANCH_OP | 0x01)
#define OP_LDW		0x00L
#define OP_LDHW		0x02L
#define OP_LDUB		0x01L
#define OP_STW		0x04L
#define OP_STUB		0x05L
#define OP_STHW		0x06L
#define OP_ADD		0x00L
#define OP_ADDcc	0x10L
#define OP_ADDX		0x08L
#define OP_ADDXcc	0x18L
#define	OP_SUB		0x04L
#define OP_SUBcc	0x14L
#define OP_SUBX		0x0CL
#define OP_SUBXcc	0x1CL
#define OP_AND		0x01L
#define OP_ANDcc	0x11L
#define OP_ANDN		0x05L
#define OP_ANDNcc	0x15L
#define OP_OR		0x02L
#define OP_ORcc 	0x12L
#define OP_ORN		0x06L
#define OP_ORNcc	0x16L
#define OP_XOR		0x03L
#define OP_XORcc 	0x13L
#define OP_XNOR		0x07L
#define OP_XNORcc	0x17L
#define OP_SLL		0x25L
#define OP_SRL		0x26L
#define OP_SRA		0x27L
#define OP_SETHI	0x04L
#define OP_JMPL		0x38L
#define OP_SAVE		0x3CL
#define OP_RESTORE	0x3DL
#define IMMEDIATE	1
#define REG_SOURCE	0
#define FMT2_INST(op, opcode, k, rd) 	(((op) << 30) | \
					 ((opcode) << 22) | \
					 ((rd) << 25) | \
					 ((k) & 0x3fffffL))
#define FMT3_INST(op, opcode, rs1, i, rs2, rd) (((op) << 30) | \
						((rd) << 25) | \
						((opcode) << 19) | \
		       				((rs1) << 14) | \
						((i) << 13) | \
						((rs2) & 0x1FFFL))
#define SAVE_REG_IMM(rs1, k, rd)	(FMT3_INST(0x2L, OP_SAVE, (rs1), IMMEDIATE, (k), (rd)))
#define SAVE_REG_REG(rs1, rs2, rd)	(FMT3_INST(0x2L, OP_SAVE, (rs1), REG_SOURCE, (rs2), (rd)))
#define RESTORE				(FMT3_INST(0x2L, OP_RESTORE, REG_G0, REG_SOURCE, REG_G0, REG_G0))
#define RET				(FMT3_INST(0x2L, OP_JMPL, REG_I7, IMMEDIATE, 8, REG_G0))
#define RETL				(FMT3_INST(0x2L, OP_JMPL, REG_O7, IMMEDIATE, 8, REG_G0))
#define CALL_REG(r)			(FMT3_INST(0x2L, OP_JMPL, (r), IMMEDIATE, 0, REG_O7))
#define CALL_REG_IMM(r, k) 		(FMT3_INST(0x2L, OP_JMPL, (r), IMMEDIATE, (k), REG_O7))
#define CALL(disp)			((0x01 << 30) | (((unsigned long) (disp)) >> 2))
#define NOP				(FMT3_INST(0x2L, OP_OR, REG_G0, REG_SOURCE, REG_G0, REG_G0))
#define LDW_REG_IMM(rs1, k, rd) 	(FMT3_INST(0x3L, OP_LDW, rs1, IMMEDIATE, k, rd))
#define LDW_REG_REG(rs1, rs2, rd) 	(FMT3_INST(0x3L, OP_LDW, rs1, REG_SOURCE, rs2, rd))
#define LDHW_REG_IMM(rs1, k, rd) 	(FMT3_INST(0x3L, OP_LDHW, rs1, IMMEDIATE, k, rd))
#define LDHW_REG_REG(rs1, rs2, rd) 	(FMT3_INST(0x3L, OP_LDHW, rs1, REG_SOURCE, rs2, rd))
#define LDUB_REG_IMM(rs1, k, rd) 	(FMT3_INST(0x3L, OP_LDUB, rs1, IMMEDIATE, k, rd))
#define LDUB_REG_REG(rs1, rs2, rd) 	(FMT3_INST(0x3L, OP_LDUB, rs1, REG_SOURCE, rs2, rd))
#define STW_REG_IMM(rs1, k, rd) 	(FMT3_INST(0x3L, OP_STW, rs1, IMMEDIATE, k, rd))
#define STW_REG_REG(rs1, rs2, rd) 	(FMT3_INST(0x3L, OP_STW, rs1, REG_SOURCE, rs2, rd))
#define STHW_REG_IMM(rs1, k, rd) 	(FMT3_INST(0x3L, OP_STHW, rs1, IMMEDIATE, k, rd))
#define STHW_REG_REG(rs1, rs2, rd) 	(FMT3_INST(0x3L, OP_STHW, rs1, REG_SOURCE, rs2, rd))
#define STUB_REG_IMM(rs1, k, rd) 	(FMT3_INST(0x3L, OP_STUB, rs1, IMMEDIATE, k, rd))
#define STUB_REG_REG(rs1, rs2, rd) 	(FMT3_INST(0x3L, OP_STUB, rs1, REG_SOURCE, rs2, rd))
#define ADD_REG_IMM(rs1, k, rd) 	(FMT3_INST(0x2L, OP_ADD, rs1, IMMEDIATE, k, rd))
#define ADD_REG_REG(rs1, rs2, rd) 	(FMT3_INST(0x2L, OP_ADD, rs1, REG_SOURCE, rs2, rd))
#define ADDcc_REG_IMM(rs1, k, rd) 	(FMT3_INST(0x2L, OP_ADDcc, rs1, IMMEDIATE, k, rd))
#define ADDcc_REG_REG(rs1, rs2, rd) 	(FMT3_INST(0x2L, OP_ADDcc, rs1, REG_SOURCE, rs2, rd))
#define ADDX_REG_IMM(rs1, k, rd) 	(FMT3_INST(0x2L, OP_ADDX, rs1, IMMEDIATE, k, rd))
#define ADDX_REG_REG(rs1, rs2, rd) 	(FMT3_INST(0x2L, OP_ADDX, rs1, REG_SOURCE, rs2, rd))
#define ADDXcc_REG_IMM(rs1, k, rd) 	(FMT3_INST(0x2L, OP_ADDXcc, rs1, IMMEDIATE, k, rd))
#define ADDXcc_REG_REG(rs1, rs2, rd) 	(FMT3_INST(0x2L, OP_ADDXcc, rs1, REG_SOURCE, rs2, rd))
#define SUB_REG_IMM(rs1, k, rd) 	(FMT3_INST(0x2L, OP_SUB, rs1, IMMEDIATE, k, rd))
#define SUB_REG_REG(rs1, rs2, rd) 	(FMT3_INST(0x2L, OP_SUB, rs1, REG_SOURCE, rs2, rd))
#define SUBcc_REG_IMM(rs1, k, rd) 	(FMT3_INST(0x2L, OP_SUBcc, rs1, IMMEDIATE, k, rd))
#define SUBcc_REG_REG(rs1, rs2, rd) 	(FMT3_INST(0x2L, OP_SUBcc, rs1, REG_SOURCE, rs2, rd))
#define SUBX_REG_IMM(rs1, k, rd) 	(FMT3_INST(0x2L, OP_SUBX, rs1, IMMEDIATE, k, rd))
#define SUBX_REG_REG(rs1, rs2, rd) 	(FMT3_INST(0x2L, OP_SUBX, rs1, REG_SOURCE, rs2, rd))
#define SUBXcc_REG_IMM(rs1, k, rd) 	(FMT3_INST(0x2L, OP_SUBXcc, rs1, IMMEDIATE, k, rd))
#define SUBXcc_REG_REG(rs1, rs2, rd) 	(FMT3_INST(0x2L, OP_SUBXcc, rs1, REG_SOURCE, rs2, rd))
#define AND_REG_IMM(rs1, k, rd) 	(FMT3_INST(0x2L, OP_AND, rs1, IMMEDIATE, k, rd))
#define AND_REG_REG(rs1, rs2, rd) 	(FMT3_INST(0x2L, OP_AND, rs1, REG_SOURCE, rs2, rd))
#define OR_REG_IMM(rs1, k, rd) 		(FMT3_INST(0x2L, OP_OR, rs1, IMMEDIATE, k, rd))
#define OR_REG_REG(rs1, rs2, rd) 	(FMT3_INST(0x2L, OP_OR, rs1, REG_SOURCE, rs2, rd))
#define XOR_REG_IMM(rs1, k, rd) 	(FMT3_INST(0x2L, OP_XOR, rs1, IMMEDIATE, k, rd))
#define XOR_REG_REG(rs1, rs2, rd) 	(FMT3_INST(0x2L, OP_XOR, rs1, REG_SOURCE, rs2, rd))
#define XNOR_REG_IMM(rs1, k, rd) 	(FMT3_INST(0x2L, OP_XNOR, rs1, IMMEDIATE, k, rd))
#define XNOR_REG_REG(rs1, rs2, rd) 	(FMT3_INST(0x2L, OP_XNOR, rs1, REG_SOURCE, rs2, rd))
#define NOT_REG(r)			(XNOR_REG_REG(r, REG_G0, r))
#define SLL_REG_IMM(rs1, k, rd) 	(FMT3_INST(0x2L, OP_SLL, rs1, IMMEDIATE, k, rd))
#define SLL_REG_REG(rs1, rs2, rd) 	(FMT3_INST(0x2L, OP_SLL, rs1, REG_SOURCE, rs2, rd))
#define SRL_REG_IMM(rs1, k, rd) 	(FMT3_INST(0x2L, OP_SRL, rs1, IMMEDIATE, k, rd))
#define SRL_REG_REG(rs1, rs2, rd) 	(FMT3_INST(0x2L, OP_SRL, rs1, REG_SOURCE, rs2, rd))
#define HI22(k) 			((((unsigned long) (k)) >> 10) & 0x3fffffL)
#define LOW10(k) 			(((unsigned long) (k)) & 0x3ffL)
#define SETHI(k, rd) 			(FMT2_INST(0x0L, OP_SETHI, k, rd))
/******************************************************************************
 * The branch instructions.
 *****************************************************************************/
#define BRANCH_INST(annul, cond, disp)	(((annul) << 29) | ((cond) << 25) | (0x800000) | ((disp) & 0x3FFFFF))
#define BRA(disp)			(BRANCH_INST(0, 0x8, disp))
#define BRN(disp)			(BRANCH_INST(0, 0x0, disp))
#define BRNE(disp)			(BRANCH_INST(0, 0x9, disp))
#define BRE(disp)			(BRANCH_INST(0, 0x1, disp))
#define BRG(disp)			(BRANCH_INST(0, 0xA, disp))
#define BRLE(disp)			(BRANCH_INST(0, 0x2, disp))
#define BRGE(disp)			(BRANCH_INST(0, 0xB, disp))
#define BRL(disp)			(BRANCH_INST(0, 0x3, disp))
#define BRGU(disp)			(BRANCH_INST(0, 0xC, disp))
#define BRLEU(disp)			(BRANCH_INST(0, 0x4, disp))
#define BRCC(disp)			(BRANCH_INST(0, 0xD, disp))
#define BRCS(disp)			(BRANCH_INST(0, 0x5, disp))
#define BRPOS(disp)			(BRANCH_INST(0, 0xE, disp))
#define BRNEG(disp)			(BRANCH_INST(0, 0x6, disp))
#define BRVC(disp)			(BRANCH_INST(0, 0xF, disp))
#define BRVS(disp)			(BRANCH_INST(0, 0x7, disp))
#define BRNZ(disp)			(BRANCH_INST(0, 0x9, disp))
#define BRZ(disp)			(BRANCH_INST(0, 0x1, disp))
/*****************************************************************************/
/*                                                                           */
/* Macros to insert target instructions etc.				     */
/*                                                                           */
/*****************************************************************************/
#define EMIT(inst)			*pcodNext++ = (inst)
#define CURRENT_LOC			(pcodNext)
#define CURRENT_HANDLE			(&pcodNext)
#ifdef DEBUG
#define ASCODE(c)  fprintf(DEBUGFILE, "\t0x%x: %s\n", DASMADDR, c); fflush(DEBUGFILE)
#define ASNOTE(c)  fprintf(DEBUGFILE, "\t%s\n", c); fflush(DEBUGFILE)
#else DEBUG
#define ASCODE(name)
#define ASNOTE(c)
#endif DEBUG
#ifdef __cplusplus
/*****************************************************************************/
/******************************** TEMPLATES **********************************/
/*****************************************************************************/
/*****************************************************************************/
/*************************** CLASSES & TYPEDEFS ******************************/
/*****************************************************************************/
typedef unsigned long CODE;
typedef unsigned short CODELABEL;
typedef CODE *CODEPTR;
typedef CODEPTR *CODEHANDLE;
typedef unsigned long REGISTER;
typedef struct tag_regEntry {	/* Describes register contents */
  INT16	nVar;			/* Name (index) of variable */
  INT16	nPriority;		/* Priority of variable */
  INT16	nHeapOffset;		/* Offset into heap of variable */
} REGENTRY;
     
typedef struct tag_regQue {
  REGISTER rRegQue[MREGS];
  BYTE bHead;
  BYTE bTail;
  BYTE bNumElements;
} REGQUE;
struct tag_codeblk {
     CODEHANDLE hcodTarget;
     CODEPTR    pcodNext;
     CODELABEL	lblNext;
     LABELREC   *plblrecFirst;
     struct tag_codeblk *pblkPrev;
typedef tag_codeblk CODEBLK;
/* record of a reference to a label */
struct tag_lblref {
     CODEPTR	pcodRefLoc;
     struct tag_lblref *prefNext;
typedef tag_lblref LABELREF;
/* record of a label */
struct tag_lblrec {
     INT16	lblName;
     BYTE	bValid;
     CODEPTR	lAddress;
     struct tag_lblref *prefFirst;
     struct tag_lblrec *precNext;
typedef tag_lblrec LABELREC;
class Cam8SimSPARCCore : public Cam8SimCore {
public:
  static const char *szRegName[] = {
    "%g0", "%g1", "%g2", "%g3", "%g4", "%g5", "%g6", "%g7",
    "%o0", "%o1", "%o2", "%o3", "%o4", "%o5", "%sp", "%tp",
    "%l0", "%l1", "%l2", "%l3", "%l4", "%l5", "%l6", "%l7",
    "%i0", "%i1", "%i2", "%i3", "%i4", "%i5", "%ds", "%ra"
  };
  static const char *szCCName[] = {
    "NEVER", "EQ", "LE", "L", "LEU", "CS", "NEG", "VS",
    "ALWAYS", "NEQ", "G", "GE", "GU", "CC", "POS", "VC"
  };
  static char REGISTERS[32][64] = {
    "G0", "G1", "G2", "G3", "G4", "G5", "G6", "G7",
    "O0", "O1", "O2", "O3", "O4", "O5", "O6", "O7",
    "L0", "L1", "L2", "L3", "L4", "L5", "L6", "L7",
    "I0", "I1", "I2", "I3", "I4", "I5", "I6", "I7",
  };
  char SYMBOLS[SymbolTableSize][64];
  REGENTRY rCurrWindow[MREGS];
  REGQUE rqueFree;
  REGQUE rqueSpillable[4];							 /* Que of spillable registers, one  */
  LABELREC *plblrecFirst;
  CODE *pcodScanNoPerm;
  CODEPTR pcodGenUpdate;
  CODEPTR pcodScanner;
  CODEPTR pcodSweep;
  CODEPTR pcodUpdateSite;
  CODEPTR pcodNext;		/* Pointer to location of next inst */
  CODEHANDLE hcodTarget;	/* Handle to Target Code Location */
  CODELABEL lblNext;		/* Next Label */
  CODEBLK *pblkTOS;
#ifdef DEBUG
  CODEPTR DASMADDR;
#endif DEBUG
#ifdef _INSTRUMENTATION_
  struct timeval tvStart, tvEnd;
  struct timezone tzZone;
#endif
  Cam8SimSPARCCore(void);
  DECL_COPYCONST(Cam8SimSPARCCore);
  virtual ~Cam8SimSPARCCore(void);
  DECL_OPEQ(Cam8SimSPARCCore);
  DECL_BZERO(Cam8SimSPARCCore);
  DECL_BCOPY(Cam8SimSPARCCore);
  DECL_BCMP(Cam8SimSPARCCore);
  void InitSim(void);
  void SimScanNoPerm(CODEHANDLE hcodCurrent);
  void SimGeneralScan(CODEHANDLE hcodCurrent);
  void SimPrologue(CODEHANDLE hcodCurrent);
  void SimEpilogue(CODEHANDLE hcodCurrent);
  void SimUpdateSite();
  void SimLoadFirstWord(unsigned short nBitOffset[]);
  void SimGetNextWord(unsigned short nPlane);
  void SimSaveLastWord(unsigned short nBitOffset[]);
  void CheckNoPerm(CODEHANDLE hcodCurrent);
  void SimUpdateCode();
  void SimLoadPlaneWords();
  void SimSavePlaneWords();
  void MapFunction (short iSrcVar, short iDestVar, BYTE bMap);
  void BuildDest(short nDest, short iDestVar, BYTE Src, BYTE Map);
  void BuildBitDest(short nDest, short iHoldReg, BYTE Src, BYTE Map, unsigned short nPlane);
  void BuildBitwiseDest(short nDest, short iDestVar, BYTE Src[], BYTE Map[]);
  short PermuteScanIndex();
  void InsertSpillable(REGISTER reg);
  void ResetSpillQue(void);
  void PushRegWindow(void);
  void PopRegWindow(CODEHANDLE hcodCurrent);
  void FreeReg(REGISTER reg);
  void ResetFreeQue(void);
  void AddQueElement(REGQUE *prque, REGISTER reg);
  void ResetQue(REGQUE *prque);
  BYTE NumFreeRegs(void);
  BYTE NumQueElements(REGQUE rque);
  REGISTER GetFreeReg(void);
  REGISTER GetSpillable(void);
  REGISTER GetQueElement(REGQUE *prque);
  void NewBlock(CODEHANDLE);
  void EndBlock();
  void Emit(INT16 opcode, BYTE op1Type, LONG32 op1, BYTE op2Type, LONG32 op2,
	    BYTE destType, LONG32 dest);
  void PrintAsm(CODEPTR pcodSource, FILE *fOut);
  void InitRegMgr(void);
  /* flushes rFlush back to memory */
  void FlushReg(REGISTER rFlush, CODEHANDLE hcodCurrent);
  /* record all the "live" registers */
  void SaveRegState(void);
  /* returns all regs to state they */
  void RestoreRegState(CODEHANDLE hcodCurrent);
  /* allocates a register for nVar */
  REGISTER GetReg(INT16 nVar, CODEHANDLE hcodCurrent, BOOL bLoad);
typedef Cam8SimSPARCCore *CAM8SIMSPARCCORE;
/*****************************************************************************/
/********************************* INLINES ***********************************/
/*****************************************************************************/
#endif
/*****************************************************************************/
/******************************* PROTOTYPES **********************************/
/*****************************************************************************/
/*****************************************************************************/
/********************************* GLOBALS ***********************************/
/*****************************************************************************/
#endif

---------------------------------------------------------------------------

#include <CAM/CAM8Sim++.H>
int main(int argc, char *argv[])
  CAM8Sim sim;
  CAM8SimInterface ifc;
  CAM8SimModule mod;
  sim.InitSimulator(&ifc, &mod);
  sim.main(argc, argv);
  ifc.InitInterface(&sim);
  ifc.main(argc, argv);
  mod.InitModule(&sim);
  mod.main(argc, argv);
void InitExitProcs()
#ifdef BADSIG
  const void * err = BADSIG;
#else
  const void * err = SIG_ERR;
#endif
  CaLib_tb.ENTER("InitExitProcs");
#ifdef sun
#if 0
  on_exit(ExitProc);								 /* Make sure it gets called on exit */
#else
  atexit(ExitProc);								 /* Make sure it gets called on exit */
#endif
#endif
     
  if ( (signal(SIGHUP, ExitSigProc) == err) ||
       (signal(SIGINT, SIG_IGN) == err) ||
       (signal(SIGQUIT, SIG_IGN) == err) ||
       (signal(SIGILL, ExitSigProc) == err) ||
       (signal(SIGFPE, ExitSigProc) == err) ||
       (signal(SIGBUS, ExitSigProc) == err) ||
       (signal(SIGSEGV, ExitSigProc) == err) ||
       (signal(SIGSYS, ExitSigProc) == err) ||
       (signal(SIGPIPE, ExitSigProc) == err) ||
       (signal(SIGTERM, ExitSigProc) == err) )
    CaLibWarning(TRUE, "Could not install cleanup routines!");
  CaLib_tb.LEAVE();
#ifdef BADSIG
void ExitSigProc(int sig, int code, struct sigcontext *scp, char *addr)
#else
void ExitSigProc(int sig)
#endif
  static char *pcSignalName[] = {
    "Unknown",
    "Hangup",
    "Interrupt",
    "Quit",
    "Illegal Instruction",
    "Trace Trap",
    "IO (Hardware) Trap",
    "Emulator Trap",
    "Floating Point Exception",
    "Kill",
    "Bus Error",
    "Segmentation Fault",
    "Bad Argument to system call",
    "Write to broken pipe",
    "Alarm",
    "Software Termination",
    "User1",
    "User2",
    "Child Termination",
    "Power down"
  };
  CaLib_tb.ENTER("ExitSigProc");
  CaLibDie.SetAppName("Cam8SIM");
     
  switch (sig) {
  case SIGHUP:
  case SIGSYS:
  case SIGPIPE:
    CaLibDie(TRUE, "%s signal received - exiting.\n", pcSignalName[sig]);
    break;
    
  case SIGILL:
  case SIGFPE:
#ifdef BADSIG
    CaLibDie(TRUE, "Attempt to execute illegal instruction at 0x%x\n", addr);
#else
    CaLibDie(TRUE, "Attempt to execute illegal instruction\n");
#endif
    break;
  case SIGBUS:
  case SIGSEGV:
#ifdef BADSIG
    CaLibDie(TRUE, "Attempt to access invalid memory location 0x%x\n", addr);
#else
    CaLibDie(TRUE, "Attempt to access invalid memory location\n");
#endif
    break;
  case SIGTERM:
    CaLibDie(TRUE, "Termination signal received - exiting.\n");
    break;
  default:
    break;
#ifdef DEBUG
  fclose(DEBUGFILE);
#endif
  Calib_tb.LEAVE();
  /*  _exit(0); */
void ExitProc()
#ifdef DEBUG
  fclose(DEBUGFILE);
#endif

---------------------------------------------------------------------------

***********************************/
  /* Now that we know the site address of the first site to be updated,   */
  /* we compute the address in sparc memory of the word that contains     */
  /* a bit of that site by adding the plane offset to the site address.   */
  /************************************************************************/
#ifndef INTERPRETER
  for (i = 0; i < nNumPlanes; i++) {
    NEXT_WORD_ADDR(i) = (AddSiteAddress(SITE_ADDR, OSR[i]) >> 5) << 2;
    NEXT_WORD_ADDR(i) += BIT_PLANE_ADDR(i);
    nBitOffset[i] = OSR[i] & 0x1F;
  xWordLength = X_BYTE_LENGTH >> 2;
  NewBlock(&pcodCurrent);
  .ENTER_PROC;
  SimLoadFirstWord(nBitOffset);
  if (IsSrcNeeded(SRC_SITE_ADDRESS)) {
    .LDW_MEM iScanIndexReg;
  if (IsSrcNeeded(SRC_LUT)) {
    .LDW_MEM iLutAddr;
  .LDW_MEM iUpdateSiteProc;
  .ADD %G0, #xWordLength, iXCtr;
  .ADD_LABEL :lblXLoop;
  SimUpdateSite();
  for (i = 0; i < 32; i++) {
    .CALL_LEAF_IND iUpdateSiteProc, #4;
    .INSTR *pcodUpdateSite;
    for (j = 0; j < nNumPlanes; j++) {
      if (nBitOffset[j] == (31 - i)) {
	SimGetNextWord(j);
      }
    }
  .SUBcc iXCtr, #1, iXCtr;
  .BR_NZ :lblXLoop;
  .NO_OP;
  SimSaveLastWord(nBitOffset);
  .RETURN_PROC;
  EndBlock();
  LP("SimSweepCode");
#else INTERPRETER
  for (i = 0; i < nNumPlanes; i++) {
    NEXT_WORD_ADDR[i] = (AddSiteAddress(SITE_ADDR, OSR[i]) >> 5) << 2;
    NEXT_WORD_ADDR[i] += BIT_PLANE_ADDR[i];
    NBIT_OFFSET[i] = OSR[i] & 0x1F;
  XWORD_LENGTH = X_BYTE_LENGTH >> 2;
  SimLoadFirstWord(NBIT_OFFSET);
  X_CTR = XWORD_LENGTH;
  do {
    for (i = 0; i < 32; i++) {
      SimUpdateSite();
      for (j = 0; j < nNumPlanes; j++) {
	if (NBIT_OFFSET[j] == (31 - i))
	  SimGetNextWord(j);
      }
    }
    X_CTR -= 1;
  } while (X_CTR);
  SimSaveLastWord(NBIT_OFFSET);
  LP("SimSweepCode");
#endif INTERPRETER
#ifndef INTERPRETER
void SimLoadFirstWord(unsigned short nBitOffset[])
  short i;
  const short iSaveBits = iTemp1;
  const short iWordAddr = iTemp1;
  EP("SimLoadFirstWord");
  for (i = 0; i < nNumPlanes; i++) {
    .LDW_IND %DS, #(offNextWordAddr+(i<<2)), iWordAddr;
    .LDW_IND iWordAddr, #0, (iPlaneWord+i);
    if (nBitOffset[i] != 0) {
      .SH_RIGHT (iPlaneWord+i), #(32 - nBitOffset[i]), iSaveBits;
      .SH_LEFT (iPlaneWord+i), #nBitOffset[i], (iPlaneWord+i);
      .OR (iPlaneWord+i), iSaveBits, (iPlaneWord+i);
    }
  LP("SimLoadFirstWord");
#else INTERPRETER
void SimLoadFirstWord(LONG32 NBIT_OFFSET[])
  short i;
  LONG32 SAVE_BITS, WORD_ADDR;
  EP("SimLoadFirstWord");
  for (i = 0; i < nNumPlanes; i++) {
    PLANE_WORD[i] = *((LONG32 *) NEXT_WORD_ADDR[i]);
    
    if (NBIT_OFFSET[i] != 0) {
      SAVE_BITS = PLANE_WORD[i] >> (32 - NBIT_OFFSET[i]);
      PLANE_WORD[i] <<= NBIT_OFFSET[i];
      PLANE_WORD[i] |= SAVE_BITS;
    }
  LP("SimLoadFirstWord");
#endif INTERPRETER
#ifndef INTERPRETER
void SimGetNextWord(unsigned short nPlane)
  const short iAddrHighBit = iTemp1;
  BOOL bWriteBack = FALSE;
  short i;
  EP("SimGetNextWord");
#else INTERPRETER
void SimGetNextWord(unsigned short nPlane)
  LONG32 ADDR_HIGH_BIT;
  BOOL bWriteBack = FALSE;
  short i;
  EP("SimGetNextWord");
#endif INTERPRETER
#ifndef INTERPRETER
  .ENTER_BASICBLK;
  if (IsDestUpdated(DEST_SITE_DATA)) {
    .STW_IND (iNextWordAddr+nPlane), #0, (iPlaneWord+nPlane);
  if (lNumXBits <= 5) {
    .RETURN_BASICBLK;
    LP("SimGetNextWord");
    return;
  .AND (iNextWordAddr+nPlane), iXHighBitMask, iAddrHighBit;
  .XNOR iXHighBitMask, %G0, iXHighBitMask;
  .AND (iNextWordAddr+nPlane), iXHighBitMask, (iNextWordAddr+nPlane);
  .ADD (iNextWordAddr+nPlane), #4, (iNextWordAddr+nPlane);
  .XOR iAddrHighBit, (iNextWordAddr+nPlane), iNextWordAddr+nPlane;
  .XNOR iXHighBitMask, %G0, iXHighBitMask;
  .LDW_IND (iNextWordAddr+nPlane), #0, (iPlaneWord+nPlane);
  .STW_MEM (iNextWordAddr+nPlane);
  .RETURN_BASICBLK;
  LP("SimGetNextWord");
#else INTERPRETER
  if (IsDestUpdated(DEST_SITE_DATA))
      *((LONG32 *) NEXT_WORD_ADDR[nPlane]) = PLANE_WORD[nPlane];
  if (lNumXBits <= 5) {
    LP("SimGetNextWord");
    return;
  ADDR_HIGH_BIT = NEXT_WORD_ADDR[nPlane] & X_HIGH_BIT_MASK;
  NEXT_WORD_ADDR[nPlane] &= (~ X_HIGH_BIT_MASK);
  NEXT_WORD_ADDR[nPlane] = (NEXT_WORD_ADDR[nPlane] + 4) ^ ADDR_HIGH_BIT;
  PLANE_WORD[nPlane] = *((LONG32 *) NEXT_WORD_ADDR[nPlane]);
  LP("SimGetNextWord");
#endif INTERPRETER
#ifndef INTERPRETER
void SimSaveLastWord(unsigned short nBitOffset[])
  short i;
  const short iSaveBits = iTemp1;
  EP("SimSaveLastWord");
#else INTERPRETER
void SimSaveLastWord(LONG32 NBIT_OFFSET[])
  short i;
  LONG32 SAVE_BITS;
  EP("SimSaveLastWord");
#endif INTERPRETER
#ifndef INTERPRETER
  if (IsDestUpdated(DEST_SITE_DATA)) {
    .ENTER_BASICBLK;
    for (i = 0; i < nNumPlanes; i++) {
      if (!nBitOffset[i])
	continue;
      .SH_RIGHT (iPlaneWord+i), #(nBitOffset[i]), iSaveBits;
      .SH_LEFT (iPlaneWord+i), #(32 - nBitOffset[i]), (iPlaneWord+i);
      .OR (iPlaneWord+i), iSaveBits, (iPlaneWord+i);
      .STW_IND (iNextWordAddr+i), #0, (iPlaneWord+i);
    }
    .RETURN_BASICBLK;
  LP("SimSaveLastWord");
#else INTERPRETER
  if (IsDestUpdated(DEST_SITE_DATA)) {
    for (i = 0; i < nNumPlanes; i++) {
      if (!NBIT_OFFSET[i])
	continue;
      SAVE_BITS = PLANE_WORD[i] >> NBIT_OFFSET[i];
      PLANE_WORD[i] <<= (32 - NBIT_OFFSET[i]);
      PLANE_WORD[i] |= SAVE_BITS;
      *((LONG32 *) NEXT_WORD_ADDR[i]) = PLANE_WORD[i];
    }
  LP("SimSaveLastWord");
#endif INTERPRETER
#ifndef INTERPRETER
void SimGeneralScan(CODEHANDLE hcodCurrent)
  /************************************************************************/
  /* Sim making no assumptions - in particular, it is expected that   */
  /* the scan index will be permuted, so that updated sites will not be   */
  /* sequentially located in memory.                                      */
  /************************************************************************/
  short i;
  CODELABEL lblMainLoop, lblAddrLoop, lblSkip1, lblSkip2;
  const short iPlaneCtr = iTemp1, iOffset = iTemp2, iPlaneBases = iTemp3;
  const short iBitOffset = iTemp4, iNextWord = iTemp5, iWordAddr = iTemp6;
  const short iSiteAddress = iTemp7, iSAHighBits = iTemp8;
  const short iOffHighBits = iTemp9, iScratch = iTemp9, iPlaneAddr = iTemp10;
  const short iSAAndMask = iTemp1, iSAOrMask = iTemp2;
  LONG32 lSAAndMask, lSAOrMask;
  LONG32 lSweepLength;
  EP("SimGeneralScan");
  nNumPlanes = CalcNumPlanes();
  lblMainLoop = NewLabel();
  lblAddrLoop = NewLabel();
  lblSkip1 = NewLabel();
  lblSkip2 = NewLabel();
#else INTERPRETER
void SimGeneralScan()
  short i;
  LONG32 PLANE_CTR;
  LONG32 SA_HIGH_BITS, OFF_HIGH_BITS, SCRATCH, PLANE_ADDR;
  LONG32 SWEEP_LENGTH, SA_OR_MASK, SA_AND_MASK, WORD_ADDR;
  nNumPlanes = CalcNumPlanes();
  EP("SimGeneralScan");
  if (nNumPlanes == 0) {
    LP("SimGeneralScan");
    return;
#endif INTERPRETER
  /************************************************************************/
  /* First, update things in the heap from where they can be accessed     */
  /* by the compiled code.                                                */
  /************************************************************************/
  /************************************************************************/
  /* Update heap copy of DCMR.						  */
  /************************************************************************/
  DCMR = DCM[0];
  /************************************************************************/
  /* Update heap copy of OFFSETS					  */
  /************************************************************************/
#ifndef INTERPRETER
  for(i = 0 ; i < CHIPS_PER_MOD; i++)
    OFFSETS(i) = OSR[i];
#else INTERPRETER
  for(i = 0 ; i < CHIPS_PER_MOD; i++)
    OFFSETS[i] = OSR[i];
#endif INTERPRETER
  /************************************************************************/
  /* Figure out the site address of the first site to be updated. This is */
  /* needed to update SITE_ADDR for display purposes. Also,               */
  /* compute the SAAndMask and SAOrMask which will be used to do the      */
  /* permutation at execution time.                                       */
  /************************************************************************/
#ifndef INTERPRETER
  SITE_ADDR = 0;
  lSAOrMask = lSAAndMask = 0;
  for (i = SCAN_INDEX_LENGTH-1; i >= 0; i--) {
    
    SITE_ADDR <<= 1;
    lSAOrMask <<= 1;
    lSAAndMask <<= 1;
    
    if (SIPR[i][0] < SCAN_INDEX_LENGTH) {
      
      /* Get the correct bit of scan indx */
      SITE_ADDR |= (SIR[0] >> SIPR[i][0]) & 0x1;
      
      if (SIPR[i][0] == i)
	lSAAndMask |= 1;
    }
    
    /* Constant of 1 */
    else if (SIPR[i][0] == PERM_CONST_1) {
      lSAOrMask |= 1;
      SITE_ADDR |= 1;
    }
    
    else if (SIPR[i][0] != PERM_CONST_0)
      WARNING("Invalid SIPR value", "SimGenScan");
    
  /************************************************************************/
  /* Figure out how many sites will be updated, and how many sites/sweep  */
  /************************************************************************/
  SITE_CTR = ScanLength();
  lSweepLength = SweepLength(&X_CTR);
#else INTERPRETER
  SITE_ADDR = 0;
  SA_OR_MASK = SA_AND_MASK = 0;
  for (i = SCAN_INDEX_LENGTH-1; i >= 0; i--) {
    
    SITE_ADDR <<= 1;
    SA_OR_MASK <<= 1;
    SA_AND_MASK <<= 1;
    
    if (SIPR[i][0] < SCAN_INDEX_LENGTH) {
      
	/* Get the correct bit of scan indx */
      SITE_ADDR |= (SIR[0] >> SIPR[i][0]) & 0x1;
      
      if (SIPR[i][0] == i)
	SA_AND_MASK |= 1;
    }
    
    /* Constant of 1 */
    else if (SIPR[i][0] == PERM_CONST_1) {
      SA_OR_MASK |= 1;
      SITE_ADDR |= 1;
    }
      
    else if (SIPR[i][0] != PERM_CONST_0)
      WARNING("Invalid SIPR value", "SimGenScan");
  /************************************************************************/
  /* Figure out how many sites will be updated, and how many sites/sweep  */
  /************************************************************************/
  SITE_CTR = ScanLength();
  SWEEP_LENGTH = SweepLength(&X_CTR);
#endif INTERPRETER
  /************************************************************************/
  /* Next, generate the code. First, permute the scan index register to   */
  /* get the site address.                                                */
  /************************************************************************/
#ifndef INTERPRETER
    .LDW_MEM iSiteCtr;
    .LDW_MEM iXCtr;
    .LDW_MEM iXByteLength;
    
    .ADD_LABEL :lblMainLoop;
    
    .ENTER_BASICBLK;
    .LDW_MEM iScanIndexReg;
    
    .ADD %G0, #lSAAndMask, iSAAndMask;
    .ADD %G0, #lSAOrMask, iSAOrMask;
    
    .AND iScanIndexReg, iSAAndMask, iSiteAddress;
    .OR iSAOrMask, iSiteAddress, iSiteAddress;
    
    for (i = SCAN_INDEX_LENGTH-1; i >= 0; i--) {
      if ((SIPR[i][0] < SCAN_INDEX_LENGTH) && (SIPR[i][0] != i)) {
	.SH_LEFT iScanIndexReg, #(31 - SIPR[i][0]), iScratch;
	.ADDcc iScratch, iScratch, iScratch;
	.ADDX %G0, %G0, iTemp10;
	.SH_LEFT iTemp10, #i, iTemp10;
	.OR iTemp10, iSiteAddress, iSiteAddress;
      }
    }
      
#else INTERPRETER
  while (SITE_CTR != 0) {
    SITE_ADDR = SCAN_INDEX_REG & SA_AND_MASK;
    SITE_ADDR |= SA_OR_MASK;
    
    for (i = SCAN_INDEX_LENGTH-1; i >= 0; i--) {
      if ((SIPR[i][0] < SCAN_INDEX_LENGTH) && (SIPR[i][0] != i)) {
	SCRATCH = SCAN_INDEX_REG << (31 - SIPR[i][0]);
	bit = HIGHB(SCRATCH);
	SITE_ADDR |= (bit << i);
      }
    }
    
#endif INTERPRETER
    /************************************************************************/
    /* Now, add site address to the offset to get the DRAM address. The     */
    /* addition must break the carries at the dimension cuts. Also, DRAM    */
    /* address must be broken into a SPARC word address and a 5 bit offset  */
    /* into the word                                                        */
    /************************************************************************/
    
#ifndef INTERPRETER
    .ADD %DS, #offOffsets, iOffset;
    .ADD %DS, #offBitPlaneAddr, iPlaneBases;
    .ADD %DS, #offBitOffsets, iBitOffset;
    .ADD %DS, #offNextWordAddr, iNextWord;


---------------------------------------------------------------------------

#include <CaLibStream++.H>
#include <CaLibError++.H>
#include <CaLibTrace++.H>
#include <CamLib++.H>
#include <Cam8Core++.H>
#include <Pipecomm++.H>
#include <Cam8SimPICore++.H>
#include "std++.H"
extern "C" {
#include <stdlib.h>
#include <string.h>
#include <sys/types.h>
#include <sys/ipc.h>
#include <sys/shm.h>
#include <sys/mman.h>
Cam8SimPICore::Cam8SimPICore(void)
  Bzero();
  ShmCnt = 0;
  InitInterface();
Cam8SimPICore::Cam8SimPICore(int mem, int in, int out)
  Bzero();
  ShmCnt = 0;
  sim_memfd = mem;
  sim_infd = in;
  sim_outfd = out;
  InitInterface();
Cam8SimPICore::~Cam8SimPICore(void)
STD_BZERO(Cam8SimPICore)
STD_BCOPY(Cam8SimPICore)
STD_BCMP(Cam8SimPICore)
int Cam8SimPICore::findidx(unsigned char *ptr)
  int i;
  if (ptr) {
    for (i = 0; i < ShmCnt; i++)
      if (ShmTable[i].buf == ptr)
	return(i);
    return(-1);
  else {
    for (i = 0; i < ShmCnt; i++)
      if (ShmTable[i].buf == NULL)
	return(i);
    
    if (ShmCnt == 8192)
      return(-1);
    else
      return(++ShmCnt);
unsigned char * Cam8SimPICore::Malloc(int size)
  int i;
  key_t key;
  int id;
  unsigned char *t;
  CaLib_tb.ENTER("Cam8SimPICore::Malloc");
  CaLibAbort((i = findidx(NULL)) < 0, "Shared memory table full");
  key = random();
  id = shmget(key, size, IPC_CREAT|IPC_EXCL|0777)
  CaLibAbort(id == -1, "shmget failed");
  t = (unsigned char *) shmat(id, NULL, 0);
  CaLibAbort(t == NULL, "shmat failed");
  ShmTable[i].key = key;
  ShmTable[i].id = id;
  ShmTable[i].buf = t;
  CaLib_tb.LEAVE();
  return(t);
unsigned char * Cam8SimPICore::Calloc(int num, int size)
  register unsigned char *t;
  CaLib_tb.ENTER("Cam8SimPICore::Calloc");
  t = Malloc(size * num);
  memset(t, 0, size * num);
  CaLib_tb.LEAVE();
  return(t);
unsigned char * Cam8SimPICore::Realloc(unsigned char *p, int size)
  register unsigned char *t;
  int i;
  CaLib_tb.ENTER("Cam8SimPICore::Realloc");
  CaLibWarning((i = findidx(p) < 0), "Unknown buffer");
  if (i >= 0) {
    CaLibWarning(shmdt(p) == -1, "shmdt failed");
    ShmTable[i].key = 0;
    ShmTable[i].id = 0;
    ShmTable[i].buf = NULL;
  t = Malloc(size);
  CaLib_tb.LEAVE();
  return(t);
void Cam8SimCore::ResetInterface(void)
  CaLib_tb.ENTER("Cam8SimCore::ResetInterface");
  /* Zero everything out to start off */
  bzero((char *) &iregs, sizeof(iregs));
  /* Enable all interrupts and exceptions */
  iregs.RER = CAM_ENABLE_NEWLIST_INT | CAM_ENABLE_TIMEOUT_INT |
              CAM_ENABLE_SBUS_INT | CAM_ENABLE_CAM_INT |
	      CAM_ENABLE_SOFT_INT | CAM_ENABLE_TIMEOUT_EXC |
	      CAM_ENABLE_CAMINT_EXC;
  /* Mark all interrupts as enabled */
  iregs.ISR = CAM_ENABLE_NEWLIST_INT | CAM_ENABLE_TIMEOUT_INT |
              CAM_ENABLE_SBUS_INT | CAM_ENABLE_CAM_INT |
	      CAM_ENABLE_SOFT_INT;
  /* Put us in wait-for-host mode */
  iregs.NLP |= CAM_WAIT_FOR_HOST;
  CaLib_tb.LEAVE();
void Cam8SimPICore::InitInterface(void)
  ResetInterface();
  comm.SetPipeDescriptors(sim_infd, sim_outfd);
  comm.SetPipeCmdTable(simcmds);
  comm.SetPipeMode(CAM_PIPEALL|CAM_PIPESILENT|CAM_PIPEFDPLX);
  newsl = FALSE;
void Cam8SimPICore::Generate_Interrupt(int type)
  CaLib_tb.ENTER("Cam8SimCore::Generate_Interrupt");
  iregs.ISR |= type;
  switch(type) {
  case CAM_CAM_INT_STATUS: {
    if ((iregs.RER & CAM_ENABLE_CAMINT_EXC) &&
	!(iregs.RER & CAM_DISABLE_CAMINT_EXC)) {
      iregs.NLP |= CAM_EXCEPTION_STATUS;
    }
    break;
  case CAM_TIMEOUT_INT_STATUS: {
    if ((iregs.RER & CAM_ENABLE_TIMEOUT_EXC) &&
	!(iregs.RER & CAM_DISABLE_TIMEOUT_EXC)) {
      iregs.NLP |= CAM_EXCEPTION_STATUS;
    }
    break;
  CaLib_tb.LEAVE();
void Cam8SimPICore::ExecuteSteplist(struct steplist_operation & slo)
  CaLib_tb.ENTER("Cam8SimPICore::ExecuteSteplist");
  // Copy slo to local buffer, resizing if needed and then write to NLP
  CaLib_tb.LEAVE();
LONG32 * Cam8SimPICore::GetNextSteplist(void)
  int rv;
  CaLib_tb.ENTER("Cam8SimPICore::GetNextSteplist");
  while (! newsl) {
    if ((rv = comm.ParsePipeMesg(NULL)) < CAM_PIPEALL) {
      /* There has been a fatal error */
      retv[0] = FATAL;
      comm.SendPipeMesg((unsigned char *) retv);
      CaLibDie("exiting\n");
    }
  newsl = FALSE;
  CaLib_tb.LEAVE();
  return((LONG32 *) (iregs.NLP & 0xFFFFFFF0));
void Cam8SimPICore::Read_NLP(LONG32 *v)
  int ecode;
  CaLib_tb.ENTER("Cam8SimPICore::Read_NLP");
  CaLibAbort(!v, "NULL Pointer");
  ecode = comm.TwoWayPipeCmd(NULL, "rdR0", NULL, NULL, (unsigned char *) v);
  CaLibAbort(ecode < 0);
  CaLib_tb.LEAVE()
void Cam8SimPICore::Read_ISR(LONG32 *v)
  int ecode;
  CaLib_tb.ENTER("Cam8SimPICore::Read_ISR");
  CaLibAbort(!v, "NULL Pointer");
  ecode = comm.TwoWayPipeCmd(NULL, "rdR1", NULL, NULL, (unsigned char *) v);
  CaLibAbort(ecode < 0);
  CaLib_tb.LEAVE()
void Cam8SimPICore::Read_CIP(LONG32 *v)
  int ecode;
  CaLib_tb.ENTER("Cam8SimPICore::Read_CIP");
  CaLibAbort(!v, "NULL Pointer");
  ecode = comm.TwoWayPipeCmd(NULL, "rdR2", NULL, NULL, (unsigned char *) v);
  CaLibAbort(ecode < 0);
  CaLib_tb.LEAVE()
void Cam8SimPICore::Read_PIP(LONG32 *v)
  int ecode;
  CaLib_tb.ENTER("Cam8SimPICore::Read_PIP");
  CaLibAbort(!v, "NULL Pointer");
  ecode = comm.TwoWayPipeCmd(NULL, "rdR3", NULL, NULL, (unsigned char *) v);
  CaLibAbort(ecode < 0);
  CaLib_tb.LEAVE()
void Cam8SimPICore::Write_NLP(const LONG32 *v)
  int ecode;
  CaLib_tb.ENTER("Cam8SimPICore::Write_NLP");
  CaLibAbort(!v, "NULL Pointer");
  ecode = comm.TwoWayPipeCmd(NULL, "wrR0", NULL, NULL, (unsigned char *) v);
  CaLibAbort(ecode < 0);
  CaLib_tb.LEAVE()
void Cam8SimPICore::Write_RER(const LONG32 *v)
  int ecode;
  CaLib_tb.ENTER("Cam8SimPICore::Write_RER");
  CaLibAbort(!v, "NULL Pointer");
  ecode = comm.TwoWayPipeCmd(NULL, "wrR1", NULL, NULL, (unsigned char *) v);
  CaLibAbort(ecode < 0);
  CaLib_tb.LEAVE()
void Cam8SimPICore::Write_DSL(const LONG32 *v)
  int ecode;
  CaLib_tb.ENTER("Cam8SimPICore::Write_DSL");
  CaLibAbort(!v, "NULL Pointer");
  ecode = comm.TwoWayPipeCmd(NULL, "wrR2", NULL, NULL, (unsigned char *) v);
  CaLibAbort(ecode < 0);
  CaLib_tb.LEAVE()
void Cam8SimPICore::Write_DBL(const LONG32 *v)
  int ecode;
  CaLib_tb.ENTER("Cam8SimPICore::Write_DBL");
  CaLibAbort(!v, "NULL Pointer");
  ecode = comm.TwoWayPipeCmd(NULL, "wrR3", NULL, NULL, (unsigned char *) v);
  CaLibAbort(ecode < 0);
  CaLib_tb.LEAVE()
/* PipeComm routines */
unsigned char *SHMAT(char *appdata, unsigned char *o, unsigned char *d)
  int i, shmid = *((int *) d);
  retv[0] = NOERR;
  retv[1] = NOERR;
  CaLibAbort((i = finidx(NULL)) < 0, "Shared memory table full");
  if ((retv[1] = (int) shmat(shmid, (const void *) NULL, NULL)) != -1) {
    ShmTable[i].id = shmid;
    ShmTable[i].buf = (unsigned char *) retv[1];
  return((unsigned char *) retv);
unsigned char *SHMDT(char *appdata, unsigned char *o, unsigned char *d)
  int i;
  unsigned char *p = *((unsigned char **) d);
  retv[0] = NOERR;
  retv[1] = NOERR;
  i = findidx(p);
  if (i < 0) {
    CaLibWarning(TRUE, "Unknown buffer");
    retv[1] = -1;
  else {
    if ((retv[1] = shmdt(p)) != -1) {
      ShmTable[i].key = 0;
      ShmTable[i].id = 0;
      ShmTable[i].buf = NULL;
    }
    else
      CaLibWarning(TRUE, "shdt failed");
  return((unsigned char *) retv);
unsigned char *READR0(char *appdata, unsigned char *o, unsigned char *d)
  retv[0] = NOERR;
  retv[1] = iregs.NLP;
  return((unsigned char *) retv);
unsigned char *READR1(char *appdata, unsigned char *o, unsigned char *d)
  retv[0] = NOERR;
  retv[1] = iregs.ISR;
  /* Turn off interrupt flags and unused bits, leave enables the same */
  iregs.ISR &= 0x00001F00;
  return((unsigned char *) retv);
unsigned char *READR2(char *appdata, unsigned char *o, unsigned char *d)
  retv[0] = NOERR;
  retv[1] = iregs.CIP;
  return((unsigned char *) retv);
unsigned char *READR3(char *appdata, unsigned char *o, unsigned char *d)
  retv[0] = NOERR;
  retv[1] = iregs.PIP;
  return((unsigned char *) retv);
unsigned char *WRITER0(char *appdata, unsigned char *o, unsigned char *d)
  LONG32 tmp = iregs.NLP & 0xF;
  if (!(iregs.NLP & CAM_EXCEPTION_STATUS)) {
    iregs.NLP = tmp | (*((int *) d) & 0xFFFFFFF0);
    newsl = TRUE;
  retv[0] = NOERR;
  return((unsigned char *) retv);
unsigned char *WRITER1(char *appdata, unsigned char *o, unsigned char *d)
  iregs.RER = *((int *) d);
  if (iregs.RER & CAM_RESET_INTERFACE) {
    ResetInterface();
  if (iregs.RER & CAM_HALT_INTERFACE)
    iregs.NLP |= CAM_INTERFACE_HALTED;
  if (iregs.RER & CAM_ENABLE_TIMEOUT_EXC)
    iregs.NLP &= ~(CAM_EXCEPTION_STATUS);
  /*  This is supposed to also resume after error ack, whatever that is
  if (iregs.RER & CAM_ENABLE_CAMINT_EXC)
  */
  if (iregs.RER & CAM_ENABLE_NEWLIST_INT)
    iregs.ISR |= CAM_ENABLE_NEWLIST_INT;
  if (iregs.RER & CAM_ENABLE_TIMEOUT_INT)
    iregs.ISR |= CAM_ENABLE_TIMEOUT_INT;
  if (iregs.RER & CAM_ENABLE_SBUS_INT)
    iregs.ISR |= CAM_ENABLE_SBUS_INT;
  if (iregs.RER & CAM_ENABLE_CAM_INT)
    iregs.ISR |= CAM_ENABLE_CAM_INT;
  if (iregs.RER & CAM_ENABLE_SOFT_INT)
    iregs.ISR |= CAM_ENABLE_SOFT_INT;
  if (iregs.RER & CAM_DISABLE_NEWLIST_INT)
    iregs.ISR &= ~(CAM_ENABLE_NEWLIST_INT);
  if (iregs.RER & CAM_DISABLE_TIMEOUT_INT)
    iregs.ISR &= ~(CAM_ENABLE_TIMEOUT_INT);
  if (iregs.RER & CAM_DISABLE_SBUS_INT)
    iregs.ISR &= ~(CAM_ENABLE_SBUS_INT);
  if (iregs.RER & CAM_DISABLE_CAM_INT)
    iregs.ISR &= ~(CAM_ENABLE_CAM_INT);
  if (iregs.RER & CAM_ENABLE_SOFT_INT)
    iregs.ISR |= CAM_ENABLE_SOFT_INT;
  retv[0] = NOERR;
  return((unsigned char *) retv);
unsigned char *WRITER2(char *appdata, unsigned char *o, unsigned char *d)
  iregs.DSL = *((int *) d);
  retv[0] = NOERR;
  return((unsigned char *) retv);
unsigned char *WRITER3(char *appdata, unsigned char *o, unsigned char *d)
  iregs.DBL = *((int *) d);
  retv[0] = NOERR;
  return((unsigned char *) retv);
unsigned char *QUIT(char *appdata, unsigned char *o, unsigned char *d)
  retv[0] = NOERR;
  qflag = -1;
  return((unsigned char *) retv);

---------------------------------------------------------------------------

p) {
  case MAP_CONST_0: {
#ifndef INTERPRETER
    .OR %G0, %G0, iDestVar;
#else INTERPRETER
    *DestVar = 0;
#endif INTERPRETER
    break;
    
  case MAP_G_NOR_S: {
#ifndef INTERPRETER
    /* Surprizingly, SPARC does not have*/
    /* a native NOR instruction! ORN is */
    /* not NOR!!!                       */
    .OR iGlueData, iSrcVar, iDestVar;
    .XNOR %G0, iDestVar, iDestVar;
#else INTERPRETER
    *DestVar = ~ (GLUE_DATA | *SrcVar);
#endif INTERPRETER
    break;
}    
  case MAP_G_AND_S_BAR: {
#ifndef INTERPRETER
    .XNOR %G0, iSrcVar, iDestVar;
    .AND iGlueData, iDestVar, iDestVar;
#else INTERPRETER
    *DestVar = GLUE_DATA & (~ *SrcVar);
#endif INTERPRETER
    break;
    
  case MAP_S_BAR: {
#ifndef INTERPRETER
    .XNOR %G0, iSrcVar, iDestVar;
#else INTERPRETER
    *DestVar = ~ *SrcVar;
#endif INTERPRETER
    break;
    
  case MAP_G_BAR_AND_S: {
#ifndef INTERPRETER
    .XNOR %G0, iGlueData, iDestVar;
    .AND iSrcVar, iDestVar, iDestVar;
#else INTERPRETER
    *DestVar = (~ GLUE_DATA) & *SrcVar;
#endif INTERPRETER
    break;
    
  case MAP_G_BAR: {
#ifndef INTERPRETER
    .XNOR %G0, iGlueData, iDestVar;
#else INTERPRETER
    *DestVar = ~ GLUE_DATA;
#endif INTERPRETER
    break;
    
  case MAP_G_XOR_S: {
#ifndef INTERPRETER
    .XOR iGlueData, iSrcVar, iDestVar;
#else INTERPRETER
    *DestVar = GLUE_DATA ^ *SrcVar;
#endif INTERPRETER
    break;
    
  case MAP_G_NAND_S: {
#ifndef INTERPRETER
    /* SPARC does not have a native NAND */
    /* instruction! ANDN is not NAND     */
    .AND iGlueData, iSrcVar, iDestVar;
    .XNOR %G0, iDestVar, iDestVar;
#else INTERPRETER
    *DestVar = ~ (GLUE_DATA & *SrcVar);
#endif INTERPRETER
    break;
    
  case MAP_G_AND_S: {
#ifndef INTERPRETER
    .AND iGlueData, iSrcVar, iDestVar;
#else INTERPRETER
    *DestVar = GLUE_DATA & *SrcVar;
#endif INTERPRETER
    break;
    
  case MAP_G_EQ_S: {
#ifndef INTERPRETER
    .XNOR iGlueData, iSrcVar, iDestVar;
#else INTERPRETER
    *DestVar = ~ (GLUE_DATA ^ *SrcVar);
#endif INTERPRETER
    break;
    
  case MAP_G: {
#ifndef INTERPRETER
    .XOR %G0, iGlueData, iDestVar;
#else INTERPRETER
    *DestVar = GLUE_DATA;
#endif INTERPRETER
    break;
    
  case MAP_G_OR_S_BAR: {
#ifndef INTERPRETER
    .XNOR %G0, iSrcVar, iDestVar;
    .OR iGlueData, iDestVar, iDestVar;
#else INTERPRETER
    *DestVar = GLUE_DATA | (~ *SrcVar);
#endif INTERPRETER
    break;
    
  case MAP_S: {
#ifndef INTERPRETER
    .XOR %G0, iSrcVar, iDestVar
#else INTERPRETER
    *DestVar = *SrcVar;
#endif INTERPRETER
      break;
    
  case MAP_G_BAR_OR_S: {
#ifndef INTERPRETER
    .XNOR %G0, iGlueData, iDestVar;
    .OR iSrcVar, iDestVar, iDestVar;
#else INTERPRETER
    *DestVar = (~ GLUE_DATA) | *SrcVar;
#endif INTERPRETER
      break;
    
  case MAP_G_OR_S: {
#ifndef INTERPRETER
    .OR iGlueData, iSrcVar, iDestVar;
#else INTERPRETER
    *DestVar = GLUE_DATA | *SrcVar;
#endif INTERPRETER
    break;
    
  case MAP_CONST_1: {
#ifndef INTERPRETER
    .XNOR %G0, %G0, iDestVar;
#else INTERPRETER
    *DestVar = 0xFFFFFFFF;
#endif INTERPRETER
    break;
  LP("MapFunction");
#ifndef INTERPRETER
void BuildDest(short nDest, short iDestVar, BYTE Src, BYTE Map)
  short iSrcVar;
#else INTERPRETER
void BuildDest(short nDest, LONG32 *DestVar, BYTE Src, BYTE Map)
  LONG32 *SrcVar;
#endif INTERPRETER
  EP("BuildDest");
#ifndef INTERPRETER
  if ((Map != MAP_G) && (Map != MAP_G_BAR)) {
    iSrcVar = (Src == SRC_SITE_DATA ? iUnGlueData :
	       Src == SRC_TBUS ? iTbusData :
	       Src == SRC_LUT ? iLutData : iTemp1);
    if ((nDest == DEST_LUT) && (Src == SRC_SITE_ADDRESS)) {
      iSrcVar = PermuteScanIndex();
    }
  MapFunction(iSrcVar, iDestVar, Map);
#else INTERPRETER
  if ((Map != MAP_G) && (Map != MAP_G_BAR)) {
    SrcVar = (Src == SRC_SITE_DATA ? &UNGLUE_DATA :
	      Src == SRC_TBUS ? &TBUS_DATA :
	      Src == SRC_LUT ? &LUT_DATA : &TEMP1);
    if ((nDest == DEST_LUT) && (Src == SRC_SITE_ADDRESS)) {
      SrcVar = PermuteScanIndex();
    }
  MapFunction(SrcVar, DestVar, Map);
#endif INTERPRETER
  LP("BuildDest");
#ifndef INTERPRETER
void BuildBitDest(short nDest, short iHoldReg, BYTE Src, BYTE Map,
		  unsigned short nPlane)
{                                                               
     
#else INTERPRETER
void BuildBitDest(short nDest, LONG32 *HoldReg, BYTE Src, BYTE Map,
		  unsigned short nPlane)
{                                                               
#endif INTERPRETER
  EP("BuildBitDest");
#ifndef INTERPRETER
  if ((nDest == DEST_LUT) && (Src == SRC_SITE_ADDRESS)) {
    .OR           %G0, %G0, iTemp6;
    
    if (SABSR[nPlane] < 24) {
      .SH_LEFT iScanIndexReg, #(31 - SABSR[nPlane]), iTemp5;
      .ADDcc iTemp5, iTemp5, iTemp5;
      .ADDXcc iTemp6, iTemp6, iTemp6;
      .SH_LEFT iTemp6, #nPlane, iTemp6;
    }
    else if (SABSR[nPlane] == 31) {
      .SH_LEFT iTemp6, #1, iTemp6;
      .ADD iTemp6, #1, iTemp6;
    }
    else if (SABSR[nPlane] == 30) {
      .SH_LEFT iTemp6, #1, iTemp6;
    }
    else {
      WARNING("Invalid SABSR value", "BuildBitDest");
      .SH_LEFT iTemp6, #1, iTemp6;
    }      
    MapFunction (iTemp6, iHoldReg, Map);
  else
    BuildDest(nDest, iHoldReg, Src, Map);
#else INTERPRETER
  if ((nDest == DEST_LUT) && (Src == SRC_SITE_ADDRESS)) {
    TEMP6 = 0;
    if (SABSR[nPlane] < 24) {
      TEMP5 = SCAN_INDEX_REG << (31 - SABSR[nPlane]);
      bit = HIGHB(TEMP6);
      TEMP6 = ((TEMP6 << 1) | HIGHB(TEMP5)) << nPlane;
      TEMP5 <<= 1;
    }
    else if (SABSR[nPlane] == 31)
      TEMP6 = (TEMP6 << 1) + 1;
    else if (SABSR[nPlane] == 30)
      TEMP6 <<= 1;
    else {
      WARNING("Invalid SABSR value", "BuildBitDest");
      TEMP6 <<= 1;
    }
    MapFunction (&TEMP6, HoldReg, Map);
  else
    BuildDest(nDest, HoldReg, Src, Map);
#endif INTERPRETER
  LP("BuildBitDest");
#ifndef INTERPRETER
void BuildBitwiseDest(short nDest, short iDestVar, BYTE Src[], BYTE Map[])
  short i;
  short iHoldReg = iTemp4;
#else INTERPRETER
void BuildBitwiseDest(short nDest, LONG32 *DestVar, BYTE Src[], BYTE Map[])
  short i;
  LONG32 *HoldReg = &TEMP4;
#endif INTERPRETER
  EP("BuildBitwiseDest");
#ifndef INTERPRETER
  for (i = nNumPlanes - 1; i >= 0; i--) {
    BuildBitDest(nDest, iHoldReg, Src[i], Map[i], i);
    .SH_LEFT iHoldReg, #(31 - i), iHoldReg;
    .ADDcc iHoldReg, iHoldReg, iHoldReg;
    .ADDXcc iDestVar, iDestVar, iDestVar;
#else INTERPRETER
  for (i = nNumPlanes - 1; i >= 0; i--) {
    BuildBitDest(nDest, HoldReg, Src[i], Map[i], i);
    *HoldReg <<= (31 - i);
    bit = HIGHB(*DestVar);
    *DestVar = (*DestVar << 1) | HIGHB(*HoldReg);
    *HoldReg <<= 1;
#endif INTERPRETER
  LP("BuildBitwiseDest");
/*****************************************************************************/
/*                                                                           */
/* This routine adds two longs breaking the carries at positions indicated   */
/* by the Dimension Cut Mask Register (DCMR). The DCMR has a 1 bit at every  */
/* bit position where the carry needs to be cut.                             */
/*                                                                           */
/*****************************************************************************/
LONG32 AddSiteAddress(LONG32 lSrc1, LONG32 lSrc2)
  LONG32 lHighBits1, lHighBits2;
  lHighBits1 = lSrc1 & DCM[0];
  lHighBits2 = lSrc2 & DCM[0];
  lSrc1 &= (~DCM[0]);
  lSrc2 &= (~DCM[0]);
  return( (lSrc1 + lSrc2) ^ lHighBits1 ^ lHighBits2 );
LONG32 SubSiteAddress(LONG32 lSrc1, LONG32 lSrc2)
  LONG32 lSignBitOffset, lSignBitKick, lLowBitsKick;
  lSignBitOffset = lSrc1 & DCM[0];
  lSignBitKick = (~lSrc2) & DCM[0];
  lSrc1 |= DCM[0];
  lLowBitsKick = lSrc2 & (~ DCM[0]);
  lSrc1 -= lLowBitsKick;
  lSignBitOffset = lSignBitOffset ^ lSignBitKick;
  lSrc1 ^= lSignBitOffset;
/*****************************************************************************/
/*                                                          

---------------------------------------------------------------------------

#ifndef _CAM8SIMJIT_H_
#define _CAM8SIMJIT_H_
#include <stdio.h>
#include <CamLib++.H>
#include "std++.H"
/*****************************************************************************/
/********************************* DEFINES ***********************************/
/*****************************************************************************/
/*****************************************************************************/
/*                                                                           */
/* operand types to use when calling Emit()				     */
/*                                                                           */
/*****************************************************************************/
#define NULL_OP		0
#define REG_OP		1
#define CONST_OP	2
#define ADDR_OP		3
#define VAR_OP		4
#define LABEL_OP	5
/*****************************************************************************/
/*                                                                           */
/* op codes for emit							     */
/*                                                                           */
/*****************************************************************************/
#define PSEUDO_OP	0x8000
#define NATIVE_OP	0x4000
#define LD_ST_OP	0x2000
#define BRANCH_OP	0x1000
#define NATIVE_OP_MASK	0x3F
#define INSTR		(PSEUDO_OP | 0xFF)
#define ENTER_PROC	(PSEUDO_OP | 0x01)
#define RETURN_PROC	(PSEUDO_OP | 0x02)
#define CALL_PROC	(PSEUDO_OP | 0x03)
#define ENTER_LEAF	(PSEUDO_OP | 0x04)
#define RETURN_LEAF	(PSEUDO_OP | 0x05)
#define CALL_LEAF	(PSEUDO_OP | 0x06)
#define CALL_LEAF_IND	(PSEUDO_OP | 0x07)
#define ENTER_BASICBLK	(PSEUDO_OP | 0x08)
#define RETURN_BASICBLK	(PSEUDO_OP | 0x09)
#define ADD_LABEL	(PSEUDO_OP | 0x0A)
#define NO_OP		(PSEUDO_OP | 0x0B)
#define LDW_MEM		(LD_ST_OP | 0x00)
#define LDW_IND		(LD_ST_OP | 0x01)
#define LDHW_IND	(LD_ST_OP | 0x02)
#define LDUB_IND	(LD_ST_OP | 0x03)
#define STW_MEM		(LD_ST_OP | 0x06)
#define STW_IND		(LD_ST_OP | 0x07)
#define STHW_IND	(LD_ST_OP | 0x08)
#define STUB_IND	(LD_ST_OP | 0x09)
#define ADD		(NATIVE_OP | 0x00)
#define ADDcc		(NATIVE_OP | 0x10)
#define ADDX		(NATIVE_OP | 0x08)
#define ADDXcc		(NATIVE_OP | 0x18)
#define	SUB		(NATIVE_OP | 0x04)
#define SUBcc		(NATIVE_OP | 0x14)
#define SUBX		(NATIVE_OP | 0x0C)
#define SUBXcc		(NATIVE_OP | 0x1C)
#define AND		(NATIVE_OP | 0x01)
#define ANDcc		(NATIVE_OP | 0x11)
#define ANDN		(NATIVE_OP | 0x05)
#define ANDNcc		(NATIVE_OP | 0x15)
#define OR		(NATIVE_OP | 0x02)
#define ORcc 		(NATIVE_OP | 0x12)
#define ORN		(NATIVE_OP | 0x06)
#define ORNcc		(NATIVE_OP | 0x16)
#define XOR		(NATIVE_OP | 0x03)
#define XORcc 		(NATIVE_OP | 0x13)
#define XNOR		(NATIVE_OP | 0x07)
#define XNORcc		(NATIVE_OP | 0x17)
#define SH_LEFT		(NATIVE_OP | 0x25)
#define SH_RIGHT	(NATIVE_OP | 0x26)
#define SH_RIGHT_ARITH	(NATIVE_OP | 0x27)
#define BRANCH		(BRANCH_OP | 0x08)
#define BR_NEVER	(BRANCH_OP | 0x00)
#define BR_NEQ		(BRANCH_OP | 0x09)
#define BR_EQ		(BRANCH_OP | 0x01)
#define BR_GR		(BRANCH_OP | 0x0A)
#define BR_LE		(BRANCH_OP | 0x02)
#define BR_GRE		(BRANCH_OP | 0x0B)
#define BR_L		(BRANCH_OP | 0x03)
#define BR_GU		(BRANCH_OP | 0x0C)
#define BR_LEU		(BRANCH_OP | 0x04)
#define BR_CC		(BRANCH_OP | 0x0D)
#define BR_CS		(BRANCH_OP | 0x05)
#define BR_POS		(BRANCH_OP | 0x0E)
#define BR_NEG		(BRANCH_OP | 0x06)
#define BR_VC		(BRANCH_OP | 0x0F)
#define BR_VS		(BRANCH_OP | 0x07)
#define BR_NZ		(BRANCH_OP | 0x09)
#define BR_Z		(BRANCH_OP | 0x01)
#ifdef __cplusplus
/*****************************************************************************/
/******************************** TEMPLATES **********************************/
/*****************************************************************************/
/*****************************************************************************/
/*************************** CLASSES & TYPEDEFS ******************************/
/*****************************************************************************/
typedef unsigned long   CODE;
typedef unsigned short	CODELABEL;
typedef CODE            *CODEPTR;
typedef CODEPTR         *CODEHANDLE;
struct tag_codeblk {
     CODEHANDLE hcodTarget;
     CODEPTR    pcodNext;
     CODELABEL	lblNext;
     LABELREC   *plblrecFirst;
     struct tag_codeblk *pblkPrev;
typedef tag_codeblk CODEBLK;
/* record of a reference to a label */
struct tag_lblref {
     CODEPTR	pcodRefLoc;
     struct tag_lblref *prefNext;
typedef tag_lblref LABELREF;
/* record of a label */
struct tag_lblrec {
     INT16	lblName;
     BYTE	bValid;
     CODEPTR	lAddress;
     struct tag_lblref *prefFirst;
     struct tag_lblrec *precNext;
typedef tag_lblrec LABELREC;
struct JIT_SymbolDetails {
  int priority;
  unsigned long offset;
  int regloc;
  unsigned char *heapaddr;
  char name[64];
class JIT_SymbolTable {
public:
  JIT_SymbolTable(unsigned char *heapbase);
  virtual ~JIT_SymbolTable(void);
  unsigned long AddSymbol(unsigned long, int, int, char[]);
  unsigned long SymbolOffset(int index);
  unsigned char *SymbolAddr(int index);
  int SymbolPriority(int index);
  int SymbolRegLoc(int index);
protected:
  unsigned char *base;
  unsigned long len;
  unsigned long cnt;
  JIT_SymbolDetails *tab;
class Cam8SimJIT {
public:
  LABELREC *plblrecFirst;
  CODEHANDLE hcodTarget;	/* Handle to Target Code Location */
  CODEPTR pcodNext;		/* Pointer to location of next inst */
  CODELABEL lblNext;		/* Next Label */
  CODEBLK *pblkTOS;
  JIT_SymbolTable symtab;
  CAM8SIMREGMGR *regmgr;
  /* Add a reference to a label */
  virtual void AddLabelRef(LABELREC *, CODEPTR);
  /* Resolve all references to a labl */
  virtual void ResolveRefs(LABELREC *, CODEPTR);
  /* Free all storage used by labels  */
  virtual void FreeLabels(void);
  /* Add a new label record */
  virtual LABELREC *AddLabel(CODELABEL, CODEPTR, BOOL);
  /* Find a label */
  /* Returns label's address */
  virtual CODEPTR GetLabelAddress(LABELREC *);
  virtual void NewBlock(CODEHANDLE);
  virtual void EndBlock(void);
  virtual LABELREC *FindLabel(CODELABEL);
  virtual CODELABEL NewLabel(void);
  virtual void Emit(INT16, BYTE, LONG32, BYTE, LONG32, BYTE, LONG32) = 0;
  virtual void PrintAsm(CODEPTR, FILE *) = 0;
  void pushblk(void);
  void popblk(void);
/*****************************************************************************/
/********************************* INLINES ***********************************/
/*****************************************************************************/
#endif
/*****************************************************************************/
/******************************* PROTOTYPES **********************************/
/*****************************************************************************/
/*****************************************************************************/
/********************************* GLOBALS ***********************************/
/*****************************************************************************/
#endif

---------------------------------------------------------------------------

#include <CaLibStream++.H>
#include <CaLibError++.H>
#include <CaLibTrace++.H>
#include <CamLib++.H>
#include <Cam8SimJIT++.H>
#include "std++.H"
JIT_SymbolTable::JIT_SymbolTable(unsigned char *heapbase)
  CaLib_tb.ENTER("JIT_SymbolTable::JIT_SymbolTable");
  base = heapbase;
  cnt = 0;
  len = 64;
  tab = Calloc(len, sizeof(JIT_SymbolDetails));
  CaLib_tb.LEAVE();
JIT_SymbolTable::~JIT_SymbolTable(void)
unsigned long AddSymbol(unsigned long size, int priority, int regloc, char name[])
  unsigned long index;
  CaLib_tb.ENTER("JIT_SymbolTable::AddSymbol");
  if (len == cnt) {
    len *= 2;
    tab = Realloc(tab, len * sizeof(JIT_SymbolDetails));
  tab[cnt].priority = priority;
  tab[cnt].offset = (cnt == 0L ? 0L : tab[cnt - 1].offset + size);
  tab[cnt].regloc = regloc;
  tab[cnt].heapaddr = base + tab[cnt].offset;
  strncpy(tab[cnt].name, name, 64);
  index = cnt;
  cnt++;
  CaLib_tb.LEAVE();
  return(index);
unsigned long SymbolOffset(int index)
  CaLib_tb.ENTER("JIT_SymbolTable::SymbolOffset");
  CaLib_tb.LEAVE();
unsigned char *SymbolAddr(int index)
  CaLib_tb.ENTER("JIT_SymbolTable::SymbolAddr");
  CaLib_tb.LEAVE();
int SymbolPriority(int index)
  CaLib_tb.ENTER("JIT_SymbolTable::SymbolPriority");
  CaLib_tb.LEAVE();
int SymbolRegLoc(int index)
  CaLib_tb.ENTER("JIT_SymbolTable::SymbolRegLoc");
  CaLib_tb.LEAVE();
void NewBlock(CODEHANDLE hcodDest)
     void pushblk(void);
     
     /* save code block state */
     pushblk();
     /* point to new code block */
     hcodTarget = hcodDest;
     pcodNext = *hcodDest;
     lblNext = 0;
void EndBlock()
     void popblk(void);
     /* Free up all label records */
     FreeLabels();
     *pcodNext = 0L;
     /* Update caller's code handle */
     *hcodTarget = pcodNext;
     /* Restore previous block state */
     popblk(); 
CODELABEL NewLabel()
     return (lblNext++);
LABELREC *AddLabel(CODELABEL lblName, CODEPTR pcodLabelLoc, BOOL bValid)
     LABELREC	*plblrecNew;
     plblrecNew = (LABELREC *) MALLOC(sizeof(LABELREC), "AddLabel");
     plblrecNew->lblName = lblName;
     if ((plblrecNew->bValid = bValid) == TRUE) {
	  plblrecNew->lAddress = pcodLabelLoc;
     }
     plblrecNew->precNext = plblrecFirst;
     plblrecNew->prefFirst = NULL;
     plblrecFirst = plblrecNew;
     return (plblrecNew);
LABELREC *FindLabel(CODELABEL lblName)
     LABELREC *plblrecNext;
     for (plblrecNext = plblrecFirst;
	  (plblrecNext != NULL) && (plblrecNext->lblName != lblName);
	  plblrecNext = plblrecNext->precNext);
     return (plblrecNext);
CODEPTR GetLabelAddress(LABELREC *plblrec)
  if (plblrec->bValid)
    return (plblrec->lAddress);
  else
    return (NULL);
void AddLabelRef(LABELREC *plblrec, CODEPTR lAddress)
     LABELREF *prefNew;
     prefNew = (LABELREF *) MALLOC(sizeof(LABELREF), "AddLabelRef");
     prefNew->pcodRefLoc = lAddress;
     prefNew->prefNext = plblrec->prefFirst;
     plblrec->prefFirst = prefNew;
void FreeLabels()
     LABELREC *plblrec;
     while (plblrecFirst != NULL) {
	  plblrec = plblrecFirst;
	  plblrecFirst = plblrec->precNext;
	  FREE(plblrec, "FreeLabels");
     }
/*****************************************************************************/
/*                                                                           */
/* Simple stack manager for pushing and pop-ing code block states.	     */
/*                                                                           */
/*****************************************************************************/
void pushblk(void)
     CODEBLK *pNew;
     pNew = MALLOC(sizeof(CODEBLK), "icode : pushblk");
     pNew->hcodTarget = hcodTarget;
     pNew->pcodNext = pcodNext;
     pNew->lblNext = lblNext;
     pNew->plblrecFirst = plblrecFirst;
     
     pNew->pblkPrev = pblkTOS;
     pblkTOS = pNew;
     plblrecFirst = NULL;
void popblk(void)
     CODEBLK *pblkOld;
     if (!pblkTOS) {
	  CRITICAL_ERROR("I-Code Block stack underflow", "popblk");
     }
     hcodTarget = pblkTOS->hcodTarget;
     pcodNext = pblkTOS->pcodNext;
     lblNext = pblkTOS->lblNext;
     plblrecFirst = pblkTOS->plblrecFirst;
     pblkOld = pblkTOS;
     pblkTOS = pblkTOS->pblkPrev;
     FREE(pblkOld, "popblk");
                 */
/* Compute the Scan length - the number of sites that will be updated in     */
/* the current scan. Basically, it should be 2^ESCP, but we need to correct  */
/* for the fact that the SIR low-order bits might not be all zero            */
/*                                                                           */
/*****************************************************************************/
LONG32 ScanLength()
  LONG32 lCarryOVFBit, lScanLength, lSIRBits;
  lCarryOVFBit = ESC[0];
  lScanLength = (1 << lCarryOVFBit);                                  
  lSIRBits = SIR[0] & (lScanLength - 1);
  lScanLength -= lSIRBits;
  return (lScanLength);
/*****************************************************************************/
/*                                                                           */
/* Determine the sweep length. The sweep length is given by either the low   */
/* bit of the DCMR or the ESCP (End-of-Scan-pointer) or the SFR register.    */
/* This is because the scan could update many lines of the lowest (X) dimen- */
/* sion, or could update just part of 1 line in the X dimension.             */
/*                                                                           */
/*****************************************************************************/
LONG32 SweepLength(LONG32 *lFirstSweep)
  LONG32 lCarryOVFBit, lSweepLength;
  lCarryOVFBit = MIN(ESW[0], lNumXBits);
  lSweepLength = (1 << lCarryOVFBit);
  *lFirstSweep = (SIR[0] & (lSweepLength - 1));
  *lFirstSweep = lSweepLength - *lFirstSweep;
  return (lSweepLength);
/*****************************************************************************/
/*                                                                           */
/* DCMRHighBit returns a long with exactly one of the 32 bits set to 1. This */
/* bit position corresponds to the highest bit in the DCMR that has a 1.     */
/*                                                                           */
/*****************************************************************************/
LONG32 DCMRHighBit()
  LONG32 lTemp1, lTemp2;                                                      
  lTemp1 = DCM[0];
  lTemp2 = 1;
  while (lTemp1 > 1) {
    lTemp1 >>= 1;
    lTemp2 <<= 1;
  return (lTemp2);
/*****************************************************************************/
/*                                                                           */
/* DCMRLowBit returns a long with exactly one of the 32 bits set to 1. This  */
/* bit position corresponds to the lowest bit in the DCMR that has a 1. We   */
/* refer to this lowest dimension generically as the X dimension.            */
/*                                                                           */
/*****************************************************************************/
LONG32 DCMRLowBit()
  LONG32 lTemp1, lTemp2;
  lTemp1 = DCM[0];
  lTemp2 = 1;
  lNumXBits = 1;
  while ((lTemp1 != 0) && ((lTemp1 & 0x01) == 0)) {
    lTemp1 >>= 1;
    lTemp2 <<= 1;
    lNumXBits++;
  return (lTemp2);
void UpdateDCMR()
  lDCMRHighBit = DCMRHighBit();
  lDCMRLowBit = DCMRLowBit();
/*****************************************************************************/
/*                                                                           */
/* The following are general purpose routines that conveniently answer       */
/* queries about the sources and destinations that need to be updated        */
/*                                                                           */
/*****************************************************************************/
/*****************************************************************************/
/*                                                                           */
/* Is a particular source needed? Only checks those planes that will be      */
/* updated or used during the next scan.                                     */
/*                                                                           */
/*****************************************************************************/
BOOL IsSrcNeeded(short nSrc)
  short i, j;
  short nLastDest;
  nLastDest = (nSrc == SRC_TBUS ? DEST_LUT : DEST_DISPLAY);
  for (i = nNumPlanes - 1; i >= 0; i--) {
    for (j = DEST_SITE_DATA; j <= nLastDest; j++) {
      if (bDestSrcMatrix[i][j][nSrc]) {
	return TRUE;
      }
    }
  return FALSE;
/*****************************************************************************/
/*                                                                           */
/* Checks to see if the source/map is the same for all planes for the given  */
/* destination.                                                              */
/*                                                                           */
/*****************************************************************************/
BOOL IsSrcSame(short nDest)
  short i;
  BYTE *src, *map;
  switch (nDest) {
  case DEST_SITE_DATA:
    src = SDS;
    map = SDM;
    break;
  case DEST_EVENT_CT:
    src = ECS;
    map = ECM;
    break;
  case DEST_DISPLAY:
    src = DDS;
    map = DDM;
    break;
  case DEST_LUT:
    src = LAS;
    map = LAM;
    break;
  default:
    return FALSE;
    break;
  for(i = 1; i < nNumPlanes; i++)
    if ((src[0] != src[i]) || (map[0] != map[i]))
      return FALSE;
  return TRUE;
/*****************************************************************************/
/*                                                                           */
/* See if a particular destination will be changed during the current scan   */
/*                                                                           */
/*****************************************************************************/
BOOL IsDestUpdated(short nDest)
  short i, j;
  for (i = nNumPlanes-1; i >= 0; i--)
    for ( j = SRC_SITE_DATA; j <= SRC_CONST_DATA; j++)
      if (bDestSrcMatrix[i][nDest][j])
	return(TRUE);
  return(FALSE);
/*****************************************************************************/
/*                                                                           */
/* Calculate the number of planes that will be updated or used in the next   */
/* scan.                                                                     */
/*                                                                           */
/*****************************************************************************/
unsigned short CalcNumPlanes()
  BOOL       bPlaneUsed[CHIPS_PER_MOD];
  short      i, j;
  memset ((char *) bPlaneUsed, 0, CHIPS_PER_MOD * sizeof(BOOL));
  UpdateDestSrcMatrix();
  for (i = CHIPS_PER_MOD-1; i >= 0; i--) {
    for (j = DEST_SITE_DATA; j <= DEST_DISPLAY; j++) {
      if ( bDestSrcMatrix[i][j][SRC_SITE_DATA] || 
	  bDestSrcMatrix[i][j][SRC_GLUED_DATA] ) {
	bPlaneUsed[i] = TRUE;
      }
    }
    
    if (!bPlaneUsed[i]) {
      for (j = SRC_TBUS; j <= SRC_CONST_DATA; j++) {
	if (bDestSrcMatrix[i][DEST_SITE_DATA][j]) {
	  bPlaneUsed[i] = TRUE;
      }
    }
    if (bPlaneUsed[i])
      break;
  }  
  return ((unsigned short) i + 1);
/*****************************************************************************/
/*                                                                           */
/* Updates a matrix of sources and destinations. There are 5 sources, 4 dest */
/* and 16 planes. In addition, there is a bit per destination indicating     */
/* whether the map field selects an inverse function or just the function.   */
/* Thus, the SrcDestMatrix is a 6x4x16 matrix.                               */
/*                                                                           */
/*****************************************************************************/
void UpdateDestSrcMatrix()
  short      i;
  char       *szFuncName = "UpdateDestSrcMatrix";    
  memset((char *) bDestSrcMatrix, 0, CHIPS_PER_MOD*NUM_SRC*NUM_DEST);
  for (i = 0; i < CHIPS_PER_MOD; i++) {
    
    /*
     * If the source for the site is the site then don't bother to generate
     * code for this.  If the map selects only the glue lines then the source
     * selection is irrelevant.  If the map selects MAP_G then this is
     * effectively the same as selecting site as the source.  If the map
     * selects CONST_0 or CONST_1 then we handle this as a special case.
     */
    if (SDS[i] != SRC_SITE_DATA)
      bDestSrcMatrix[i][DEST_SITE_DATA][SDS[i]] = TRUE;
    if ((SDM[i] != MAP_S) && (SDM[i] != MAP_S_BAR)) {
      if (SDM[i] != MAP_G)
	bDestSrcMatrix[i][DEST_SITE_DATA][SRC_GLUED_DATA] = TRUE;
      if ((SDM[i] == MAP_CONST_0) || (SDM[i] == MAP_CONST_1)) {
	bDestSrcMatrix[i][DEST_SITE_DATA][SRC_CONST_DATA] = TRUE;
	bDestSrcMatrix[i][DEST_SITE_DATA][SRC_GLUED_DATA] = FALSE;
	bDestSrcMatrix[i][DEST_SITE_DATA][SDS[i]] = FALSE;
      }
      if ((SDM[i] == MAP_G) || (SDM[i] == MAP_G_BAR))
	bDestSrcMatrix[i][DEST_SITE_DATA][SDS[i]] = FALSE;
    }
    /*
     * If the source for the event counter is constant zero then don't bother
     * to generate code for this.  If the map selects only the glue lines then
     * the source selection is irrelevant.
     */
    bDestSrcMatrix[i][DEST_EVENT_CT][ECS[i]] = TRUE;
    if ((ECM[i] != MAP_S) && (ECM[i] != MAP_S_BAR)) {
      bDestSrcMatrix[i][DEST_EVENT_CT][SRC_GLUED_DATA] = TRUE;
      if ((ECM[i] == MAP_CONST_0) || (ECM[i] == MAP_CONST_1)) {
	if (ECM[i] == MAP_CONST_1)
	  bDestSrcMatrix[i][DEST_EVENT_CT][SRC_CONST_DATA] = TRUE;
	bDestSrcMatrix[i][DEST_EVENT_CT][SRC_GLUED_DATA] = FALSE;
	bDestSrcMatrix[i][DEST_EVENT_CT][ECS[i]] = FALSE;
      }
      if ((ECM[i] == MAP_G) || (ECM[i] == MAP_G_BAR))
 	bDestSrcMatrix[i][DEST_EVENT_CT][ECS[i]] = FALSE;
    }
    /*
     * If the source for the display is the host (tbus) then don't bother to
     * generate code for this.  If the map selects only the glue lines then
     * the source selection is irrelevant.
     */
    if ((DDS[i] != SRC_TBUS))
      bDestSrcMatrix[i][DEST_DISPLAY][DDS[i]] = TRUE;
    if ((DDM[i] != MAP_S) && (DDM[i] != MAP_S_BAR)) {
      bDestSrcMatrix[i][DEST_DISPLAY][SRC_GLUED_DATA] = TRUE;
      if ((DDM[i] == MAP_CONST_0) || (DDM[i] == MAP_CONST_1)) {
	bDestSrcMatrix[i][DEST_DISPLAY][SRC_CONST_DATA] = TRUE;
	bDestSrcMatrix[i][DEST_DISPLAY][SRC_GLUED_DATA] = FALSE;
	bDestSrcMatrix[i][DEST_DISPLAY][DDS[i]] = FALSE;
      }
      if ((DDM[i] == MAP_G) || (DDM[i] == MAP_G_BAR)) {
	bDestSrcMatrix[i][DEST_DISPLAY][DDS[i]] = FALSE;
      }
    }
    /*
     * If the map selects only the glue lines then the source selection is
     * irrelevant.
     */
    bDestSrcMatrix[i][DEST_LUT][LAS[i]] = TRUE;
    if ((LAM[i] != MAP_S) && (LAM[i] != MAP_S_BAR)) {
      bDestSrcMatrix[i][DEST_LUT][SRC_GLUED_DATA] = TRUE;
      if ((LAM[i] == MAP_CONST_0) || (LAM[i] == MAP_CONST_1)) {
	bDestSrcMatrix[i][DEST_LUT][SRC_CONST_DATA] = TRUE;
	bDestSrcMatrix[i][DEST_LUT][SRC_GLUED_DATA] = FALSE;
	bDestSrcMatrix[i][DEST_LUT][LAS[i]] = FALSE;
      }
      if ((LAM[i] == MAP_G) || (LAM[i] == MAP_G_BAR)) {
	bDestSrcMatrix[i][DEST_LUT][LAS[i]] = FALSE;
      }
    }


---------------------------------------------------------------------------

#include <CaLibStream++.H>
#include <CaLibError++.H>
#include <CaLibTrace++.H>
#include <CamLib++.H>
#include <Cam8Core++.H>
#include <Cam8SimCore++.H>
#include "std++.H"
Cam8SimCore::Cam8SimCore(void)
Cam8SimCore::~Cam8SimCore(void)
STD_BZERO(Cam8SimCore)
STD_BCOPY(Cam8SimCore)
STD_BCMP(Cam8SimCore)
void Cam8SimCore::ResetInterface(void)
  CaLib_tb.ENTER("Cam8SimCore::ResetInterface");
  /* Zero everything out to start off */
  bzero((char *) &iregs, sizeof(iregs));
  /* Enable all interrupts and exceptions */
  iregs.RER = CAM_ENABLE_NEWLIST_INT | CAM_ENABLE_TIMEOUT_INT |
              CAM_ENABLE_SBUS_INT | CAM_ENABLE_CAM_INT |
	      CAM_ENABLE_SOFT_INT | CAM_ENABLE_TIMEOUT_EXC |
	      CAM_ENABLE_CAMINT_EXC;
  /* Mark all interrupts as enabled */
  iregs.ISR = CAM_ENABLE_NEWLIST_INT | CAM_ENABLE_TIMEOUT_INT |
              CAM_ENABLE_SBUS_INT | CAM_ENABLE_CAM_INT |
	      CAM_ENABLE_SOFT_INT;
  /* Put us in wait-for-host mode */
  iregs.NLP |= CAM_WAIT_FOR_HOST;
  CaLib_tb.LEAVE();
void Cam8SimCore::InitInterface(void)
  CaLib_tb.ENTER("Cam8SimCore::InitInterface");
  ResetInterface();
  CaLib_tb.LEAVE();
void Cam8SimCore::ExecuteSteplist(struct steplist_operation & slo)
  CaLib_tb.ENTER("Cam8SimCore::ExecuteSteplist");
  SimStepList((long32 *) slo.buf);
  CaLib_tb.LEAVE();
void Cam8SimCore::Generate_Interrupt(int type)
  CaLib_tb.ENTER("Cam8SimCore::Generate_Interrupt");
  iregs.ISR |= type;
  switch(type) {
  case CAM_CAM_INT_STATUS: {
    if ((iregs.RER & CAM_ENABLE_CAMINT_EXC) &&
	!(iregs.RER & CAM_DISABLE_CAMINT_EXC)) {
      iregs.NLP |= CAM_EXCEPTION_STATUS;
    }
    break;
  case CAM_TIMEOUT_INT_STATUS: {
    if ((iregs.RER & CAM_ENABLE_TIMEOUT_EXC) &&
	!(iregs.RER & CAM_DISABLE_TIMEOUT_EXC)) {
      iregs.NLP |= CAM_EXCEPTION_STATUS;
    }
    break;
  CaLib_tb.LEAVE();
void Cam8SimCore::Read_NLP(long32 *v)
  CaLib_tb.ENTER("Cam8SimCore::Read_NLP");
  CaLibAbort(!v, "NULL Pointer");
  *v = iregs.NLP;
  CaLib_tb.LEAVE();
void Cam8SimCore::Read_ISR(long32 *v)
  CaLib_tb.ENTER("Cam8SimCore::Read_ISR");
  CaLibAbort(!v, "NULL Pointer");
  *v = iregs.ISR;
  /* Turn off interrupt flags and unused bits, leave enables the same */
  iregs.ISR &= 0x00001F00;
  CaLib_tb.LEAVE();
void Cam8SimCore::Read_CIP(long32 *v)
  CaLib_tb.ENTER("Cam8SimCore::Read_CIP");
  CaLibAbort(!v, "NULL Pointer");
  *v = iregs.CIP;
  CaLib_tb.LEAVE();
void Cam8SimCore::Read_PIP(long32 *v)
  CaLib_tb.ENTER("Cam8SimCore::Read_PIP");
  CaLibAbort(!v, "NULL Pointer");
  *v = iregs.PIP;
  CaLib_tb.LEAVE();
void Cam8SimCore::Write_NLP(const long32 *v)
  long32 tmp = iregs.NLP & 0xF;
  CaLib_tb.ENTER("Cam8SimCore::Write_NLP");
  CaLibAbort(!v, "NULL Pointer");
  if (!(iregs.NLP & CAM_EXCEPTION_STATUS))
    iregs.NLP = tmp | (*v) & 0xFFFFFFF0);
  CaLib_tb.LEAVE();
void Cam8SimCore::Write_RER(const long32 *v)
  CaLib_tb.ENTER("Cam8SimCore::Write_RER");
  CaLibAbort(!v, "NULL Pointer");
  iregs.RER = *v;
  if (iregs.RER & CAM_RESET_INTERFACE) {
    ResetInterface();
  if (iregs.RER & CAM_HALT_INTERFACE)
    iregs.NLP |= CAM_INTERFACE_HALTED;
  if (iregs.RER & CAM_ENABLE_TIMEOUT_EXC)
    iregs.NLP &= ~(CAM_EXCEPTION_STATUS);
  /*  This is supposed to also resume after error ack, whatever that is
  if (iregs.RER & CAM_ENABLE_CAMINT_EXC)
  */
  if (iregs.RER & CAM_ENABLE_NEWLIST_INT)
    iregs.ISR |= CAM_ENABLE_NEWLIST_INT;
  if (iregs.RER & CAM_ENABLE_TIMEOUT_INT)
    iregs.ISR |= CAM_ENABLE_TIMEOUT_INT;
  if (iregs.RER & CAM_ENABLE_SBUS_INT)
    iregs.ISR |= CAM_ENABLE_SBUS_INT;
  if (iregs.RER & CAM_ENABLE_CAM_INT)
    iregs.ISR |= CAM_ENABLE_CAM_INT;
  if (iregs.RER & CAM_ENABLE_SOFT_INT)
    iregs.ISR |= CAM_ENABLE_SOFT_INT;
  if (iregs.RER & CAM_DISABLE_NEWLIST_INT)
    iregs.ISR &= ~(CAM_ENABLE_NEWLIST_INT);
  if (iregs.RER & CAM_DISABLE_TIMEOUT_INT)
    iregs.ISR &= ~(CAM_ENABLE_TIMEOUT_INT);
  if (iregs.RER & CAM_DISABLE_SBUS_INT)
    iregs.ISR &= ~(CAM_ENABLE_SBUS_INT);
  if (iregs.RER & CAM_DISABLE_CAM_INT)
    iregs.ISR &= ~(CAM_ENABLE_CAM_INT);
  if (iregs.RER & CAM_ENABLE_SOFT_INT)
    iregs.ISR |= CAM_ENABLE_SOFT_INT;
  CaLib_tb.LEAVE();
void Cam8SimCore::Write_DSL(const long32 *v)
  CaLib_tb.ENTER("Cam8SimCore::Write_DSL");
  CaLibAbort(!v, "NULL Pointer");
  iregs.DSL = *v;
  CaLib_tb.LEAVE();
void Cam8SimCore::Write_DBL(const long32 *v)
  CaLib_tb.ENTER("Cam8SimCore::Write_DBL");
  CaLibAbort(!v, "NULL Pointer");
  iregs.DBL = *v;
  CaLib_tb.LEAVE();
void Cam8SimCore::InitSimulator(void)
  CaLib_tb.ENTER("Cam8SimCore::InitSimulator");
  CaLibAbort(!co, "NULL core object pointer");
  core = co;
  InitStepList();
  if (debug) {
  /* Need to open a new file, set the CAMSTREAM dbug to it and turn on a flag */
  InitHeap();
  CaLib_tb.LEAVE();
void Cam8SimCore::InitStepList(void)
  CaLib_tb.ENTER("Cam8SimCore::InitStepList()");
  SENTER(RFINDEX(REG_MSR), MSR, BIT8);
  SENTER(RFINDEX(FLD_SSM), SSM, BIT8);
  SENTER(RFINDEX(FLD_RT), RT, BIT8);
  SENTER(RFINDEX(FLD_ECT), ECT, BIT8);
  SENTER(RFINDEX(FLD_RPK), RPK, BIT8);
  SENTER(RFINDEX(FLD_ALT), ALT, BIT8);
  SENTER(RFINDEX(FLD_KA), KA, BIT32);
  SENTER(RFINDEX(FLD_XKS), XKS, BIT8);
  SENTER(RFINDEX(FLD_YKS), YKS, BIT8);
  SENTER(RFINDEX(FLD_ZKS), ZKS, BIT8);
  SENTER(RFINDEX(FLD_XKMF), XKMF, BIT8);
  SENTER(RFINDEX(FLD_YKMF), YKMF, BIT8);
  SENTER(RFINDEX(FLD_ZKMF), ZKMF, BIT8);
  SENTER(RFINDEX(REG_SABSR), SABSR, BIT8);
  SENTER(RFINDEX(FLD_LAS), LAS, BIT8);
  SENTER(RFINDEX(FLD_LAM), LAM, BIT8);
  SENTER(RFINDEX(FLD_FOS), FOS, BIT8);
  SENTER(RFINDEX(FLD_FOM), FOM, BIT8);
  SENTER(RFINDEX(FLD_SDS), SDS, BIT8);
  SENTER(RFINDEX(FLD_SDM), SDM, BIT8);
  SENTER(RFINDEX(FLD_ECS), ECS, BIT8);
  SENTER(RFINDEX(FLD_ECM), ECM, BIT8);
  SENTER(RFINDEX(FLD_DDS), DDS, BIT8);
  SENTER(RFINDEX(FLD_DDM), DDM, BIT8);
  SENTER(RFINDEX(REG_SSR), SSR, BIT8);
  SENTER(RFINDEX(REG_ECR), ECR, BIT32);
  SENTER(RFINDEX(REG_LIR), LIR, BIT8);
  SENTER(RFINDEX(REG_LIPR), LIPR, BIT8);
  SENTER(RFINDEX(REG_SIR), SIR, BIT32);
  SENTER(RFINDEX(FLD_SSA0), SSA0, BIT8);
  SENTER(RFINDEX(FLD_SSA1), SSA1, BIT8);
  SENTER(RFINDEX(FLD_SSA2), SSA2, BIT8);
  SENTER(RFINDEX(FLD_SSA3), SSA3, BIT8);
  SENTER(RFINDEX(FLD_SSA4), SSA4, BIT8);
  SENTER(RFINDEX(FLD_SSA5), SSA5, BIT8);
  SENTER(RFINDEX(FLD_SSA6), SSA6, BIT8);
  SENTER(RFINDEX(FLD_SSA7), SSA7, BIT8);
  SENTER(RFINDEX(FLD_SSA8), SSA8, BIT8);
  SENTER(RFINDEX(FLD_SSA9), SSA9, BIT8);
  SENTER(RFINDEX(FLD_SSA10), SSA10, BIT8);
  SENTER(RFINDEX(FLD_SSA11), SSA11, BIT8);
  SENTER(RFINDEX(FLD_SSA12), SSA12, BIT8);
  SENTER(RFINDEX(FLD_SSA13), SSA13, BIT8);
  SENTER(RFINDEX(FLD_SSA14), SSA14, BIT8);
  SENTER(RFINDEX(FLD_SSA15), SSA15, BIT8);
  SENTER(RFINDEX(FLD_SSA16), SSA16, BIT8);
  SENTER(RFINDEX(FLD_SSA17), SSA17, BIT8);
  SENTER(RFINDEX(FLD_SSA18), SSA18, BIT8);
  SENTER(RFINDEX(FLD_SSA19), SSA19, BIT8);
  SENTER(RFINDEX(FLD_SSA20), SSA20, BIT8);
  SENTER(RFINDEX(FLD_SSA21), SSA21, BIT8);
  SENTER(RFINDEX(FLD_SSA22), SSA22, BIT8);
  SENTER(RFINDEX(FLD_SSA23), SSA23, BIT8);
  SENTER(RFINDEX(FLD_SM), SM, BIT8);
  SENTER(RFINDEX(FLD_ESC), ESC, BIT8);
  SENTER(RFINDEX(FLD_ESW), ESW, BIT8);
  SENTER(RFINDEX(FLD_EST), EST, BIT8);
  SENTER(RFINDEX(FLD_SBRC), SBRC, BIT8);
  SENTER(RFINDEX(FLD_RCL), RCL, BIT8);
  SENTER(RFINDEX(FLD_ECL), ECL, BIT8);
  SENTER(RFINDEX(FLD_STM), STM, BIT8);
  SENTER(RFINDEX(REG_OSR), OSR, BIT32);
  SENTER(RFINDEX(FLD_DCM), DCM, BIT32);
  SENTER(RFINDEX(FLD_XDCP), XDCP, BIT8);
  SENTER(RFINDEX(FLD_YDCP), YDCP, BIT8);
  SENTER(RFINDEX(FLD_ZDCP), ZDCP, BIT8);
  SENTER(RFINDEX(FLD_LPL), LPL, BIT8);
  SENTER(RFINDEX(FLD_FPL), FPL, BIT8);
  SENTER(RFINDEX(FLD_DCS), DCS, BIT8);
  SENTER(RFINDEX(FLD_TBD), TBD, BIT8);
  SENTER(RFINDEX(FLD_TMS), TMS, BIT8);
  SENTER(RFINDEX(FLD_NBF), NBF, BIT8);
  SENTER(RFINDEX(FLD_SRE), SRE, BIT8);
  SENTER(RFINDEX(FLD_ALS), ALS, BIT8);
  SENTER(RFINDEX(FLD_MAFS), MAFS, BIT8);
  SENTER(RFINDEX(FLD_MBFS), MBFS, BIT8);
  SENTER(RFINDEX(FLD_XMPC), XMPC, BIT8);
  SENTER(RFINDEX(FLD_XPPC), XPPC, BIT8);
  SENTER(RFINDEX(FLD_YMPC), YMPC, BIT8);
  SENTER(RFINDEX(FLD_YPPC), YPPC, BIT8);
  SENTER(RFINDEX(FLD_ZMPC), ZMPC, BIT8);
  SENTER(RFINDEX(FLD_ZPPC), ZPPC, BIT8);
  SENTER(RFINDEX(REG_MIDR), MIDR, BIT8);
  SENTER(RFINDEX(REG_GIDR), GIDR, BIT8);
  SENTER(RFINDEX(FLD_BPIE), BPIE, BIT8);
  SENTER(RFINDEX(FLD_BCIE), BCIE, BIT8);
  SENTER(RFINDEX(FLD_GCIE), GCIE, BIT8);
  SENTER(RFINDEX(FLD_MAIE), MAIE, BIT8);
  SENTER(RFINDEX(FLD_MBIE), MBIE, BIT8);
  SENTER(RFINDEX(FLD_SSIE), SSIE, BIT8);
  SENTER(RFINDEX(FLD_XHIE), XHIE, BIT8);
  SENTER(RFINDEX(FLD_RLIE), RLIE, BIT8);
  SENTER(RFINDEX(FLD_URIE), URIE, BIT8);
  SENTER(RFINDEX(FLD_ISIE), ISIE, BIT8);
  SENTER(RFINDEX(FLD_BPIF), BPIF, BIT8);
  SENTER(RFINDEX(FLD_BCIF), BCIF, BIT8);
  SENTER(RFINDEX(FLD_GCIF), GCIF, BIT8);
  SENTER(RFINDEX(FLD_MAIF), MAIF, BIT8);
  SENTER(RFINDEX(FLD_MBIF), MBIF, BIT8);
  SENTER(RFINDEX(FLD_SSIF), SSIF, BIT8);
  SENTER(RFINDEX(FLD_XHIF), XHIF, BIT8);
  SENTER(RFINDEX(FLD_RLIF), RLIF, BIT8);
  SENTER(RFINDEX(FLD_URIF), URIF, BIT8);
  SENTER(RFINDEX(FLD_ISIF), ISIF, BIT8);
  SENTER(RFINDEX(FLD_VWE), VWE, BIT8);
  SENTER(RFINDEX(FLD_VWIE), VWIE, BIT8);
  SENTER(RFINDEX(FLD_VWIF), VWIF, BIT8);
  SENTER(RFINDEX(FLD_LDOC), LDOC, BIT8);
  SENTER(RFINDEX(FLD_HDOC), HDOC, BIT8);
  CaLib_tb.LEAVE();
void Cam8SimCore::vwecheck(int16 *base, int reg_fld, int imm)
  register int i;
  int f = 0, o;
  long32 pbuf[CHIPS_PER_MOD];
  Bt bt;
  CaLib_tb.ENTER("Cam8SimCore::vwecheck");
  bt = base_type[reg_fld];
  if (VWECHK) {
    UnpackStateInto(base, reg_fld, imm, (byte *) pbuf, bt.type);
    for (i = 0; i < CHIPS_PER_MOD; i++) {
      o = bt.type * i;
      if (VWE[i]) {
	if (bcmp(bt.base + o, ((byte *) pbuf) + o, bt.type) != 0) {
	  f = 1;
	  VWIF[i] = 1;
      }
      else
	bcopy(((byte *) pbuf) + o, bt.base + o, bt.type);
    }
  else
    UnpackState(base, reg_fld, imm);
  CaLib_tb.LEAVE();
void Cam8SimCore::SimStepList(long32 *plFirstInstr)
  long32 *plCurr = NULL, *plNext = NULL;
  long32 lData = 0, lLength;
  short nRegister, i, imm = FALSE;
  bool bHostJump, bHostWait, bByteMode, bReadMode;
  bool bDone = FALSE;
  long32 pbuf[CHIPS_PER_MOD];
  bHostJump = bHostWait = FALSE;
  CaLib_tb.ENTER("Cam8SimCore::SimStepList");
  for (plCurr = plFirstInstr; !bDone; plCurr = plNext) {
    bHostJump = (*plCurr & HOST_JUMP_MASK) != 0;
    bHostWait = (*plCurr & HOST_WAIT_MASK) != 0;
    bDone = bHostJump || bHostWait;
    bByteMode = (*plCurr & byte_MODE_MASK) != 0;
    bReadMode = (*plCurr & READ_CAM_MASK) != 0;
    
    cam8sim_iregs.PIP = cam8sim_iregs.CIP;
    cam8sim_iregs.CIP = (long32) plNext;
    if (*plCurr & RESET_CAM_MASK) {
      memset ((char *) &Cam8State, 0, sizeof(Cam8State));
      LIOR = LUT1;
      LUT_ADDR = (long32) LUT0;
      bSourceRegChange = bDestChange = TRUE;
      
      if (debug) {
	fprintf(DEBUGFILE, "CAM Reset\n");
	fflush(DEBUGFILE);
      }
    }
    
    
    nRegister = *plCurr & register_ADDR_MASK;
    imm = (*plCurr & IMMEDIATE_DATA_MASK) != 0;
    lData = *(plCurr + 1);
    lLength = *(plCurr + 2);
    
    plNext = (long32 *) (*(plCurr + 3));
    
    if ((*plCurr & READ_CAM_MASK) && (*plCurr & IMMEDIATE_DATA_MASK)) {
      if (debug)
	fprintf(DEBUGFILE, "NOOP\n");
      continue;
    }
    
    
    if (debug) {
      fprintf(DEBUGFILE, "REG = %d (%s), ", nRegister, REGNAMES[nRegister]);
      if (imm)
	fprintf(DEBUGFILE, "IMMEDIATE DATA, ");
      fprintf(DEBUGFILE, "byteMODE = %d, READMODE = %d\n",
	      bByteMode, bReadMode);
      fflush(DEBUGFILE);
    }
    
    if ((*plCurr & READ_CAM_MASK) != 0) {
      int16 *pnBuffer;
      
      Cam8State.bReadMode = TRUE;
      bDestChange = TRUE;
      
      pnBuffer = (int16 *) lData;
      
      SimReadInstr(pnBuffer, *plCurr, lData, lLength);
      
      continue;
    }
    
    
    switch (nRegister) {
      
    case RFINDEX(REG_MSR): {
      vwecheck((int16 *) lData, RFINDEX(REG_MSR), imm);
      break;
    }      
      
      
    case RFINDEX(REG_RMR): {
      vwecheck((int16 *) lData, RFINDEX(FLD_SSM), imm);
      vwecheck((int16 *) lData, RFINDEX(FLD_RT), imm);
      vwecheck((int16 *) lData, RFINDEX(FLD_ECT), imm);
      vwecheck((int16 *) lData, RFINDEX(FLD_RPK), imm);
      vwecheck((int16 *) lData, RFINDEX(FLD_ALT), imm);
      
      for(i = 0; i < CHIPS_PER_MOD; i++) {
	if (ECT[i] == 1) {
          ECR[i] = EVENT_COUNT[i];
          EVENT_COUNT[i] = 0L;
        }
        if (RPK[i] == 1)
          DoKick(i);
      }
      
      if (ALT[0] == 1) {
        int16 *pnTemp;
        
        pnTemp = LIOR;
        LIOR = (int16 *) LUT_ADDR;
        LUT_ADDR = (long32) pnTemp;
        
        for (i = 0; i < CHIPS_PER_MOD; i++)
	  ALS[i] ^= 1;
      }
      if (Cam8State.bReadMode != FALSE) {
	bDestChange = TRUE;
	Cam8State.bReadMode = FALSE;
      }
      if (SSM[0] != 0) {
	Cam8State.WhyScan = RFINDEX(REG_RMR);
	SimExecScan();
      }
      
      break;
    }
      
      
    case RFINDEX(REG_KR): {
      vwecheck((int16 *) lData, RFINDEX(FLD_KA), imm);
      vwecheck((int16 *) lData, RFINDEX(FLD_XKS), imm);
      vwecheck((int16 *) lData, RFINDEX(FLD_YKS), imm);
      vwecheck((int16 *) lData, RFINDEX(FLD_ZKS), imm);
      vwecheck((int16 *) lData, RFINDEX(FLD_XKMF), imm);
      vwecheck((int16 *) lData, RFINDEX(FLD_YKMF), imm);
      vwecheck((int16 *) lData, RFINDEX(FLD_ZKMF), imm);
      DoKick(-1);
      break;
    }
      
      
    case RFINDEX(REG_SABSR):
      {
	vwecheck((int16 *) lData, RFINDEX(REG_SABSR), imm);
	break;
      }
    case RFINDEX(REG_LASR):
    case RFINDEX(REG_FOSR):
    case RFINDEX(REG_SDSR):
    case RFINDEX(REG_ECSR):
    case RFINDEX(REG_DSR): {
      vwecheck((int16 *) lData, FLD_SELECT(nRegister), imm);
      vwecheck((int16 *) lData, FLD_MAP(nRegister), imm);
      bSourceRegChange = TRUE;
      break;
    }
      
    case RFINDEX(REG_SSR): {
      vwecheck((int16 *) lData, RFINDEX(REG_SSR), imm);
      
      break;
    }
      
      
    case RFINDEX(REG_ECR): {
      if (ECL[0] != lLength) {
	ConstantSetAll(RLIF, 1);
	Generate_Interrupt(CAM_CAM_INT_STATUS);
      }
      else {
	int i;
	UnpackBits((int16 *) lData, 0, lLength, imm, (byte *) ECR, BIT32);
	for(i = 0; i < CHIPS_PER_MOD; i++)
	  EVENT_COUNT[i] = ECR[i];
      }
      break;
    }
      
      
    case RFINDEX(REG_LIR): {
      vwecheck((int16 *) lData, RFINDEX(REG_LIR), imm);
      break;
    }
      
      
    case RFINDEX(REG_LIPR): {
      vwecheck((int16 *) lData, RFINDEX(REG_LIPR), imm);
      
      break;
    }
      
      
    case RFINDEX(REG_LIOR): {
      int16 nLUTEntry, nLUTNextIndex;
      int16 *pnLUT, *pnSource;
      int i, j;
      int16 nImmediate[2];
      
      if (imm) {
        nImmediate[0] = (int16) lData >> 16;
        nImmediate[1] = (int16) lData & 0xFF;
        pnSource = &nImmediate[0];
      }
      
      else
        pnSource = (int16 *) lData;
      
      for (i = 0; i < lLength; i++) {
        nLUTNextIndex = 0;
        for (j = CHIPS_PER_MOD - 1; j >= 0; j--) {
          nLUTNextIndex <<= 1;
          if (LIPR[j] < 16)
            nLUTNextIndex |= ((LIR[j] >> LIPR[j]) & 0x1);
          else if (LIPR[j] == 31)
            nLUTNextIndex |= 0x1;
	  LIR[j]++;
        }
        pnLUT = LIOR + nLUTNextIndex;                 
        
        if (imm) {
          *pnLUT = *pnSource;
          pnSource = &nImmediate[i % 2];
        } 
        
        else {
          *pnLUT = *pnSource;
          pnSource++;
        }
      }
      
      break;
    }
      
      
    case RFINDEX(REG_SIR): {
      vwecheck((int16 *) lData, RFINDEX(REG_SIR), imm);
      
      SCAN_INDEX_REG = SIR[0];
      
      break;
    }
      
      
    case RFINDEX(REG_SIPR): {
      int j;
      
      for(j = 0; j < SCAN_INDEX_LENGTH; j++)
        vwecheck((int16 *) lData, RFINDEX(FLD_SSA(j)), imm);
      
      break;
    }
      
      
    case RFINDEX(REG_SIOR): {
      if ((Cam8State.bByteMode != bByteMode) || 
          (Cam8State.bImmediate != imm)) {
        Cam8State.bByteMode = bByteMode;
        Cam8State.bImmediate = imm;
        bSourceRegChange = TRUE;
      }
      
      if (imm) {
        SIOR = (byte *) &lData;
        TBUS_DATA = lData;
      }
      
      else {
        SIOR = (byte *) lData;
	TBUS_ADDR = lData;
      }
      
      if (Cam8State.bReadMode != FALSE) {
        bDestChange = TRUE;
        Cam8State.bReadMode = FALSE;
      }
      
      Cam8State.WhyScan = RFINDEX(REG_SIOR);
      SimExecScan();      
      break;
    }
      
      
    case RFINDEX(REG_SFR): {
      vwecheck((int16 *) lData, RFINDEX(FLD_SM), imm);
      vwecheck((int16 *) lData, RFINDEX(FLD_ESC), imm);
      vwecheck((int16 *) lData, RFINDEX(FLD_ESW), imm);
      vwecheck((int16 *) lData, RFINDEX(FLD_EST), imm);
      vwecheck((int16 *) lData, RFINDEX(FLD_SBRC), imm);
      vwecheck((int16 *) lData, RFINDEX(FLD_RCL), imm);
      vwecheck((int16 *) lData, RFINDEX(FLD_ECL), imm);
      vwecheck((int16 *) lData, RFINDEX(FLD_STM), imm);
      
      break;
    }
      
      
    case RFINDEX(REG_OSR): {
      vwecheck((int16 *) lData, nRegister, imm);
      break;
    }
      
      
    case RFINDEX(REG_DR): {
      vwecheck((int16 *) lData, RFINDEX(FLD_DCM), imm);
      vwecheck((int16 *) lData, RFINDEX(FLD_XDCP), imm);
      vwecheck((int16 *) lData, RFINDEX(FLD_YDCP), imm);
      vwecheck((int16 *) lData, RFINDEX(FLD_ZDCP), imm);
      UpdateDCMR();
      
      break;
    }
      
      
    case RFINDEX(REG_HER): {
      vwecheck((int16 *) lData, RFINDEX(FLD_LPL), imm);
      vwecheck((int16 *) lData, RFINDEX(FLD_FPL), imm);
      vwecheck((int16 *) lData, RFINDEX(FLD_DCS), imm);
      vwecheck((int16 *) lData, RFINDEX(FLD_TBD), imm);
      vwecheck((int16 *) lData, RFINDEX(FLD_TMS), imm);
      vwecheck((int16 *) lData, RFINDEX(FLD_NBF), imm);
      vwecheck((int16 *) lData, RFINDEX(FLD_SRE), imm);
      vwecheck((int16 *) lData, RFINDEX(FLD_ALS), imm);
       
      if (ALS[0] == 1) {
        LIOR = (int16 *) LUT0;
        LUT_ADDR = (long32) LUT1;
      } 
      
      else {
        LIOR = (int16 *) LUT1;
        LUT_ADDR = (long32) LUT0;
      }
      
      bSourceRegChange = TRUE;
      
      break;
    }
      
      
    case RFINDEX(REG_MPCR): {
      vwecheck((int16 *) lData, RFINDEX(FLD_MAFS), imm);
      vwecheck((int16 *) lData, RFINDEX(FLD_MBFS), imm);
      break;
    }
      
      
    case RFINDEX(REG_GPCR): {
      vwecheck((int16 *) lData, RFINDEX(FLD_XMPC), imm);
      vwecheck((int16 *) lData, RFINDEX(FLD_XPPC), imm);
      vwecheck((int16 *) lData, RFINDEX(FLD_YMPC), imm);
      vwecheck((int16 *) lData, RFINDEX(FLD_YPPC), imm);
      vwecheck((int16 *) lData, RFINDEX(FLD_ZMPC), imm);
      vwecheck((int16 *) lData, RFINDEX(FLD_ZPPC), imm);
      break;
    }
      
      
    case RFINDEX(REG_MIDR): {
      vwecheck((int16 *) lData, RFINDEX(REG_MIDR), imm);
      break;
    }
      
      
    case RFINDEX(REG_GIDR): {
      vwecheck((int16 *) lData, RFINDEX(REG_GIDR), imm);
      break;
    }
      
      
    case RFINDEX(REG_IER): {
      vwecheck((int16 *) lData, RFINDEX(FLD_BPIE), imm);
      vwecheck((int16 *) lData, RFINDEX(FLD_BCIE), imm);
      vwecheck((int16 *) lData, RFINDEX(FLD_GCIE), imm);
      vwecheck((int16 *) lData, RFINDEX(FLD_MAIE), imm);
      vwecheck((int16 *) lData, RFINDEX(FLD_MBIE), imm);
      vwecheck((int16 *) lData, RFINDEX(FLD_SSIE), imm);
      vwecheck((int16 *) lData, RFINDEX(FLD_XHIE), imm);
      vwecheck((int16 *) lData, RFINDEX(FLD_RLIE), imm);
      vwecheck((int16 *) lData, RFINDEX(FLD_URIE), imm);
      vwecheck((int16 *) lData, RFINDEX(FLD_ISIE), imm);
      break;
    }
      
      
    case RFINDEX(REG_IFR): {
      vwecheck((int16 *) lData, RFINDEX(FLD_BPIF), imm);
      vwecheck((int16 *) lData, RFINDEX(FLD_BCIF), imm);
      vwecheck((int16 *) lData, RFINDEX(FLD_GCIF), imm);
      vwecheck((int16 *) lData, RFINDEX(FLD_MAIF), imm);
      vwecheck((int16 *) lData, RFINDEX(FLD_MBIF), imm);
      vwecheck((int16 *) lData, RFINDEX(FLD_SSIF), imm);
      vwecheck((int16 *) lData, RFINDEX(FLD_XHIF), imm);
      vwecheck((int16 *) lData, RFINDEX(FLD_RLIF), imm);
      vwecheck((int16 *) lData, RFINDEX(FLD_URIF), imm);
      vwecheck((int16 *) lData, RFINDEX(FLD_ISIF), imm);
      break;
    }
      
      
    case RFINDEX(REG_VWR): {
      register int i;
      
      UnpackState((int16 *) lData, RFINDEX(FLD_VWE), imm);
      UnpackState((int16 *) lData, RFINDEX(FLD_VWIE), imm);
      UnpackState((int16 *) lData, RFINDEX(FLD_VWIF), imm);
      VWECHK = 0;
      for (i = 0; i < CHIPS_PER_MOD; i++)
	if (VWE[i] == 1)
	  VWECHK = 1;
      
      break;
    }
      
      
    case RFINDEX(REG_DOCR): {
      vwecheck((int16 *) lData, RFINDEX(FLD_LDOC), imm);
      vwecheck((int16 *) lData, RFINDEX(FLD_HDOC), imm);
      
      break;
    }
      
      
    default: {
      
      fprintf(stderr, "Don't recognize register %d\n", nRegister);
      break;
    }
    }
    
    cam8sim_iregs.PIP = (long32) plCurr;
  } /*   for (plCurr = plFirstInstr; !bDone; plCurr = plNext;) */
  cam8sim_iregs.ISR |= CAM_NEWLIST_INT_STATUS;
  CaLib_tb.LEAVE();
void Cam8SimCore::SimReadInstr(int16 *pnBuffer, long32 lInstr, long32 lData,
			   long32 lLength)
  bool bByteMode;
  short nRegister, i, imm;
  long32 pbuf[CHIPS_PER_MOD];
  CaLib_tb.ENTER("Cam8SimCore::SimReadInstr");
  bByteMode = (lInstr & byte_MODE_MASK) != 0;
  nRegister = lInstr & register_ADDR_MASK;
  imm = (lInstr & IMMEDIATE_DATA_MASK) != 0;
  switch (nRegister) {
    
  case RFINDEX(REG_MSR): {
    PackState(pnBuffer, RFINDEX(REG_MSR));
    break;
  }      
    
    
  case RFINDEX(REG_RMR): {
    PackState(pnBuffer, RFINDEX(FLD_SSM));
    PackState(pnBuffer, RFINDEX(FLD_RT));
    PackState(pnBuffer, RFINDEX(FLD_ECT));
    PackState(pnBuffer, RFINDEX(FLD_RPK));
    PackState(pnBuffer, RFINDEX(FLD_ALT));
    break;
    
    
  case RFINDEX(REG_KR): {
    PackState(pnBuffer, RFINDEX(FLD_KA));
    PackState(pnBuffer, RFINDEX(FLD_XKS));
    PackState(pnBuffer, RFINDEX(FLD_YKS));
    PackState(pnBuffer, RFINDEX(FLD_ZKS));
    PackState(pnBuffer, RFINDEX(FLD_XKMF));
    PackState(pnBuffer, RFINDEX(FLD_YKMF));
    PackState(pnBuffer, RFINDEX(FLD_ZKMF));
    break;
    
    
  case RFINDEX(REG_SABSR): {
    PackState(pnBuffer, RFINDEX(REG_SABSR));
    
    break;
    
    
  case RFINDEX(REG_LASR):
  case RFINDEX(REG_FOSR):
  case RFINDEX(REG_SDSR):
  case RFINDEX(REG_ECSR):
  case RFINDEX(REG_DSR): {
    PackState(pnBuffer, FLD_SELECT(nRegister));
    PackState(pnBuffer, FLD_MAP(nRegister));    
    break;
    
    
  case RFINDEX(REG_SSR): {
    *pnBuffer = 0xFFFF;
    
    break;
    
    
  case RFINDEX(REG_ECR): {
    int diff;
    if ((diff = ECL[0] - lLength) != 0){
      ConstantSetAll(RLIF, 1);
      if (diff < 0)
	Generate_Interrupt(CAM_CAM_INT_STATUS);
      else
	Generate_Interrupt(CAM_TIMEOUT_INT_STATUS);
    }
    
    else
      PackBits(pnBuffer, 0, lLength, (byte *) ECR, BIT32);
    
    break;
    
    
  case RFINDEX(REG_LIR): {
    PackState(pnBuffer, RFINDEX(REG_LIR));
    break;
    
    
  case RFINDEX(REG_LIPR): {
    PackState(pnBuffer, RFINDEX(REG_LIPR));
    break;
    
    
  case RFINDEX(REG_LIOR): {
    int16 nLUTEntry, nLUTNextIndex;
    int16 *pnLUT;
    int i, j;
    int16 nImmediate[2];
    
    
    for (i = 0; i < lLength; i++) {
      nLUTNextIndex = 0;
      
      for (j = CHIPS_PER_MOD - 1; j >= 0; j--) {
	nLUTNextIndex <<= 1;
	if (LIPR[j] < 16)
	  nLUTNextIndex |= ((LIR[j] >> LIPR[j]) & 0x1);
	else if (LIPR[j] == 31)
	  nLUTNextIndex |= 0x1;
	LIR[j]++;
      }
      
      pnLUT = LIOR + nLUTNextIndex;                 
      
      *pnBuffer = *pnLUT;
      pnBuffer++;
    }
    
    break;
    
    
  case RFINDEX(REG_SIR): {
    PackState(pnBuffer, RFINDEX(REG_SIR));
    break;
    
    
  case RFINDEX(REG_SIPR): {
    int j;
    
    /* j counts which field of register */
    for(j = 0; j < SCAN_INDEX_LENGTH; j++)
      PackState(pnBuffer, RFINDEX(FLD_SSA(j)));
    break;
    
    
  case RFINDEX(REG_SIOR): {
    Cam8State.bByteMode = bByteMode;
    SIOR = (byte *) pnBuffer;
    
    if (Cam8State.bReadMode !=  TRUE) {
      bDestChange = TRUE;
      Cam8State.bReadMode =  TRUE;
    }
    
    Cam8State.WhyScan = RFINDEX(REG_SIOR);
    SimExecScan();
    break;
    
    
  case RFINDEX(REG_SFR): {
    PackState(pnBuffer, RFINDEX(FLD_SM));
    PackState(pnBuffer, RFINDEX(FLD_ESC));
    PackState(pnBuffer, RFINDEX(FLD_ESW));
    PackState(pnBuffer, RFINDEX(FLD_EST));
    PackState(pnBuffer, RFINDEX(FLD_SBRC));
    PackState(pnBuffer, RFINDEX(FLD_RCL));
    PackState(pnBuffer, RFINDEX(FLD_ECL));
    PackState(pnBuffer, RFINDEX(FLD_STM));
    
    break;
    
    
  case RFINDEX(REG_OSR): {
    PackState(pnBuffer, RFINDEX(REG_OSR));
    break;
    
    
  case RFINDEX(REG_DR): {
    PackState(pnBuffer, RFINDEX(FLD_DCM));
    PackState(pnBuffer, RFINDEX(FLD_XDCP));
    PackState(pnBuffer, RFINDEX(FLD_YDCP));
    PackState(pnBuffer, RFINDEX(FLD_ZDCP));
    
    break;
    
    
  case RFINDEX(REG_HER): {
    PackState(pnBuffer, RFINDEX(FLD_LPL));
    PackState(pnBuffer, RFINDEX(FLD_FPL));
    PackState(pnBuffer, RFINDEX(FLD_DCS));
    PackState(pnBuffer, RFINDEX(FLD_TBD));
    PackState(pnBuffer, RFINDEX(FLD_TMS));
    PackState(pnBuffer, RFINDEX(FLD_NBF));
    PackState(pnBuffer, RFINDEX(FLD_SRE));
    PackState(pnBuffer, RFINDEX(FLD_ALS));
    
    break;
    
    
  case RFINDEX(REG_MPCR): {
    PackState(pnBuffer, RFINDEX(FLD_MAFS));
    PackState(pnBuffer, RFINDEX(FLD_MBFS));
    
    break;
    
    
  case RFINDEX(REG_GPCR): {
    PackState(pnBuffer, RFINDEX(FLD_XMPC));
    PackState(pnBuffer, RFINDEX(FLD_XPPC));
    PackState(pnBuffer, RFINDEX(FLD_YMPC));
    PackState(pnBuffer, RFINDEX(FLD_YPPC));
    PackState(pnBuffer, RFINDEX(FLD_ZMPC));
    PackState(pnBuffer, RFINDEX(FLD_ZPPC));
    
    break;
    
    
  case RFINDEX(REG_MIDR): {
    PackState(pnBuffer, RFINDEX(REG_MIDR));
    
    break;
    
    
  case RFINDEX(REG_GIDR): {
    PackState(pnBuffer, RFINDEX(REG_GIDR));
    
    break;
    
    
  case RFINDEX(REG_IER): {
    PackState(pnBuffer, RFINDEX(FLD_BPIE));
    PackState(pnBuffer, RFINDEX(FLD_BCIE));
    PackState(pnBuffer, RFINDEX(FLD_GCIE));
    PackState(pnBuffer, RFINDEX(FLD_MAIE));
    PackState(pnBuffer, RFINDEX(FLD_MBIE));
    PackState(pnBuffer, RFINDEX(FLD_SSIE));
    PackState(pnBuffer, RFINDEX(FLD_XHIE));
    PackState(pnBuffer, RFINDEX(FLD_RLIE));
    PackState(pnBuffer, RFINDEX(FLD_URIE));
    PackState(pnBuffer, RFINDEX(FLD_ISIE));
    break;
    
    
  case RFINDEX(REG_IFR): {
    PackState(pnBuffer, RFINDEX(FLD_BPIF));
    PackState(pnBuffer, RFINDEX(FLD_BCIF));
    PackState(pnBuffer, RFINDEX(FLD_GCIF));
    PackState(pnBuffer, RFINDEX(FLD_MAIF));
    PackState(pnBuffer, RFINDEX(FLD_MBIF));
    PackState(pnBuffer, RFINDEX(FLD_SSIF));
    PackState(pnBuffer, RFINDEX(FLD_XHIF));
    PackState(pnBuffer, RFINDEX(FLD_RLIF));
    PackState(pnBuffer, RFINDEX(FLD_URIF));
    PackState(pnBuffer, RFINDEX(FLD_ISIF));
    
    break;
    
    
  case RFINDEX(REG_VWR): {
    PackState(pnBuffer, RFINDEX(FLD_VWE));
    PackState(pnBuffer, RFINDEX(FLD_VWIE));
    PackState(pnBuffer, RFINDEX(FLD_VWIF));
    break;
    
    
  case RFINDEX(REG_DOCR): {
    PackState(pnBuffer, RFINDEX(FLD_LDOC));
    PackState(pnBuffer, RFINDEX(FLD_HDOC));
    
    break;
    
    
  default: {
    
    fprintf(stderr, "Don't recognize register %d\n", nRegister);
    break;
  CaLib_tb.LEAVE();
void Cam8SimCore::DoKick(short p)
  register int i, j;
  long32 lSignBitOffset, lSignBitKick, lLowBitsKick;
  long32 lDCM;
  long32 lKA;
  CaLib_tb.ENTER("Cam8SimCore::DoKick");
  /************************************************************************/
  /* The kick and offset registers are two n-dimension-vectors, and the   */
  /* place where all dimensions end is determined by lDCMR. To subtract   */
  /* an n-dimension-kick from the corresponding offset, we first extract  */
  /* out the sign bits of both (by and-ing with lDCMR). Next, we set the  */
  /* most sig bits of every dimension in offset to 1, so that when we     */
  /* subtract out the kick, we don't borrow from the next higher          */
  /* dimension. Next, we subtract the value bits of kick (lowbits) from   */
  /* this offset. This will give the 'sign' bit of the new offset and its */
  /* value. The final sign bit of the offset is determined by :           */
  /*                                                                      */
  /*     sign bit = new sign bit xor (old sign bit xnor kick sign bit)    */
  /*                                                                      */
  /* To do the xnor operation, we simply store the inverse of the kick    */
  /* sign bit and then do an xor                                          */
  /*                                                                      */
  /* One easy way to derive this is to think of a sample dimension with   */
  /* 4 bits. Then, the bit positions have values  -8  4  2  1. The        */
  /* subtract operation as described above becomes (8 + 4*o.2 + 2*o.1 +   */
  /* 1*o.0 - 4*k.2 - 2*k.1 - 1*k.0) - 8 - 8*o.sign + 8.k.sign             */
  /* where o.X means the X'th bit of offset and k.X means the X'th bit of */
  /* kick. Since the final offset is of the form -8*o.sign + 4*o.2 +      */
  /* 2*o.1 + 1*o.o, we can express the sign bit as the above logical      */
  /* function of the three individual sign bits.                          */
  /*                                                                      */
  /************************************************************************/
  if (p == -1) {
    p = 0;
    j = CHIPS_PER_MOD;
  else
    j = p + 1;
  for(i = p; i < j; i++) {
    lSignBitOffset = OSR[i] & DCM[i];
    lSignBitKick = (~KA[i]) & DCM[i];
    OSR[i] |= DCM[i];
    lLowBitsKick =  KA[i] & (~ DCM[i]);
    
    OSR[i] -= lLowBitsKick;
    lSignBitOffset ^= lSignBitKick;
    OSR[i] ^= lSignBitOffset;
  CaLib_tb.LEAVE();
void Cam8SimCore::SimExecScan(void)
  int i;
  bool bNoPerm = TRUE;
  bool bNoPermLast5 = TRUE;
  long32 lLogScanLength = ESC[0] + 1L;
  CaLib_tb.ENTER("SimExecScan");  
  /************************************************************************/
  /* First, parse down the tree to see that we are going to update atleast*/
  /* 32 sites and that the lowest dimension extends over 32 bits. This    */
  /* second requirement is necessary because the optimized code can only  */
  /* handle dimension wraparounds at word boundaries.                     */
  /************************************************************************/
  if (lLogScanLength < 5)
    bNoPerm = bNoPermLast5 = FALSE;
  else if (lNumXBits < 5)
    bNoPerm = bNoPermLast5 = FALSE;
  else
    bNoPerm = bNoPermLast5 = TRUE;
  /************************************************************************/
  /* Now, determine if there is any permutation of the scan index in the  */
  /* bits of the SIR that will be significant over this scan.             */
  /************************************************************************/
  for (i = 0; i < MIN(5, ESC[0]); i++) {
    if (SIPR[i][0] != i) {
      bNoPerm = bNoPermLast5 = FALSE;
      break;
    }
    
    lLogScanLength--;
    
    if (!lLogScanLength)
      break;
  for (i = 5; i < MIN(SCAN_INDEX_LENGTH, ESC[0]); i++) {
    if (SIPR[i][0] != i)
      bNoPerm = FALSE;
    lLogScanLength--;
    if (!lLogScanLength)
      break;
#ifdef _FRAMEBUFFER_
  FRAME_ADDR = (long32) FRAMEb;
#endif _FRAMEBUFFER_
  if (bNoPerm)
    CheckNoPerm();
  else if (bNoPermLast5)
    SimGeneralScan();
  else
    SimGeneralScan();
  if (SCAN_INDEX_REG > 0xFFFFFF)
    SCAN_INDEX_REG = 0;
  SIR[0] = SCAN_INDEX_REG;
  CaLib_tb.LEAVE();
/*****************************************************************************/
/*                                                                           */
/* CheckNoPerm is necessary for the following reason - suppose there is no   */
/* permutation of the Scan Index, but suppose the the bits that extend over  */
/* the lowest dimension (ie, the bits to the _right_ of the lowest bit of    */
/* DCMR) are not all zeros. Then, the first sweep will not scan a multiple-  */
/* of-two number of sites, and we cannot do an optimized scan.               */
/*                                                                           */
/*****************************************************************************/
void Cam8SimCore::CheckNoPerm(void)
  long32 lSIRSigBits, lSIR;
  CaLib_tb.ENTER("CheckNoPerm");
  lSIRSigBits = MIN(ESC[0], lNumXBits);
  lSIR = SIR[0] & ~((~0x0) << lSIRSigBits);
  if ((lSIR == 0) && (MIN(lNumXBits, ESC[0]) >= 2)) {
    if (bForceGeneralScan)
      SimGeneralScan();
    else
      SimScanNoPerm();
  else
    SimGeneralScan();
  CaLib_tb.LEAVE();
void Cam8SimCore::SimUpdateSite(void)
  short i;
  long32 SiteDataSrc = UNGLUE_DATA;
  CaLib_tb.ENTER("SimUpdateSite");
  if (IsSrcNeeded(SRC_TBUS) &&
      ((CAM8State.WhyScan != RFINDEX(REG_SIOR)) || (!CAM8State.bReadMode))) {
    if (!CAM8State.bImmediate) {
      if (CAM8State.bByteMode) {
	TBUS_DATA = *((byte *) TBUS_ADDR);
	TBUS_ADDR += 1;
      }
      
      else {
	TBUS_DATA = *((int16 *) TBUS_ADDR);
	TBUS_ADDR += 2;
      } /* else */
    } /* if (!CAM8State.bImmediate) */
  if (IsSrcNeeded(SRC_SITE_DATA)) {
    UNGLUE_DATA = 0;
    for (i = nNumPlanes-1; i >= 0; i--) {
      bit = HIGHB(PLANE_WORD[i]);
      PLANE_WORD[i] <<= 1; 
      UNGLUE_DATA = (UNGLUE_DATA << 1) | bit;
    }
  /* For Now glued and unglued data are the same */
  if (IsSrcNeeded(SRC_GLUED_DATA)) {
    if (!IsSrcNeeded(SRC_SITE_DATA)) {
      GLUE_DATA = 0;
      for (i = nNumPlanes-1; i >= 0; i--) {
	bit = HIGHB(PLANE_WORD[i]);
	PLANE_WORD[i] <<= 1; 
	GLUE_DATA = (GLUE_DATA << 1) | bit;
      }
    }
    else
      GLUE_DATA = UNGLUE_DATA;
  if (IsSrcNeeded(SRC_LUT)) {
    LUT_DATA = 0;
    if (IsSrcSame(DEST_LUT))
      BuildDest(DEST_LUT, &LUT_DATA, LAS[0], LAM[0]);           
    else
      BuildBitwiseDest(DEST_LUT, &LUT_DATA, LAS, LAM);
    LUT_DATA = (long32) (((int16 *) LUT_ADDR)[LUT_DATA]);
  /************************************************************************/
  /*                                                                      */
  /* All the sources needed to update all the destinations should now be  */
  /* in place. Update all the destinations in the following order : EC,   */
  /* Display (ie, scan io reads), and Site Data. Note that Site data      */
  /* must be updated last, because it destroys the Site Data register,    */
  /* which is one of the possible Sources (unglued data).                 */
  /*                                                                      */
  /************************************************************************/
  if (IsDestUpdated(DEST_DISPLAY)) {
    if (IsSrcSame(DEST_DISPLAY))
      BuildDest(DEST_DISPLAY, &DISP_DATA, DDS[0], DDM[0]);
    else
      BuildBitwiseDest(DEST_DISPLAY, &DISP_DATA, DDS, DDM);
#ifdef _FRAMEBUFFER_
    *((byte *) FRAME_ADDR) = DISP_DATA;
    FRAME_ADDR += 1;
#endif
    
  /* SCAN-IO READ */
  if ((CAM8State.WhyScan == RFINDEX(REG_SIOR)) && CAM8State.bReadMode) {
    if (CAM8State.bByteMode) {
      *((byte *) SIOR) = (byte) DISP_DATA;
      SIOR += 1;
    }
    else {
      *((int16 *) SIOR) = (int16) DISP_DATA;
      SIOR += 2;
    }
  if (IsDestUpdated(DEST_EVENT_CT)) {
    if (IsSrcSame(DEST_EVENT_CT))
      BuildDest(DEST_EVENT_CT, &TEMP1, ECS[0], ECM[0]);
    else
      BuildBitwiseDest(DEST_EVENT_CT, &TEMP1, ECS, ECM);
    
    TEMP1 <<= (32 - nNumPlanes);
    for (i = nNumPlanes-1; i >= 0; i--) {
      EVENT_COUNT[i] += ((TEMP1 & 0x80000000) ? 0x1 : 0x0);
      TEMP1 <<= 1;
    }
  if (IsDestUpdated(DEST_SITE_DATA)) {
    if (IsSrcSame(DEST_SITE_DATA)) {
      if (SDM[0] == MAP_S) {
	SiteDataSrc = (SDS[0] == SRC_SITE_DATA ? UNGLUE_DATA :
		       SDS[0] == SRC_TBUS ? TBUS_DATA :
		       SDS[0] == SRC_LUT ? LUT_DATA : TEMP1);
      }
      
      else {
	BuildDest(DEST_SITE_DATA, &SITE_DATA, SDS[0], SDM[0]);
	SiteDataSrc = SITE_DATA;
      }
    }
    
    else {
      BuildBitwiseDest(DEST_SITE_DATA, &SITE_DATA, SDS, SDM);
      SiteDataSrc = SITE_DATA;
    }
    
    SiteDataSrc <<= (32 - nNumPlanes);
    for (i = nNumPlanes - 1; i >= 0; i--) {                                
      bit = HIGHB(SiteDataSrc);
      SiteDataSrc <<= 1;
      
      if ((IsSrcNeeded(SRC_SITE_DATA)) || (IsSrcNeeded(SRC_GLUED_DATA)))
	PLANE_WORD[i] |= bit;
      else
	PLANE_WORD[i] = (PLANE_WORD[i] << 1) | bit;
    }
  CaLib_tb.LEAVE();
void Cam8SimCore::SimScanNoPerm(void)
  long32 PLANE_CTR, WORD_ADDR, HIGH_BIT;
  CaLib_tb.ENTER("SimScanNoPerm");
  /************************************************************************/
  /* compute HIGH_BIT_MASK and X_HIGH_BIT_MASK				  */
  /************************************************************************/
  HIGH_BIT_MASK = lDCMRHighBit >> 3;
  X_HIGH_BIT_MASK = lDCMRLowBit >> 3;
  /************************************************************************/
  /* SITE_CTR is set to how many sweeps are to be done. X_byte_LENGTH is  */
  /* set to how many bytes will be updated per sweep                      */
  /************************************************************************/
  if (ESC[0] < lNumXBits) {
    SITE_CTR = 1;
    X_byte_LENGTH = 1 << (ESC[0] - 3);
  else {
    SITE_CTR = ScanLength() >> lNumXBits;                                  
    X_byte_LENGTH = lDCMRLowBit >> 2;
  nNumPlanes = CalcNumPlanes();
  if (nNumPlanes == 0) {
    CaLib_tb.LEAVE();
    return;
  /************************************************************************/
  /* Code starts here                                                     */
  /************************************************************************/
  while (SITE_CTR != 0) {
    SimSweepCode();
    for(PLANE_CTR = 0; PLANE_CTR < nNumPlanes; PLANE_CTR++) {  
      WORD_ADDR = NEXT_WORD_ADDR[PLANE_CTR];
      HIGH_BIT = WORD_ADDR & HIGH_BIT_MASK;
      WORD_ADDR &= (~ HIGH_BIT_MASK);
      WORD_ADDR += X_byte_LENGTH;
      WORD_ADDR ^= HIGH_BIT;
      NEXT_WORD_ADDR[PLANE_CTR] = WORD_ADDR;
      /*
      NEXT_WORD_ADDR[PLANE_CTR] =
	(((NEXT_WORD_ADDR[PLANE_CTR] & (~ HIGH_BIT_MASK)) + X_byte_LENGTH) ^
	 (NEXT_WORD_ADDR[PLANE_CTR] & HIGH_BIT_MASK));
	 */
    }
    SCAN_INDEX_REG += (X_byte_LENGTH << 3);
    if (SCAN_INDEX_REG > 0xFFFFFF)
      SCAN_INDEX_REG = 0;
    SITE_CTR--;
    ConstantSetAll(SIR, SCAN_INDEX_REG);
  CaLib_tb.LEAVE();
void Cam8SimCore::SimSweepCode(void)
  short i, j;
  long32 NBIT_OFFSET[CHIPS_PER_MOD], XWORD_LENGTH;
  CaLib_tb.ENTER("SimSweepCode");
  /************************************************************************/
  /* We assume here that the scan index is not permuted to arrive at the  */
  /* site address; however, some bits of the site address could be fixed  */
  /* at constant 0 or 1 as indicated by SIPR. Here, the site address of   */
  /* the first site to be updated is computed.                            */
  /************************************************************************/
  SITE_ADDR = 0;
  for (i = SCAN_INDEX_LENGTH-1; i >= 0; i--) {
    
    SITE_ADDR <<= 1;
    if (SIPR[i][0] == PERM_CONST_1)
      SITE_ADDR |= 0x1;
    else if (SIPR[i][0] != PERM_CONST_0)
      SITE_ADDR |= (SIR[0] >> i) & 0x1;
  /************************************************************************/
  /* Now that we know the site address of the first site to be updated,   */
  /* we compute the address in sparc memory of the word that contains     */
  /* a bit of that site by adding the plane offset to the site address.   */
  /************************************************************************/
  for (i = 0; i < nNumPlanes; i++) {
    NEXT_WORD_ADDR[i] = (AddSiteAddress(SITE_ADDR, OSR[i]) >> 5) << 2;
    NEXT_WORD_ADDR[i] += BIT_PLANE_ADDR[i];
    NBIT_OFFSET[i] = OSR[i] & 0x1F;
  XWORD_LENGTH = X_byte_LENGTH >> 2;
  SimLoadFirstWord(NBIT_OFFSET);
  X_CTR = XWORD_LENGTH;
  do {
    for (i = 0; i < 32; i++) {
      SimUpdateSite();
      for (j = 0; j < nNumPlanes; j++) {
	if (NBIT_OFFSET[j] == (31 - i))
	  SimGetNextWord(j);
      }
    }
    X_CTR -= 1;
  } while (X_CTR);
  SimSaveLastWord(NBIT_OFFSET);
  CaLib_tb.LEAVE();
void Cam8SimCore::SimLoadFirstWord(long32 NBIT_OFFSET[])
  short i;
  long32 SAVE_BITS, WORD_ADDR;
  CaLib_tb.ENTER("SimLoadFirstWord");
  for (i = 0; i < nNumPlanes; i++) {
    PLANE_WORD[i] = *((long32 *) NEXT_WORD_ADDR[i]);
    
    if (NBIT_OFFSET[i] != 0) {
      SAVE_BITS = PLANE_WORD[i] >> (32 - NBIT_OFFSET[i]);
      PLANE_WORD[i] <<= NBIT_OFFSET[i];
      PLANE_WORD[i] |= SAVE_BITS;
    }
  CaLib_tb.LEAVE();
void Cam8SimCore::SimGetNextWord(unsigned short nPlane)
  long32 ADDR_HIGH_BIT;
  bool bWriteBack = FALSE;
  short i;
  CaLib_tb.ENTER("SimGetNextWord");
  if (IsDestUpdated(DEST_SITE_DATA))
      *((long32 *) NEXT_WORD_ADDR[nPlane]) = PLANE_WORD[nPlane];
  if (lNumXBits <= 5) {
    CaLib_tb.LEAVE();
    return;
  ADDR_HIGH_BIT = NEXT_WORD_ADDR[nPlane] & X_HIGH_BIT_MASK;
  NEXT_WORD_ADDR[nPlane] &= (~ X_HIGH_BIT_MASK);
  NEXT_WORD_ADDR[nPlane] = (NEXT_WORD_ADDR[nPlane] + 4) ^ ADDR_HIGH_BIT;
  PLANE_WORD[nPlane] = *((long32 *) NEXT_WORD_ADDR[nPlane]);
  CaLib_tb.LEAVE();
void Cam8SimCore::SimSaveLastWord(long32 NBIT_OFFSET[])
  short i;
  long32 SAVE_BITS;
  CaLib_tb.ENTER("SimSaveLastWord");
  if (IsDestUpdated(DEST_SITE_DATA)) {
    for (i = 0; i < nNumPlanes; i++) {
      if (!NBIT_OFFSET[i])
	continue;
      SAVE_BITS = PLANE_WORD[i] >> NBIT_OFFSET[i];
      PLANE_WORD[i] <<= (32 - NBIT_OFFSET[i]);
      PLANE_WORD[i] |= SAVE_BITS;
      *((long32 *) NEXT_WORD_ADDR[i]) = PLANE_WORD[i];
    }
  CaLib_tb.LEAVE();
void Cam8SimCore::SimGeneralScan(void)
  short i;
  long32 PLANE_CTR;
  long32 SA_HIGH_BITS, OFF_HIGH_BITS, SCRATCH, PLANE_ADDR;
  long32 SWEEP_LENGTH, SA_OR_MASK, SA_AND_MASK, WORD_ADDR;
  nNumPlanes = CalcNumPlanes();
  CaLib_tb.ENTER("SimGeneralScan");
  if (nNumPlanes == 0) {
    CaLib_tb.LEAVE();
    return;
  /************************************************************************/
  /* First, update things in the heap from where they can be accessed     */
  /* by the compiled code.                                                */
  /************************************************************************/
  /************************************************************************/
  /* Update heap copy of DCMR.						  */
  /************************************************************************/
  DCMR = DCM[0];
  /************************************************************************/
  /* Update heap copy of OFFSETS					  */
  /************************************************************************/
  for(i = 0 ; i < CHIPS_PER_MOD; i++)
    OFFSETS[i] = OSR[i];
  /************************************************************************/
  /* Figure out the site address of the first site to be updated. This is */
  /* needed to update SITE_ADDR for display purposes. Also,               */
  /* compute the SAAndMask and SAOrMask which will be used to do the      */
  /* permutation at execution time.                                       */
  /************************************************************************/
  SITE_ADDR = 0;
  SA_OR_MASK = SA_AND_MASK = 0;
  for (i = SCAN_INDEX_LENGTH-1; i >= 0; i--) {
    
    SITE_ADDR <<= 1;
    SA_OR_MASK <<= 1;
    SA_AND_MASK <<= 1;
    
    if (SIPR[i][0] < SCAN_INDEX_LENGTH) {
      
	/* Get the correct bit of scan indx */
      SITE_ADDR |= (SIR[0] >> SIPR[i][0]) & 0x1;
      
      if (SIPR[i][0] == i)
	SA_AND_MASK |= 1;
    }
    
    /* Constant of 1 */
    else if (SIPR[i][0] == PERM_CONST_1) {
      SA_OR_MASK |= 1;
      SITE_ADDR |= 1;
    }
      
    else if (SIPR[i][0] != PERM_CONST_0)
      WARNING("Invalid SIPR value", "SimGenScan");
  /************************************************************************/
  /* Figure out how many sites will be updated, and how many sites/sweep  */
  /************************************************************************/
  SITE_CTR = ScanLength();
  SWEEP_LENGTH = SweepLength(&X_CTR);
  /************************************************************************/
  /* Next, generate the code. First, permute the scan index register to   */
  /* get the site address.                                                */
  /************************************************************************/
  while (SITE_CTR != 0) {
    SITE_ADDR = SCAN_INDEX_REG & SA_AND_MASK;
    SITE_ADDR |= SA_OR_MASK;
    
    for (i = SCAN_INDEX_LENGTH-1; i >= 0; i--) {
      if ((SIPR[i][0] < SCAN_INDEX_LENGTH) && (SIPR[i][0] != i)) {
	SCRATCH = SCAN_INDEX_REG << (31 - SIPR[i][0]);
	bit = HIGHB(SCRATCH);
	SITE_ADDR |= (bit << i);
      }
    }
    
    /************************************************************************/
    /* Now, add site address to the offset to get the DRAM address. The     */
    /* addition must break the carries at the dimension cuts. Also, DRAM    */
    /* address must be broken into a SPARC word address and a 5 bit offset  */
    /* into the word                                                        */
    /************************************************************************/
    
    SA_HIGH_BITS = SITE_ADDR & DCMR;
    SITE_ADDR = SITE_ADDR & (~ DCMR); 
    SITE_ADDR = (SITE_ADDR & (~ DCMR)) & SITE_ADDR_MASK;
    for(PLANE_CTR = 0; PLANE_CTR < nNumPlanes; PLANE_CTR++) {
      WORD_ADDR = OFFSETS[PLANE_CTR];
      OFF_HIGH_BITS = WORD_ADDR & DCMR;
      WORD_ADDR = SITE_ADDR + (WORD_ADDR & (~ DCMR));
      WORD_ADDR = (WORD_ADDR ^ OFF_HIGH_BITS) ^ SA_HIGH_BITS;
      PLANE_ADDR = BIT_PLANE_ADDR[PLANE_CTR];
      NEXT_WORD_ADDR[PLANE_CTR] = PLANE_ADDR + ((WORD_ADDR >> 5) << 2);
      BIT_OFFSETS[PLANE_CTR] = WORD_ADDR & 0x1F;
    }
  /************************************************************************/
  /* Now, the heap has the word addresses and bit offsets for the next    */
  /* site. So go ahead and update the site.                               */
  /************************************************************************/
    SimUpdateCode();
    if ((--X_CTR) == 0)
      X_CTR = SWEEP_LENGTH;
    
    if ((++SCAN_INDEX_REG) > 0xFFFFFF)
      SCAN_INDEX_REG = 0;
    
    SITE_CTR--;
    ConstantSetAll(SIR, SCAN_INDEX_REG);
  CaLib_tb.LEAVE();
void Cam8SimCore::SimUpdateCode(void)
  CaLib_tb.ENTER("SimUpdateCode");
  SimLoadPlaneWords();
  SimUpdateSite();
  SimSavePlaneWords();
  CaLib_tb.LEAVE();
void Cam8SimCore::SimLoadPlaneWords(void)
  short i;
  long32 WORD_ADDR, BIT_OFFSET, SAVE_BITS;
  CaLib_tb.ENTER("SimLoadPlaneWords");
  if (!IsSrcNeeded(SRC_SITE_DATA) && !IsSrcNeeded(SRC_GLUED_DATA) &&
      !IsDestUpdated(DEST_SITE_DATA)) {
    CaLib_tb.LEAVE();
    return;
  for (i = 0; i < nNumPlanes; i++) {
    WORD_ADDR = NEXT_WORD_ADDR[i];
    PLANE_WORD[i] = *((long32 *) WORD_ADDR);
    BIT_OFFSET = BIT_OFFSETS[i];
    SAVE_BITS = PLANE_WORD[i] >> (32 - BIT_OFFSET);
    PLANE_WORD[i] <<= BIT_OFFSET;
    PLANE_WORD[i] |= SAVE_BITS;
    PLANE_WORD[i] = (*((long32 *) NEXT_WORD_ADDR[i]) << BIT_OFFSETS[i]) |
                    (*((long32 *) NEXT_WORD_ADDR[i]) >> (32 - BIT_OFFSETS[i]));
  CaLib_tb.LEAVE();
void Cam8SimCore::SimSavePlaneWords(void)
  short i;
  long32 WORD_ADDR, BIT_OFFSET, SAVE_BITS;
  CaLib_tb.ENTER("SimSavePlaneWords");
  if (!IsDestUpdated(DEST_SITE_DATA)) {
    CaLib_tb.LEAVE();
    return;
  for (i = 0; i < nNumPlanes; i++) {
    BIT_OFFSET = BIT_OFFSETS[i];
    SAVE_BITS = PLANE_WORD[i] << (31 - BIT_OFFSET);
    PLANE_WORD[i] >>= (BIT_OFFSET + 1);
    PLANE_WORD[i] |= SAVE_BITS;
    WORD_ADDR = NEXT_WORD_ADDR[i];
    *((long32 *) WORD_ADDR) = PLANE_WORD[i];
    PLANE_WORD[i] = (PLANE_WORD[i] >> (BIT_OFFSETS[i] + 1)) |
                    (PLANE_WORD[i] << (31 - BIT_OFFSETS[i]));
    *((long32 *) NEXT_WORD_ADDR[i]) = PLANE_WORD[i];
  CaLib_tb.LEAVE();
}     
long32 * Cam8SimCore::PermuteScanIndex(void)
  short i;
  bool bIsPermuted = FALSE;
  CaLib_tb.ENTER("PermuteScanIndex");
  for (i = nNumPlanes - 1; i >= 0; i--) {
    if (SABSR[i] != i) {
      bIsPermuted = TRUE;
      break;
    }
  if (!bIsPermuted) {
    CaLib_tb.LEAVE();
    return(&SCAN_IN
DEX_REG);
  TEMP6 = 0;
  for (i = nNumPlanes-1; i >= 0; i--) {
    if (SABSR[i] < 24) {
      TEMP5 = SCAN_INDEX_REG << (31 - SABSR[i]);
      bit = HIGHB(TEMP6);
      TEMP6 = (TEMP6 << 1) | HIGHB(TEMP5);
      TEMP5 <<= 1;
    }
    else if (SABSR[i] == 31) {
      TEMP6 <<= 1;
      TEMP6 += 1;
    }
    else if (SABSR[i] == 30) {
      TEMP6 <<= 1;
    }
    else {
      WARNING("Invalid SABSR value!", "PermuteScanIndex");
      TEMP6 <<= 1;
    }
  CaLib_tb.LEAVE();
  return (&TEMP6);
void Cam8SimCore::MapFunction(long32 *SrcVar, long32 *DestVar, byte bMap)
  CaLib_tb.ENTER("MapFunction");
  switch (bMap) {
  case MAP_CONST_0: {
    *DestVar = 0;
    break;
    
  case MAP_G_NOR_S: {
    *DestVar = ~ (GLUE_DATA | *SrcVar);
    break;
}    
  case MAP_G_AND_S_BAR: {
    *DestVar = GLUE_DATA & (~ *SrcVar);
    break;
    
  case MAP_S_BAR: {
    *DestVar = ~ *SrcVar;
    break;
    
  case MAP_G_BAR_AND_S: {
    *DestVar = (~ GLUE_DATA) & *SrcVar;
    break;
    
  case MAP_G_BAR: {
    *DestVar = ~ GLUE_DATA;
    break;
    
  case MAP_G_XOR_S: {
    *DestVar = GLUE_DATA ^ *SrcVar;
    break;
    
  case MAP_G_NAND_S: {
    *DestVar = ~ (GLUE_DATA & *SrcVar);
    break;
    
  case MAP_G_AND_S: {
    *DestVar = GLUE_DATA & *SrcVar;
    break;
    
  case MAP_G_EQ_S: {
    *DestVar = ~ (GLUE_DATA ^ *SrcVar);
    break;
    
  case MAP_G: {
    *DestVar = GLUE_DATA;
    break;
    
  case MAP_G_OR_S_BAR: {
    *DestVar = GLUE_DATA | (~ *SrcVar);
    break;
    
  case MAP_S: {
    *DestVar = *SrcVar;
      break;
    
  case MAP_G_BAR_OR_S: {
    *DestVar = (~ GLUE_DATA) | *SrcVar;
      break;
    
  case MAP_G_OR_S: {
    *DestVar = GLUE_DATA | *SrcVar;
    break;
    
  case MAP_CONST_1: {
    *DestVar = 0xFFFFFFFF;
    break;
  CaLib_tb.LEAVE();
void Cam8SimCore::BuildDest(short nDest, long32 *DestVar, byte Src, byte Map)
  long32 *SrcVar;
  CaLib_tb.ENTER("BuildDest");
  if ((Map != MAP_G) && (Map != MAP_G_BAR)) {
    SrcVar = (Src == SRC_SITE_DATA ? &UNGLUE_DATA :
	      Src == SRC_TBUS ? &TBUS_DATA :
	      Src == SRC_LUT ? &LUT_DATA : &TEMP1);
    if ((nDest == DEST_LUT) && (Src == SRC_SITE_ADDRESS)) {
      SrcVar = PermuteScanIndex();
    }
  MapFunction(SrcVar, DestVar, Map);
  CaLib_tb.LEAVE();
void Cam8SimCore::BuildBitDest(short nDest, long32 *HoldReg, byte Src, byte Map,
		  unsigned short nPlane)
{                                                               
  CaLib_tb.ENTER("BuildBitDest");
  if ((nDest == DEST_LUT) && (Src == SRC_SITE_ADDRESS)) {
    TEMP6 = 0;
    if (SABSR[nPlane] < 24) {
      TEMP5 = SCAN_INDEX_REG << (31 - SABSR[nPlane]);
      bit = HIGHB(TEMP6);
      TEMP6 = ((TEMP6 << 1) | HIGHB(TEMP5)) << nPlane;
      TEMP5 <<= 1;
    }
    else if (SABSR[nPlane] == 31)
      TEMP6 = (TEMP6 << 1) + 1;
    else if (SABSR[nPlane] == 30)
      TEMP6 <<= 1;
    else {
      WARNING("Invalid SABSR value", "BuildBitDest");
      TEMP6 <<= 1;
    }
    MapFunction (&TEMP6, HoldReg, Map);
  else
    BuildDest(nDest, HoldReg, Src, Map);
  CaLib_tb.LEAVE();
void Cam8SimCore::BuildBitwiseDest(short nDest, long32 *DestVar, byte Src[], byte Map[])
  short i;
  long32 *HoldReg = &TEMP4;
  CaLib_tb.ENTER("BuildBitwiseDest");
  for (i = nNumPlanes - 1; i >= 0; i--) {
    BuildBitDest(nDest, HoldReg, Src[i], Map[i], i);
    *HoldReg <<= (31 - i);
    bit = HIGHB(*DestVar);
    *DestVar = (*DestVar << 1) | HIGHB(*HoldReg);
    *HoldReg <<= 1;
  CaLib_tb.LEAVE();
/*****************************************************************************/
/*                                                                           */
/* This routine adds two longs breaking the carries at positions indicated   */
/* by the Dimension Cut Mask Register (DCMR). The DCMR has a 1 bit at every  */
/* bit position where the carry needs to be cut.                             */
/*                                                                           */
/*****************************************************************************/
long32 Cam8SimCore::AddSiteAddress(long32 lSrc1, long32 lSrc2)
  long32 lHighBits1, lHighBits2;
  lHighBits1 = lSrc1 & DCM[0];
  lHighBits2 = lSrc2 & DCM[0];
  lSrc1 &= (~DCM[0]);
  lSrc2 &= (~DCM[0]);
  return( (lSrc1 + lSrc2) ^ lHighBits1 ^ lHighBits2 );
long32 Cam8SimCore::SubSiteAddress(long32 lSrc1, long32 lSrc2)
  long32 lSignBitOffset, lSignBitKick, lLowBitsKick;
  lSignBitOffset = lSrc1 & DCM[0];
  lSignBitKick = (~lSrc2) & DCM[0];
  lSrc1 |= DCM[0];
  lLowBitsKick = lSrc2 & (~ DCM[0]);
  lSrc1 -= lLowBitsKick;
  lSignBitOffset = lSignBitOffset ^ lSignBitKick;
  lSrc1 ^= lSignBitOffset;
/*****************************************************************************/
/*                                                                           */
/* Compute the Scan length - the number of sites that will be updated in     */
/* the current scan. Basically, it should be 2^ESCP, but we need to correct  */
/* for the fact that the SIR low-order bits might not be all zero            */
/*                                                                           */
/*****************************************************************************/
long32 Cam8SimCore::ScanLength(void)
  long32 lCarryOVFBit, lScanLength, lSIRBits;
  lCarryOVFBit = ESC[0];
  lScanLength = (1 << lCarryOVFBit);                                  
  lSIRBits = SIR[0] & (lScanLength - 1);
  lScanLength -= lSIRBits;
  return (lScanLength);
/*****************************************************************************/
/*                                                                           */
/* Determine the sweep length. The sweep length is given by either the low   */
/* bit of the DCMR or the ESCP (End-of-Scan-pointer) or the SFR register.    */
/* This is because the scan could update many lines of the lowest (X) dimen- */
/* sion, or could update just part of 1 line in the X dimension.             */
/*                                                                           */
/*****************************************************************************/
long32 Cam8SimCore::SweepLength(long32 *lFirstSweep)
  long32 lCarryOVFBit, lSweepLength;
  lCarryOVFBit = MIN(ESW[0], lNumXBits);
  lSweepLength = (1 << lCarryOVFBit);
  *lFirstSweep = (SIR[0] & (lSweepLength - 1));
  *lFirstSweep = lSweepLength - *lFirstSweep;
  return (lSweepLength);
/*****************************************************************************/
/*                                                                           */
/* DCMRHighBit returns a long with exactly one of the 32 bits set to 1. This */
/* bit position corresponds to the highest bit in the DCMR that has a 1.     */
/*                                                                           */
/*****************************************************************************/
long32 Cam8SimCore::DCMRHighBit(void)
  long32 lTemp1, lTemp2;                                                      
  lTemp1 = DCM[0];
  lTemp2 = 1;
  while (lTemp1 > 1) {
    lTemp1 >>= 1;
    lTemp2 <<= 1;
  return (lTemp2);
/*****************************************************************************/
/*                                                                           */
/* DCMRLowBit returns a long with exactly one of the 32 bits set to 1. This  */
/* bit position corresponds to the lowest bit in the DCMR that has a 1. We   */
/* refer to this lowest dimension generically as the X dimension.            */
/*                                                                           */
/*****************************************************************************/
long32 Cam8SimCore::DCMRLowBit(void)
  long32 lTemp1, lTemp2;
  lTemp1 = DCM[0];
  lTemp2 = 1;
  lNumXBits = 1;
  while ((lTemp1 != 0) && ((lTemp1 & 0x01) == 0)) {
    lTemp1 >>= 1;
    lTemp2 <<= 1;
    lNumXBits++;
  return (lTemp2);
void Cam8SimCore::UpdateDCMR(void)
  lDCMRHighBit = DCMRHighBit();
  lDCMRLowBit = DCMRLowBit();
/*****************************************************************************/
/*                                                                           */
/* The following are general purpose routines that conveniently answer       */
/* queries about the sources and destinations that need to be updated        */
/*                                                                           */
/*****************************************************************************/
/*****************************************************************************/
/*                                                                           */
/* Is a particular source needed? Only checks those planes that will be      */
/* updated or used during the next scan.                                     */
/*                                                                           */
/*****************************************************************************/
bool Cam8SimCore::IsSrcNeeded(short nSrc)
  short i, j;
  short nLastDest;
  nLastDest = (nSrc == SRC_TBUS ? DEST_LUT : DEST_DISPLAY);
  for (i = nNumPlanes - 1; i >= 0; i--) {
    for (j = DEST_SITE_DATA; j <= nLastDest; j++) {
      if (bDestSrcMatrix[i][j][nSrc]) {
	return TRUE;
      }
    }
  return FALSE;
/*****************************************************************************/
/*                                                                           */
/* Checks to see if the source/map is the same for all planes for the given  */
/* destination.                                                              */
/*                                                                           */
/*****************************************************************************/
bool Cam8SimCore::IsSrcSame(short nDest)
  short i;
  byte *src, *map;
  switch (nDest) {
  case DEST_SITE_DATA:
    src = SDS;
    map = SDM;
    break;
  case DEST_EVENT_CT:
    src = ECS;
    map = ECM;
    break;
  case DEST_DISPLAY:
    src = DDS;
    map = DDM;
    break;
  case DEST_LUT:
    src = LAS;
    map = LAM;
    break;
  default:
    return FALSE;
    break;
  for(i = 1; i < nNumPlanes; i++)
    if ((src[0] != src[i]) || (map[0] != map[i]))
      return FALSE;
  return TRUE;
/*****************************************************************************/
/*                                                                           */
/* See if a particular destination will be changed during the current scan   */
/*                                                                           */
/*****************************************************************************/
bool Cam8SimCore::IsDestUpdated(short nDest)
  short i, j;
  for (i = nNumPlanes-1; i >= 0; i--)
    for ( j = SRC_SITE_DATA; j <= SRC_CONST_DATA; j++)
      if (bDestSrcMatrix[i][nDest][j])
	return(TRUE);
  return(FALSE);
/*****************************************************************************/
/*                                                                           */
/* Calculate the number of planes that will be updated or used in the next   */
/* scan.                                                                     */
/*                                                                           */
/*****************************************************************************/
unsigned short Cam8SimCore::CalcNumPlanes(void)
  bool       bPlaneUsed[CHIPS_PER_MOD];
  short      i, j;
  memset ((char *) bPlaneUsed, 0, CHIPS_PER_MOD * sizeof(bool));
  UpdateDestSrcMatrix();
  for (i = CHIPS_PER_MOD-1; i >= 0; i--) {
    for (j = DEST_SITE_DATA; j <= DEST_DISPLAY; j++) {
      if ( bDestSrcMatrix[i][j][SRC_SITE_DATA] || 
	  bDestSrcMatrix[i][j][SRC_GLUED_DATA] ) {
	bPlaneUsed[i] = TRUE;
      }
    }
    
    if (!bPlaneUsed[i]) {
      for (j = SRC_TBUS; j <= SRC_CONST_DATA; j++) {
	if (bDestSrcMatrix[i][DEST_SITE_DATA][j]) {
	  bPlaneUsed[i] = TRUE;
      }
    }
    if (bPlaneUsed[i])
      break;
  }  
  return ((unsigned short) i + 1);
/*****************************************************************************/
/*                                                                           */
/* Updates a matrix of sources and destinations. There are 5 sources, 4 dest */
/* and 16 planes. In addition, there is a bit per destination indicating     */
/* whether the map field selects an inverse function or just the function.   */
/* Thus, the SrcDestMatrix is a 6x4x16 matrix.                               */
/*                                                                           */
/*****************************************************************************/
void Cam8SimCore::UpdateDestSrcMatrix(void)
  short      i;
  char       *szFuncName = "UpdateDestSrcMatrix";    
  memset((char *) bDestSrcMatrix, 0, CHIPS_PER_MOD*NUM_SRC*NUM_DEST);
  for (i = 0; i < CHIPS_PER_MOD; i++) {
    
    /*
     * If the source for the site is the site then don't bother to generate
     * code for this.  If the map selects only the glue lines then the source
     * selection is irrelevant.  If the map selects MAP_G then this is
     * effectively the same as selecting site as the source.  If the map
     * selects CONST_0 or CONST_1 then we handle this as a special case.
     */
    if (SDS[i] != SRC_SITE_DATA)
      bDestSrcMatrix[i][DEST_SITE_DATA][SDS[i]] = TRUE;
    if ((SDM[i] != MAP_S) && (SDM[i] != MAP_S_BAR)) {
      if (SDM[i] != MAP_G)
	bDestSrcMatrix[i][DEST_SITE_DATA][SRC_GLUED_DATA] = TRUE;
      if ((SDM[i] == MAP_CONST_0) || (SDM[i] == MAP_CONST_1)) {
	bDestSrcMatrix[i][DEST_SITE_DATA][SRC_CONST_DATA] = TRUE;
	bDestSrcMatrix[i][DEST_SITE_DATA][SRC_GLUED_DATA] = FALSE;
	bDestSrcMatrix[i][DEST_SITE_DATA][SDS[i]] = FALSE;
      }
      if ((SDM[i] == MAP_G) || (SDM[i] == MAP_G_BAR))
	bDestSrcMatrix[i][DEST_SITE_DATA][SDS[i]] = FALSE;
    }
    /*
     * If the source for the event counter is constant zero then don't bother
     * to generate code for this.  If the map selects only the glue lines then
     * the source selection is irrelevant.
     */
    bDestSrcMatrix[i][DEST_EVENT_CT][ECS[i]] = TRUE;
    if ((ECM[i] != MAP_S) && (ECM[i] != MAP_S_BAR)) {
      bDestSrcMatrix[i][DEST_EVENT_CT][SRC_GLUED_DATA] = TRUE;
      if ((ECM[i] == MAP_CONST_0) || (ECM[i] == MAP_CONST_1)) {
	if (ECM[i] == MAP_CONST_1)
	  bDestSrcMatrix[i][DEST_EVENT_CT][SRC_CONST_DATA] = TRUE;
	bDestSrcMatrix[i][DEST_EVENT_CT][SRC_GLUED_DATA] = FALSE;
	bDestSrcMatrix[i][DEST_EVENT_CT][ECS[i]] = FALSE;
      }
      if ((ECM[i] == MAP_G) || (ECM[i] == MAP_G_BAR))
 	bDestSrcMatrix[i][DEST_EVENT_CT][ECS[i]] = FALSE;
    }
    /*
     * If the source for the display is the host (tbus) then don't bother to
     * generate code for this.  If the map selects only the glue lines then
     * the source selection is irrelevant.
     */
    if ((DDS[i] != SRC_TBUS))
      bDestSrcMatrix[i][DEST_DISPLAY][DDS[i]] = TRUE;
    if ((DDM[i] != MAP_S) && (DDM[i] != MAP_S_BAR)) {
      bDestSrcMatrix[i][DEST_DISPLAY][SRC_GLUED_DATA] = TRUE;
      if ((DDM[i] == MAP_CONST_0) || (DDM[i] == MAP_CONST_1)) {
	bDestSrcMatrix[i][DEST_DISPLAY][SRC_CONST_DATA] = TRUE;
	bDestSrcMatrix[i][DEST_DISPLAY][SRC_GLUED_DATA] = FALSE;
	bDestSrcMatrix[i][DEST_DISPLAY][DDS[i]] = FALSE;
      }
      if ((DDM[i] == MAP_G) || (DDM[i] == MAP_G_BAR)) {
	bDestSrcMatrix[i][DEST_DISPLAY][DDS[i]] = FALSE;
      }
    }
    /*
     * If the map selects only the glue lines then the source selection is
     * irrelevant.
     */
    bDestSrcMatrix[i][DEST_LUT][LAS[i]] = TRUE;
    if ((LAM[i] != MAP_S) && (LAM[i] != MAP_S_BAR)) {
      bDestSrcMatrix[i][DEST_LUT][SRC_GLUED_DATA] = TRUE;
      if ((LAM[i] == MAP_CONST_0) || (LAM[i] == MAP_CONST_1)) {
	bDestSrcMatrix[i][DEST_LUT][SRC_CONST_DATA] = TRUE;
	bDestSrcMatrix[i][DEST_LUT][SRC_GLUED_DATA] = FALSE;
	bDestSrcMatrix[i][DEST_LUT][LAS[i]] = FALSE;
      }
      if ((LAM[i] == MAP_G) || (LAM[i] == MAP_G_BAR)) {
	bDestSrcMatrix[i][DEST_LUT][LAS[i]] = FALSE;
      }
    }
/* Unpack register of length < 32 bits or register field */
void Cam8SimCore::UnpackState(int16 *base, int reg_fld, int imm)
  if (BITLEN(reg_fld) > 32) {
    WARNING("Can't unpack a register or field of len > 32", "UnpackState");
    UnpackBits(base, BITOFF(reg_fld), 32, imm, base_type[reg_fld].base,
	       base_type[reg_fld].type);
  else
    UnpackBits(base, BITOFF(reg_fld), BITLEN(reg_fld), imm,
	       base_type[reg_fld].base, base_type[reg_fld].type);
void Cam8SimCore::UnpackStateInto(int16 *base, int reg_fld, int imm, byte *dest, int type)
  if (BITLEN(reg_fld) > 32) {
    WARNING("Can't unpack a register or field of len > 32", "UnpackStateInto");
    UnpackBits(base, BITOFF(reg_fld), 32, imm, dest, type);
  else
    UnpackBits(base, BITOFF(reg_fld), BITLEN(reg_fld), imm, dest, type);
/* Pack register of length < 32 bits or register field */
void Cam8SimCore::PackState(int16 *base, int reg_fld)
  if (BITLEN(reg_fld) > 32) {
    WARNING("Can't pack a register or field of len > 32", "PackState");
    PackBits(base, BITOFF(reg_fld), 32, base_type[reg_fld].base,
	     base_type[reg_fld].type);
  else
    PackBits(base, BITOFF(reg_fld), BITLEN(reg_fld),
	     base_type[reg_fld].base, base_type[reg_fld].type);
void Cam8SimCore::PackStateFrom(int16 *base, int reg_fld, byte *src, int type)
  if (BITLEN(reg_fld) > 32) {
    WARNING("Can't pack a register or field of len > 32", "PackStateFrom");
    PackBits(base, BITOFF(reg_fld), 32, src, type);
  else
    PackBits(base, BITOFF(reg_fld), BITLEN(reg_fld), src, type);


---------------------------------------------------------------------------

#include <CaLibStream++.H>
#include <CaLibError++.H>
#include <CaLibTrace++.H>
#include <CamLib++.H>
#include <Cam8SimJIT++.H>
#include <Cam8SimSPARCJIT++.H>
#include "std++.H"
Cam8SimSPARCJIT::Cam8SimSPARCJIT(Cam8SimRegMgr *rm)
  regmgr = rm;
  hcodTarget = NULL;						 /* Handle to Target Code Location   */
  pcodNext = NULL;						 /* Pointer to location of next inst */
  lblNext = 0;							 /* Next Label 			     */
  pblkTOS = NULL;
Cam8SimSPARCJIT::~Cam8SimSPARCJIT(void)
/*****************************************************************************/
/*                                                                           */
/* Translate an intermediate instruction into target code. 		     */
/*                                                                           */
/*****************************************************************************/
void Emit(INT16 opcode,
	  BYTE op1Type, LONG32 op1,
	  BYTE op2Type, LONG32 op2,
	  BYTE destType, LONG32 dest)
     char *szFuncName = "Emit";
     
#ifdef DEBUG
     DASMADDR = pcodNext;
#endif
     if (opcode & NATIVE_OP) {							 /* NATIVE INSTRUCTION 		     */
	  REGISTER rs1, rs2, rd;						 
	  switch (op1Type) {							 /* Figure out rs1 		     */
	     case NULL_OP:
	       rs1 = REG_G0;
	       break;
	     case REG_OP:
	       rs1 = (REGISTER) op1;
	       break;
	     case VAR_OP:
	       rs1 = GetReg(op1, CURRENT_HANDLE, TRUE);
	       break;
	     default:
	       CRITICAL_ERROR("Invalid argument for rs1", szFuncName);
	       break;
	  }
	  switch (destType) {							 /* Figure out the dest register     */
	     case NULL_OP:
	       rs1 = REG_G0;
	       break;
	     case REG_OP:
	       rd = (REGISTER) dest;
	       break;
	     case VAR_OP:
	       rd = GetReg(dest, CURRENT_HANDLE, FALSE);
	       break;
	     default:
	       CRITICAL_ERROR("Invalid argument for rd", szFuncName);
	       break;
	  }
	  switch (op2Type) {							 /* Figure out rs2. This is done     */
	     case REG_OP:							 /* last because rs2 might be a      */
	       rs2 = (REGISTER) op2;						 /* constant > 13 bits, and we might */
	       break;								 /* have to preload it into the dest */
	     case VAR_OP:
	       rs2 = GetReg(op2, CURRENT_HANDLE, TRUE);
	       break;
	     case CONST_OP:
	       if (((signed long) op2) > 4095 ||				 /* if op2 will not fit in 13 bits   */
		   ((signed long) op2) < -4096) {
		    EMIT( SETHI(HI22(op2), rd) );
		    EMIT( OR_REG_IMM(rd, LOW10(op2), rd) );
		    op2Type = REG_OP;
		    rs2 = rd;
	       }
	       break;
	       
	     default:
	       CRITICAL_ERROR("Invalid argument for rs2", szFuncName);
	       break;
	  }
	  opcode = opcode & NATIVE_OP_MASK;					 /* extract the target's native op-  */
										 /* code... 			     */
	  if (op2Type == CONST_OP) {
	       *pcodNext++ = FMT3_INST(0x02L, opcode, rs1, IMMEDIATE, op2, rd);	 /* and emit the instruction 	     */
	  } else {
	       *pcodNext++ = FMT3_INST(0x02L, opcode, rs1, REG_SOURCE, rs2, rd);
	  }									 /* -------------------------------- */
     } else if (opcode & LD_ST_OP) {						 /* LOAD-STORE INSTRUCTION 	     */
	  REGISTER rs1, rs2, rd;
	  switch (opcode) {
	     case LDW_MEM:							 /* bring op1 into a register 	     */
	       if (op1Type == VAR_OP) {
		    rs1 = GetReg(op1, CURRENT_HANDLE, TRUE);
	       } else {
		    CRITICAL_ERROR("Invalid LDW_MEM argument",
				   szFuncName);
	       }
	       break;
	     case LDUB_IND:
	     case LDHW_IND:
	     case LDW_IND:							 /* load indirect : dest <- [op1+op2]*/
	       if (op1Type == VAR_OP) {
		    rs1 = GetReg(op1, CURRENT_HANDLE, TRUE);
	       } else if (op1Type == REG_OP) {
		    rs1 = (REGISTER) op1;
	       } else {
		    CRITICAL_ERROR("Invalid LDW_IND argument 1",
				   szFuncName);
	       }
	       if (op2Type == VAR_OP) {
		    rs2 = GetReg(op2, CURRENT_HANDLE, TRUE);
	       } else if (op2Type == REG_OP) {
		    rs2 = (REGISTER) op2;
	       } else if (op2Type == CONST_OP) {
		    /* do nothing */
	       } else {
		    CRITICAL_ERROR("Invalid LDW_IND argument 2",
				   szFuncName);
	       }
		    
	       if (destType == VAR_OP) {
		    rd = GetReg(dest, CURRENT_HANDLE, FALSE);
	       } else if (op2Type == REG_OP) {
		    rd = (REGISTER) dest;
	       } else {
		    CRITICAL_ERROR("Invalid LDW_IND argument",
				   szFuncName);
	       }
	       
	       if (opcode == LDW_IND) {
		    (op2Type == CONST_OP) ? (EMIT( LDW_REG_IMM(rs1, op2, rd) )) :
		      (EMIT( LDW_REG_REG(rs1, rs2, rd)));
	       } else if (opcode == LDHW_IND) {
		    (op2Type == CONST_OP) ? (EMIT( LDHW_REG_IMM(rs1, op2, rd) )) :
		      (EMIT( LDHW_REG_REG(rs1, rs2, rd)));	
	       } else {
		    (op2Type == CONST_OP) ? (EMIT( LDUB_REG_IMM(rs1, op2, rd) )) :
		      (EMIT( LDUB_REG_REG(rs1, rs2, rd) ));
	       }
	       break;
	       
	     case STW_MEM:							 /* flush op1 to memory 	     */
	       if (op1Type == VAR_OP) {
		    rs1 = GetReg(op1, CURRENT_HANDLE, TRUE);			 /* 	hopefully, op1 is already    */
		    FlushReg(rs1, CURRENT_HANDLE);				 /* 	in a register!		     */
	       } else {
		    CRITICAL_ERROR("Invalid STW_MEM argument",
				   szFuncName);
	       }
	       break;
	     case STUB_IND:
	     case STHW_IND:
	     case STW_IND:							 /* store indirect: [op1+op2] <- dest*/
	       if (op1Type == VAR_OP) {						 /* 	get op1 - var or reg 	     */
		    rs1 = GetReg(op1, CURRENT_HANDLE, TRUE);
	       } else if (op1Type == REG_OP) {
		    rs1 = (REGISTER) op1;
	       } else {
		    CRITICAL_ERROR("Invalid STW_IND argument",
				   szFuncName);
	       }
	       if (op2Type == VAR_OP) {						 /* 	get op2 - var, reg, or const */
		    rs2 = GetReg(op2, CURRENT_HANDLE, TRUE);
	       } else if (op2Type == REG_OP) {
		    rs2 = (REGISTER) op2;
	       } else if (op2Type == CONST_OP) {
		    /* do nothing */
	       } else {
		    CRITICAL_ERROR("Invalid LDW_IND argument 2",
				   szFuncName);
	       }
		    
	       if (destType == VAR_OP) {					 /* 	get dest - var or reg 	     */
		    rd = GetReg(dest, CURRENT_HANDLE, TRUE);
	       } else if (op2Type == REG_OP) {
		    rd = (REGISTER) dest;
	       } else {
		    CRITICAL_ERROR("Invalid STW_IND argument",
				   szFuncName);
	       }
	       if (opcode == STW_IND) {
		    (op2Type == CONST_OP) ? (EMIT( STW_REG_IMM(rs1, op2, rd))) :
		      (EMIT( STW_REG_REG(rs1, rs2, rd)));
	       } else if (opcode == STHW_IND) {
		    (op2Type == CONST_OP) ? (EMIT( STHW_REG_IMM(rs1, op2, rd))) :
		      (EMIT( STHW_REG_REG(rs1, rs2, rd)));
	       } else {
		    (op2Type == CONST_OP) ? (EMIT( STUB_REG_IMM(rs1, op2, rd))) :
		      (EMIT( STUB_REG_REG(rs1, rs2, rd)));
	       }
	       break;
	       
	     default:
	       CRITICAL_ERROR("Unknown Load Store operation",
			      szFuncName);
	       break;
	  }									 /* -------------------------------- */
     } else if (opcode & BRANCH_OP) {						 /* BRANCH INSTRUCTION 		     */
	  LABELREC	*plblrecBranch;
	  LONG32	lDisp;
	  opcode &= NATIVE_OP_MASK;						 /* extract the native branch code   */
	  if (op1Type == LABEL_OP) {
	       if ((plblrecBranch = FindLabel((CODELABEL) op1)) != NULL) {	 /* if label was encountered before  */
		    CODEPTR pcodBranchLoc = GetLabelAddress(plblrecBranch);	 /*     Get address of branch loc    */
		    if (!pcodBranchLoc) {					 /* 	if label's addrss is unknown */
			 AddLabelRef(plblrecBranch, CURRENT_LOC);		 /* 	   add a ref record. 	     */
			 lDisp = 0;						 /* 	   dummy disp 		     */
		    } else {							 /*     else label's addr is known   */
			 lDisp = pcodBranchLoc - CURRENT_LOC;			 /*        calculate displacement    */
		    }
		    EMIT( BRANCH_INST(0, opcode, lDisp) );			 /* 	Emit branch instruction      */
	       } else {								 /* Label was not encountered before */
		    plblrecBranch = AddLabel((CODELABEL) op1, 0, FALSE);	 /* 	So create new record 	     */
		    AddLabelRef(plblrecBranch, CURRENT_LOC);			 /* 	add a ref record to it 	     */
		    EMIT( BRANCH_INST(0, opcode, 0) );				 /* 	emit filler branch instr     */
	       }
	  } else {
	       CRITICAL_ERROR("Branch to a non-label", szFuncName);
	  }									 /* -------------------------------- */
     } else {									 /* PSEUDO INSTRUCTION 		     */
	  switch (opcode) {
	     case INSTR:							 /* op1 is a valid sparc instruction */
	       EMIT( op1 );							 /* 	simply insert it 	     */
	       break;								 /* 	useful to fill delay slots   */
	       
	     case ENTER_PROC:							 /* procedure entry prologue 	     */
	       PushRegWindow();							 /*     Inform register manager of   */
	       if (op1Type == CONST_OP) {					 /*     new register window 	     */
		    EMIT( SAVE_REG_IMM(REG_SP, -112-8-op1, REG_SP) );		 /* 	-112 is gcc's local frame    */
	       } else {								 /*     and we need 2 words to save  */
		    EMIT( SAVE_REG_IMM(REG_SP, -112-8, REG_SP) );		 /* 	our own fp and return addr   */
	       }								 /*     registers. 		     */
	       EMIT( STW_REG_IMM(REG_SP, 72, REG_G7) );				 /* 	sp+8 = our fp register       */
	       EMIT( STW_REG_IMM(REG_SP, 68, REG_RA) );				 /* 	sp+4 = our return address    */
	       EMIT( SETHI(HI22(pcHeap), REG_DS) );				 /* 	make ds point to heap base   */
	       if ( LOW10(pcHeap) != 0) {
		    EMIT( OR_REG_IMM(REG_DS, LOW10(pcHeap), REG_DS) );
	       }
	       break;
	       
	     case RETURN_PROC:							 /* return from procedure 	     */
	       PopRegWindow(CURRENT_HANDLE);					 /* 	restore reg. window 	     */
	       EMIT( LDW_REG_IMM(REG_SP, 72, REG_G7) );				 /* 	restore saved fp register    */
	       EMIT( LDW_REG_IMM(REG_SP, 68, REG_RA) );				 /* 	restore our return address   */
	       EMIT( RET );							 /* 	return from procedure	     */
	       EMIT( RESTORE );							 /* 	and restore the reg window   */
	       break;
	       
	     case CALL_PROC:							 /* call a procedure 		     */
	       if (op1Type == ADDR_OP) {
		    op1 -= (LONG32) pcodNext;
		    EMIT( CALL(op1) );						 /* 	call procedure at addr op1   */
	       } else {
		    CRITICAL_ERROR("Invalid procedure call", szFuncName);
	       }
	       break;
	     case ENTER_LEAF:							 /* leaf procedure entry 	     */
	       SaveRegState();							 /*     Save all the live registers  */
	       break;
	     case RETURN_LEAF:							 /* return from leaf procedure 	     */
	       RestoreRegState(CURRENT_HANDLE);					 /*  	Restore live registers	     */
	       EMIT( RETL );							 /*     return to caller 	     */
	       EMIT( NOP );							 /* 	delay slot 		     */
	       break;
	       
	     case CALL_LEAF:							 /* call a leaf procedure 	     */
	       if (op1Type == ADDR_OP) {
		    EMIT( SETHI(HI22(op1), REG_RA) );
		    EMIT( CALL_REG_IMM(REG_RA, LOW10(op1)) );
	       } else {
		    CRITICAL_ERROR("Invalid leaf procedure call",
				   szFuncName);
	       }
	       break;
	     case CALL_LEAF_IND: {
		  REGISTER rs1, rs2, rd;
		  
		  if (op1Type == VAR_OP) {
		       rs1 = GetReg(op1, CURRENT_HANDLE, TRUE);
		  } else {
		       CRITICAL_ERROR("Invalid op1 : indirect leaf procedure call",
				      szFuncName);
		  }
		  if (op2Type == CONST_OP) {
		       /* do nothing */
		  } else if (op2Type != NULL_OP) {
		       CRITICAL_ERROR("Invalid op2 : indirect leaf procedure call",
		       		      szFuncName);
		  } 
		  
		  EMIT( CALL_REG_IMM(rs1, op2) );
	       }
	       break;
		       
		       
	     case ENTER_BASICBLK:
	       SaveRegState();
	       break;
	     case RETURN_BASICBLK:
	       RestoreRegState(CURRENT_HANDLE);
	       break;
	       
	     case ADD_LABEL:							 /* define a label 		     */
	       if (op1Type == LABEL_OP) {
		    LABELREC *plblrec;
		    
		    if ((plblrec = FindLabel((CODELABEL) op1)) == NULL) {	 /* 	if first time seeing label   */
			 AddLabel((CODELABEL) op1, CURRENT_LOC, TRUE);		 /* 	   add a new label record    */
		    } else {							 /* 	else  			     */
			 ResolveRefs(plblrec, CURRENT_LOC);			 /* 	   resolve all refs to label */
		    }
	       } else {
		    CRITICAL_ERROR("Invalid operand to ADD_LABEL",		
				   szFuncName);
	       }
	       break;
	     case NO_OP:
	       EMIT( NOP );
	       break;
	       
	     default:
	       CRITICAL_ERROR("Unknown pseudo-op", szFuncName);
	       break;
     }
void ResolveRefs(LABELREC *plblrec, CODEPTR lAddress)
     if (plblrec->bValid == TRUE) {
	  WARNING("Possible redefinition of label", "ResolveRefs");
     } else {
	  LABELREF *prefNext;
	  CODEPTR pcodRefLoc;
	  LONG32 lDisp;
	  plblrec->bValid = TRUE;						 /* update label record for future   */
	  plblrec->lAddress = lAddress;						 /* reference resolutions 	     */
	  do {									 /* Now, update all references.      */
	       prefNext = plblrec->prefFirst;					 /* Assume at least one reference!   */
	       pcodRefLoc = prefNext->pcodRefLoc;				 
	       lDisp = lAddress - pcodRefLoc;					 /* calculate displacement 	     */
	       lDisp &= 0x3FFFFF;						 /* least sig 22 bits only 	     */
	       *pcodRefLoc |= lDisp;						 /* and patch the refering instruct  */
	       plblrec->prefFirst = prefNext->prefNext;
	       FREE(prefNext, "ResolveRefs");					 /* release the reference record     */
	  } while (plblrec->prefFirst != NULL);
     }
     
void PrintAsm(CODEPTR pcodSource, FILE *fOut)
  CODEPTR pcod;
  unsigned short op;
  for (pcod = pcodSource; *pcod != 0; pcod++) {
    
    fprintf(fOut, "0x%x: ", pcod);
    
    op = (*pcod >> 30) & 0x3L;
    switch (op) {
    case 0:
      Fmt2Instr(*pcod, fOut);
      break;
      
    case 1:
      Fmt1Instr(*pcod, fOut);
      break;
      
    case 2:
    case 3:
      Fmt3Instr(*pcod, fOut);
      break;
    }
void Fmt1Instr(INSTRUCTION instr, FILE *fOut)
  fprintf(fOut, "CALL \t%x\n", (instr & 0x3FFFFFFFL));
void Fmt2Instr(INSTRUCTION instr, FILE *fOut)
  unsigned short op2, cc, rd;
  signed long disp;
  op2 = (instr >> 22) & 0x7L;
  if (op2 == 4) {								 /* SETHI 			     */
    unsigned long hi22;
    hi22 = (instr << 10);
    rd = (instr >> 25) & 0x1FL;
    fprintf(fOut,"SETHI \t%s, \t%x (%x)\n", szRegName[rd],
	    (instr & 0x003FFFFFL), hi22);
  } else if (op2 == 2) {							 /* BRANCH 			     */
    cc = (instr >> 25) & 0xFL;
    if (instr & 0x00200000L) {
      disp = instr | 0xFFC00000L;
    } else {
      disp = instr & 0x1FFFFF;
    }
    fprintf(fOut,"BR%s \t%d\n", szCCName[cc], disp);
  } else {
    fprintf(fOut,"UNIMP BR : %x\n", instr);
void Fmt3Instr(INSTRUCTION instr, FILE *fOut)
  unsigned short majorOp, opcode, imm, rs1, rs2, rd;
  signed long lConst;
  majorOp = (instr >> 30) & 0x3L;
  opcode = (instr >> 19) & 0x3FL;
  rd = (instr >> 25) & 0x1FL;
  rs1 = (instr >> 14) & 0x1FL;
  rs2 = instr & 0x1FL;
  imm = (instr >> 13) & 0x1L;
  if (imm) {
    if (instr & 0x00001000L) {
      lConst = (instr | 0xFFFFF000L);
    } else {
      lConst = (instr & 0xFFFL);
    }
  if (majorOp == 3) {							 /* LOAD-STORE 			     */
    switch (opcode) {
    case OP_LDW:
      fprintf(fOut,"LDW ");
      break;
    case OP_LDHW:
      fprintf(fOut,"LDHW ");
      break;
    case OP_LDUB:
      fprintf(fOut,"LDUB ");
      break;
    case OP_STW:
      fprintf(fOut,"STW ");
      break;
    case OP_STUB:
      fprintf(fOut,"STUB ");
      break;
      
    default:
      fprintf(fOut,"UNIMP LOAD-STORE : %x\n", instr);
      return;
      break;
    };
  } else {									 /* ARITHMETIC 			     */
    switch (opcode) {
    case OP_ADD:
      fprintf(fOut,"ADD ");
      break;
    case OP_ADDcc:
      fprintf(fOut,"ADDcc ");
      break;
    case OP_ADDX:
      fprintf(fOut,"ADDX ");
      break;
    case OP_ADDXcc:
      fprintf(fOut,"ADDXcc ");
      break;
      
    case OP_SUB:
      fprintf(fOut,"SUB ");
      break;
    case OP_SUBcc:
      fprintf(fOut,"SUBcc ");
      break;
    case OP_SUBX:
      fprintf(fOut,"SUBX ");
      break;
    case OP_SUBXcc:
      fprintf(fOut,"SUBXcc ");
      break;
      
    case OP_AND:							 /* LOGICAL 			     */
      fprintf(fOut,"AND ");
      break;
    case OP_ANDcc:
      fprintf(fOut,"ANDcc ");
      break;
    case OP_ANDN:
      fprintf(fOut,"ANDN ");
      break;
    case OP_ANDNcc:
      fprintf(fOut,"ANDNcc ");
      break;
      
    case OP_OR:
      fprintf(fOut,"OR ");
      break;
    case OP_ORcc:
      fprintf(fOut,"ORcc ");
      break;
    case OP_ORN:
      fprintf(fOut,"ORN ");
      break;
    case OP_ORNcc:
      fprintf(fOut,"ORNcc ");
      break;
      
    case OP_XOR:
      fprintf(fOut,"XOR ");
      break;
    case OP_XORcc:
      fprintf(fOut,"XORcc ");
      break;
    case OP_XNOR:
      fprintf(fOut,"XNOR ");
      break;
    case OP_XNORcc:
      fprintf(fOut,"XNORcc ");
      break;
      
      
    case OP_SLL:
      fprintf(fOut,"SLL ");
      break;
    case OP_SRL:
      fprintf(fOut,"SRL ");
      break;
    case OP_SRA:
      fprintf(fOut,"SRA ");
      break;
      
    case OP_JMPL:							 /* CONTROL TRANSFER 		     */
      fprintf(fOut,"JMPL ");
      break;
    case OP_SAVE:
      fprintf(fOut,"SAVE ");
      break;
    case OP_RESTORE:
      fprintf(fOut,"RESTOR");
      break;
      
    default:
      fprintf(fOut,"UNIMP LOGICAL-ARITH : %x\n", instr);
      return;
      break;
    };
  if (imm) {
    fprintf(fOut,"\t%s \t%d \t%s\n", szRegName[rs1], lConst, szRegName[rd]);
  } else {
    fprintf(fOut,"\t%s \t%s \t%s\n", szRegName[rs1], szRegName[rs2],
	    szRegName[rd]);
#include <CaLibStream++.H>
#include <CaLibError++.H>
#include <CaLibTrace++.H>
#include <CamLib++.H>
#include <Cam8SimJIT++.H>
#include "std++.H"
void NewBlock(CODEHANDLE hcodDest)
     void pushblk(void);
     
     /* save code block state */
     pushblk();
     /* point to new code block */
     hcodTarget = hcodDest;
     pcodNext = *hcodDest;
     lblNext = 0;
void EndBlock()
     void popblk(void);
     /* Free up all label records */
     FreeLabels();
     *pcodNext = 0L;
     /* Update caller's code handle */
     *hcodTarget = pcodNext;
     /* Restore previous block state */
     popblk(); 
CODELABEL NewLabel()
     return (lblNext++);
LABELREC *AddLabel(CODELABEL lblName, CODEPTR pcodLabelLoc, BOOL bValid)
     LABELREC	*plblrecNew;
     plblrecNew = (LABELREC *) MALLOC(sizeof(LABELREC), "AddLabel");
     plblrecNew->lblName = lblName;
     if ((plblrecNew->bValid = bValid) == TRUE) {
	  plblrecNew->lAddress = pcodLabelLoc;
     }
     plblrecNew->precNext = plblrecFirst;
     plblrecNew->prefFirst = NULL;
     plblrecFirst = plblrecNew;
     return (plblrecNew);
LABELREC *FindLabel(CODELABEL lblName)
     LABELREC *plblrecNext;
     for (plblrecNext = plblrecFirst;
	  (plblrecNext != NULL) && (plblrecNext->lblName != lblName);
	  plblrecNext = plblrecNext->precNext);
     return (plblrecNext);
CODEPTR GetLabelAddress(LABELREC *plblrec)
     if (plblrec->bValid) {
	  return (plblrec->lAddress);
     } else {
	  return (NULL);
     }
void AddLabelRef(LABELREC *plblrec, CODEPTR lAddress)
     LABELREF *prefNew;
     prefNew = (LABELREF *) MALLOC(sizeof(LABELREF), "AddLabelRef");
     prefNew->pcodRefLoc = lAddress;
     prefNew->prefNext = plblrec->prefFirst;
     plblrec->prefFirst = prefNew;
void FreeLabels()
     LABELREC *plblrec;
     while (plblrecFirst != NULL) {
	  plblrec = plblrecFirst;
	  plblrecFirst = plblrec->precNext;
	  FREE(plblrec, "FreeLabels");
     }
/*****************************************************************************/
/*                                                                           */
/* Simple stack manager for pushing and pop-ing code block states.	     */
/*                                                                           */
/*****************************************************************************/
void pushblk()
     CODEBLK *pNew;
     pNew = MALLOC(sizeof(CODEBLK), "icode : pushblk");
     pNew->hcodTarget = hcodTarget;
     pNew->pcodNext = pcodNext;
     pNew->lblNext = lblNext;
     pNew->plblrecFirst = plblrecFirst;
     
     pNew->pblkPrev = pblkTOS;
     pblkTOS = pNew;
     plblrecFirst = NULL;
void popblk()
     CODEBLK *pblkOld;
     if (!pblkTOS) {
	  CRITICAL_ERROR("I-Code Block stack underflow", "popblk");
     }
     hcodTarget = pblkTOS->hcodTarget;
     pcodNext = pblkTOS->pcodNext;
     lblNext = pblkTOS->lblNext;
     plblrecFirst = pblkTOS->plblrecFirst;
     pblkOld = pblkTOS;
     pblkTOS = pblkTOS->pblkPrev;
     FREE(pblkOld, "popblk");
#ifndef _CAM8SIMSPARCJIT_H_
#define _CAM8SIMSPARCJIT_H_
#include <CamLib++.H>
#include <Cam8SimSPARCRegMgr++.H>
#include "std++.H"
/*****************************************************************************/
/********************************* DEFINES ***********************************/
/*****************************************************************************/
#define OP_LDW		0x00L
#define OP_LDHW		0x02L
#define OP_LDUB		0x01L
#define OP_STW		0x04L
#define OP_STUB		0x05L
#define OP_STHW		0x06L
#define OP_ADD		0x00L
#define OP_ADDcc	0x10L
#define OP_ADDX		0x08L
#define OP_ADDXcc	0x18L
#define	OP_SUB		0x04L
#define OP_SUBcc	0x14L
#define OP_SUBX		0x0CL
#define OP_SUBXcc	0x1CL
#define OP_AND		0x01L
#define OP_ANDcc	0x11L
#define OP_ANDN		0x05L
#define OP_ANDNcc	0x15L
#define OP_OR		0x02L
#define OP_ORcc 	0x12L
#define OP_ORN		0x06L
#define OP_ORNcc	0x16L
#define OP_XOR		0x03L
#define OP_XORcc 	0x13L
#define OP_XNOR		0x07L
#define OP_XNORcc	0x17L
#define OP_SLL		0x25L
#define OP_SRL		0x26L
#define OP_SRA		0x27L
#define OP_SETHI	0x04L
#define OP_JMPL		0x38L
#define OP_SAVE		0x3CL
#define OP_RESTORE	0x3DL
#define IMMEDIATE	1
#define REG_SOURCE	0
#define FMT2_INST(op, opcode, k, rd) 	(((op) << 30) | \
					 ((opcode) << 22) | \
					 ((rd) << 25) | \
					 ((k) & 0x3fffffL))
#define FMT3_INST(op, opcode, rs1, i, rs2, rd) (((op) << 30) | \
						((rd) << 25) | \
						((opcode) << 19) | \
		       				((rs1) << 14) | \
						((i) << 13) | \
						((rs2) & 0x1FFFL))
#define SAVE_REG_IMM(rs1, k, rd)	(FMT3_INST(0x2L, OP_SAVE, (rs1), IMMEDIATE, (k), (rd)))
#define SAVE_REG_REG(rs1, rs2, rd)	(FMT3_INST(0x2L, OP_SAVE, (rs1), REG_SOURCE, (rs2), (rd)))
#define RESTORE				(FMT3_INST(0x2L, OP_RESTORE, REG_G0, REG_SOURCE, REG_G0, REG_G0))
#define RET				(FMT3_INST(0x2L, OP_JMPL, REG_I7, IMMEDIATE, 8, REG_G0))
#define RETL				(FMT3_INST(0x2L, OP_JMPL, REG_O7, IMMEDIATE, 8, REG_G0))
#define CALL_REG(r)			(FMT3_INST(0x2L, OP_JMPL, (r), IMMEDIATE, 0, REG_O7))
#define CALL_REG_IMM(r, k) 		(FMT3_INST(0x2L, OP_JMPL, (r), IMMEDIATE, (k), REG_O7))
#define CALL(disp)			((0x01 << 30) | (((unsigned long) (disp)) >> 2))
#define NOP				(FMT3_INST(0x2L, OP_OR, REG_G0, REG_SOURCE, REG_G0, REG_G0))
#define LDW_REG_IMM(rs1, k, rd) 	(FMT3_INST(0x3L, OP_LDW, rs1, IMMEDIATE, k, rd))
#define LDW_REG_REG(rs1, rs2, rd) 	(FMT3_INST(0x3L, OP_LDW, rs1, REG_SOURCE, rs2, rd))
#define LDHW_REG_IMM(rs1, k, rd) 	(FMT3_INST(0x3L, OP_LDHW, rs1, IMMEDIATE, k, rd))
#define LDHW_REG_REG(rs1, rs2, rd) 	(FMT3_INST(0x3L, OP_LDHW, rs1, REG_SOURCE, rs2, rd))
#define LDUB_REG_IMM(rs1, k, rd) 	(FMT3_INST(0x3L, OP_LDUB, rs1, IMMEDIATE, k, rd))
#define LDUB_REG_REG(rs1, rs2, rd) 	(FMT3_INST(0x3L, OP_LDUB, rs1, REG_SOURCE, rs2, rd))
#define STW_REG_IMM(rs1, k, rd) 	(FMT3_INST(0x3L, OP_STW, rs1, IMMEDIATE, k, rd))
#define STW_REG_REG(rs1, rs2, rd) 	(FMT3_INST(0x3L, OP_STW, rs1, REG_SOURCE, rs2, rd))
#define STHW_REG_IMM(rs1, k, rd) 	(FMT3_INST(0x3L, OP_STHW, rs1, IMMEDIATE, k, rd))
#define STHW_REG_REG(rs1, rs2, rd) 	(FMT3_INST(0x3L, OP_STHW, rs1, REG_SOURCE, rs2, rd))
#define STUB_REG_IMM(rs1, k, rd) 	(FMT3_INST(0x3L, OP_STUB, rs1, IMMEDIATE, k, rd))
#define STUB_REG_REG(rs1, rs2, rd) 	(FMT3_INST(0x3L, OP_STUB, rs1, REG_SOURCE, rs2, rd))
#define ADD_REG_IMM(rs1, k, rd) 	(FMT3_INST(0x2L, OP_ADD, rs1, IMMEDIATE, k, rd))
#define ADD_REG_REG(rs1, rs2, rd) 	(FMT3_INST(0x2L, OP_ADD, rs1, REG_SOURCE, rs2, rd))
#define ADDcc_REG_IMM(rs1, k, rd) 	(FMT3_INST(0x2L, OP_ADDcc, rs1, IMMEDIATE, k, rd))
#define ADDcc_REG_REG(rs1, rs2, rd) 	(FMT3_INST(0x2L, OP_ADDcc, rs1, REG_SOURCE, rs2, rd))
#define ADDX_REG_IMM(rs1, k, rd) 	(FMT3_INST(0x2L, OP_ADDX, rs1, IMMEDIATE, k, rd))
#define ADDX_REG_REG(rs1, rs2, rd) 	(FMT3_INST(0x2L, OP_ADDX, rs1, REG_SOURCE, rs2, rd))
#define ADDXcc_REG_IMM(rs1, k, rd) 	(FMT3_INST(0x2L, OP_ADDXcc, rs1, IMMEDIATE, k, rd))
#define ADDXcc_REG_REG(rs1, rs2, rd) 	(FMT3_INST(0x2L, OP_ADDXcc, rs1, REG_SOURCE, rs2, rd))
#define SUB_REG_IMM(rs1, k, rd) 	(FMT3_INST(0x2L, OP_SUB, rs1, IMMEDIATE, k, rd))
#define SUB_REG_REG(rs1, rs2, rd) 	(FMT3_INST(0x2L, OP_SUB, rs1, REG_SOURCE, rs2, rd))
#define SUBcc_REG_IMM(rs1, k, rd) 	(FMT3_INST(0x2L, OP_SUBcc, rs1, IMMEDIATE, k, rd))
#define SUBcc_REG_REG(rs1, rs2, rd) 	(FMT3_INST(0x2L, OP_SUBcc, rs1, REG_SOURCE, rs2, rd))
#define SUBX_REG_IMM(rs1, k, rd) 	(FMT3_INST(0x2L, OP_SUBX, rs1, IMMEDIATE, k, rd))
#define SUBX_REG_REG(rs1, rs2, rd) 	(FMT3_INST(0x2L, OP_SUBX, rs1, REG_SOURCE, rs2, rd))
#define SUBXcc_REG_IMM(rs1, k, rd) 	(FMT3_INST(0x2L, OP_SUBXcc, rs1, IMMEDIATE, k, rd))
#define SUBXcc_REG_REG(rs1, rs2, rd) 	(FMT3_INST(0x2L, OP_SUBXcc, rs1, REG_SOURCE, rs2, rd))
#define AND_REG_IMM(rs1, k, rd) 	(FMT3_INST(0x2L, OP_AND, rs1, IMMEDIATE, k, rd))
#define AND_REG_REG(rs1, rs2, rd) 	(FMT3_INST(0x2L, OP_AND, rs1, REG_SOURCE, rs2, rd))
#define OR_REG_IMM(rs1, k, rd) 		(FMT3_INST(0x2L, OP_OR, rs1, IMMEDIATE, k, rd))
#define OR_REG_REG(rs1, rs2, rd) 	(FMT3_INST(0x2L, OP_OR, rs1, REG_SOURCE, rs2, rd))
#define XOR_REG_IMM(rs1, k, rd) 	(FMT3_INST(0x2L, OP_XOR, rs1, IMMEDIATE, k, rd))
#define XOR_REG_REG(rs1, rs2, rd) 	(FMT3_INST(0x2L, OP_XOR, rs1, REG_SOURCE, rs2, rd))
#define XNOR_REG_IMM(rs1, k, rd) 	(FMT3_INST(0x2L, OP_XNOR, rs1, IMMEDIATE, k, rd))
#define XNOR_REG_REG(rs1, rs2, rd) 	(FMT3_INST(0x2L, OP_XNOR, rs1, REG_SOURCE, rs2, rd))
#define NOT_REG(r)			(XNOR_REG_REG(r, REG_G0, r))
#define SLL_REG_IMM(rs1, k, rd) 	(FMT3_INST(0x2L, OP_SLL, rs1, IMMEDIATE, k, rd))
#define SLL_REG_REG(rs1, rs2, rd) 	(FMT3_INST(0x2L, OP_SLL, rs1, REG_SOURCE, rs2, rd))
#define SRL_REG_IMM(rs1, k, rd) 	(FMT3_INST(0x2L, OP_SRL, rs1, IMMEDIATE, k, rd))
#define SRL_REG_REG(rs1, rs2, rd) 	(FMT3_INST(0x2L, OP_SRL, rs1, REG_SOURCE, rs2, rd))
#define HI22(k) 			((((unsigned long) (k)) >> 10) & 0x3fffffL)
#define LOW10(k) 			(((unsigned long) (k)) & 0x3ffL)
#define SETHI(k, rd) 			(FMT2_INST(0x0L, OP_SETHI, k, rd))
/******************************************************************************
 * The branch instructions.
 *****************************************************************************/
#define BRANCH_INST(annul, cond, disp)	(((annul) << 29) | ((cond) << 25) | (0x800000) | ((disp) & 0x3FFFFF))
#define BRA(disp)			(BRANCH_INST(0, 0x8, disp))
#define BRN(disp)			(BRANCH_INST(0, 0x0, disp))
#define BRNE(disp)			(BRANCH_INST(0, 0x9, disp))
#define BRE(disp)			(BRANCH_INST(0, 0x1, disp))
#define BRG(disp)			(BRANCH_INST(0, 0xA, disp))
#define BRLE(disp)			(BRANCH_INST(0, 0x2, disp))
#define BRGE(disp)			(BRANCH_INST(0, 0xB, disp))
#define BRL(disp)			(BRANCH_INST(0, 0x3, disp))
#define BRGU(disp)			(BRANCH_INST(0, 0xC, disp))
#define BRLEU(disp)			(BRANCH_INST(0, 0x4, disp))
#define BRCC(disp)			(BRANCH_INST(0, 0xD, disp))
#define BRCS(disp)			(BRANCH_INST(0, 0x5, disp))
#define BRPOS(disp)			(BRANCH_INST(0, 0xE, disp))
#define BRNEG(disp)			(BRANCH_INST(0, 0x6, disp))
#define BRVC(disp)			(BRANCH_INST(0, 0xF, disp))
#define BRVS(disp)			(BRANCH_INST(0, 0x7, disp))
#define BRNZ(disp)			(BRANCH_INST(0, 0x9, disp))
#define BRZ(disp)			(BRANCH_INST(0, 0x1, disp))
/*****************************************************************************/
/*                                                                           */
/* Macros to insert target instructions etc.				     */
/*                                                                           */
/*****************************************************************************/
#define EMIT(inst)			*pcodNext++ = (inst)
#define CURRENT_LOC			(pcodNext)
#define CURRENT_HANDLE			(&pcodNext)
#ifdef __cplusplus
/*****************************************************************************/
/******************************** TEMPLATES **********************************/
/*****************************************************************************/
/*****************************************************************************/
/*************************** CLASSES & TYPEDEFS ******************************/
/*****************************************************************************/
typedef unsigned long INSTRUCTION;
class Cam8SimSPARCJIT : Cam8SimJIT {
public:
  static const char *szRegName[] = {
    "%g0", "%g1", "%g2", "%g3", "%g4", "%g5", "%g6", "%g7",
    "%o0", "%o1", "%o2", "%o3", "%o4", "%o5", "%sp", "%tp",
    "%l0", "%l1", "%l2", "%l3", "%l4", "%l5", "%l6", "%l7",
    "%i0", "%i1", "%i2", "%i3", "%i4", "%i5", "%ds", "%ra"
  };
  static const char *szCCName[] = {
    "NEVER", "EQ", "LE", "L", "LEU", "CS", "NEG", "VS",
    "ALWAYS", "NEQ", "G", "GE", "GU", "CC", "POS", "VC"
  };
  void NewBlock(CODEHANDLE);
  void EndBlock();
  void Emit(INT16 opcode, BYTE op1Type, LONG32 op1, BYTE op2Type, LONG32 op2,
	    BYTE destType, LONG32 dest) = 0;
  void PrintAsm(CODEPTR pcodSource, FILE *fOut);
/*****************************************************************************/
/********************************* INLINES ***********************************/
/*****************************************************************************/
#endif
/*****************************************************************************/
/******************************* PROTOTYPES **********************************/
/*****************************************************************************/
/*****************************************************************************/
/********************************* GLOBALS ***********************************/
/*****************************************************************************/
#endif

---------------------------------------------------------------------------

#ifndef _CAM8SIM_H_
#define _CAM8SIM_H_
#include <CamLib++.H>
#include <Cam8Core++.H>
#include <Cam8++.H>
#include <Cam8SimJIT++.H>
#include "std++.H"
/*****************************************************************************/
/********************************* DEFINES ***********************************/
/*****************************************************************************/
#define PERM_CONST_1            31                                               
#define PERM_CONST_0            30
#define LONG32_SIZE		(sizeof(LONG32))
#define INT16_SIZE		(sizeof(INT16))
#define ACTIVE_LUT_SELECT	0x8000	 /* bit in Hardware Env Reg (HER)    */
#define FLD_SELECT(i)		((i) + 32)
#define FLD_MAP(i)		((i) + 64)
#define NUM_DEST		4
#define NUM_SRC			6
#define SRC_SITE_DATA		0
#define SRC_TBUS		1
#define SRC_FLYWHEEL		2
#define SRC_LUT			3
#define SRC_SITE_ADDRESS	3
#define SRC_GLUED_DATA		4
#define SRC_CONST_DATA		5
#define DEST_SITE_DATA		0
#define DEST_EVENT_CT		1
#define DEST_LUT		2
#define DEST_DISPLAY		3
#define MAP_CONST_0		0
#define MAP_G_NOR_S		1
#define MAP_G_AND_S_BAR		2
#define MAP_S_BAR		3
#define MAP_G_BAR_AND_S		4
#define MAP_G_BAR		5
#define MAP_G_XOR_S		6
#define MAP_G_NAND_S		7
#define MAP_G_AND_S		8
#define MAP_G_EQ_S		9
#define MAP_G			10
#define MAP_G_OR_S_BAR		11
#define MAP_S			12
#define MAP_G_BAR_OR_S		13
#define MAP_G_OR_S		14
#define MAP_CONST_1		15
#ifndef INTERPRETER
#define SCANNER_CODE_SIZE       (1024 * LONG32_SIZE)
#define SWEEP_CODE_SIZE         (1024 * LONG32_SIZE)
#define UPDATE_CODE_SIZE        (1024 * LONG32_SIZE)
#else !INTERPRETER
#define HIGHB(x)		(((x) & 0x80000000) ? 0x1 : 0x0)
#endif !INTERPRETER
#ifdef DEBUG
#define EP(name) fprintf(DEBUGFILE, "ENTER: %s\n", name)
#define LP(name) fprintf(DEBUGFILE, "LEAVE: %s\n", name)
#ifndef INTERPRETER
#define ASCODE(c)  fprintf(DEBUGFILE, "\t0x%x: %s\n", DASMADDR, c); fflush(DEBUGFILE)
#define ASNOTE(c)  fprintf(DEBUGFILE, "\t%s\n", c); fflush(DEBUGFILE)
#endif !INTERPRETER
#else DEBUG
#define EP(name)
#define LP(name)
#ifndef INTERPRETER
#define ASCODE(name)
#define ASNOTE(c)
#endif !INTERPRETER
#endif DEBUG
#ifdef __cplusplus
/*****************************************************************************/
/******************************** TEMPLATES **********************************/
/*****************************************************************************/
/*****************************************************************************/
/*************************** CLASSES & TYPEDEFS ******************************/
/*****************************************************************************/
typedef struct {
  char *base;
  int type;
} Bt, *BT;
class Cam8Sim : public Cam8 {
public:
  int VWECHK = 0;
  Bt base_type[790];
  CAM8SimJIT *jit;
  /* CAM8 Registers */
  BYTE MSR[CHIPS_PER_MOD];
  BYTE SSM[CHIPS_PER_MOD];
  BYTE RT[CHIPS_PER_MOD];
  BYTE ECT[CHIPS_PER_MOD];
  BYTE RPK[CHIPS_PER_MOD];
  BYTE ALT[CHIPS_PER_MOD];
  LONG32 KA[CHIPS_PER_MOD];
  BYTE XKS[CHIPS_PER_MOD];
  BYTE YKS[CHIPS_PER_MOD];
  BYTE ZKS[CHIPS_PER_MOD];
  BYTE XKMF[CHIPS_PER_MOD];
  BYTE YKMF[CHIPS_PER_MOD];
  BYTE ZKMF[CHIPS_PER_MOD];
  BYTE SABSR[CHIPS_PER_MOD];
  BYTE LAS[CHIPS_PER_MOD];
  BYTE LAM[CHIPS_PER_MOD];
  BYTE FOS[CHIPS_PER_MOD];
  BYTE FOM[CHIPS_PER_MOD];
  BYTE SDS[CHIPS_PER_MOD];
  BYTE SDM[CHIPS_PER_MOD];
  BYTE ECS[CHIPS_PER_MOD];
  BYTE ECM[CHIPS_PER_MOD];
  BYTE DDS[CHIPS_PER_MOD];
  BYTE DDM[CHIPS_PER_MOD];
  BYTE SSR[CHIPS_PER_MOD];
  LONG32 ECR[CHIPS_PER_MOD];
  INT16 LIR[CHIPS_PER_MOD];
  BYTE LIPR[CHIPS_PER_MOD];
  INT16 *LIOR;
  LONG32 SIR[CHIPS_PER_MOD];
  BYTE SSA[24][CHIPS_PER_MOD];
  BYTE *SIOR;
  BYTE SM[CHIPS_PER_MOD];
  BYTE ESC[CHIPS_PER_MOD];
  BYTE ESW[CHIPS_PER_MOD];
  BYTE EST[CHIPS_PER_MOD];
  BYTE SBRC[CHIPS_PER_MOD];
  BYTE RCL[CHIPS_PER_MOD];
  BYTE ECL[CHIPS_PER_MOD];
  BYTE STM[CHIPS_PER_MOD];
  LONG32 OSR[CHIPS_PER_MOD];
  LONG32 DCM[CHIPS_PER_MOD];
  BYTE XDCP[CHIPS_PER_MOD];
  BYTE YDCP[CHIPS_PER_MOD];
  BYTE ZDCP[CHIPS_PER_MOD];
  BYTE LPL[CHIPS_PER_MOD];
  BYTE FPL[CHIPS_PER_MOD];
  BYTE DCS[CHIPS_PER_MOD];
  BYTE TBD[CHIPS_PER_MOD];
  BYTE TMS[CHIPS_PER_MOD];
  BYTE NBF[CHIPS_PER_MOD];
  BYTE SRE[CHIPS_PER_MOD];
  BYTE ALS[CHIPS_PER_MOD];
  BYTE MAFS[CHIPS_PER_MOD];
  BYTE MBFS[CHIPS_PER_MOD];
  BYTE XMPC[CHIPS_PER_MOD];
  BYTE XPPC[CHIPS_PER_MOD];
  BYTE YMPC[CHIPS_PER_MOD];
  BYTE YPPC[CHIPS_PER_MOD];
  BYTE ZMPC[CHIPS_PER_MOD];
  BYTE ZPPC[CHIPS_PER_MOD];
  BYTE MIDR[CHIPS_PER_MOD];
  BYTE GIDR[CHIPS_PER_MOD];
  BYTE BPIE[CHIPS_PER_MOD];
  BYTE BCIE[CHIPS_PER_MOD];
  BYTE GCIE[CHIPS_PER_MOD];
  BYTE MAIE[CHIPS_PER_MOD];
  BYTE MBIE[CHIPS_PER_MOD];
  BYTE SSIE[CHIPS_PER_MOD];
  BYTE XHIE[CHIPS_PER_MOD];
  BYTE RLIE[CHIPS_PER_MOD];
  BYTE URIE[CHIPS_PER_MOD];
  BYTE ISIE[CHIPS_PER_MOD];
  BYTE BPIF[CHIPS_PER_MOD];
  BYTE BCIF[CHIPS_PER_MOD];
  BYTE GCIF[CHIPS_PER_MOD];
  BYTE MAIF[CHIPS_PER_MOD];
  BYTE MBIF[CHIPS_PER_MOD];
  BYTE SSIF[CHIPS_PER_MOD];
  BYTE XHIF[CHIPS_PER_MOD];
  BYTE RLIF[CHIPS_PER_MOD];
  BYTE URIF[CHIPS_PER_MOD];
  BYTE ISIF[CHIPS_PER_MOD];
  BYTE VWE[CHIPS_PER_MOD];
  BYTE VWIE[CHIPS_PER_MOD];
  BYTE VWIF[CHIPS_PER_MOD];
  BYTE LDOC[CHIPS_PER_MOD];
  BYTE HDOC[CHIPS_PER_MOD];
  unsigned short nNumPlanes;
  BYTE WhyScan;
#ifdef _FRAMEBUFFER_
  BYTE *FRAMEb;							/* FRAME buffer */
#endif _FRAMEBUFFER_
  BOOL bDestSrcMatrix [CHIPS_PER_MOD][NUM_DEST][NUM_SRC];
  BOOL bSourceRegChange;
  BOOL bDestChange;
  BOOL bForceGeneralScan;
  BOOL bByteMode;
  BOOL bImmediate;
  BOOL bReadMode;
  INT16 *LUTb[2];						/* LUT buffers */
  LONG32 SITE_ADDR;
  LONG32 lDCMRHighBit;
  LONG32 lDCMRLowBit;
  LONG32 lNumXBits;
#ifndef INTERPRETER
  CODE *pcodScanNoPerm;
  CODEPTR pcodGenUpdate;
  CODEPTR pcodScanner;
  CODEPTR pcodSweep;
  CODEPTR pcodUpdateSite;
#else !INTERPRETER
  LONG32 bit;
  LONG32 HIGH_BIT_MASK;
  LONG32 X_HIGH_BIT_MASK;
  LONG32 X_BYTE_LENGTH;
  LONG32 X_CTR;
  LONG32 SITE_CTR;
  LONG32 OFFSETS[CHIPS_PER_MOD];
  LONG32 BIT_OFFSETS[CHIPS_PER_MOD];
  LONG32 DCMR;
  LONG32 SCAN_INDEX_REG;
  LONG32 LUT_ADDR;
  LONG32 BIT_PLANE_ADDR[CHIPS_PER_MOD];
  LONG32 NEXT_WORD_ADDR[CHIPS_PER_MOD];
  LONG32 PLANE_WORD[CHIPS_PER_MOD];
  LONG32 EVENT_COUNT[CHIPS_PER_MOD];
  LONG32 UNGLUE_DATA;
  LONG32 GLUE_DATA;
  LONG32 SITE_DATA;
  LONG32 TBUS_DATA;
  LONG32 LUT_DATA;
  LONG32 DISP_DATA;
  LONG32 TBUS_ADDR;
  LONG32 FRAME_ADDR;
  LONG32 TEMP1;
  LONG32 TEMP2;
  LONG32 TEMP3;
  LONG32 TEMP4;
  LONG32 TEMP5;
  LONG32 TEMP6;
  LONG32 TEMP7;
  LONG32 TEMP8;
  LONG32 TEMP9;
  LONG32 TEMP10;
#endif !INTERPRETER
#ifdef DEBUG
  FILE* DEBUGFILE;
#ifndef INTERPRETER
  CODEPTR DASMADDR;
#endif !INTERPRETER
#endif DEBUG
#ifdef _INSTRUMENTATION_
  struct timeval tvStart, tvEnd;
  struct timezone tzZone;
#endif
  Cam8Sim(void);
  DECL_COPYCONST(Cam8Sim);
  virtual ~Cam8Sim(void);
  DECL_OPEQ(Cam8Sim);
  DECL_BZERO(Cam8Sim);
  DECL_BCOPY(Cam8Sim);
  DECL_BCMP(Cam8Sim);
  void InitSimulator(Cam8Core *);
  void InitStepList(void);
  void InitExitProcs();
  void ExitSigProc();
  void ExitProc();
  void UnpackState(INT16 *, int, int);
  void UnpackStateInto(INT16 *, int, int, BYTE *, int);
  void PackState(INT16 *, int);
  void PackStateFrom(INT16 *, int, BYTE *, int);
#ifndef INTERPRETER
  void InitSim(void);
  void SimScanNoPerm(CODEHANDLE hcodCurrent);
  void SimGeneralScan(CODEHANDLE hcodCurrent);
  void SimPrologue(CODEHANDLE hcodCurrent);
  void SimEpilogue(CODEHANDLE hcodCurrent);
  void SimUpdateSite();
  void SimLoadFirstWord(unsigned short nBitOffset[]);
  void SimGetNextWord(unsigned short nPlane);
  void SimSaveLastWord(unsigned short nBitOffset[]);
  void CheckNoPerm(CODEHANDLE hcodCurrent);
  void SimUpdateCode();
  void SimLoadPlaneWords();
  void SimSavePlaneWords();
  void MapFunction (short iSrcVar, short iDestVar, BYTE bMap);
  void BuildDest(short nDest, short iDestVar, BYTE Src, BYTE Map);
  void BuildBitDest(short nDest, short iHoldReg, BYTE Src, BYTE Map, unsigned short nPlane);
  void BuildBitwiseDest(short nDest, short iDestVar, BYTE Src[], BYTE Map[]);
  short PermuteScanIndex();
#else !INTERPRETER
  void SimScanNoPerm();
  void SimGeneralScan();
  void SimUpdateSite();
  void CheckNoPerm();
  void SimLoadFirstWord(LONG32 nBitOffset[]);
  void SimGetNextWord(unsigned short nPlane);
  void SimSaveLastWord(LONG32 nBitOffset[]);
  void SimUpdateCode();
  void SimLoadPlaneWords();
  void SimSavePlaneWords();
  void MapFunction (LONG32 *SrcVar, LONG32 *DestVar, BYTE bMap);
  void BuildDest(short nDest, LONG32 *DestVar, BYTE Src, BYTE Map);
  void BuildBitDest(short nDest, LONG32 *HoldReg, BYTE Src, BYTE Map, unsigned short nPlane);
  void BuildBitwiseDest(short nDest, LONG32 *DestVar, BYTE Src[], BYTE Map[]);
  LONG32 *PermuteScanIndex();
#endif !INTERPRETER
  void InitModule(void);
  void SimStepList(LONG32 *plFirstInstr);
  void SimScan(void);
  void UpdateDCMR(void);
  void UpdateDestSrcMatrix(void);
  void UpdateDCMR();
  void UpdateDestSrcMatrix();
  unsigned short CalcNumPlanes();
  unsigned short CalcNumPlanes(void);
  BOOL IsSrcNeeded(short nSrc);
  BOOL IsSrcSame(short nDest);
  BOOL IsDestUpdated(short nDest);
  BOOL IsSrcNeeded(short nSrc);
  BOOL IsSrcSame(short nDest);
  BOOL IsDestUpdated(short nDest);
  LONG32 AddSiteAddress(LONG32 lSrc1, LONG32 lSrc2);
  LONG32 SubSiteAddress(LONG32 lSrc1, LONG32 lSrc2);
  LONG32 ScanLength(void);
  LONG32 SweepLength(LONG32 *lFirstSweep);
  LONG32 AddSiteAddress(LONG32 lSrc1, LONG32 lSrc2);
  LONG32 SubSiteAddress(LONG32 lSrc1, LONG32 lSrc2);
  LONG32 ScanLength();
  LONG32 SweepLength(LONG32 *lFirstSweep);
  LONG32 DCMRHighBit();
  LONG32 DCMRLowBit();
  inline void ConstantSetAll(BYTE r[], BYTE v);
  inline void ConstantSetAll(INT16 r[], INT16 v);
  inline void ConstantSetAll(LONG32 r[], LONG32 v);
  inline void SetAll(BYTE r[], BYTE v[]);
  inline void SetAll(INT16 r[], INT16 v[]);
  inline void SetAll(LONG32 r[], LONG32 v[]);
protected:
  inline void SENTER(int i, char *b, int t);
/*****************************************************************************/
/********************************* INLINES ***********************************/
/*****************************************************************************/
inline void Cam8Sim::SENTER(int i, char *b, int t)
  base_type[i].base = b;
  base_type[i].type = t;
inline void Cam8Sim::ConstantSetAll(BYTE r[], BYTE v)
  register int i;
  for(i = 0; i < CHIPS_PER_MOD; i++)
    r[i]=v;
inline void Cam8Sim::ConstantSetAll(INT16 r[], INT16 v)
  register int i;
  for(i = 0; i < CHIPS_PER_MOD; i++)
    r[i]=v;
inline void Cam8Sim::ConstantSetAll(LONG32 r[], LONG32 v)
  register int i;
  for(i = 0; i < CHIPS_PER_MOD; i++)
    r[i]=v;
inline void Cam8Sim::SetAll(BYTE r[], BYTE v[])
  memcpy(r, v, CHIPS_PER_MOD * sizeof(BYTE));
inline void Cam8Sim::SetAll(INT16 r[], INT16 v[])
  memcpy(r, v, CHIPS_PER_MOD * sizeof(BYTE));
inline void Cam8Sim::SetAll(LONG32 r[], LONG32 v[])
  memcpy(r, v, CHIPS_PER_MOD * sizeof(BYTE));
#endif
/*****************************************************************************/
/******************************* PROTOTYPES **********************************/
/*****************************************************************************/
/*****************************************************************************/
/********************************* GLOBALS ***********************************/
/*****************************************************************************/
#endif
#include <CamLib++.H>
#include <CaLibStream++.H>
#include <CaLibError++.H>
#include <CaLibTrace++.H>
#include <Cam8Core++.H>
#include <Cam8SimSPARCJIT++.H>
#include <Cam8Sim++.H>
#include <CAM/CAM_instr.h>
#include <CAM/CAM_util.h>
#include "std++.H"
extern "C" {
#include <stdio.h>
#include <strings.h>
#include <setjmp.h>
#include <sys/mman.h>
#include <sys/types.h>
#include <sys/ipc.h>
#include <sys/shm.h>
#ifdef _INSTRUMENTATION_
#include <sys/time.h>
#endif
Cam8Sim::Cam8Sim(void)
  Bzero();
  bSourceRegChange = TRUE;
  bDestChange = TRUE;
  bForceGeneralScan = FALSE;
Cam8Sim::~Cam8Sim(void)
void Cam8Sim::InitSimulator(CAM8CORE co)
  CaLib_tb.ENTER("Cam8Sim::InitSimulator");
  CaLibAbort(!co, "NULL core object pointer");
  core = co;
  InitStepList();
  InitExitProcs();
#ifdef DEBUG
  /* Need to open a new file, set the CAMSTREAM dbug to it and turn on a flag */
#endif
#ifndef INTERPRETER
  InitSymbolTable();
#endif INTERPRETER
  InitHeap();
#ifndef INTERPRETER
  InitSim();
#endif INTERPRETER
  CaLib_tb.LEAVE();
void Cam8Sim::InitStepList()
  CaLib_tb.ENTER("Cam8Sim::InitStepList()");
  SENTER(RFINDEX(REG_MSR), MSR, BIT8);
  SENTER(RFINDEX(FLD_SSM), SSM, BIT8);
  SENTER(RFINDEX(FLD_RT), RT, BIT8);
  SENTER(RFINDEX(FLD_ECT), ECT, BIT8);
  SENTER(RFINDEX(FLD_RPK), RPK, BIT8);
  SENTER(RFINDEX(FLD_ALT), ALT, BIT8);
  SENTER(RFINDEX(FLD_KA), KA, BIT32);
  SENTER(RFINDEX(FLD_XKS), XKS, BIT8);
  SENTER(RFINDEX(FLD_YKS), YKS, BIT8);
  SENTER(RFINDEX(FLD_ZKS), ZKS, BIT8);
  SENTER(RFINDEX(FLD_XKMF), XKMF, BIT8);
  SENTER(RFINDEX(FLD_YKMF), YKMF, BIT8);
  SENTER(RFINDEX(FLD_ZKMF), ZKMF, BIT8);
  SENTER(RFINDEX(REG_SABSR), SABSR, BIT8);
  SENTER(RFINDEX(FLD_LAS), LAS, BIT8);
  SENTER(RFINDEX(FLD_LAM), LAM, BIT8);
  SENTER(RFINDEX(FLD_FOS), FOS, BIT8);
  SENTER(RFINDEX(FLD_FOM), FOM, BIT8);
  SENTER(RFINDEX(FLD_SDS), SDS, BIT8);
  SENTER(RFINDEX(FLD_SDM), SDM, BIT8);
  SENTER(RFINDEX(FLD_ECS), ECS, BIT8);
  SENTER(RFINDEX(FLD_ECM), ECM, BIT8);
  SENTER(RFINDEX(FLD_DDS), DDS, BIT8);
  SENTER(RFINDEX(FLD_DDM), DDM, BIT8);
  SENTER(RFINDEX(REG_SSR), SSR, BIT8);
  SENTER(RFINDEX(REG_ECR), ECR, BIT32);
  SENTER(RFINDEX(REG_LIR), LIR, BIT8);
  SENTER(RFINDEX(REG_LIPR), LIPR, BIT8);
  SENTER(RFINDEX(REG_SIR), SIR, BIT32);
  SENTER(RFINDEX(FLD_SSA0), SSA0, BIT8);
  SENTER(RFINDEX(FLD_SSA1), SSA1, BIT8);
  SENTER(RFINDEX(FLD_SSA2), SSA2, BIT8);
  SENTER(RFINDEX(FLD_SSA3), SSA3, BIT8);
  SENTER(RFINDEX(FLD_SSA4), SSA4, BIT8);
  SENTER(RFINDEX(FLD_SSA5), SSA5, BIT8);
  SENTER(RFINDEX(FLD_SSA6), SSA6, BIT8);
  SENTER(RFINDEX(FLD_SSA7), SSA7, BIT8);
  SENTER(RFINDEX(FLD_SSA8), SSA8, BIT8);
  SENTER(RFINDEX(FLD_SSA9), SSA9, BIT8);
  SENTER(RFINDEX(FLD_SSA10), SSA10, BIT8);
  SENTER(RFINDEX(FLD_SSA11), SSA11, BIT8);
  SENTER(RFINDEX(FLD_SSA12), SSA12, BIT8);
  SENTER(RFINDEX(FLD_SSA13), SSA13, BIT8);
  SENTER(RFINDEX(FLD_SSA14), SSA14, BIT8);
  SENTER(RFINDEX(FLD_SSA15), SSA15, BIT8);
  SENTER(RFINDEX(FLD_SSA16), SSA16, BIT8);
  SENTER(RFINDEX(FLD_SSA17), SSA17, BIT8);
  SENTER(RFINDEX(FLD_SSA18), SSA18, BIT8);
  SENTER(RFINDEX(FLD_SSA19), SSA19, BIT8);
  SENTER(RFINDEX(FLD_SSA20), SSA20, BIT8);
  SENTER(RFINDEX(FLD_SSA21), SSA21, BIT8);
  SENTER(RFINDEX(FLD_SSA22), SSA22, BIT8);
  SENTER(RFINDEX(FLD_SSA23), SSA23, BIT8);
  SENTER(RFINDEX(FLD_SM), SM, BIT8);
  SENTER(RFINDEX(FLD_ESC), ESC, BIT8);
  SENTER(RFINDEX(FLD_ESW), ESW, BIT8);
  SENTER(RFINDEX(FLD_EST), EST, BIT8);
  SENTER(RFINDEX(FLD_SBRC), SBRC, BIT8);
  SENTER(RFINDEX(FLD_RCL), RCL, BIT8);
  SENTER(RFINDEX(FLD_ECL), ECL, BIT8);
  SENTER(RFINDEX(FLD_STM), STM, BIT8);
  SENTER(RFINDEX(REG_OSR), OSR, BIT32);
  SENTER(RFINDEX(FLD_DCM), DCM, BIT32);
  SENTER(RFINDEX(FLD_XDCP), XDCP, BIT8);
  SENTER(RFINDEX(FLD_YDCP), YDCP, BIT8);
  SENTER(RFINDEX(FLD_ZDCP), ZDCP, BIT8);
  SENTER(RFINDEX(FLD_LPL), LPL, BIT8);
  SENTER(RFINDEX(FLD_FPL), FPL, BIT8);
  SENTER(RFINDEX(FLD_DCS), DCS, BIT8);
  SENTER(RFINDEX(FLD_TBD), TBD, BIT8);
  SENTER(RFINDEX(FLD_TMS), TMS, BIT8);
  SENTER(RFINDEX(FLD_NBF), NBF, BIT8);
  SENTER(RFINDEX(FLD_SRE), SRE, BIT8);
  SENTER(RFINDEX(FLD_ALS), ALS, BIT8);
  SENTER(RFINDEX(FLD_MAFS), MAFS, BIT8);
  SENTER(RFINDEX(FLD_MBFS), MBFS, BIT8);
  SENTER(RFINDEX(FLD_XMPC), XMPC, BIT8);
  SENTER(RFINDEX(FLD_XPPC), XPPC, BIT8);
  SENTER(RFINDEX(FLD_YMPC), YMPC, BIT8);
  SENTER(RFINDEX(FLD_YPPC), YPPC, BIT8);
  SENTER(RFINDEX(FLD_ZMPC), ZMPC, BIT8);
  SENTER(RFINDEX(FLD_ZPPC), ZPPC, BIT8);
  SENTER(RFINDEX(REG_MIDR), MIDR, BIT8);
  SENTER(RFINDEX(REG_GIDR), GIDR, BIT8);
  SENTER(RFINDEX(FLD_BPIE), BPIE, BIT8);
  SENTER(RFINDEX(FLD_BCIE), BCIE, BIT8);
  SENTER(RFINDEX(FLD_GCIE), GCIE, BIT8);
  SENTER(RFINDEX(FLD_MAIE), MAIE, BIT8);
  SENTER(RFINDEX(FLD_MBIE), MBIE, BIT8);
  SENTER(RFINDEX(FLD_SSIE), SSIE, BIT8);
  SENTER(RFINDEX(FLD_XHIE), XHIE, BIT8);
  SENTER(RFINDEX(FLD_RLIE), RLIE, BIT8);
  SENTER(RFINDEX(FLD_URIE), URIE, BIT8);
  SENTER(RFINDEX(FLD_ISIE), ISIE, BIT8);
  SENTER(RFINDEX(FLD_BPIF), BPIF, BIT8);
  SENTER(RFINDEX(FLD_BCIF), BCIF, BIT8);
  SENTER(RFINDEX(FLD_GCIF), GCIF, BIT8);
  SENTER(RFINDEX(FLD_MAIF), MAIF, BIT8);
  SENTER(RFINDEX(FLD_MBIF), MBIF, BIT8);
  SENTER(RFINDEX(FLD_SSIF), SSIF, BIT8);
  SENTER(RFINDEX(FLD_XHIF), XHIF, BIT8);
  SENTER(RFINDEX(FLD_RLIF), RLIF, BIT8);
  SENTER(RFINDEX(FLD_URIF), URIF, BIT8);
  SENTER(RFINDEX(FLD_ISIF), ISIF, BIT8);
  SENTER(RFINDEX(FLD_VWE), VWE, BIT8);
  SENTER(RFINDEX(FLD_VWIE), VWIE, BIT8);
  SENTER(RFINDEX(FLD_VWIF), VWIF, BIT8);
  SENTER(RFINDEX(FLD_LDOC), LDOC, BIT8);
  SENTER(RFINDEX(FLD_HDOC), HDOC, BIT8);
  CaLib_tb.LEAVE();
void Cam8Sim::InitExitProcs()
#ifdef BADSIG
  const void * err = BADSIG;
#else
  const void * err = SIG_ERR;
#endif
  CaLib_tb.ENTER("Cam8Sim::InitExitProcs");
#ifdef sun
#if 0
  on_exit(ExitProc);								 /* Make sure it gets called on exit */
#else
  atexit(ExitProc);								 /* Make sure it gets called on exit */
#endif
#endif
     
  if ( (signal(SIGHUP, ExitSigProc) == err) ||
       (signal(SIGINT, SIG_IGN) == err) ||
       (signal(SIGQUIT, SIG_IGN) == err) ||
       (signal(SIGILL, ExitSigProc) == err) ||
       (signal(SIGFPE, ExitSigProc) == err) ||
       (signal(SIGBUS, ExitSigProc) == err) ||
       (signal(SIGSEGV, ExitSigProc) == err) ||
       (signal(SIGSYS, ExitSigProc) == err) ||
       (signal(SIGPIPE, ExitSigProc) == err) ||
       (signal(SIGTERM, ExitSigProc) == err) )
    CaLibWarning(TRUE, "Could not install cleanup routines!");
  CaLib_tb.LEAVE();
#ifdef BADSIG
void Cam8Sim::ExitSigProc(int sig, int code, struct sigcontext *scp, char *addr)
#else
void Cam8Sim::ExitSigProc(int sig)
#endif
  static char *pcSignalName[] = {
    "Unknown",
    "Hangup",
    "Interrupt",
    "Quit",
    "Illegal Instruction",
    "Trace Trap",
    "IO (Hardware) Trap",
    "Emulator Trap",
    "Floating Point Exception",
    "Kill",
    "Bus Error",
    "Segmentation Fault",
    "Bad Argument to system call",
    "Write to broken pipe",
    "Alarm",
    "Software Termination",
    "User1",
    "User2",
    "Child Termination",
    "Power down"
  };
  CaLib_tb.ENTER("Cam8Sim::ExitSigProc");
  CaLibDie.SetAppName("Cam8SIM");
     
  switch (sig) {
  case SIGHUP:
  case SIGSYS:
  case SIGPIPE:
    CaLibDie(TRUE, "%s signal received - exiting.\n", pcSignalName[sig]);
    break;
    
  case SIGILL:
  case SIGFPE:
#ifdef BADSIG
    CaLibDie(TRUE, "Attempt to execute illegal instruction at 0x%x\n", addr);
#else
    CaLibDie(TRUE, "Attempt to execute illegal instruction\n");
#endif
    break;
  case SIGBUS:
  case SIGSEGV:
#ifdef BADSIG
    CaLibDie(TRUE, "Attempt to access invalid memory location 0x%x\n", addr);
#else
    CaLibDie(TRUE, "Attempt to access invalid memory location\n");
#endif
    break;
  case SIGTERM:
    CaLibDie(TRUE, "Termination signal received - exiting.\n");
    break;
  default:
    break;
#ifdef DEBUG
  fclose(DEBUGFILE);
#endif
  Calib_tb.LEAVE();
  /*  _exit(0); */
void Cam8Sim::ExitProc()
#ifdef DEBUG
  fclose(DEBUGFILE);
#endif
#ifndef INTERPRETER
void InitSim()
  const int prot = PROT_READ | PROT_WRITE | PROT_EXEC;
  pcodScanner = VALLOC(SCANNER_CODE_SIZE, "InitSim : pcodScanner");
  pcodGenUpdate = VALLOC(SCANNER_CODE_SIZE, "InitSim : pcodGenUpdate");
  pcodSweep = VALLOC(SWEEP_CODE_SIZE, "InitSim : pcodSweep");
  pcodUpdateSite = VALLOC(UPDATE_CODE_SIZE, "InitSim : pcodUpdateSite");
  mprotect(pcodScanner, SCANNER_CODE_SIZE, prot);
  mprotect(pcodGenUpdate, SCANNER_CODE_SIZE, prot);
  mprotect(pcodSweep, SWEEP_CODE_SIZE, prot);
  mprotect(pcodUpdateSite, UPDATE_CODE_SIZE, prot);
  UPDATE_SITE_CODE = (LONG32) pcodUpdateSite;
  InitRegMgr();
#endif INTERPRETER
void Cam8Sim::ReadCmdLine(int argc, char *argv[])
  register int i;
  for(i = 1; i < argc; i++) {
    if (strcmp(argv[i], "-g") == 0) {
      bForceGeneralScan = TRUE;
      continue;
    }
void Cam8Sim::vwecheck(INT16 *base, int reg_fld, int imm)
  register int i;
  int f = 0, o;
  LONG32 pbuf[CHIPS_PER_MOD];
  Bt bt;
  bt = base_type[reg_fld];
  if (VWECHK) {
    UnpackStateInto(base, reg_fld, imm, (BYTE *) pbuf, bt.type);
    for (i = 0; i < CHIPS_PER_MOD; i++) {
      o = bt.type * i;
      if (VWE[i]) {
	if (bcmp(bt.base + o, ((BYTE *) pbuf) + o, bt.type) != 0) {
	  f = 1;
	  VWIF[i] = 1;
      }
      else
	bcopy(((BYTE *) pbuf) + o, bt.base + o, bt.type);
    }
  else
    UnpackState(base, reg_fld, imm);
void Cam8Sim::SimStepList(LONG32 *plFirstInstr)
  LONG32 *plCurr = NULL, *plNext = NULL;
  LONG32 lData = 0, lLength;
  short nRegister, i, imm = FALSE;
  BOOL bHostJump, bHostWait, bByteMode, bReadMode;
  BOOL bDone = FALSE;
  LONG32 pbuf[CHIPS_PER_MOD];
  bHostJump = bHostWait = FALSE;
  for (plCurr = plFirstInstr; !bDone; plCurr = plNext) {
    bHostJump = (*plCurr & HOST_JUMP_MASK) != 0;
    bHostWait = (*plCurr & HOST_WAIT_MASK) != 0;
    bDone = bHostJump || bHostWait;
    bByteMode = (*plCurr & BYTE_MODE_MASK) != 0;
    bReadMode = (*plCurr & READ_CAM_MASK) != 0;
    
    cam8sim_iregs.PIP = cam8sim_iregs.CIP;
    cam8sim_iregs.CIP = (LONG32) plNext;
    if (*plCurr & RESET_CAM_MASK) {
      memset ((char *) &Cam8State, 0, sizeof(Cam8State));
      LIOR = LUT1;
      LUT_ADDR = (LONG32) LUT0;
      bSourceRegChange = bDestChange = TRUE;
      
#ifdef DEBUG
      fprintf(DEBUGFILE, "CAM Reset\n");
      fflush(DEBUGFILE);
#endif
    }
    
    
    nRegister = *plCurr & REGISTER_ADDR_MASK;
    imm = (*plCurr & IMMEDIATE_DATA_MASK) != 0;
    lData = *(plCurr + 1);
    lLength = *(plCurr + 2);
    
    plNext = (LONG32 *) (*(plCurr + 3));
    
    if ((*plCurr & READ_CAM_MASK) && (*plCurr & IMMEDIATE_DATA_MASK)) {
#ifdef DEBUG
      fprintf(DEBUGFILE, "NOOP\n");
#endif
      continue;
    }
    
    
#ifdef DEBUG
    fprintf(DEBUGFILE, "REG = %d (%s), ", nRegister, REGNAMES[nRegister]);
    if (imm)
      fprintf(DEBUGFILE, "IMMEDIATE DATA, ");
    fprintf(DEBUGFILE, "BYTEMODE = %d, READMODE = %d\n", bByteMode, bReadMode);
    fflush(DEBUGFILE);
#endif
    
    if ((*plCurr & READ_CAM_MASK) != 0) {
      INT16 *pnBuffer;
      
      Cam8State.bReadMode = TRUE;
      bDestChange = TRUE;
      
      pnBuffer = (INT16 *) lData;
      
      SimReadInstr(pnBuffer, *plCurr, lData, lLength);
      
      continue;
    }
    
    
    switch (nRegister) {
      
    case RFINDEX(REG_MSR): {
      vwecheck((INT16 *) lData, RFINDEX(REG_MSR), imm);
      break;
    }      
      
      
    case RFINDEX(REG_RMR): {
      vwecheck((INT16 *) lData, RFINDEX(FLD_SSM), imm);
      vwecheck((INT16 *) lData, RFINDEX(FLD_RT), imm);
      vwecheck((INT16 *) lData, RFINDEX(FLD_ECT), imm);
      vwecheck((INT16 *) lData, RFINDEX(FLD_RPK), imm);
      vwecheck((INT16 *) lData, RFINDEX(FLD_ALT), imm);
      
#ifndef INTERPRETER
      for(i = 0; i < CHIPS_PER_MOD; i++) {
	if (ECT[i] == 1) {
          ECR[i] = EVENT_COUNT(i);
          EVENT_COUNT(i) = 0L;
        }
        if (RPK[i] == 1)
          DoKick(i);
      }
      
#else INTERPRETER
      for(i = 0; i < CHIPS_PER_MOD; i++) {
	if (ECT[i] == 1) {
          ECR[i] = EVENT_COUNT[i];
          EVENT_COUNT[i] = 0L;
        }
        if (RPK[i] == 1)
          DoKick(i);
      }
      
#endif INTERPRETER
      if (ALT[0] == 1) {
        INT16 *pnTemp;
        
        pnTemp = LIOR;
        LIOR = (INT16 *) LUT_ADDR;
        LUT_ADDR = (LONG32) pnTemp;
        
        for (i = 0; i < CHIPS_PER_MOD; i++)
	  ALS[i] ^= 1;
      }
      if (Cam8State.bReadMode != FALSE) {
	bDestChange = TRUE;
	Cam8State.bReadMode = FALSE;
      }
      if (SSM[0] != 0) {
	Cam8State.WhyScan = RFINDEX(REG_RMR);
#ifndef INTERPRETER
        SimCompScan();
        
#ifndef _DRYRUN_                 
#ifdef _INSTRUMENTATION_
	gettimeofday(&tvStart, &tzZone);
#endif
        SimExecScan();
#ifdef _INSTRUMENTATION_
	gettimeofday(&tvEnd, &tzZone);
      
	fprintf(stderr, "Regular Scan took %d usecs\n",
		(tvEnd.tv_sec - tvStart.tv_sec) * 1000000 +
		(tvEnd.tv_usec - tvStart.tv_usec));
#endif _INSTRUMENTATION_
#endif _DRYRUN_
#else INTERPRETER
	SimExecScan();
#endif INTERPRETER
      }
      
      break;
    }
      
      
    case RFINDEX(REG_KR): {
      vwecheck((INT16 *) lData, RFINDEX(FLD_KA), imm);
      vwecheck((INT16 *) lData, RFINDEX(FLD_XKS), imm);
      vwecheck((INT16 *) lData, RFINDEX(FLD_YKS), imm);
      vwecheck((INT16 *) lData, RFINDEX(FLD_ZKS), imm);
      vwecheck((INT16 *) lData, RFINDEX(FLD_XKMF), imm);
      vwecheck((INT16 *) lData, RFINDEX(FLD_YKMF), imm);
      vwecheck((INT16 *) lData, RFINDEX(FLD_ZKMF), imm);
      DoKick(-1);
      break;
    }
      
      
    case RFINDEX(REG_SABSR):
      {
	vwecheck((INT16 *) lData, RFINDEX(REG_SABSR), imm);
	break;
      }
    case RFINDEX(REG_LASR):
    case RFINDEX(REG_FOSR):
    case RFINDEX(REG_SDSR):
    case RFINDEX(REG_ECSR):
    case RFINDEX(REG_DSR): {
      vwecheck((INT16 *) lData, FLD_SELECT(nRegister), imm);
      vwecheck((INT16 *) lData, FLD_MAP(nRegister), imm);
      bSourceRegChange = TRUE;
      break;
    }
      
    case RFINDEX(REG_SSR): {
      vwecheck((INT16 *) lData, RFINDEX(REG_SSR), imm);
      
      break;
    }
      
      
    case RFINDEX(REG_ECR): {
      if (ECL[0] != lLength) {
	ConstantSetAll(RLIF, 1);
	Generate_Interrupt(CAM_CAM_INT_STATUS);
      }
      else {
	int i;
	UnpackBits((INT16 *) lData, 0, lLength, imm, (BYTE *) ECR, BIT32);
	for(i = 0; i < CHIPS_PER_MOD; i++)
#ifndef INTERPRETER
	  EVENT_COUNT(i) = ECR[i];
#else INTERPRETER
	  EVENT_COUNT[i] = ECR[i];
#endif INTERPRETER
      }
      break;
    }
      
      
    case RFINDEX(REG_LIR): {
      vwecheck((INT16 *) lData, RFINDEX(REG_LIR), imm);
      break;
    }
      
      
    case RFINDEX(REG_LIPR): {
      vwecheck((INT16 *) lData, RFINDEX(REG_LIPR), imm);
      
      break;
    }
      
      
    case RFINDEX(REG_LIOR): {
      INT16 nLUTEntry, nLUTNextIndex;
      INT16 *pnLUT, *pnSource;
      int i, j;
      INT16 nImmediate[2];
      
      if (imm) {
        nImmediate[0] = (INT16) lData >> 16;
        nImmediate[1] = (INT16) lData & 0xFF;
        pnSource = &nImmediate[0];
      }
      
      else
        pnSource = (INT16 *) lData;
      
      for (i = 0; i < lLength; i++) {
        nLUTNextIndex = 0;
        for (j = CHIPS_PER_MOD - 1; j >= 0; j--) {
          nLUTNextIndex <<= 1;
          if (LIPR[j] < 16)
            nLUTNextIndex |= ((LIR[j] >> LIPR[j]) & 0x1);
          else if (LIPR[j] == 31)
            nLUTNextIndex |= 0x1;
	  LIR[j]++;
        }
        pnLUT = LIOR + nLUTNextIndex;                 
        
        if (imm) {
          *pnLUT = *pnSource;
          pnSource = &nImmediate[i % 2];
        } 
        
        else {
          *pnLUT = *pnSource;
          pnSource++;
        }
      }
      
      break;
    }
      
      
    case RFINDEX(REG_SIR): {
      vwecheck((INT16 *) lData, RFINDEX(REG_SIR), imm);
      
      SCAN_INDEX_REG = SIR[0];
      
      break;
    }
      
      
    case RFINDEX(REG_SIPR): {
      int j;
      
      for(j = 0; j < SCAN_INDEX_LENGTH; j++)
        vwecheck((INT16 *) lData, RFINDEX(FLD_SSA(j)), imm);
      
      break;
    }
      
      
    case RFINDEX(REG_SIOR): {
      if ((Cam8State.bByteMode != bByteMode) || 
          (Cam8State.bImmediate != imm)) {
        Cam8State.bByteMode = bByteMode;
        Cam8State.bImmediate = imm;
        bSourceRegChange = TRUE;
      }
      
      if (imm) {
        SIOR = (BYTE *) &lData;
        TBUS_DATA = lData;
#ifndef INTERPRETER
	SIOREG = (LONG32) SIOR;
#endif INTERPRETER
      }
      
      else {
        SIOR = (BYTE *) lData;
	TBUS_ADDR = lData;
#ifndef INTERPRETER
	SIOREG = (LONG32) SIOR;
#endif INTERPRETER
      }
      
      if (Cam8State.bReadMode != FALSE) {
        bDestChange = TRUE;
        Cam8State.bReadMode = FALSE;
      }
      
      Cam8State.WhyScan = RFINDEX(REG_SIOR);
#ifndef INTERPRETER
      SimCompScan();
#ifndef _DRYRUN_                 
#ifdef _INSTRUMENTATION_
      gettimeofday(&tvStart, &tzZone);
#endif
      SimExecScan();
#ifdef _INSTRUMENTATION_
      gettimeofday(&tvEnd, &tzZone);
      
      fprintf(stderr, "Scan I/O Write took %d usecs\n",
	      (tvEnd.tv_sec - tvStart.tv_sec) * 1000000 +
	      (tvEnd.tv_usec - tvStart.tv_usec));
#endif _INSTRUMENTATION_
#endif _DRYRUN_
      
#else INTERPRETER
      
      SimExecScan();      
#endif INTERPRETER
      break;
    }
      
      
    case RFINDEX(REG_SFR): {
      vwecheck((INT16 *) lData, RFINDEX(FLD_SM), imm);
      vwecheck((INT16 *) lData, RFINDEX(FLD_ESC), imm);
      vwecheck((INT16 *) lData, RFINDEX(FLD_ESW), imm);
      vwecheck((INT16 *) lData, RFINDEX(FLD_EST), imm);
      vwecheck((INT16 *) lData, RFINDEX(FLD_SBRC), imm);
      vwecheck((INT16 *) lData, RFINDEX(FLD_RCL), imm);
      vwecheck((INT16 *) lData, RFINDEX(FLD_ECL), imm);
      vwecheck((INT16 *) lData, RFINDEX(FLD_STM), imm);
      
      break;
    }
      
      
    case RFINDEX(REG_OSR): {
      vwecheck((INT16 *) lData, nRegister, imm);
      break;
    }
      
      
    case RFINDEX(REG_DR): {
      vwecheck((INT16 *) lData, RFINDEX(FLD_DCM), imm);
      vwecheck((INT16 *) lData, RFINDEX(FLD_XDCP), imm);
      vwecheck((INT16 *) lData, RFINDEX(FLD_YDCP), imm);
      vwecheck((INT16 *) lData, RFINDEX(FLD_ZDCP), imm);
      UpdateDCMR();
      
      break;
    }
      
      
    case RFINDEX(REG_HER): {
      vwecheck((INT16 *) lData, RFINDEX(FLD_LPL), imm);
      vwecheck((INT16 *) lData, RFINDEX(FLD_FPL), imm);
      vwecheck((INT16 *) lData, RFINDEX(FLD_DCS), imm);
      vwecheck((INT16 *) lData, RFINDEX(FLD_TBD), imm);
      vwecheck((INT16 *) lData, RFINDEX(FLD_TMS), imm);
      vwecheck((INT16 *) lData, RFINDEX(FLD_NBF), imm);
      vwecheck((INT16 *) lData, RFINDEX(FLD_SRE), imm);
      vwecheck((INT16 *) lData, RFINDEX(FLD_ALS), imm);
       
      if (ALS[0] == 1) {
        LIOR = (INT16*) LUT0;
        LUT_ADDR = (LONG32) LUT1;
      } 
      
      else {
        LIOR = (INT16 *) LUT1;
        LUT_ADDR = (LONG32) LUT0;
      }
      
      bSourceRegChange = TRUE;
      
      break;
    }
      
      
    case RFINDEX(REG_MPCR): {
      vwecheck((INT16 *) lData, RFINDEX(FLD_MAFS), imm);
      vwecheck((INT16 *) lData, RFINDEX(FLD_MBFS), imm);
      break;
    }
      
      
    case RFINDEX(REG_GPCR): {
      vwecheck((INT16 *) lData, RFINDEX(FLD_XMPC), imm);
      vwecheck((INT16 *) lData, RFINDEX(FLD_XPPC), imm);
      vwecheck((INT16 *) lData, RFINDEX(FLD_YMPC), imm);
      vwecheck((INT16 *) lData, RFINDEX(FLD_YPPC), imm);
      vwecheck((INT16 *) lData, RFINDEX(FLD_ZMPC), imm);
      vwecheck((INT16 *) lData, RFINDEX(FLD_ZPPC), imm);
      break;
    }
      
      
    case RFINDEX(REG_MIDR): {
      vwecheck((INT16 *) lData, RFINDEX(REG_MIDR), imm);
      break;
    }
      
      
    case RFINDEX(REG_GIDR): {
      vwecheck((INT16 *) lData, RFINDEX(REG_GIDR), imm);
      break;
    }
      
      
    case RFINDEX(REG_IER): {
      vwecheck((INT16 *) lData, RFINDEX(FLD_BPIE), imm);
      vwecheck((INT16 *) lData, RFINDEX(FLD_BCIE), imm);
      vwecheck((INT16 *) lData, RFINDEX(FLD_GCIE), imm);
      vwecheck((INT16 *) lData, RFINDEX(FLD_MAIE), imm);
      vwecheck((INT16 *) lData, RFINDEX(FLD_MBIE), imm);
      vwecheck((INT16 *) lData, RFINDEX(FLD_SSIE), imm);
      vwecheck((INT16 *) lData, RFINDEX(FLD_XHIE), imm);
      vwecheck((INT16 *) lData, RFINDEX(FLD_RLIE), imm);
      vwecheck((INT16 *) lData, RFINDEX(FLD_URIE), imm);
      vwecheck((INT16 *) lData, RFINDEX(FLD_ISIE), imm);
      break;
    }
      
      
    case RFINDEX(REG_IFR): {
      vwecheck((INT16 *) lData, RFINDEX(FLD_BPIF), imm);
      vwecheck((INT16 *) lData, RFINDEX(FLD_BCIF), imm);
      vwecheck((INT16 *) lData, RFINDEX(FLD_GCIF), imm);
      vwecheck((INT16 *) lData, RFINDEX(FLD_MAIF), imm);
      vwecheck((INT16 *) lData, RFINDEX(FLD_MBIF), imm);
      vwecheck((INT16 *) lData, RFINDEX(FLD_SSIF), imm);
      vwecheck((INT16 *) lData, RFINDEX(FLD_XHIF), imm);
      vwecheck((INT16 *) lData, RFINDEX(FLD_RLIF), imm);
      vwecheck((INT16 *) lData, RFINDEX(FLD_URIF), imm);
      vwecheck((INT16 *) lData, RFINDEX(FLD_ISIF), imm);
      break;
    }
      
      
    case RFINDEX(REG_VWR): {
      register int i;
      
      UnpackState((INT16 *) lData, RFINDEX(FLD_VWE), imm);
      UnpackState((INT16 *) lData, RFINDEX(FLD_VWIE), imm);
      UnpackState((INT16 *) lData, RFINDEX(FLD_VWIF), imm);
      VWECHK = 0;
      for (i = 0; i < CHIPS_PER_MOD; i++)
	if (VWE[i] == 1)
	  VWECHK = 1;
      
      break;
    }
      
      
    case RFINDEX(REG_DOCR): {
      vwecheck((INT16 *) lData, RFINDEX(FLD_LDOC), imm);
      vwecheck((INT16 *) lData, RFINDEX(FLD_HDOC), imm);
      
      break;
    }
      
      
    default: {
      
      fprintf(stderr, "Don't recognize register %d\n", nRegister);
      break;
    }
    }
    
    cam8sim_iregs.PIP = (LONG32) plCurr;
  } /*   for (plCurr = plFirstInstr; !bDone; plCurr = plNext;) */
  cam8sim_iregs.ISR |= CAM_NEWLIST_INT_STATUS;
void Cam8Sim::SimReadInstr(INT16 *pnBuffer, LONG32 lInstr, LONG32 lData,
			   LONG32 lLength)
  BOOL bByteMode;
  short nRegister, i, imm;
  LONG32 pbuf[CHIPS_PER_MOD];
  bByteMode = (lInstr & BYTE_MODE_MASK) != 0;
  nRegister = lInstr & REGISTER_ADDR_MASK;
  imm = (lInstr & IMMEDIATE_DATA_MASK) != 0;
  switch (nRegister) {
    
  case RFINDEX(REG_MSR): {
    PackState(pnBuffer, RFINDEX(REG_MSR));
    break;
  }      
    
    
  case RFINDEX(REG_RMR): {
    PackState(pnBuffer, RFINDEX(FLD_SSM));
    PackState(pnBuffer, RFINDEX(FLD_RT));
    PackState(pnBuffer, RFINDEX(FLD_ECT));
    PackState(pnBuffer, RFINDEX(FLD_RPK));
    PackState(pnBuffer, RFINDEX(FLD_ALT));
    break;
    
    
  case RFINDEX(REG_KR): {
    PackState(pnBuffer, RFINDEX(FLD_KA));
    PackState(pnBuffer, RFINDEX(FLD_XKS));
    PackState(pnBuffer, RFINDEX(FLD_YKS));
    PackState(pnBuffer, RFINDEX(FLD_ZKS));
    PackState(pnBuffer, RFINDEX(FLD_XKMF));
    PackState(pnBuffer, RFINDEX(FLD_YKMF));
    PackState(pnBuffer, RFINDEX(FLD_ZKMF));
    break;
    
    
  case RFINDEX(REG_SABSR): {
    PackState(pnBuffer, RFINDEX(REG_SABSR));
    
    break;
    
    
  case RFINDEX(REG_LASR):
  case RFINDEX(REG_FOSR):
  case RFINDEX(REG_SDSR):
  case RFINDEX(REG_ECSR):
  case RFINDEX(REG_DSR): {
    PackState(pnBuffer, FLD_SELECT(nRegister));
    PackState(pnBuffer, FLD_MAP(nRegister));    
    break;
    
    
  case RFINDEX(REG_SSR): {
    *pnBuffer = 0xFFFF;
    
    break;
    
    
  case RFINDEX(REG_ECR): {
    int diff;
    if ((diff = ECL[0] - lLength) != 0){
      ConstantSetAll(RLIF, 1);
      if (diff < 0)
	Generate_Interrupt(CAM_CAM_INT_STATUS);
      else
	Generate_Interrupt(CAM_TIMEOUT_INT_STATUS);
    }
    
    else
      PackBits(pnBuffer, 0, lLength, (BYTE *) ECR, BIT32);
    
    break;
    
    
  case RFINDEX(REG_LIR): {
    PackState(pnBuffer, RFINDEX(REG_LIR));
    break;
    
    
  case RFINDEX(REG_LIPR): {
    PackState(pnBuffer, RFINDEX(REG_LIPR));
    break;
    
    
  case RFINDEX(REG_LIOR): {
    INT16 nLUTEntry, nLUTNextIndex;
    INT16 *pnLUT;
    int i, j;
    INT16 nImmediate[2];
    
    
    for (i = 0; i < lLength; i++) {
      nLUTNextIndex = 0;
      
      for (j = CHIPS_PER_MOD - 1; j >= 0; j--) {
	nLUTNextIndex <<= 1;
	if (LIPR[j] < 16)
	  nLUTNextIndex |= ((LIR[j] >> LIPR[j]) & 0x1);
	else if (LIPR[j] == 31)
	  nLUTNextIndex |= 0x1;
	LIR[j]++;
      }
      
      pnLUT = LIOR + nLUTNextIndex;                 
      
      *pnBuffer = *pnLUT;
      pnBuffer++;
    }
    
    break;
    
    
  case RFINDEX(REG_SIR): {
    PackState(pnBuffer, RFINDEX(REG_SIR));
    break;
    
    
  case RFINDEX(REG_SIPR): {
    int j;
    
    /* j counts which field of register */
    for(j = 0; j < SCAN_INDEX_LENGTH; j++)
      PackState(pnBuffer, RFINDEX(FLD_SSA(j)));
    break;
    
    
  case RFINDEX(REG_SIOR): {
    Cam8State.bByteMode = bByteMode;
    SIOR = (BYTE *) pnBuffer;
    
#ifndef INTERPRETER
	SIOREG = (LONG32) SIOR;
#endif INTERPRETER
    if (Cam8State.bReadMode !=  TRUE) {
      bDestChange = TRUE;
      Cam8State.bReadMode =  TRUE;
    }
    
    Cam8State.WhyScan = RFINDEX(REG_SIOR);
#ifndef INTERPRETER
    SimCompScan();
#ifndef _DRYRUN_                 
#ifdef _INSTRUMENTATION_
  gettimeofday(&tvStart, &tzZone);
#endif
    SimExecScan();
#ifdef _INSTRUMENTATION_
    gettimeofday(&tvEnd, &tzZone);
      
    fprintf(stderr, "Scan I/O Read took %d usecs\n",
	    (tvEnd.tv_sec - tvStart.tv_sec) * 1000000 +
	    (tvEnd.tv_usec - tvStart.tv_usec));
#endif _INSTRUMENTATION_
#endif _DRYRUN_
#else INTERPRETER
    SimExecScan();
#endif INTERPRETER
    
    break;
    
    
  case RFINDEX(REG_SFR): {
    PackState(pnBuffer, RFINDEX(FLD_SM));
    PackState(pnBuffer, RFINDEX(FLD_ESC));
    PackState(pnBuffer, RFINDEX(FLD_ESW));
    PackState(pnBuffer, RFINDEX(FLD_EST));
    PackState(pnBuffer, RFINDEX(FLD_SBRC));
    PackState(pnBuffer, RFINDEX(FLD_RCL));
    PackState(pnBuffer, RFINDEX(FLD_ECL));
    PackState(pnBuffer, RFINDEX(FLD_STM));
    
    break;
    
    
  case RFINDEX(REG_OSR): {
    PackState(pnBuffer, RFINDEX(REG_OSR));
    break;
    
    
  case RFINDEX(REG_DR): {
    PackState(pnBuffer, RFINDEX(FLD_DCM));
    PackState(pnBuffer, RFINDEX(FLD_XDCP));
    PackState(pnBuffer, RFINDEX(FLD_YDCP));
    PackState(pnBuffer, RFINDEX(FLD_ZDCP));
    
    break;
    
    
  case RFINDEX(REG_HER): {
    PackState(pnBuffer, RFINDEX(FLD_LPL));
    PackState(pnBuffer, RFINDEX(FLD_FPL));
    PackState(pnBuffer, RFINDEX(FLD_DCS));
    PackState(pnBuffer, RFINDEX(FLD_TBD));
    PackState(pnBuffer, RFINDEX(FLD_TMS));
    PackState(pnBuffer, RFINDEX(FLD_NBF));
    PackState(pnBuffer, RFINDEX(FLD_SRE));
    PackState(pnBuffer, RFINDEX(FLD_ALS));
    
    break;
    
    
  case RFINDEX(REG_MPCR): {
    PackState(pnBuffer, RFINDEX(FLD_MAFS));
    PackState(pnBuffer, RFINDEX(FLD_MBFS));
    
    break;
    
    
  case RFINDEX(REG_GPCR): {
    PackState(pnBuffer, RFINDEX(FLD_XMPC));
    PackState(pnBuffer, RFINDEX(FLD_XPPC));
    PackState(pnBuffer, RFINDEX(FLD_YMPC));
    PackState(pnBuffer, RFINDEX(FLD_YPPC));
    PackState(pnBuffer, RFINDEX(FLD_ZMPC));
    PackState(pnBuffer, RFINDEX(FLD_ZPPC));
    
    break;
    
    
  case RFINDEX(REG_MIDR): {
    PackState(pnBuffer, RFINDEX(REG_MIDR));
    
    break;
    
    
  case RFINDEX(REG_GIDR): {
    PackState(pnBuffer, RFINDEX(REG_GIDR));
    
    break;
    
    
  case RFINDEX(REG_IER): {
    PackState(pnBuffer, RFINDEX(FLD_BPIE));
    PackState(pnBuffer, RFINDEX(FLD_BCIE));
    PackState(pnBuffer, RFINDEX(FLD_GCIE));
    PackState(pnBuffer, RFINDEX(FLD_MAIE));
    PackState(pnBuffer, RFINDEX(FLD_MBIE));
    PackState(pnBuffer, RFINDEX(FLD_SSIE));
    PackState(pnBuffer, RFINDEX(FLD_XHIE));
    PackState(pnBuffer, RFINDEX(FLD_RLIE));
    PackState(pnBuffer, RFINDEX(FLD_URIE));
    PackState(pnBuffer, RFINDEX(FLD_ISIE));
    break;
    
    
  case RFINDEX(REG_IFR): {
    PackState(pnBuffer, RFINDEX(FLD_BPIF));
    PackState(pnBuffer, RFINDEX(FLD_BCIF));
    PackState(pnBuffer, RFINDEX(FLD_GCIF));
    PackState(pnBuffer, RFINDEX(FLD_MAIF));
    PackState(pnBuffer, RFINDEX(FLD_MBIF));
    PackState(pnBuffer, RFINDEX(FLD_SSIF));
    PackState(pnBuffer, RFINDEX(FLD_XHIF));
    PackState(pnBuffer, RFINDEX(FLD_RLIF));
    PackState(pnBuffer, RFINDEX(FLD_URIF));
    PackState(pnBuffer, RFINDEX(FLD_ISIF));
    
    break;
    
    
  case RFINDEX(REG_VWR): {
    PackState(pnBuffer, RFINDEX(FLD_VWE));
    PackState(pnBuffer, RFINDEX(FLD_VWIE));
    PackState(pnBuffer, RFINDEX(FLD_VWIF));
    break;
    
    
  case RFINDEX(REG_DOCR): {
    PackState(pnBuffer, RFINDEX(FLD_LDOC));
    PackState(pnBuffer, RFINDEX(FLD_HDOC));
    
    break;
    
    
  default: {
    
    fprintf(stderr, "Don't recognize register %d\n", nRegister);
    break;
void DoKick(short p)
  register int i, j;
  LONG32 lSignBitOffset, lSignBitKick, lLowBitsKick;
  LONG32 lDCM;
  LONG32 lKA;
  /************************************************************************/
  /* The kick and offset registers are two n-dimension-vectors, and the   */
  /* place where all dimensions end is determined by lDCMR. To subtract   */
  /* an n-dimension-kick from the corresponding offset, we first extract  */
  /* out the sign bits of both (by and-ing with lDCMR). Next, we set the  */
  /* most sig bits of every dimension in offset to 1, so that when we     */
  /* subtract out the kick, we don't borrow from the next higher          */
  /* dimension. Next, we subtract the value bits of kick (lowbits) from   */
  /* this offset. This will give the 'sign' bit of the new offset and its */
  /* value. The final sign bit of the offset is determined by :           */
  /*                                                                      */
  /*     sign bit = new sign bit xor (old sign bit xnor kick sign bit)    */
  /*                                                                      */
  /* To do the xnor operation, we simply store the inverse of the kick    */
  /* sign bit and then do an xor                                          */
  /*                                                                      */
  /* One easy way to derive this is to think of a sample dimension with   */
  /* 4 bits. Then, the bit positions have values  -8  4  2  1. The        */
  /* subtract operation as described above becomes (8 + 4*o.2 + 2*o.1 +   */
  /* 1*o.0 - 4*k.2 - 2*k.1 - 1*k.0) - 8 - 8*o.sign + 8.k.sign             */
  /* where o.X means the X'th bit of offset and k.X means the X'th bit of */
  /* kick. Since the final offset is of the form -8*o.sign + 4*o.2 +      */
  /* 2*o.1 + 1*o.o, we can express the sign bit as the above logical      */
  /* function of the three individual sign bits.                          */
  /*                                                                      */
  /************************************************************************/
  if (p == -1) {
    p = 0;
    j = CHIPS_PER_MOD;
  else
    j = p + 1;
  for(i = p; i < j; i++) {
    lSignBitOffset = OSR[i] & DCM[i];
    lSignBitKick = (~KA[i]) & DCM[i];
    OSR[i] |= DCM[i];
    lLowBitsKick =  KA[i] & (~ DCM[i]);
    
    OSR[i] -= lLowBitsKick;
    lSignBitOffset ^= lSignBitKick;
    OSR[i] ^= lSignBitOffset;
#ifndef INTERPRETER
int SimCompScan()
  int i;
  BOOL bNoPerm = TRUE;
  BOOL bNoPermLast5 = TRUE;
  CODEPTR pcodCurrent;
  CODEHANDLE hcodCurrent;
  LONG32 lLogScanLength = ESC[0] + 1L;
  EP("SimCompScan");  
#else INTERPRETER
void SimExecScan()
  int i;
  BOOL bNoPerm = TRUE;
  BOOL bNoPermLast5 = TRUE;
  LONG32 lLogScanLength = ESC[0] + 1L;
  EP("SimExecScan");  
#endif INTERPRETER
  /************************************************************************/
  /* First, parse down the tree to see that we are going to update atleast*/
  /* 32 sites and that the lowest dimension extends over 32 bits. This    */
  /* second requirement is necessary because the optimized code can only  */
  /* handle dimension wraparounds at word boundaries.                     */
  /************************************************************************/
  if (lLogScanLength < 5)
    bNoPerm = bNoPermLast5 = FALSE;
  else if (lNumXBits < 5)
    bNoPerm = bNoPermLast5 = FALSE;
  else
    bNoPerm = bNoPermLast5 = TRUE;
  /************************************************************************/
  /* Now, determine if there is any permutation of the scan index in the  */
  /* bits of the SIR that will be significant over this scan.             */
  /************************************************************************/
  for (i = 0; i < MIN(5, ESC[0]); i++) {
    if (SIPR[i][0] != i) {
      bNoPerm = bNoPermLast5 = FALSE;
      break;
    }
    
    lLogScanLength--;
    
    if (!lLogScanLength)
      break;
  for (i = 5; i < MIN(SCAN_INDEX_LENGTH, ESC[0]); i++) {
    if (SIPR[i][0] != i)
      bNoPerm = FALSE;
    lLogScanLength--;
    if (!lLogScanLength)
      break;
#ifndef INTERPRETER
#ifdef _FRAMEBUFFER_
  FRAME = (LONG32) FRAMEb;
#endif _FRAMEBUFFER_
  pcodCurrent = pcodScanner;
  hcodCurrent = &pcodCurrent;
  SimPrologue(hcodCurrent);
  if (bNoPerm)
    CheckNoPerm(hcodCurrent);
  else if (bNoPermLast5)
    SimGeneralScan(hcodCurrent);
  else
    SimGeneralScan(hcodCurrent);
  SimEpilogue(hcodCurrent);
  LP("SimCompScan");
#else INTERPRETER
#ifdef _FRAMEBUFFER_
  FRAME_ADDR = (LONG32) FRAMEb;
#endif _FRAMEBUFFER_
  if (bNoPerm)
    CheckNoPerm();
  else if (bNoPermLast5)
    SimGeneralScan();
  else
    SimGeneralScan();
  if (SCAN_INDEX_REG > 0xFFFFFF)
    SCAN_INDEX_REG = 0;
  SIR[0] = SCAN_INDEX_REG;
  LP("SimExecScan");
#endif INTERPRETER
/*****************************************************************************/
/*                                                                           */
/* CheckNoPerm is necessary for the following reason - suppose there is no   */
/* permutation of the Scan Index, but suppose the the bits that extend over  */
/* the lowest dimension (ie, the bits to the _right_ of the lowest bit of    */
/* DCMR) are not all zeros. Then, the first sweep will not scan a multiple-  */
/* of-two number of sites, and we cannot do an optimized scan.               */
/*                                                                           */
/*****************************************************************************/
#ifndef INTERPRETER
void CheckNoPerm(CODEHANDLE hcodCurrent)
  LONG32 lSIRSigBits, lSIR;
#else INTERPRETER
void CheckNoPerm()
  LONG32 lSIRSigBits, lSIR;
#endif INTERPRETER
  EP("CheckNoPerm");
  lSIRSigBits = MIN(ESC[0], lNumXBits);
  lSIR = SIR[0] & ~((~0x0) << lSIRSigBits);
#ifndef INTERPRETER
  if ((lSIR == 0) && (MIN(lNumXBits, ESC[0]) >= 2)) {
    if (bForceGeneralScan)
      SimGeneralScan(hcodCurrent);
    else
      SimScanNoPerm(hcodCurrent);
  else
    SimGeneralScan(hcodCurrent);
#else INTERPRETER
  if ((lSIR == 0) && (MIN(lNumXBits, ESC[0]) >= 2)) {
    if (bForceGeneralScan)
      SimGeneralScan();
    else
      SimScanNoPerm();
  else
    SimGeneralScan();
#endif INTERPRETER
  LP("CheckNoPerm");
#ifndef INTERPRETER
void SimPrologue(CODEHANDLE hcodCurrent)
  EP("SimPrologue");
  NewBlock(hcodCurrent);
  .ENTER_PROC;
  LP("SimPrologue");
}     
void SimEpilogue(CODEHANDLE hcodCurrent)
  EP("SimEpilogue");
 .RETURN_PROC;
  EndBlock();
  LP("SimEpilogue");
void SimExecScan()
  void (*fScan)(void);
  fScan = (void (*)()) pcodScanner;
  (*fScan)();
  ConstantSetAll(SIR, SCAN_INDEX_REG);
#endif INTERPRETER
#ifndef INTERPRETER
void SimUpdateSite()
  short i;
  CODEPTR pcodCurrent = pcodUpdateSite;
  EP("SimUpdateSite");
#ifdef _INCREMENTAL_COMPILE_     
  if (!(bSourceRegChange || bDestChange)) {
    LP("SimUpdateSite");
    return;
  else {
    bSourceRegChange = FALSE;
    bDestChange = FALSE;
#endif
  NewBlock(&pcodCurrent);
  .ENTER_LEAF,   
#else INTERPRETER
void SimUpdateSite()
  short i;
  LONG32 SiteDataSrc = UNGLUE_DATA;
  EP("SimUpdateSite");
#endif INTERPRETER
#ifndef INTERPRETER
  if (IsSrcNeeded(SRC_TBUS) &&
      ((CAM8State.WhyScan != RFINDEX(REG_SIOR)) || (!CAM8State.bReadMode))) {
    if (!CAM8State.bImmediate) {
      if (CAM8State.bByteMode) {
	.LDUB_IND   iTbusAddr, #0, iTbusData;
	.ADD iTbusAddr, #1, iTbusAddr;
      } 
      
      else {
	.LDHW_IND iTbusAddr, #0, iTbusData;
	.ADD iTbusAddr, #2, iTbusAddr;
      }
    }
#else INTERPRETER
  if (IsSrcNeeded(SRC_TBUS) &&
      ((CAM8State.WhyScan != RFINDEX(REG_SIOR)) || (!CAM8State.bReadMode))) {
    if (!CAM8State.bImmediate) {
      if (CAM8State.bByteMode) {
	TBUS_DATA = *((BYTE *) TBUS_ADDR);
	TBUS_ADDR += 1;
      }
      
      else {
	TBUS_DATA = *((INT16 *) TBUS_ADDR);
	TBUS_ADDR += 2;
      } /* else */
    } /* if (!CAM8State.bImmediate) */
#endif INTERPRETER
#ifndef INTERPRETER
  if (IsSrcNeeded(SRC_SITE_DATA)) {
    .OR %G0, %G0, iUnGlueData;
    for (i = nNumPlanes-1; i >= 0; i--) {      
      .ADDcc (iPlaneWord+i), (iPlaneWord+i), (iPlaneWord+i);
      .ADDX iUnGlueData, iUnGlueData, iUnGlueData;
    }
  }  
#else INTERPRETER
  if (IsSrcNeeded(SRC_SITE_DATA)) {
    UNGLUE_DATA = 0;
    for (i = nNumPlanes-1; i >= 0; i--) {
      bit = HIGHB(PLANE_WORD[i]);
      PLANE_WORD[i] <<= 1; 
      UNGLUE_DATA = (UNGLUE_DATA << 1) | bit;
    }
#endif INTERPRETER
#ifndef INTERPRETER
  /* For Now glued and unglued data are the same */
  if (IsSrcNeeded(SRC_GLUED_DATA)) {
    if (!IsSrcNeeded(SRC_SITE_DATA)) {
      .OR %G0, %G0, iGlueData;
      for (i = nNumPlanes-1; i >= 0; i--) {      
	.ADDcc (iPlaneWord+i), (iPlaneWord+i), (iPlaneWord+i);
	.ADDX iGlueData, iGlueData, iGlueData;
      }
    }
    else {
      .OR %G0, iUnGlueData, iGlueData;
    }
#else INTERPRETER
  /* For Now glued and unglued data are the same */
  if (IsSrcNeeded(SRC_GLUED_DATA)) {
    if (!IsSrcNeeded(SRC_SITE_DATA)) {
      GLUE_DATA = 0;
      for (i = nNumPlanes-1; i >= 0; i--) {
	bit = HIGHB(PLANE_WORD[i]);
	PLANE_WORD[i] <<= 1; 
	GLUE_DATA = (GLUE_DATA << 1) | bit;
      }
    }
    else
      GLUE_DATA = UNGLUE_DATA;
#endif INTERPRETER
#ifndef INTERPRETER
  if (IsSrcNeeded(SRC_LUT)) {
    .OR   %G0, %G0, iLutData;
    if (IsSrcSame(DEST_LUT))
      BuildDest(DEST_LUT, iLutData, LAS[0], LAM[0]);            
    else
      BuildBitwiseDest(DEST_LUT, iLutData, LAS, LAM);
    .SH_LEFT      iLutData, #1, iLutData;
    .LDHW_IND     iLutAddr, iLutData, iLutData;
#else INTERPRETER
  if (IsSrcNeeded(SRC_LUT)) {
    LUT_DATA = 0;
    if (IsSrcSame(DEST_LUT))
      BuildDest(DEST_LUT, &LUT_DATA, LAS[0], LAM[0]);           
    else
      BuildBitwiseDest(DEST_LUT, &LUT_DATA, LAS, LAM);
    LUT_DATA = (LONG32) (((INT16 *) LUT_ADDR)[LUT_DATA]);
#endif INTERPRETER
  /************************************************************************/
  /*                                                                      */
  /* All the sources needed to update all the destinations should now be  */
  /* in place. Update all the destinations in the following order : EC,   */
  /* Display (ie, scan io reads), and Site Data. Note that Site data      */
  /* must be updated last, because it destroys the Site Data register,    */
  /* which is one of the possible Sources (unglued data).                 */
  /*                                                                      */
  /************************************************************************/
#ifndef INTERPRETER
  if (IsDestUpdated(DEST_DISPLAY)) {
    if (IsSrcSame(DEST_DISPLAY))
      BuildDest(DEST_DISPLAY, iTemp1, DDS[0], DDM[0]);
    else
      BuildBitwiseDest(DEST_DISPLAY, iTemp1, DDS, DDM);
#ifdef _FRAMEBUFFER_
    .STUB_IND iFrame, #0, iTemp1;
    .ADD iFrame, #1, iFrame;
#endif
#else INTERPRETER
  if (IsDestUpdated(DEST_DISPLAY)) {
    if (IsSrcSame(DEST_DISPLAY))
      BuildDest(DEST_DISPLAY, &DISP_DATA, DDS[0], DDM[0]);
    else
      BuildBitwiseDest(DEST_DISPLAY, &DISP_DATA, DDS, DDM);
#ifdef _FRAMEBUFFER_
    *((BYTE *) FRAME_ADDR) = DISP_DATA;
    FRAME_ADDR += 1;
#endif
    
#endif INTERPRETER
#ifndef INTERPRETER
  /* SCAN-IO READ */
  if ((CAM8State.WhyScan == RFINDEX(REG_SIOR)) && CAM8State.bReadMode) {
    if (CAM8State.bByteMode) {
      .STUB_IND iSIOR, #0, iTemp1;
      .ADD iSIOR, #1, iSIOR;
      }
    else {
      .STHW_IND iSIOR, #0, iTemp1;
      .ADD iSIOR, #2, iSIOR;
    }
#else INTERPRETER
  /* SCAN-IO READ */
  if ((CAM8State.WhyScan == RFINDEX(REG_SIOR)) && CAM8State.bReadMode) {
    if (CAM8State.bByteMode) {
      *((BYTE *) SIOR) = (BYTE) DISP_DATA;
      SIOR += 1;
    }
    else {
      *((INT16 *) SIOR) = (INT16) DISP_DATA;
      SIOR += 2;
    }
#endif INTERPRETER
#ifndef INTERPRETER
  if (IsDestUpdated(DEST_EVENT_CT)) {
    if (IsSrcSame(DEST_EVENT_CT))
      BuildDest(DEST_EVENT_CT, iTemp1, ECS[0], ECM[0]);
    else
      BuildBitwiseDest(DEST_EVENT_CT, iTemp1, ECS, ECM);
    
    .SH_LEFT iTemp1, #(32 - nNumPlanes), iTemp1;
    for (i = nNumPlanes-1; i >= 0; i--) {
      .LDW_IND %DS, #(offEventCount+(i<<2)), iTemp2;
      .ADDcc iTemp1, iTemp1, iTemp1;
      .ADDX iTemp2, #0, iTemp2;
      .STW_IND %DS, #(offEventCount+(i<<2)), iTemp2;
    }
#else INTERPRETER
  if (IsDestUpdated(DEST_EVENT_CT)) {
    if (IsSrcSame(DEST_EVENT_CT))
      BuildDest(DEST_EVENT_CT, &TEMP1, ECS[0], ECM[0]);
    else
      BuildBitwiseDest(DEST_EVENT_CT, &TEMP1, ECS, ECM);
    
    TEMP1 <<= (32 - nNumPlanes);
    for (i = nNumPlanes-1; i >= 0; i--) {
      EVENT_COUNT[i] += ((TEMP1 & 0x80000000) ? 0x1 : 0x0);
      TEMP1 <<= 1;
    }
#endif INTERPRETER
#ifndef INTERPRETER
  if (IsDestUpdated(DEST_SITE_DATA)) {
    if (IsSrcSame(DEST_SITE_DATA)) {
      if (SDM[0] == MAP_S) {
	switch(SDS[0]) {
	case SRC_SITE_DATA: {
	  .OR %G0, iUnGlueData, iSiteDataSrc;
	  break;
	case SRC_TBUS: {
	  .OR %G0, iTbusData, iSiteDataSrc;
	  break;
	case SRC_LUT: {
	  .OR %G0, iLutData, iSiteDataSrc;
	  break;
	default: {
	  .OR %G0, iTemp1, iSiteDataSrc;
	  break;
      }
      else
	BuildDest(DEST_SITE_DATA, iSiteDataSrc, SDS[0], SDM[0]);
    }    
    else
      BuildBitwiseDest(DEST_SITE_DATA, iSiteDataSrc, SDS, SDM);
    .SH_LEFT iSiteDataSrc, #(32 - nNumPlanes), iSiteDataSrc;
    for (i = nNumPlanes - 1; i >= 0; i--) {                                
      .ADDcc iSiteDataSrc, iSiteDataSrc, iSiteDataSrc;
      
      if ((IsSrcNeeded(SRC_SITE_DATA)) || (IsSrcNeeded(SRC_GLUED_DATA))) {
	.ADDX (iPlaneWord+i), #0, (iPlaneWord+i);
      }
      else {
	.ADDX (iPlaneWord+i), (iPlaneWord+i), (iPlaneWord+i);
      }
    }
  .RETURN_LEAF;
    
  EndBlock();
  LP("SimUpdateSite");
#else INTERPRETER
  if (IsDestUpdated(DEST_SITE_DATA)) {
    if (IsSrcSame(DEST_SITE_DATA)) {
      if (SDM[0] == MAP_S) {
	SiteDataSrc = (SDS[0] == SRC_SITE_DATA ? UNGLUE_DATA :
		       SDS[0] == SRC_TBUS ? TBUS_DATA :
		       SDS[0] == SRC_LUT ? LUT_DATA : TEMP1);
      }
      
      else {
	BuildDest(DEST_SITE_DATA, &SITE_DATA, SDS[0], SDM[0]);
	SiteDataSrc = SITE_DATA;
      }
    }
    
    else {
      BuildBitwiseDest(DEST_SITE_DATA, &SITE_DATA, SDS, SDM);
      SiteDataSrc = SITE_DATA;
    }
    
    SiteDataSrc <<= (32 - nNumPlanes);
    for (i = nNumPlanes - 1; i >= 0; i--) {                                
      bit = HIGHB(SiteDataSrc);
      SiteDataSrc <<= 1;
      
      if ((IsSrcNeeded(SRC_SITE_DATA)) || (IsSrcNeeded(SRC_GLUED_DATA)))
	PLANE_WORD[i] |= bit;
      else
	PLANE_WORD[i] = (PLANE_WORD[i] << 1) | bit;
    }
  LP("SimUpdateSite");
#endif INTERPRETER
#ifndef INTERPRETER
static void SimSweepCode();
#else INTERPRETER
static void SimSweepCode();
#endif INTERPRETER
#ifndef INTERPRETER
void SimScanNoPerm(CODEHANDLE hcodCurrent)
  LONG32 lTemp1, lTemp2;
  CODELABEL lblYLoop, lblAddrLo

---------------------------------------------------------------------------

op, lblSkip;
  const short iPlaneCtr = iTemp1,
  iHeapOffset = iTemp2,
  iWordAddr = iTemp3,
  iHighBit = iTemp4;
  EP("SimScanNoPerm");
  lblSkip = NewLabel();
  lblYLoop = NewLabel();
  lblAddrLoop = NewLabel();
  /************************************************************************/
  /* Sim assuming the scan index is not permuted. This implies that   */
  /* bits to be updated during this scan are all consecutive.             */
  /************************************************************************/
#else INTERPRETER
void SimScanNoPerm()
  LONG32 PLANE_CTR, WORD_ADDR, HIGH_BIT;
  EP("SimScanNoPerm");
#endif INTERPRETER
  /************************************************************************/
  /* compute HIGH_BIT_MASK and X_HIGH_BIT_MASK				  */
  /************************************************************************/
  HIGH_BIT_MASK = lDCMRHighBit >> 3;
  X_HIGH_BIT_MASK = lDCMRLowBit >> 3;
  /************************************************************************/
  /* SITE_CTR is set to how many sweeps are to be done. X_BYTE_LENGTH is  */
  /* set to how many bytes will be updated per sweep                      */
  /************************************************************************/
  if (ESC[0] < lNumXBits) {
    SITE_CTR = 1;
    X_BYTE_LENGTH = 1 << (ESC[0] - 3);
  else {
    SITE_CTR = ScanLength() >> lNumXBits;                                  
    X_BYTE_LENGTH = lDCMRLowBit >> 2;
  nNumPlanes = CalcNumPlanes();
#ifdef INTERPRETER
  if (nNumPlanes == 0) {
    LP("SimScanNoPerm");
    return;
#endif INTERPRETER
  /************************************************************************/
  /* Code starts here                                                     */
  /************************************************************************/
#ifndef INTERPRETER
  .LDW_MEM iSiteCtr;
  .ADD_LABEL :lblYLoop;
  SimSweepCode();
  .CALL_PROC [pcodSweep];
  .NO_OP;
  .ADD %DS, #offNextWordAddr, iHeapOffset;
  .LDW_MEM iHighBitMask;
  .LDW_MEM iXByteLength;
  .ADD %G0, #0, iPlaneCtr;
  .ADD_LABEL :lblAddrLoop;
  .SUBcc iPlaneCtr, #(nNumPlanes*4), %G0;
  .BR_GRE :lblSkip;
  .LDW_IND iHeapOffset, iPlaneCtr, iWordAddr;
  .AND iHighBitMask, iWordAddr, iHighBit;
  .XNOR iHighBitMask, %G0, iHighBitMask;
  .AND iHighBitMask, iWordAddr, iWordAddr;
  .ADD iXByteLength, iWordAddr, iWordAddr;
  .XOR iHighBit, iWordAddr, iWordAddr;
  .STW_IND iHeapOffset, iPlaneCtr, iWordAddr;
  .ADD iPlaneCtr, #4, iPlaneCtr;
  .BRANCH :lblAddrLoop;
  .XNOR iHighBitMask, %G0, iHighBitMask;
  .ADD_LABEL :lblSkip;
  .SH_LEFT iXByteLength, #3, iTemp1;
  .LDW_MEM iScanIndexReg;
  .ADD iScanIndexReg, iTemp1, iScanIndexReg;
  .SUBcc iScanIndexReg, #0xFFFFFF, iTemp1;
  .BR_L :lblSkip;
  .NO_OP;
  .OR %G0, %G0, iScanIndexReg;
  .ADD_LABEL :lblSkip;
  .SUBcc iSiteCtr, #1, iSiteCtr;
  .BR_NZ :lblYLoop;
  .STW_MEM iScanIndexReg;
  LP("SimScanNoPerm");
#else INTERPRETER
  while (SITE_CTR != 0) {
    SimSweepCode();
    for(PLANE_CTR = 0; PLANE_CTR < nNumPlanes; PLANE_CTR++) {  
      WORD_ADDR = NEXT_WORD_ADDR[PLANE_CTR];
      HIGH_BIT = WORD_ADDR & HIGH_BIT_MASK;
      WORD_ADDR &= (~ HIGH_BIT_MASK);
      WORD_ADDR += X_BYTE_LENGTH;
      WORD_ADDR ^= HIGH_BIT;
      NEXT_WORD_ADDR[PLANE_CTR] = WORD_ADDR;
      /*
      NEXT_WORD_ADDR[PLANE_CTR] =
	(((NEXT_WORD_ADDR[PLANE_CTR] & (~ HIGH_BIT_MASK)) + X_BYTE_LENGTH) ^
	 (NEXT_WORD_ADDR[PLANE_CTR] & HIGH_BIT_MASK));
	 */
    }
    SCAN_INDEX_REG += (X_BYTE_LENGTH << 3);
    if (SCAN_INDEX_REG > 0xFFFFFF)
      SCAN_INDEX_REG = 0;
    SITE_CTR--;
    ConstantSetAll(SIR, SCAN_INDEX_REG);
  LP("SimScanNoPerm");
#endif INTERPRETER
#ifndef INTERPRETER
void SimSweepCode()
  LONG32 xWordLength;
  CODELABEL lblXLoop;
  unsigned short nBitOffset[CHIPS_PER_MOD];
  short i, j;
  CODEPTR pcodCurrent = pcodSweep;
  EP("SimSweepCode");
  lblXLoop = NewLabel();
#else INTERPRETER
void SimSweepCode()
  short i, j;
  LONG32 NBIT_OFFSET[CHIPS_PER_MOD], XWORD_LENGTH;
  EP("SimSweepCode");
#endif INTERPRETER
  /************************************************************************/
  /* We assume here that the scan index is not permuted to arrive at the  */
  /* site address; however, some bits of the site address could be fixed  */
  /* at constant 0 or 1 as indicated by SIPR. Here, the site address of   */
  /* the first site to be updated is computed.                            */
  /************************************************************************/
  SITE_ADDR = 0;
  for (i = SCAN_INDEX_LENGTH-1; i >= 0; i--) {
    
    SITE_ADDR <<= 1;
    if (SIPR[i][0] == PERM_CONST_1)
      SITE_ADDR |= 0x1;
    else if (SIPR[i][0] != PERM_CONST_0)
      SITE_ADDR |= (SIR[0] >> i) & 0x1;
  /***************************************7
*********************************/
  /* Now that we know the site address of the first site to be updated,   */
  /* we compute the address in sparc memory of the word that contains     */
  /* a bit of that site by adding the plane offset to the site address.   */
  /************************************************************************/
#ifndef INTERPRETER
  for (i = 0; i < nNumPlanes; i++) {
    NEXT_WORD_ADDR(i) = (AddSiteAddress(SITE_ADDR, OSR[i]) >> 5) << 2;
    NEXT_WORD_ADDR(i) += BIT_PLANE_ADDR(i);
    nBitOffset[i] = OSR[i] & 0x1F;
  xWordLength = X_BYTE_LENGTH >> 2;
  NewBlock(&pcodCurrent);
  .ENTER_PROC;
  SimLoadFirstWord(nBitOffset);
  if (IsSrcNeeded(SRC_SITE_ADDRESS)) {
    .LDW_MEM iScanIndexReg;
  if (IsSrcNeeded(SRC_LUT)) {
    .LDW_MEM iLutAddr;
  .LDW_MEM iUpdateSiteProc;
  .ADD %G0, #xWordLength, iXCtr;
  .ADD_LABEL :lblXLoop;
  SimUpdateSite();
  for (i = 0; i < 32; i++) {
    .CALL_LEAF_IND iUpdateSiteProc, #4;
    .INSTR *pcodUpdateSite;
    for (j = 0; j < nNumPlanes; j++) {
      if (nBitOffset[j] == (31 - i)) {
	SimGetNextWord(j);
      }
    }
  .SUBcc iXCtr, #1, iXCtr;
  .BR_NZ :lblXLoop;
  .NO_OP;
  SimSaveLastWord(nBitOffset);
  .RETURN_PROC;
  EndBlock();
  LP("SimSweepCode");
#else INTERPRETER
  for (i = 0; i < nNumPlanes; i++) {
    NEXT_WORD_ADDR[i] = (AddSiteAddress(SITE_ADDR, OSR[i]) >> 5) << 2;
    NEXT_WORD_ADDR[i] += BIT_PLANE_ADDR[i];
    NBIT_OFFSET[i] = OSR[i] & 0x1F;
  XWORD_LENGTH = X_BYTE_LENGTH >> 2;
  SimLoadFirstWord(NBIT_OFFSET);
  X_CTR = XWORD_LENGTH;
  do {
    for (i = 0; i < 32; i++) {
      SimUpdateSite();
      for (j = 0; j < nNumPlanes; j++) {
	if (NBIT_OFFSET[j] == (31 - i))
	  SimGetNextWord(j);
      }
    }
    X_CTR -= 1;
  } while (X_CTR);
  SimSaveLastWord(NBIT_OFFSET);
  LP("SimSweepCode");
#endif INTERPRETER
#ifndef INTERPRETER
void SimLoadFirstWord(unsigned short nBitOffset[])
  short i;
  const short iSaveBits = iTemp1;
  const short iWordAddr = iTemp1;
  EP("SimLoadFirstWord");
  for (i = 0; i < nNumPlanes; i++) {
    .LDW_IND %DS, #(offNextWordAddr+(i<<2)), iWordAddr;
    .LDW_IND iWordAddr, #0, (iPlaneWord+i);
    if (nBitOffset[i] != 0) {
      .SH_RIGHT (iPlaneWord+i), #(32 - nBitOffset[i]), iSaveBits;
      .SH_LEFT (iPlaneWord+i), #nBitOffset[i], (iPlaneWord+i);
      .OR (iPlaneWord+i), iSaveBits, (iPlaneWord+i);
    }
  LP("SimLoadFirstWord");
#else INTERPRETER
void SimLoadFirstWord(LONG32 NBIT_OFFSET[])
  short i;
  LONG32 SAVE_BITS, WORD_ADDR;
  EP("SimLoadFirstWord");
  for (i = 0; i < nNumPlanes; i++) {
    PLANE_WORD[i] = *((LONG32 *) NEXT_WORD_ADDR[i]);
    
    if (NBIT_OFFSET[i] != 0) {
      SAVE_BITS = PLANE_WORD[i] >> (32 - NBIT_OFFSET[i]);
      PLANE_WORD[i] <<= NBIT_OFFSET[i];
      PLANE_WORD[i] |= SAVE_BITS;
    }
  LP("SimLoadFirstWord");
#endif INTERPRETER
#ifndef INTERPRETER
void SimGetNextWord(unsigned short nPlane)
  const short iAddrHighBit = iTemp1;
  BOOL bWriteBack = FALSE;
  short i;
  EP("SimGetNextWord");
#else INTERPRETER
void SimGetNextWord(unsigned short nPlane)
  LONG32 ADDR_HIGH_BIT;
  BOOL bWriteBack = FALSE;
  short i;
  EP("SimGetNextWord");
#endif INTERPRETER
#ifndef INTERPRETER
  .ENTER_BASICBLK;
  if (IsDestUpdated(DEST_SITE_DATA)) {
    .STW_IND (iNextWordAddr+nPlane), #0, (iPlaneWord+nPlane);
  if (lNumXBits <= 5) {
    .RETURN_BASICBLK;
    LP("SimGetNextWord");
    return;
  .AND (iNextWordAddr+nPlane), iXHighBitMask, iAddrHighBit;
  .XNOR iXHighBitMask, %G0, iXHighBitMask;
  .AND (iNextWordAddr+nPlane), iXHighBitMask, (iNextWordAddr+nPlane);
  .ADD (iNextWordAddr+nPlane), #4, (iNextWordAddr+nPlane);
  .XOR iAddrHighBit, (iNextWordAddr+nPlane), iNextWordAddr+nPlane;
  .XNOR iXHighBitMask, %G0, iXHighBitMask;
  .LDW_IND (iNextWordAddr+nPlane), #0, (iPlaneWord+nPlane);
  .STW_MEM (iNextWordAddr+nPlane);
  .RETURN_BASICBLK;
  LP("SimGetNextWord");
#else INTERPRETER
  if (IsDestUpdated(DEST_SITE_DATA))
      *((LONG32 *) NEXT_WORD_ADDR[nPlane]) = PLANE_WORD[nPlane];
  if (lNumXBits <= 5) {
    LP("SimGetNextWord");
    return;
  ADDR_HIGH_BIT = NEXT_WORD_ADDR[nPlane] & X_HIGH_BIT_MASK;
  NEXT_WORD_ADDR[nPlane] &= (~ X_HIGH_BIT_MASK);
  NEXT_WORD_ADDR[nPlane] = (NEXT_WORD_ADDR[nPlane] + 4) ^ ADDR_HIGH_BIT;
  PLANE_WORD[nPlane] = *((LONG32 *) NEXT_WORD_ADDR[nPlane]);
  LP("SimGetNextWord");
#endif INTERPRETER
#ifndef INTERPRETER
void SimSaveLastWord(unsigned short nBitOffset[])
  short i;
  const short iSaveBits = iTemp1;
  EP("SimSaveLastWord");
#else INTERPRETER
void SimSaveLastWord(LONG32 NBIT_OFFSET[])
  short i;
  LONG32 SAVE_BITS;
  EP("SimSaveLastWord");
#endif INTERPRETER
#ifndef INTERPRETER
  if (IsDestUpdated(DEST_SITE_DATA)) {
    .ENTER_BASICBLK;
    for (i = 0; i < nNumPlanes; i++) {
      if (!nBitOffset[i])
	continue;
      .SH_RIGHT (iPlaneWord+i), #(nBitOffset[i]), iSaveBits;
      .SH_LEFT (iPlaneWord+i), #(32 - nBitOffset[i]), (iPlaneWord+i);
      .OR (iPlaneWord+i), iSaveBits, (iPlaneWord+i);
      .STW_IND (iNextWordAddr+i), #0, (iPlaneWord+i);
    }
    .RETURN_BASICBLK;
  LP("SimSaveLastWord");
#else INTERPRETER
  if (IsDestUpdated(DEST_SITE_DATA)) {
    for (i = 0; i < nNumPlanes; i++) {
      if (!NBIT_OFFSET[i])
	continue;
      SAVE_BITS = PLANE_WORD[i] >> NBIT_OFFSET[i];
      PLANE_WORD[i] <<= (32 - NBIT_OFFSET[i]);
      PLANE_WORD[i] |= SAVE_BITS;
      *((LONG32 *) NEXT_WORD_ADDR[i]) = PLANE_WORD[i];
    }
  LP("SimSaveLastWord");
#endif INTERPRETER
#ifndef INTERPRETER
void SimGeneralScan(CODEHANDLE hcodCurrent)
  /************************************************************************/
  /* Sim making no assumptions - in particular, it is expected that   */
  /* the scan index will be permuted, so that updated sites will not be   */
  /* sequentially located in memory.                                      */
  /************************************************************************/
  short i;
  CODELABEL lblMainLoop, lblAddrLoop, lblSkip1, lblSkip2;
  const short iPlaneCtr = iTemp1, iOffset = iTemp2, iPlaneBases = iTemp3;
  const short iBitOffset = iTemp4, iNextWord = iTemp5, iWordAddr = iTemp6;
  const short iSiteAddress = iTemp7, iSAHighBits = iTemp8;
  const short iOffHighBits = iTemp9, iScratch = iTemp9, iPlaneAddr = iTemp10;
  const short iSAAndMask = iTemp1, iSAOrMask = iTemp2;
  LONG32 lSAAndMask, lSAOrMask;
  LONG32 lSweepLength;
  EP("SimGeneralScan");
  nNumPlanes = CalcNumPlanes();
  lblMainLoop = NewLabel();
  lblAddrLoop = NewLabel();
  lblSkip1 = NewLabel();
  lblSkip2 = NewLabel();
#else INTERPRETER
void SimGeneralScan()
  short i;
  LONG32 PLANE_CTR;
  LONG32 SA_HIGH_BITS, OFF_HIGH_BITS, SCRATCH, PLANE_ADDR;
  LONG32 SWEEP_LENGTH, SA_OR_MASK, SA_AND_MASK, WORD_ADDR;
  nNumPlanes = CalcNumPlanes();
  EP("SimGeneralScan");
  if (nNumPlanes == 0) {
    LP("SimGeneralScan");
    return;
#endif INTERPRETER
  /************************************************************************/
  /* First, update things in the heap from where they can be accessed     */
  /* by the compiled code.                                                */
  /************************************************************************/
  /************************************************************************/
  /* Update heap copy of DCMR.						  */
  /************************************************************************/
  DCMR = DCM[0];
  /************************************************************************/
  /* Update heap copy of OFFSETS					  */
  /************************************************************************/
#ifndef INTERPRETER
  for(i = 0 ; i < CHIPS_PER_MOD; i++)
    OFFSETS(i) = OSR[i];
#else INTERPRETER
  for(i = 0 ; i < CHIPS_PER_MOD; i++)
    OFFSETS[i] = OSR[i];
#endif INTERPRETER
  /************************************************************************/
  /* Figure out the site address of the first site to be updated. This is */
  /* needed to update SITE_ADDR for display purposes. Also,               */
  /* compute the SAAndMask and SAOrMask which will be used to do the      */
  /* permutation at execution time.                                       */
  /************************************************************************/
#ifndef INTERPRETER
  SITE_ADDR = 0;
  lSAOrMask = lSAAndMask = 0;
  for (i = SCAN_INDEX_LENGTH-1; i >= 0; i--) {
    
    SITE_ADDR <<= 1;
    lSAOrMask <<= 1;
    lSAAndMask <<= 1;
    
    if (SIPR[i][0] < SCAN_INDEX_LENGTH) {
      
      /* Get the correct bit of scan indx */
      SITE_ADDR |= (SIR[0] >> SIPR[i][0]) & 0x1;
      
      if (SIPR[i][0] == i)
	lSAAndMask |= 1;
    }
    
    /* Constant of 1 */
    else if (SIPR[i][0] == PERM_CONST_1) {
      lSAOrMask |= 1;
      SITE_ADDR |= 1;
    }
    
    else if (SIPR[i][0] != PERM_CONST_0)
      WARNING("Invalid SIPR value", "SimGenScan");
    
  /************************************************************************/
  /* Figure out how many sites will be updated, and how many sites/sweep  */
  /************************************************************************/
  SITE_CTR = ScanLength();
  lSweepLength = SweepLength(&X_CTR);
#else INTERPRETER
  SITE_ADDR = 0;
  SA_OR_MASK = SA_AND_MASK = 0;
  for (i = SCAN_INDEX_LENGTH-1; i >= 0; i--) {
    
    SITE_ADDR <<= 1;
    SA_OR_MASK <<= 1;
    SA_AND_MASK <<= 1;
    
    if (SIPR[i][0] < SCAN_INDEX_LENGTH) {
      
	/* Get the correct bit of scan indx */
      SITE_ADDR |= (SIR[0] >> SIPR[i][0]) & 0x1;
      
      if (SIPR[i][0] == i)
	SA_AND_MASK |= 1;
    }
    
    /* Constant of 1 */
    else if (SIPR[i][0] == PERM_CONST_1) {
      SA_OR_MASK |= 1;
      SITE_ADDR |= 1;
    }
      
    else if (SIPR[i][0] != PERM_CONST_0)
      WARNING("Invalid SIPR value", "SimGenScan");
  /************************************************************************/
  /* Figure out how many sites will be updated, and how many sites/sweep  */
  /************************************************************************/
  SITE_CTR = ScanLength();
  SWEEP_LENGTH = SweepLength(&X_CTR);
#endif INTERPRETER
  /************************************************************************/
  /* Next, generate the code. First, permute the scan index register to   */
  /* get the site address.                                                */
  /************************************************************************/
#ifndef INTERPRETER
    .LDW_MEM iSiteCtr;
    .LDW_MEM iXCtr;
    .LDW_MEM iXByteLength;
    
    .ADD_LABEL :lblMainLoop;
    
    .ENTER_BASICBLK;
    .LDW_MEM iScanIndexReg;
    
    .ADD %G0, #lSAAndMask, iSAAndMask;
    .ADD %G0, #lSAOrMask, iSAOrMask;
    
    .AND iScanIndexReg, iSAAndMask, iSiteAddress;
    .OR iSAOrMask, iSiteAddress, iSiteAddress;
    
    for (i = SCAN_INDEX_LENGTH-1; i >= 0; i--) {
      if ((SIPR[i][0] < SCAN_INDEX_LENGTH) && (SIPR[i][0] != i)) {
	.SH_LEFT iScanIndexReg, #(31 - SIPR[i][0]), iScratch;
	.ADDcc iScratch, iScratch, iScratch;
	.ADDX %G0, %G0, iTemp10;
	.SH_LEFT iTemp10, #i, iTemp10;
	.OR iTemp10, iSiteAddress, iSiteAddress;
      }
    }
      
#else INTERPRETER
  while (SITE_CTR != 0) {
    SITE_ADDR = SCAN_INDEX_REG & SA_AND_MASK;
    SITE_ADDR |= SA_OR_MASK;
    
    for (i = SCAN_INDEX_LENGTH-1; i >= 0; i--) {
      if ((SIPR[i][0] < SCAN_INDEX_LENGTH) && (SIPR[i][0] != i)) {
	SCRATCH = SCAN_INDEX_REG << (31 - SIPR[i][0]);
	bit = HIGHB(SCRATCH);
	SITE_ADDR |= (bit << i);
      }
    }
    
#endif INTERPRETER
    /************************************************************************/
    /* Now, add site address to the offset to get the DRAM address. The     */
    /* addition must break the carries at the dimension cuts. Also, DRAM    */
    /* address must be broken into a SPARC word address and a 5 bit offset  */
    /* into the word                                                        */
    /************************************************************************/
    
#ifndef INTERPRETER
    .ADD %DS, #offOffsets, iOffset;
    .ADD %DS, #offBitPlaneAddr, iPlaneBases;
    .ADD %DS, #offBitOffsets, iBitOffset;
    .ADD %DS, #offNextWordAddr, iNextWord;
    
    .LDW_MEM iDcmr;
    .AND iDcmr, iSiteAddress, iSAHighBits;
    .XNOR %G0, iDcmr, iDcmr;
    .AND iDcmr, iSiteAddress, iSiteAddress;
    .AND iDcmr, iSiteAddress, iScratch;
    .AND iScratch, #(SITE_ADDR_MASK), iSiteAddress;
    .XNOR %G0, iDcmr, iDcmr;
    
    .ADD %G0, #0, iPlaneCtr;
    .ADD_LABEL :lblAddrLoop;
    
    .LDW_IND iOffset, iPlaneCtr, iWordAddr;
    .AND iDcmr,  iWordAddr, iOffHighBits;
    .XNOR %G0, iDcmr, iDcmr;
    .AND iDcmr,  iWordAddr, iWordAddr;
    .ADD iSiteAddress, iWordAddr, iWordAddr;
    .XOR iWordAddr, iOffHighBits, iWordAddr;
    .XOR iWordAddr, iSAHighBits, iWordAddr;
    
    .LDW_IND iPlaneBases, iPlaneCtr, iPlaneAddr;
    .SH_RIGHT iWordAddr, #5, iScratch;
    .SH_LEFT iScratch, #2, iScratch;
    .ADD iScratch, iPlaneAddr, iScratch;
    .STW_IND iNextWord, iPlaneCtr, iScratch;
    .AND iWordAddr, #0x1F, iWordAddr;
    .STW_IND iBitOffset, iPlaneCtr, iWordAddr;
    
    .ADD iPlaneCtr, #4, iPlaneCtr;
    .SUBcc iPlaneCtr, #(nNumPlanes * 4), %G0;
    .BR_L :lblAddrLoop;
    .XNOR %G0, iDcmr, iDcmr;
    
    .RETURN_BASICBLK;
    
#else INTERPRETER
    SA_HIGH_BITS = SITE_ADDR & DCMR;
    SITE_ADDR = SITE_ADDR & (~ DCMR); 
    SITE_ADDR = (SITE_ADDR & (~ DCMR)) & SITE_ADDR_MASK;
    for(PLANE_CTR = 0; PLANE_CTR < nNumPlanes; PLANE_CTR++) {
      WORD_ADDR = OFFSETS[PLANE_CTR];
      OFF_HIGH_BITS = WORD_ADDR & DCMR;
      WORD_ADDR = SITE_ADDR + (WORD_ADDR & (~ DCMR));
      WORD_ADDR = (WORD_ADDR ^ OFF_HIGH_BITS) ^ SA_HIGH_BITS;
      PLANE_ADDR = BIT_PLANE_ADDR[PLANE_CTR];
      NEXT_WORD_ADDR[PLANE_CTR] = PLANE_ADDR + ((WORD_ADDR >> 5) << 2);
      BIT_OFFSETS[PLANE_CTR] = WORD_ADDR & 0x1F;
    }
#endif INTERPRETER
  /************************************************************************/
  /* Now, the heap has the word addresses and bit offsets for the next    */
  /* site. So go ahead and update the site.                               */
  /************************************************************************/
#ifndef INTERPRETER
  SimUpdateCode();
  .CALL_PROC [pcodGenUpdate];
  .NO_OP;
  .LDW_MEM iScanIndexReg;
  .SUBcc iXCtr, #1, iXCtr;
  .BR_NZ :lblSkip1;
  .NO_OP;
  .ADD %G0, #lSweepLength, iXCtr;
  .ADD_LABEL :lblSkip1;
  .ADD iScanIndexReg, #1, iScanIndexReg;
  .SUBcc iScanIndexReg, #(0xFFFFFF), iScratch;
  .BR_L :lblSkip2;
  .NO_OP;
  .OR %G0, %G0, iScanIndexReg;    
  .ADD_LABEL :lblSkip2;
  .SUBcc iSiteCtr, #1, iSiteCtr;
  .BR_NZ :lblMainLoop;
  .STW_MEM iScanIndexReg;
  LP("SimGeneralScan");
#else INTERPRETER
    SimUpdateCode();
    if ((--X_CTR) == 0)
      X_CTR = SWEEP_LENGTH;
    
    if ((++SCAN_INDEX_REG) > 0xFFFFFF)
      SCAN_INDEX_REG = 0;
    
    SITE_CTR--;
    ConstantSetAll(SIR, SCAN_INDEX_REG);
  LP("SimGeneralScan");
#endif INTERPRETER
#ifndef INTERPRETER
static void SimUpdateCode()
  CODEPTR pcodCurrent = pcodGenUpdate;
  EP("SimUpdateCode");
  NewBlock(&pcodCurrent);
  .ENTER_PROC;
  SimLoadPlaneWords();
  SimUpdateSite();
  .CALL_LEAF [pcodUpdateSite];
  .NO_OP;
  SimSavePlaneWords();
     
  .RETURN_PROC;
  EndBlock();
  LP("SimUpdateCode");
#else INTERPRETER
static void SimUpdateCode()
  EP("SimUpdateCode");
  SimLoadPlaneWords();
  SimUpdateSite();
  SimSavePlaneWords();
  LP("SimUpdateCode");
#endif INTERPRETER
#ifndef INTERPRETER
static void SimLoadPlaneWords()
  short i;
  const short iWordAddr = iTemp1;
  const short iBitOffset = iTemp1;
  const short iSaveBits = iTemp2;
  const short iScratch = iTemp3;
  EP("SimLoadPlaneWords");
  if (!IsSrcNeeded(SRC_SITE_DATA) && !IsSrcNeeded(SRC_GLUED_DATA) &&
      !IsDestUpdated(DEST_SITE_DATA)) {
    LP("SimLoadPlaneWords");
    return;
  .ADD %G0, #32, iScratch;
  for (i = 0; i < nNumPlanes; i++) {
    .LDW_IND %DS, #(offNextWordAddr+(i<<2)), iWordAddr;
    .LDW_IND iWordAddr, #0, (iPlaneWord+i);
    .LDW_IND %DS, #(offBitOffsets+(i<<2)), iBitOffset;
    .SUB iScratch, iBitOffset, iBitOffset;
    .SH_RIGHT (iPlaneWord+i), iBitOffset, iSaveBits;
    .SUB iScratch, iBitOffset, iBitOffset;
    .SH_LEFT (iPlaneWord+i), iBitOffset, (iPlaneWord+i);
    .OR (iPlaneWord+i), iSaveBits, (iPlaneWord+i);
  LP("SimLoadPlaneWords");
#else INTERPRETER
static void SimLoadPlaneWords()
  short i;
  LONG32 WORD_ADDR, BIT_OFFSET, SAVE_BITS;
  EP("SimLoadPlaneWords");
  if (!IsSrcNeeded(SRC_SITE_DATA) && !IsSrcNeeded(SRC_GLUED_DATA) &&
      !IsDestUpdated(DEST_SITE_DATA)) {
    LP("SimLoadPlaneWords");
    return;
  for (i = 0; i < nNumPlanes; i++) {
    WORD_ADDR = NEXT_WORD_ADDR[i];
    PLANE_WORD[i] = *((LONG32 *) WORD_ADDR);
    BIT_OFFSET = BIT_OFFSETS[i];
    SAVE_BITS = PLANE_WORD[i] >> (32 - BIT_OFFSET);
    PLANE_WORD[i] <<= BIT_OFFSET;
    PLANE_WORD[i] |= SAVE_BITS;
    PLANE_WORD[i] = (*((LONG32 *) NEXT_WORD_ADDR[i]) << BIT_OFFSETS[i]) |
                    (*((LONG32 *) NEXT_WORD_ADDR[i]) >> (32 - BIT_OFFSETS[i]));
  LP("SimLoadPlaneWords");
#endif INTERPRETER
#ifndef INTERPRETER
static void SimSavePlaneWords()
  short i;
  const short iWordAddr = iTemp1;
  const short iBitOffset = iTemp1;
  const short iSaveBits = iTemp2;
  const short iScratch = iTemp3;
  EP("SimSavePlaneWords");
  if (!IsDestUpdated(DEST_SITE_DATA)) {
    LP("SimSavePlaneWords");
    return;
  .ADD %G0, #31, iScratch;
  for (i = 0; i < nNumPlanes; i++) {
    .LDW_IND %DS, #(offBitOffsets+(i<<2)), iBitOffset;
    .SUB iScratch, iBitOffset, iBitOffset;
    .SH_LEFT (iPlaneWord+i), iBitOffset, iSaveBits;
    .SUB iScratch, iBitOffset, iBitOffset;
    .ADD iBitOffset, #1, iBitOffset;
    .SH_RIGHT (iPlaneWord+i), iBitOffset, (iPlaneWord+i);
    .OR (iPlaneWord+i), iSaveBits, (iPlaneWord+i);
    .LDW_IND %DS, #(offNextWordAddr+(i<<2)), iWordAddr;
    .STW_IND iWordAddr, #0, (iPlaneWord+i);
  LP("SimSavePlaneWords");
}     
#else INTERPRETER
static void SimSavePlaneWords()
  short i;
  LONG32 WORD_ADDR, BIT_OFFSET, SAVE_BITS;
  EP("SimSavePlaneWords");
  if (!IsDestUpdated(DEST_SITE_DATA)) {
    LP("SimSavePlaneWords");
    return;
  for (i = 0; i < nNumPlanes; i++) {
    BIT_OFFSET = BIT_OFFSETS[i];
    SAVE_BITS = PLANE_WORD[i] << (31 - BIT_OFFSET);
    PLANE_WORD[i] >>= (BIT_OFFSET + 1);
    PLANE_WORD[i] |= SAVE_BITS;
    WORD_ADDR = NEXT_WORD_ADDR[i];
    *((LONG32 *) WORD_ADDR) = PLANE_WORD[i];
    PLANE_WORD[i] = (PLANE_WORD[i] >> (BIT_OFFSETS[i] + 1)) |
                    (PLANE_WORD[i] << (31 - BIT_OFFSETS[i]));
    *((LONG32 *) NEXT_WORD_ADDR[i]) = PLANE_WORD[i];
  LP("SimSavePlaneWords");
}     
#endif INTERPRETER
#ifndef INTERPRETER
short PermuteScanIndex()
#else INTERPRETER
LONG32 *PermuteScanIndex()
#endif INTERPRETER
  short i;
  BOOL bIsPermuted = FALSE;
  EP("PermuteScanIndex");
  for (i = nNumPlanes - 1; i >= 0; i--) {
    if (SABSR[i] != i) {
      bIsPermuted = TRUE;
      break;
    }
#ifndef INTERPRETER
  if (!bIsPermuted) {
    LP("PermuteScanIndex");
    return (iScanIndexReg);
#else INTERPRETER
  if (!bIsPermuted) {
    LP("PermuteScanIndex");
    return(&SCAN_INDEX_REG);
#endif INTERPRETER
#ifndef INTERPRETER
  .OR %G0, %G0, iTemp6;
  for (i = nNumPlanes-1; i >= 0; i--) {
    if (SABSR[i] < 24) {
      .SH_LEFT iScanIndexReg, #(31 - SABSR[i]), iTemp5;
      .ADDcc iTemp5, iTemp5, iTemp5;
      .ADDXcc iTemp6, iTemp6, iTemp6;
    }
    else if (SABSR[i] == 31) {
      .SH_LEFT iTemp6, #1, iTemp6;
      .ADD iTemp6, #1, iTemp6;
    }
    else if (SABSR[i] == 30) {
      .SH_LEFT iTemp6, #1, iTemp6;
    }
    else {
      WARNING("Invalid SABSR value!", "PermuteScanIndex");
      .SH_LEFT iTemp6, #1, iTemp6;
    }
  LP("PermuteScanIndex");
  return (iTemp6);
#else INTERPRETER
  TEMP6 = 0;
  for (i = nNumPlanes-1; i >= 0; i--) {
    if (SABSR[i] < 24) {
      TEMP5 = SCAN_INDEX_REG << (31 - SABSR[i]);
      bit = HIGHB(TEMP6);
      TEMP6 = (TEMP6 << 1) | HIGHB(TEMP5);
      TEMP5 <<= 1;
    }
    else if (SABSR[i] == 31) {
      TEMP6 <<= 1;
      TEMP6 += 1;
    }
    else if (SABSR[i] == 30) {
      TEMP6 <<= 1;
    }
    else {
      WARNING("Invalid SABSR value!", "PermuteScanIndex");
      TEMP6 <<= 1;
    }
  LP("PermuteScanIndex");
  return (&TEMP6);
#endif INTERPRETER
#ifndef INTERPRETER
void MapFunction (short iSrcVar, short iDestVar, BYTE bMap)
#else INTERPRETER
void MapFunction (LONG32 *SrcVar, LONG32 *DestVar, BYTE bMap)
#endif INTERPRETER
  EP("MapFunction");
  switch (bMap) {
  case MAP_CONST_0: {
#ifndef INTERPRETER
    .OR %G0, %G0, iDestVar;
#else INTERPRETER
    *DestVar = 0;
#endif INTERPRETER
    break;
    
  case MAP_G_NOR_S: {
#ifndef INTERPRETER
    /* Surprizingly, SPARC does not have*/
    /* a native NOR instruction! ORN is */
    /* not NOR!!!                       */
    .OR iGlueData, iSrcVar, iDestVar;
    .XNOR %G0, iDestVar, iDestVar;
#else INTERPRETER
    *DestVar = ~ (GLUE_DATA | *SrcVar);
#endif INTERPRETER
    break;
}    
  case MAP_G_AND_S_BAR: {
#ifndef INTERPRETER
    .XNOR %G0, iSrcVar, iDestVar;
    .AND iGlueData, iDestVar, iDestVar;
#else INTERPRETER
    *DestVar = GLUE_DATA & (~ *SrcVar);
#endif INTERPRETER
    break;
    
  case MAP_S_BAR: {
#ifndef INTERPRETER
    .XNOR %G0, iSrcVar, iDestVar;
#else INTERPRETER
    *DestVar = ~ *SrcVar;
#endif INTERPRETER
    break;
    
  case MAP_G_BAR_AND_S: {
#ifndef INTERPRETER
    .XNOR %G0, iGlueData, iDestVar;
    .AND iSrcVar, iDestVar, iDestVar;
#else INTERPRETER
    *DestVar = (~ GLUE_DATA) & *SrcVar;
#endif INTERPRETER
    break;
    
  case MAP_G_BAR: {
#ifndef INTERPRETER
    .XNOR %G0, iGlueData, iDestVar;
#else INTERPRETER
    *DestVar = ~ GLUE_DATA;
#endif INTERPRETER
    break;
    
  case MAP_G_XOR_S: {
#ifndef INTERPRETER
    .XOR iGlueData, iSrcVar, iDestVar;
#else INTERPRETER
    *DestVar = GLUE_DATA ^ *SrcVar;
#endif INTERPRETER
    break;
    
  case MAP_G_NAND_S: {
#ifndef INTERPRETER
    /* SPARC does not have a native NAND */
    /* instruction! ANDN is not NAND     */
    .AND iGlueData, iSrcVar, iDestVar;
    .XNOR %G0, iDestVar, iDestVar;
#else INTERPRETER
    *DestVar = ~ (GLUE_DATA & *SrcVar);
#endif INTERPRETER
    break;
    
  case MAP_G_AND_S: {
#ifndef INTERPRETER
    .AND iGlueData, iSrcVar, iDestVar;
#else INTERPRETER
    *DestVar = GLUE_DATA & *SrcVar;
#endif INTERPRETER
    break;
    
  case MAP_G_EQ_S: {
#ifndef INTERPRETER
    .XNOR iGlueData, iSrcVar, iDestVar;
#else INTERPRETER
    *DestVar = ~ (GLUE_DATA ^ *SrcVar);
#endif INTERPRETER
    break;
    
  case MAP_G: {
#ifndef INTERPRETER
    .XOR %G0, iGlueData, iDestVar;
#else INTERPRETER
    *DestVar = GLUE_DATA;
#endif INTERPRETER
    break;
    
  case MAP_G_OR_S_BAR: {
#ifndef INTERPRETER
    .XNOR %G0, iSrcVar, iDestVar;
    .OR iGlueData, iDestVar, iDestVar;
#else INTERPRETER
    *DestVar = GLUE_DATA | (~ *SrcVar);
#endif INTERPRETER
    break;
    
  case MAP_S: {
#ifndef INTERPRETER
    .XOR %G0, iSrcVar, iDestVar
#else INTERPRETER
    *DestVar = *SrcVar;
#endif INTERPRETER
      break;
    
  case MAP_G_BAR_OR_S: {
#ifndef INTERPRETER
    .XNOR %G0, iGlueData, iDestVar;
    .OR iSrcVar, iDestVar, iDestVar;
#else INTERPRETER
    *DestVar = (~ GLUE_DATA) | *SrcVar;
#endif INTERPRETER
      break;
    
  case MAP_G_OR_S: {
#ifndef INTERPRETER
    .OR iGlueData, iSrcVar, iDestVar;
#else INTERPRETER
    *DestVar = GLUE_DATA | *SrcVar;
#endif INTERPRETER
    break;
    
  case MAP_CONST_1: {
#ifndef INTERPRETER
    .XNOR %G0, %G0, iDestVar;
#else INTERPRETER
    *DestVar = 0xFFFFFFFF;
#endif INTERPRETER
    break;
  LP("MapFunction");
#ifndef INTERPRETER
void BuildDest(short nDest, short iDestVar, BYTE Src, BYTE Map)
  short iSrcVar;
#else INTERPRETER
void BuildDest(short nDest, LONG32 *DestVar, BYTE Src, BYTE Map)
  LONG32 *SrcVar;
#endif INTERPRETER
  EP("BuildDest");
#ifndef INTERPRETER
  if ((Map != MAP_G) && (Map != MAP_G_BAR)) {
    iSrcVar = (Src == SRC_SITE_DATA ? iUnGlueData :
	       Src == SRC_TBUS ? iTbusData :
	       Src == SRC_LUT ? iLutData : iTemp1);
    if ((nDest == DEST_LUT) && (Src == SRC_SITE_ADDRESS)) {
      iSrcVar = PermuteScanIndex();
    }
  MapFunction(iSrcVar, iDestVar, Map);
#else INTERPRETER
  if ((Map != MAP_G) && (Map != MAP_G_BAR)) {
    SrcVar = (Src == SRC_SITE_DATA ? &UNGLUE_DATA :
	      Src == SRC_TBUS ? &TBUS_DATA :
	      Src == SRC_LUT ? &LUT_DATA : &TEMP1);
    if ((nDest == DEST_LUT) && (Src == SRC_SITE_ADDRESS)) {
      SrcVar = PermuteScanIndex();
    }
  MapFunction(SrcVar, DestVar, Map);
#endif INTERPRETER
  LP("BuildDest");
#ifndef INTERPRETER
void BuildBitDest(short nDest, short iHoldReg, BYTE Src, BYTE Map,
		  unsigned short nPlane)
{                                                               
     
#else INTERPRETER
void BuildBitDest(short nDest, LONG32 *HoldReg, BYTE Src, BYTE Map,
		  unsigned short nPlane)
{                                                               
#endif INTERPRETER
  EP("BuildBitDest");
#ifndef INTERPRETER
  if ((nDest == DEST_LUT) && (Src == SRC_SITE_ADDRESS)) {
    .OR           %G0, %G0, iTemp6;
    
    if (SABSR[nPlane] < 24) {
      .SH_LEFT iScanIndexReg, #(31 - SABSR[nPlane]), iTemp5;
      .ADDcc iTemp5, iTemp5, iTemp5;
      .ADDXcc iTemp6, iTemp6, iTemp6;
      .SH_LEFT iTemp6, #nPlane, iTemp6;
    }
    else if (SABSR[nPlane] == 31) {
      .SH_LEFT iTemp6, #1, iTemp6;
      .ADD iTemp6, #1, iTemp6;
    }
    else if (SABSR[nPlane] == 30) {
      .SH_LEFT iTemp6, #1, iTemp6;
    }
    else {
      WARNING("Invalid SABSR value", "BuildBitDest");
      .SH_LEFT iTemp6, #1, iTemp6;
    }      
    MapFunction (iTemp6, iHoldReg, Map);
  else
    BuildDest(nDest, iHoldReg, Src, Map);
#else INTERPRETER
  if ((nDest == DEST_LUT) && (Src == SRC_SITE_ADDRESS)) {
    TEMP6 = 0;
    if (SABSR[nPlane] < 24) {
      TEMP5 = SCAN_INDEX_REG << (31 - SABSR[nPlane]);
      bit = HIGHB(TEMP6);
      TEMP6 = ((TEMP6 << 1) | HIGHB(TEMP5)) << nPlane;
      TEMP5 <<= 1;
    }
    else if (SABSR[nPlane] == 31)
      TEMP6 = (TEMP6 << 1) + 1;
    else if (SABSR[nPlane] == 30)
      TEMP6 <<= 1;
    else {
      WARNING("Invalid SABSR value", "BuildBitDest");
      TEMP6 <<= 1;
    }
    MapFunction (&TEMP6, HoldReg, Map);
  else
    BuildDest(nDest, HoldReg, Src, Map);
#endif INTERPRETER
  LP("BuildBitDest");
#ifndef INTERPRETER
void BuildBitwiseDest(short nDest, short iDestVar, BYTE Src[], BYTE Map[])
  short i;
  short iHoldReg = iTemp4;
#else INTERPRETER
void BuildBitwiseDest(short nDest, LONG32 *DestVar, BYTE Src[], BYTE Map[])
  short i;
  LONG32 *HoldReg = &TEMP4;
#endif INTERPRETER
  EP("BuildBitwiseDest");
#ifndef INTERPRETER
  for (i = nNumPlanes - 1; i >= 0; i--) {
    BuildBitDest(nDest, iHoldReg, Src[i], Map[i], i);
    .SH_LEFT iHoldReg, #(31 - i), iHoldReg;
    .ADDcc iHoldReg, iHoldReg, iHoldReg;
    .ADDXcc iDestVar, iDestVar, iDestVar;
#else INTERPRETER
  for (i = nNumPlanes - 1; i >= 0; i--) {
    BuildBitDest(nDest, HoldReg, Src[i], Map[i], i);
    *HoldReg <<= (31 - i);
    bit = HIGHB(*DestVar);
    *DestVar = (*DestVar << 1) | HIGHB(*HoldReg);
    *HoldReg <<= 1;
#endif INTERPRETER
  LP("BuildBitwiseDest");
/*****************************************************************************/
/*                                                                           */
/* This routine adds two longs breaking the carries at positions indicated   */
/* by the Dimension Cut Mask Register (DCMR). The DCMR has a 1 bit at every  */
/* bit position where the carry needs to be cut.                             */
/*                                                                           */
/*****************************************************************************/
LONG32 AddSiteAddress(LONG32 lSrc1, LONG32 lSrc2)
  LONG32 lHighBits1, lHighBits2;
  lHighBits1 = lSrc1 & DCM[0];
  lHighBits2 = lSrc2 & DCM[0];
  lSrc1 &= (~DCM[0]);
  lSrc2 &= (~DCM[0]);
  return( (lSrc1 + lSrc2) ^ lHighBits1 ^ lHighBits2 );
LONG32 SubSiteAddress(LONG32 lSrc1, LONG32 lSrc2)
  LONG32 lSignBitOffset, lSignBitKick, lLowBitsKick;
  lSignBitOffset = lSrc1 & DCM[0];
  lSignBitKick = (~lSrc2) & DCM[0];
  lSrc1 |= DCM[0];
  lLowBitsKick = lSrc2 & (~ DCM[0]);
  lSrc1 -= lLowBitsKick;
  lSignBitOffset = lSignBitOffset ^ lSignBitKick;
  lSrc1 ^= lSignBitOffset;
/*****************************************************************************/
/*                                                                           */
/* Compute the Scan length - the number of sites that will be updated in     */
/* the current scan. Basically, it should be 2^ESCP, but we need to correct  */
/* for the fact that the SIR low-order bits might not be all zero            */
/*                                                                           */
/*****************************************************************************/
LONG32 ScanLength()
  LONG32 lCarryOVFBit, lScanLength, lSIRBits;
  lCarryOVFBit = ESC[0];
  lScanLength = (1 << lCarryOVFBit);                                  
  lSIRBits = SIR[0] & (lScanLength - 1);
  lScanLength -= lSIRBits;
  return (lScanLength);
/*****************************************************************************/
/*                                                                           */
/* Determine the sweep length. The sweep length is given by either the low   */
/* bit of the DCMR or the ESCP (End-of-Scan-pointer) or the SFR register.    */
/* This is because the scan could update many lines of the lowest (X) dimen- */
/* sion, or could update just part of 1 line in the X dimension.             */
/*                                                                           */
/*****************************************************************************/
LONG32 SweepLength(LONG32 *lFirstSweep)
  LONG32 lCarryOVFBit, lSweepLength;
  lCarryOVFBit = MIN(ESW[0], lNumXBits);
  lSweepLength = (1 << lCarryOVFBit);
  *lFirstSweep = (SIR[0] & (lSweepLength - 1));
  *lFirstSweep = lSweepLength - *lFirstSweep;
  return (lSweepLength);
/*****************************************************************************/
/*                                                                           */
/* DCMRHighBit returns a long with exactly one of the 32 bits set to 1. This */
/* bit position corresponds to the highest bit in the DCMR that has a 1.     */
/*                                                                           */
/*****************************************************************************/
LONG32 DCMRHighBit()
  LONG32 lTemp1, lTemp2;                                                      
  lTemp1 = DCM[0];
  lTemp2 = 1;
  while (lTemp1 > 1) {
    lTemp1 >>= 1;
    lTemp2 <<= 1;
  return (lTemp2);
/*****************************************************************************/
/*                                                                           */
/* DCMRLowBit returns a long with exactly one of the 32 bits set to 1. This  */
/* bit position corresponds to the lowest bit in the DCMR that has a 1. We   */
/* refer to this lowest dimension generically as the X dimension.            */
/*                                                                           */
/*****************************************************************************/
LONG32 DCMRLowBit()
  LONG32 lTemp1, lTemp2;
  lTemp1 = DCM[0];
  lTemp2 = 1;
  lNumXBits = 1;
  while ((lTemp1 != 0) && ((lTemp1 & 0x01) == 0)) {
    lTemp1 >>= 1;
    lTemp2 <<= 1;
    lNumXBits++;
  return (lTemp2);
void UpdateDCMR()
  lDCMRHighBit = DCMRHighBit();
  lDCMRLowBit = DCMRLowBit();
/*****************************************************************************/
/*                                                                           */
/* The following are general purpose routines that conveniently answer       */
/* queries about the sources and destinations that need to be updated        */
/*                                                                           */
/*****************************************************************************/
/*****************************************************************************/
/*                                                                           */
/* Is a particular source needed? Only checks those planes that will be      */
/* updated or used during the next scan.                                     */
/*                                                                           */
/*****************************************************************************/
BOOL IsSrcNeeded(short nSrc)
  short i, j;
  short nLastDest;
  nLastDest = (nSrc == SRC_TBUS ? DEST_LUT : DEST_DISPLAY);
  for (i = nNumPlanes - 1; i >= 0; i--) {
    for (j = DEST_SITE_DATA; j <= nLastDest; j++) {
      if (bDestSrcMatrix[i][j][nSrc]) {
	return TRUE;
      }
    }
  return FALSE;
/*****************************************************************************/
/*                                                                           */
/* Checks to see if the source/map is the same for all planes for the given  */
/* destination.                                                              */
/*                                                                           */
/*****************************************************************************/
BOOL IsSrcSame(short nDest)
  short i;
  BYTE *src, *map;
  switch (nDest) {
  case DEST_SITE_DATA:
    src = SDS;
    map = SDM;
    break;
  case DEST_EVENT_CT:
    src = ECS;
    map = ECM;
    break;
  case DEST_DISPLAY:
    src = DDS;
    map = DDM;
    break;
  case DEST_LUT:
    src = LAS;
    map = LAM;
    break;
  default:
    return FALSE;
    break;
  for(i = 1; i < nNumPlanes; i++)
    if ((src[0] != src[i]) || (map[0] != map[i]))
      return FALSE;
  return TRUE;
/*****************************************************************************/
/*                                                                           */
/* See if a particular destination will be changed during the current scan   */
/*                                                                           */
/*****************************************************************************/
BOOL IsDestUpdated(short nDest)
  short i, j;
  for (i = nNumPlanes-1; i >= 0; i--)
    for ( j = SRC_SITE_DATA; j <= SRC_CONST_DATA; j++)
      if (bDestSrcMatrix[i][nDest][j])
	return(TRUE);
  return(FALSE);
/*****************************************************************************/
/*                                                                           */
/* Calculate the number of planes that will be updated or used in the next   */
/* scan.                                                                     */
/*                                                                           */
/*****************************************************************************/
unsigned short CalcNumPlanes()
  BOOL       bPlaneUsed[CHIPS_PER_MOD];
  short      i, j;
  memset ((char *) bPlaneUsed, 0, CHIPS_PER_MOD * sizeof(BOOL));
  UpdateDestSrcMatrix();
  for (i = CHIPS_PER_MOD-1; i >= 0; i--) {
    for (j = DEST_SITE_DATA; j <= DEST_DISPLAY; j++) {
      if ( bDestSrcMatrix[i][j][SRC_SITE_DATA] || 
	  bDestSrcMatrix[i][j][SRC_GLUED_DATA] ) {
	bPlaneUsed[i] = TRUE;
      }
    }
    
    if (!bPlaneUsed[i]) {
      for (j = SRC_TBUS; j <= SRC_CONST_DATA; j++) {
	if (bDestSrcMatrix[i][DEST_SITE_DATA][j]) {
	  bPlaneUsed[i] = TRUE;
      }
    }
    if (bPlaneUsed[i])
      break;
  }  
  return ((unsigned short) i + 1);
/*****************************************************************************/
/*                                                                           */
/* Updates a matrix of sources and destinations. There are 5 sources, 4 dest */
/* and 16 planes. In addition, there is a bit per destination indicating     */
/* whether the map field selects an inverse function or just the function.   */
/* Thus, the SrcDestMatrix is a 6x4x16 matrix.                               */
/*                                                                           */
/*****************************************************************************/
void UpdateDestSrcMatrix()
  short      i;
  char       *szFuncName = "UpdateDestSrcMatrix";    
  memset((char *) bDestSrcMatrix, 0, CHIPS_PER_MOD*NUM_SRC*NUM_DEST);
  for (i = 0; i < CHIPS_PER_MOD; i++) {
    
    /*
     * If the source for the site is the site then don't bother to generate
     * code for this.  If the map selects only the glue lines then the source
     * selection is irrelevant.  If the map selects MAP_G then this is
     * effectively the same as selecting site as the source.  If the map
     * selects CONST_0 or CONST_1 then we handle this as a special case.
     */
    if (SDS[i] != SRC_SITE_DATA)
      bDestSrcMatrix[i][DEST_SITE_DATA][SDS[i]] = TRUE;
    if ((SDM[i] != MAP_S) && (SDM[i] != MAP_S_BAR)) {
      if (SDM[i] != MAP_G)
	bDestSrcMatrix[i][DEST_SITE_DATA][SRC_GLUED_DATA] = TRUE;
      if ((SDM[i] == MAP_CONST_0) || (SDM[i] == MAP_CONST_1)) {
	bDestSrcMatrix[i][DEST_SITE_DATA][SRC_CONST_DATA] = TRUE;
	bDestSrcMatrix[i][DEST_SITE_DATA][SRC_GLUED_DATA] = FALSE;
	bDestSrcMatrix[i][DEST_SITE_DATA][SDS[i]] = FALSE;
      }
      if ((SDM[i] == MAP_G) || (SDM[i] == MAP_G_BAR))
	bDestSrcMatrix[i][DEST_SITE_DATA][SDS[i]] = FALSE;
    }
    /*
     * If the source for the event counter is constant zero then don't bother
     * to generate code for this.  If the map selects only the glue lines then
     * the source selection is irrelevant.
     */
    bDestSrcMatrix[i][DEST_EVENT_CT][ECS[i]] = TRUE;
    if ((ECM[i] != MAP_S) && (ECM[i] != MAP_S_BAR)) {
      bDestSrcMatrix[i][DEST_EVENT_CT][SRC_GLUED_DATA] = TRUE;
      if ((ECM[i] == MAP_CONST_0) || (ECM[i] == MAP_CONST_1)) {
	if (ECM[i] == MAP_CONST_1)
	  bDestSrcMatrix[i][DEST_EVENT_CT][SRC_CONST_DATA] = TRUE;
	bDestSrcMatrix[i][DEST_EVENT_CT][SRC_GLUED_DATA] = FALSE;
	bDestSrcMatrix[i][DEST_EVENT_CT][ECS[i]] = FALSE;
      }
      if ((ECM[i] == MAP_G) || (ECM[i] == MAP_G_BAR))
 	bDestSrcMatrix[i][DEST_EVENT_CT][ECS[i]] = FALSE;
    }
    /*
     * If the source for the display is the host (tbus) then don't bother to
     * generate code for this.  If the map selects only the glue lines then
     * the source selection is irrelevant.
     */
    if ((DDS[i] != SRC_TBUS))
      bDestSrcMatrix[i][DEST_DISPLAY][DDS[i]] = TRUE;
    if ((DDM[i] != MAP_S) && (DDM[i] != MAP_S_BAR)) {
      bDestSrcMatrix[i][DEST_DISPLAY][SRC_GLUED_DATA] = TRUE;
      if ((DDM[i] == MAP_CONST_0) || (DDM[i] == MAP_CONST_1)) {
	bDestSrcMatrix[i][DEST_DISPLAY][SRC_CONST_DATA] = TRUE;
	bDestSrcMatrix[i][DEST_DISPLAY][SRC_GLUED_DATA] = FALSE;
	bDestSrcMatrix[i][DEST_DISPLAY][DDS[i]] = FALSE;
      }
      if ((DDM[i] == MAP_G) || (DDM[i] == MAP_G_BAR)) {
	bDestSrcMatrix[i][DEST_DISPLAY][DDS[i]] = FALSE;
      }
    }
    /*
     * If the map selects only the glue lines then the source selection is
     * irrelevant.
     */
    bDestSrcMatrix[i][DEST_LUT][LAS[i]] = TRUE;
    if ((LAM[i] != MAP_S) && (LAM[i] != MAP_S_BAR)) {
      bDestSrcMatrix[i][DEST_LUT][SRC_GLUED_DATA] = TRUE;
      if ((LAM[i] == MAP_CONST_0) || (LAM[i] == MAP_CONST_1)) {
	bDestSrcMatrix[i][DEST_LUT][SRC_CONST_DATA] = TRUE;
	bDestSrcMatrix[i][DEST_LUT][SRC_GLUED_DATA] = FALSE;
	bDestSrcMatrix[i][DEST_LUT][LAS[i]] = FALSE;
      }
      if ((LAM[i] == MAP_G) || (LAM[i] == MAP_G_BAR)) {
	bDestSrcMatrix[i][DEST_LUT][LAS[i]] = FALSE;
      }
    }
/* Unpack register of length < 32 bits or register field */
void Cam8Sim::UnpackState(INT16 *base, int reg_fld, int imm)
  if (BITLEN(reg_fld) > 32) {
    WARNING("Can't unpack a register or field of len > 32", "UnpackState");
    UnpackBits(base, BITOFF(reg_fld), 32, imm, base_type[reg_fld].base,
	       base_type[reg_fld].type);
  else
    UnpackBits(base, BITOFF(reg_fld), BITLEN(reg_fld), imm,
	       base_type[reg_fld].base, base_type[reg_fld].type);
void Cam8Sim::UnpackStateInto(INT16 *base, int reg_fld, int imm, BYTE *dest, int type)
  if (BITLEN(reg_fld) > 32) {
    WARNING("Can't unpack a register or field of len > 32", "UnpackStateInto");
    UnpackBits(base, BITOFF(reg_fld), 32, imm, dest, type);
  else
    UnpackBits(base, BITOFF(reg_fld), BITLEN(reg_fld), imm, dest, type);
/* Pack register of length < 32 bits or register field */
void Cam8Sim::PackState(INT16 *base, int reg_fld)
  if (BITLEN(reg_fld) > 32) {
    WARNING("Can't pack a register or field of len > 32", "PackState");
    PackBits(base, BITOFF(reg_fld), 32, base_type[reg_fld].base,
	     base_type[reg_fld].type);
  else
    PackBits(base, BITOFF(reg_fld), BITLEN(reg_fld),
	     base_type[reg_fld].base, base_type[reg_fld].type);
void Cam8Sim::PackStateFrom(INT16 *base, int reg_fld, BYTE *src, int type)
  if (BITLEN(reg_fld) > 32) {
    WARNING("Can't pack a register or field of len > 32", "PackStateFrom");
    PackBits(base, BITOFF(reg_fld), 32, src, type);
  else
    PackBits(base, BITOFF(reg_fld), BITLEN(reg_fld), src, type);

---------------------------------------------------------------------------

#ifndef _CAM8SIMJIT_H_
#define _CAM8SIMJIT_H_
#include <pair.h>
#include <stdio.h>
#include <CamLib++.H>
#include "std++.H"
/*****************************************************************************/
/********************************* DEFINES ***********************************/
/*****************************************************************************/
/*****************************************************************************/
/*                                                                           */
/* operand types to use when calling Emit()				     */
/*                                                                           */
/*****************************************************************************/
#define NULL_OP		0
#define REG_OP		1
#define CONST_OP	2
#define ADDR_OP		3
#define VAR_OP		4
#define LABEL_OP	5
/*****************************************************************************/
/*                                                                           */
/* op codes for emit							     */
/*                                                                           */
/*****************************************************************************/
#define PSEUDO_OP	0x8000
#define NATIVE_OP	0x4000
#define LD_ST_OP	0x2000
#define BRANCH_OP	0x1000
#define NATIVE_OP_MASK	0x3F
#define INSTR		(PSEUDO_OP | 0xFF)
#define ENTER_PROC	(PSEUDO_OP | 0x01)
#define RETURN_PROC	(PSEUDO_OP | 0x02)
#define CALL_PROC	(PSEUDO_OP | 0x03)
#define ENTER_LEAF	(PSEUDO_OP | 0x04)
#define RETURN_LEAF	(PSEUDO_OP | 0x05)
#define CALL_LEAF	(PSEUDO_OP | 0x06)
#define CALL_LEAF_IND	(PSEUDO_OP | 0x07)
#define ENTER_BASICBLK	(PSEUDO_OP | 0x08)
#define RETURN_BASICBLK	(PSEUDO_OP | 0x09)
#define ADD_LABEL	(PSEUDO_OP | 0x0A)
#define NO_OP		(PSEUDO_OP | 0x0B)
#define LDW_MEM		(LD_ST_OP | 0x00)
#define LDW_IND		(LD_ST_OP | 0x01)
#define LDHW_IND	(LD_ST_OP | 0x02)
#define LDUB_IND	(LD_ST_OP | 0x03)
#define STW_MEM		(LD_ST_OP | 0x06)
#define STW_IND		(LD_ST_OP | 0x07)
#define STHW_IND	(LD_ST_OP | 0x08)
#define STUB_IND	(LD_ST_OP | 0x09)
#define ADD		(NATIVE_OP | 0x00)
#define ADDcc		(NATIVE_OP | 0x10)
#define ADDX		(NATIVE_OP | 0x08)
#define ADDXcc		(NATIVE_OP | 0x18)
#define	SUB		(NATIVE_OP | 0x04)
#define SUBcc		(NATIVE_OP | 0x14)
#define SUBX		(NATIVE_OP | 0x0C)
#define SUBXcc		(NATIVE_OP | 0x1C)
#define AND		(NATIVE_OP | 0x01)
#define ANDcc		(NATIVE_OP | 0x11)
#define ANDN		(NATIVE_OP | 0x05)
#define ANDNcc		(NATIVE_OP | 0x15)
#define OR		(NATIVE_OP | 0x02)
#define ORcc 		(NATIVE_OP | 0x12)
#define ORN		(NATIVE_OP | 0x06)
#define ORNcc		(NATIVE_OP | 0x16)
#define XOR		(NATIVE_OP | 0x03)
#define XORcc 		(NATIVE_OP | 0x13)
#define XNOR		(NATIVE_OP | 0x07)
#define XNORcc		(NATIVE_OP | 0x17)
#define SH_LEFT		(NATIVE_OP | 0x25)
#define SH_RIGHT	(NATIVE_OP | 0x26)
#define SH_RIGHT_ARITH	(NATIVE_OP | 0x27)
#define BRANCH		(BRANCH_OP | 0x08)
#define BR_NEVER	(BRANCH_OP | 0x00)
#define BR_NEQ		(BRANCH_OP | 0x09)
#define BR_EQ		(BRANCH_OP | 0x01)
#define BR_GR		(BRANCH_OP | 0x0A)
#define BR_LE		(BRANCH_OP | 0x02)
#define BR_GRE		(BRANCH_OP | 0x0B)
#define BR_L		(BRANCH_OP | 0x03)
#define BR_GU		(BRANCH_OP | 0x0C)
#define BR_LEU		(BRANCH_OP | 0x04)
#define BR_CC		(BRANCH_OP | 0x0D)
#define BR_CS		(BRANCH_OP | 0x05)
#define BR_POS		(BRANCH_OP | 0x0E)
#define BR_NEG		(BRANCH_OP | 0x06)
#define BR_VC		(BRANCH_OP | 0x0F)
#define BR_VS		(BRANCH_OP | 0x07)
#define BR_NZ		(BRANCH_OP | 0x09)
#define BR_Z		(BRANCH_OP | 0x01)
#ifdef __cplusplus
/*****************************************************************************/
/******************************** TEMPLATES **********************************/
/*****************************************************************************/
/*****************************************************************************/
/*************************** CLASSES & TYPEDEFS ******************************/
/*****************************************************************************/
typedef unsigned long   CODE;
typedef unsigned short	CODELABEL;
typedef CODE            *CODEPTR;
typedef CODEPTR         *CODEHANDLE;
struct tag_codeblk {
     CODEHANDLE hcodTarget;
     CODEPTR    pcodNext;
     CODELABEL	lblNext;
     LABELREC   *plblrecFirst;
     struct tag_codeblk *pblkPrev;
typedef tag_codeblk CODEBLK;
/* record of a reference to a label */
struct tag_lblref {
     CODEPTR	pcodRefLoc;
     struct tag_lblref *prefNext;
typedef tag_lblref LABELREF;
/* record of a label */
struct tag_lblrec {
     INT16	lblName;
     BYTE	bValid;
     CODEPTR	lAddress;
     struct tag_lblref *prefFirst;
     struct tag_lblrec *precNext;
typedef tag_lblrec LABELREC;
struct JIT_SymbolDetails {
  int priority;
  unsigned long offset;
  int regloc;
  unsigned char *heapaddr;
  char name[64];
class JIT_SymbolTable {
public:
  JIT_SymbolTable(unsigned char *heapbase);
  virtual ~JIT_SymbolTable(void);
  unsigned long AddSymbol(unsigned long, int, int, char[]);
  unsigned long SymbolOffset(int index);
  unsigned char *SymbolAddr(int index);
  int SymbolPriority(int index);
  int SymbolRegLoc(int index);
protected:
  unsigned char *base;
  unsigned long len;
  unsigned long cnt;
  JIT_SymbolDetails *tab;
class Cam8SimJIT {
public:
  LABELREC *plblrecFirst;
  CODEHANDLE hcodTarget;	/* Handle to Target Code Location */
  CODEPTR pcodNext;		/* Pointer to location of next inst */
  CODELABEL lblNext;		/* Next Label */
  CODEBLK *pblkTOS;
  JIT_SymbolTable symtab;
  CAM8SIMREGMGR *regmgr;
  /* Add a reference to a label */
  virtual void AddLabelRef(LABELREC *, CODEPTR);
  /* Resolve all references to a labl */
  virtual void ResolveRefs(LABELREC *, CODEPTR);
  /* Free all storage used by labels  */
  virtual void FreeLabels(void);
  /* Add a new label record */
  virtual LABELREC *AddLabel(CODELABEL, CODEPTR, BOOL);
  /* Find a label */
  /* Returns label's address */
  virtual CODEPTR GetLabelAddress(LABELREC *);
  virtual void NewBlock(CODEHANDLE);
  virtual void EndBlock(void);
  virtual LABELREC *FindLabel(CODELABEL);
  virtual CODELABEL NewLabel(void);
  virtual void Emit(INT16, BYTE, LONG32, BYTE, LONG32, BYTE, LONG32) = 0;
  virtual void PrintAsm(CODEPTR, FILE *) = 0;
  void pushblk(void);
  void popblk(void);
/*****************************************************************************/
/********************************* INLINES ***********************************/
/*****************************************************************************/
#endif
/*****************************************************************************/
/******************************* PROTOTYPES **********************************/
/*****************************************************************************/
/*****************************************************************************/
/********************************* GLOBALS ***********************************/
/*****************************************************************************/
#endif
#ifndef _CAM8SIMJIT_H_
#define _CAM8SIMJIT_H_
#include <pair.h>
#include <stdio.h>
#include <CamLib++.H>
#include "std++.H"
/*****************************************************************************/
/********************************* DEFINES ***********************************/
/*****************************************************************************/
/*****************************************************************************/
/*                                                                           */
/* operand types to use when calling Emit()				     */
/*                                                                           */
/*****************************************************************************/
#define NULL_OP		0
#define REG_OP		1
#define CONST_OP	2
#define ADDR_OP		3
#define VAR_OP		4
#define LABEL_OP	5
/*****************************************************************************/
/*                                                                           */
/* op codes for emit							     */
/*                                                                           */
/*****************************************************************************/
#define PSEUDO_OP	0x8000
#define NATIVE_OP	0x4000
#define LD_ST_OP	0x2000
#define BRANCH_OP	0x1000
#define NATIVE_OP_MASK	0x3F
#define INSTR		(PSEUDO_OP | 0xFF)
#define ENTER_PROC	(PSEUDO_OP | 0x01)
#define RETURN_PROC	(PSEUDO_OP | 0x02)
#define CALL_PROC	(PSEUDO_OP | 0x03)
#define ENTER_LEAF	(PSEUDO_OP | 0x04)
#define RETURN_LEAF	(PSEUDO_OP | 0x05)
#define CALL_LEAF	(PSEUDO_OP | 0x06)
#define CALL_LEAF_IND	(PSEUDO_OP | 0x07)
#define ENTER_BASICBLK	(PSEUDO_OP | 0x08)
#define RETURN_BASICBLK	(PSEUDO_OP | 0x09)
#define ADD_LABEL	(PSEUDO_OP | 0x0A)
#define NO_OP		(PSEUDO_OP | 0x0B)
#define LDW_MEM		(LD_ST_OP | 0x00)
#define LDW_IND		(LD_ST_OP | 0x01)
#define LDHW_IND	(LD_ST_OP | 0x02)
#define LDUB_IND	(LD_ST_OP | 0x03)
#define STW_MEM		(LD_ST_OP | 0x06)
#define STW_IND		(LD_ST_OP | 0x07)
#define STHW_IND	(LD_ST_OP | 0x08)
#define STUB_IND	(LD_ST_OP | 0x09)
#define ADD		(NATIVE_OP | 0x00)
#define ADDcc		(NATIVE_OP | 0x10)
#define ADDX		(NATIVE_OP | 0x08)
#define ADDXcc		(NATIVE_OP | 0x18)
#define	SUB		(NATIVE_OP | 0x04)
#define SUBcc		(NATIVE_OP | 0x14)
#define SUBX		(NATIVE_OP | 0x0C)
#define SUBXcc		(NATIVE_OP | 0x1C)
#define AND		(NATIVE_OP | 0x01)
#define ANDcc		(NATIVE_OP | 0x11)
#define ANDN		(NATIVE_OP | 0x05)
#define ANDNcc		(NATIVE_OP | 0x15)
#define OR		(NATIVE_OP | 0x02)
#define ORcc 		(NATIVE_OP | 0x12)
#define ORN		(NATIVE_OP | 0x06)
#define ORNcc		(NATIVE_OP | 0x16)
#define XOR		(NATIVE_OP | 0x03)
#define XORcc 		(NATIVE_OP | 0x13)
#define XNOR		(NATIVE_OP | 0x07)
#define XNORcc		(NATIVE_OP | 0x17)
#define SH_LEFT		(NATIVE_OP | 0x25)
#define SH_RIGHT	(NATIVE_OP | 0x26)
#define SH_RIGHT_ARITH	(NATIVE_OP | 0x27)
#define BRANCH		(BRANCH_OP | 0x08)
#define BR_NEVER	(BRANCH_OP | 0x00)
#define BR_NEQ		(BRANCH_OP | 0x09)
#define BR_EQ		(BRANCH_OP | 0x01)
#define BR_GR		(BRANCH_OP | 0x0A)
#define BR_LE		(BRANCH_OP | 0x02)
#define BR_GRE		(BRANCH_OP | 0x0B)
#define BR_L		(BRANCH_OP | 0x03)
#define BR_GU		(BRANCH_OP | 0x0C)
#define BR_LEU		(BRANCH_OP | 0x04)
#define BR_CC		(BRANCH_OP | 0x0D)
#define BR_CS		(BRANCH_OP | 0x05)
#define BR_POS		(BRANCH_OP | 0x0E)
#define BR_NEG		(BRANCH_OP | 0x06)
#define BR_VC		(BRANCH_OP | 0x0F)
#define BR_VS		(BRANCH_OP | 0x07)
#define BR_NZ		(BRANCH_OP | 0x09)
#define BR_Z		(BRANCH_OP | 0x01)
#ifdef __cplusplus
/*****************************************************************************/
/******************************** TEMPLATES **********************************/
/*****************************************************************************/
/*****************************************************************************/
/*************************** CLASSES & TYPEDEFS ******************************/
/*****************************************************************************/
typedef unsigned long   CODE;
typedef unsigned short	CODELABEL;
typedef CODE            *CODEPTR;
typedef CODEPTR         *CODEHANDLE;
struct tag_codeblk {
     CODEHANDLE hcodTarget;
     CODEPTR    pcodNext;
     CODELABEL	lblNext;
     LABELREC   *plblrecFirst;
     struct tag_codeblk *pblkPrev;
typedef tag_codeblk CODEBLK;
/* record of a reference to a label */
struct tag_lblref {
     CODEPTR	pcodRefLoc;
     struct tag_lblref *prefNext;
typedef tag_lblref LABELREF;
/* record of a label */
struct tag_lblrec {
     INT16	lblName;
     BYTE	bValid;
     CODEPTR	lAddress;
     struct tag_lblref *prefFirst;
     struct tag_lblrec *precNext;
typedef tag_lblrec LABELREC;
struct JIT_SymbolDetails {
  int priority;
  unsigned long offset;
  int regloc;
  unsigned char *heapaddr;
class JIT_SymbolTable {
public:
  JIT_SymbolTable(unsigned char *heapbase);
  virtual ~JIT_SymbolTable(void);
  unsigned long AddSymbol(unsigned long, int, int, char[]);
  unsigned long SymbolOffset(int index);
  unsigned char *SymbolAddr(int index);
  int SymbolPriority(int index);
  int SymbolRegLoc(int index);
protected:
  unsigned char *base;
  unsigned long len;
  unsigned long cnt;
  pair<const char name[64], tab;
class Cam8SimJIT {
public:
  LABELREC *plblrecFirst;
  CODEHANDLE hcodTarget;	/* Handle to Target Code Location */
  CODEPTR pcodNext;		/* Pointer to location of next inst */
  CODELABEL lblNext;		/* Next Label */
  CODEBLK *pblkTOS;
  JIT_SymbolTable symtab;
  CAM8SIMREGMGR *regmgr;
  /* Add a reference to a label */
  virtual void AddLabelRef(LABELREC *, CODEPTR);
  /* Resolve all references to a labl */
  virtual void ResolveRefs(LABELREC *, CODEPTR);
  /* Free all storage used by labels  */
  virtual void FreeLabels(void);
  /* Add a new label record */
  virtual LABELREC *AddLabel(CODELABEL, CODEPTR, BOOL);
  /* Find a label */
  /* Returns label's address */
  virtual CODEPTR GetLabelAddress(LABELREC *);
  virtual void NewBlock(CODEHANDLE);
  virtual void EndBlock(void);
  virtual LABELREC *FindLabel(CODELABEL);
  virtual CODELABEL NewLabel(void);
  virtual void Emit(INT16, BYTE, LONG32, BYTE, LONG32, BYTE, LONG32) = 0;
  virtual void PrintAsm(CODEPTR, FILE *) = 0;
  void pushblk(void);
  void popblk(void);
/*****************************************************************************/
/********************************* INLINES ***********************************/
/*****************************************************************************/
#endif
/*****************************************************************************/
/******************************* PROTOTYPES **********************************/
/*****************************************************************************/
/*****************************************************************************/
/********************************* GLOBALS ***********************************/
/*****************************************************************************/
#endif
#ifndef _CAM8SIMJIT_H_
#define _CAM8SIMJIT_H_
#include <pair.h>
#include <stdio.h>
#include <CamLib++.H>
#include "std++.H"
/*****************************************************************************/
/********************************* DEFINES ***********************************/
/*****************************************************************************/
/*****************************************************************************/
/*                                                                           */
/* operand types to use when calling Emit()				     */
/*                                                                           */
/*****************************************************************************/
#define NULL_OP		0
#define REG_OP		1
#define CONST_OP	2
#define ADDR_OP		3
#define VAR_OP		4
#define LABEL_OP	5
/*****************************************************************************/
/*                                                                           */
/* op codes for emit							     */
/*                                                                           */
/*****************************************************************************/
#define PSEUDO_OP	0x8000
#define NATIVE_OP	0x4000
#define LD_ST_OP	0x2000
#define BRANCH_OP	0x1000
#define NATIVE_OP_MASK	0x3F
#define INSTR		(PSEUDO_OP | 0xFF)
#define ENTER_PROC	(PSEUDO_OP | 0x01)
#define RETURN_PROC	(PSEUDO_OP | 0x02)
#define CALL_PROC	(PSEUDO_OP | 0x03)
#define ENTER_LEAF	(PSEUDO_OP | 0x04)
#define RETURN_LEAF	(PSEUDO_OP | 0x05)
#define CALL_LEAF	(PSEUDO_OP | 0x06)
#define CALL_LEAF_IND	(PSEUDO_OP | 0x07)
#define ENTER_BASICBLK	(PSEUDO_OP | 0x08)
#define RETURN_BASICBLK	(PSEUDO_OP | 0x09)
#define ADD_LABEL	(PSEUDO_OP | 0x0A)
#define NO_OP		(PSEUDO_OP | 0x0B)
#define LDW_MEM		(LD_ST_OP | 0x00)
#define LDW_IND		(LD_ST_OP | 0x01)
#define LDHW_IND	(LD_ST_OP | 0x02)
#define LDUB_IND	(LD_ST_OP | 0x03)
#define STW_MEM		(LD_ST_OP | 0x06)
#define STW_IND		(LD_ST_OP | 0x07)
#define STHW_IND	(LD_ST_OP | 0x08)
#define STUB_IND	(LD_ST_OP | 0x09)
#define ADD		(NATIVE_OP | 0x00)
#define ADDcc		(NATIVE_OP | 0x10)
#define ADDX		(NATIVE_OP | 0x08)
#define ADDXcc		(NATIVE_OP | 0x18)
#define	SUB		(NATIVE_OP | 0x04)
#define SUBcc		(NATIVE_OP | 0x14)
#define SUBX		(NATIVE_OP | 0x0C)
#define SUBXcc		(NATIVE_OP | 0x1C)
#define AND		(NATIVE_OP | 0x01)
#define ANDcc		(NATIVE_OP | 0x11)
#define ANDN		(NATIVE_OP | 0x05)
#define ANDNcc		(NATIVE_OP | 0x15)
#define OR		(NATIVE_OP | 0x02)
#define ORcc 		(NATIVE_OP | 0x12)
#define ORN		(NATIVE_OP | 0x06)
#define ORNcc		(NATIVE_OP | 0x16)
#define XOR		(NATIVE_OP | 0x03)
#define XORcc 		(NATIVE_OP | 0x13)
#define XNOR		(NATIVE_OP | 0x07)
#define XNORcc		(NATIVE_OP | 0x17)
#define SH_LEFT		(NATIVE_OP | 0x25)
#define SH_RIGHT	(NATIVE_OP | 0x26)
#define SH_RIGHT_ARITH	(NATIVE_OP | 0x27)
#define BRANCH		(BRANCH_OP | 0x08)
#define BR_NEVER	(BRANCH_OP | 0x00)
#define BR_NEQ		(BRANCH_OP | 0x09)
#define BR_EQ		(BRANCH_OP | 0x01)
#define BR_GR		(BRANCH_OP | 0x0A)
#define BR_LE		(BRANCH_OP | 0x02)
#define BR_GRE		(BRANCH_OP | 0x0B)
#define BR_L		(BRANCH_OP | 0x03)
#define BR_GU		(BRANCH_OP | 0x0C)
#define BR_LEU		(BRANCH_OP | 0x04)
#define BR_CC		(BRANCH_OP | 0x0D)
#define BR_CS		(BRANCH_OP | 0x05)
#define BR_POS		(BRANCH_OP | 0x0E)
#define BR_NEG		(BRANCH_OP | 0x06)
#define BR_VC		(BRANCH_OP | 0x0F)
#define BR_VS		(BRANCH_OP | 0x07)
#define BR_NZ		(BRANCH_OP | 0x09)
#define BR_Z		(BRANCH_OP | 0x01)
#ifdef __cplusplus
/*****************************************************************************/
/******************************** TEMPLATES **********************************/
/*****************************************************************************/
/*****************************************************************************/
/*************************** CLASSES & TYPEDEFS ******************************/
/*****************************************************************************/
typedef unsigned long   CODE;
typedef unsigned short	CODELABEL;
typedef CODE            *CODEPTR;
typedef CODEPTR         *CODEHANDLE;
struct tag_codeblk {
     CODEHANDLE hcodTarget;
     CODEPTR    pcodNext;
     CODELABEL	lblNext;
     LABELREC   *plblrecFirst;
     struct tag_codeblk *pblkPrev;
typedef tag_codeblk CODEBLK;
/* record of a reference to a label */
struct tag_lblref {
     CODEPTR	pcodRefLoc;
     struct tag_lblref *prefNext;
typedef tag_lblref LABELREF;
/* record of a label */
struct tag_lblrec {
     INT16	lblName;
     BYTE	bValid;
     CODEPTR	lAddress;
     struct tag_lblref *prefFirst;
     struct tag_lblrec *precNext;
typedef tag_lblrec LABELREC;
struct JIT_SymbolDetails {
  int priority;
  unsigned long offset;
  int regloc;
  unsigned char *heapaddr;
typedef pair<const char name[64], JIT_SymbolDetails> JIT_SymHash;
class JIT_SymbolTable {
public:
  JIT_SymbolTable(unsigned char *heapbase);
  virtual ~JIT_SymbolTable(void);
  unsigned long AddSymbol(unsigned long, int, int, char[]);
  unsigned long SymbolOffset(int index);
  unsigned char *SymbolAddr(int index);
  int SymbolPriority(int index);
  int SymbolRegLoc(int index);
protected:
  unsigned char *base;
  unsigned long len;
  unsigned long cnt;
  JIT_SymHash tab;
class Cam8SimJIT {
public:
  LABELREC *plblrecFirst;
  CODEHANDLE hcodTarget;	/* Handle to Target Code Location */
  CODEPTR pcodNext;		/* Pointer to location of next inst */
  CODELABEL lblNext;		/* Next Label */
  CODEBLK *pblkTOS;
  JIT_SymbolTable symtab;
  CAM8SIMREGMGR *regmgr;
  /* Add a reference to a label */
  virtual void AddLabelRef(LABELREC *, CODEPTR);
  /* Resolve all references to a labl */
  virtual void ResolveRefs(LABELREC *, CODEPTR);
  /* Free all storage used by labels  */
  virtual void FreeLabels(void);
  /* Add a new label record */
  virtual LABELREC *AddLabel(CODELABEL, CODEPTR, BOOL);
  /* Find a label */
  /* Returns label's address */
  virtual CODEPTR GetLabelAddress(LABELREC *);
  virtual void NewBlock(CODEHANDLE);
  virtual void EndBlock(void);
  virtual LABELREC *FindLabel(CODELABEL);
  virtual CODELABEL NewLabel(void);
  virtual void Emit(INT16, BYTE, LONG32, BYTE, LONG32, BYTE, LONG32) = 0;
  virtual void PrintAsm(CODEPTR, FILE *) = 0;
  void pushblk(void);
  void popblk(void);
/*****************************************************************************/
/********************************* INLINES ***********************************/
/*****************************************************************************/
#endif
/*****************************************************************************/
/******************************* PROTOTYPES **********************************/
/*****************************************************************************/
/*****************************************************************************/
/********************************* GLOBALS ***********************************/
/*****************************************************************************/
#endif

---------------------------------------------------------------------------

#ifndef _CAM8SIMSPARCCORE_H_
#define _CAM8SIMSPARCCORE_H_
#include <CamLib++.H>
#include <Cam8Core++.H>
#include <Cam8++.H>
#include <Cam8SimJIT++.H>
#include "std++.H"
/*****************************************************************************/
/********************************* DEFINES ***********************************/
/*****************************************************************************/
#define SCANNER_CODE_SIZE       (1024 * LONG32_SIZE)
#define SWEEP_CODE_SIZE         (1024 * LONG32_SIZE)
#define UPDATE_CODE_SIZE        (1024 * LONG32_SIZE)
#define MREGS	32
/*****************************************************************************/
/*                                                                           */
/* macros for convenient addressing of SPARC registers			     */
/*                                                                           */
/*****************************************************************************/
#define REG_G0	0L
#define REG_G1	1L
#define REG_G2	2L
#define REG_G3	3L
#define REG_G4	4L
#define REG_G5	5L
#define REG_G6	6L
#define REG_G7	7L
#define REG_O0	8L
#define REG_O1	9L
#define REG_O2	10L
#define REG_O3	11L
#define REG_O4	12L
#define REG_O5	13L
#define REG_O6	14L
#define REG_O7	15L
#define REG_L0	16L
#define REG_L1	17L
#define REG_L2	18L
#define REG_L3	19L
#define REG_L4	20L
#define REG_L5	21L
#define REG_L6	22L
#define REG_L7	23L
#define REG_I0	24L
#define REG_I1	25L
#define REG_I2	26L
#define REG_I3	27L
#define REG_I4	28L
#define REG_I5	29L
#define REG_I6	30L
#define REG_I7	31L
#define REG_SP	14L			/* Stack Pointer */
#define REG_TP	15L			/* The Temp register */
#define REG_DS	07L			/* pointer to Heap base */
#define REG_FP	30L			/* Frame Pointer */
#define REG_RA	31L			/* Return Address */
/*****************************************************************************/
/*                                                                           */
/* operand types to use when calling Emit()				     */
/*                                                                           */
/*****************************************************************************/
#define NULL_OP		0
#define REG_OP		1
#define CONST_OP	2
#define ADDR_OP		3
#define VAR_OP		4
#define LABEL_OP	5
/*****************************************************************************/
/*                                                                           */
/* op codes for emit							     */
/*                                                                           */
/*****************************************************************************/
#define PSEUDO_OP	0x8000
#define NATIVE_OP	0x4000
#define LD_ST_OP	0x2000
#define BRANCH_OP	0x1000
#define NATIVE_OP_MASK	0x3F
#define INSTR		(PSEUDO_OP | 0xFF)
#define ENTER_PROC	(PSEUDO_OP | 0x01)
#define RETURN_PROC	(PSEUDO_OP | 0x02)
#define CALL_PROC	(PSEUDO_OP | 0x03)
#define ENTER_LEAF	(PSEUDO_OP | 0x04)
#define RETURN_LEAF	(PSEUDO_OP | 0x05)
#define CALL_LEAF	(PSEUDO_OP | 0x06)
#define CALL_LEAF_IND	(PSEUDO_OP | 0x07)
#define ENTER_BASICBLK	(PSEUDO_OP | 0x08)
#define RETURN_BASICBLK	(PSEUDO_OP | 0x09)
#define ADD_LABEL	(PSEUDO_OP | 0x0A)
#define NO_OP		(PSEUDO_OP | 0x0B)
#define LDW_MEM		(LD_ST_OP | 0x00)
#define LDW_IND		(LD_ST_OP | 0x01)
#define LDHW_IND	(LD_ST_OP | 0x02)
#define LDUB_IND	(LD_ST_OP | 0x03)
#define STW_MEM		(LD_ST_OP | 0x06)
#define STW_IND		(LD_ST_OP | 0x07)
#define STHW_IND	(LD_ST_OP | 0x08)
#define STUB_IND	(LD_ST_OP | 0x09)
#define ADD		(NATIVE_OP | 0x00)
#define ADDcc		(NATIVE_OP | 0x10)
#define ADDX		(NATIVE_OP | 0x08)
#define ADDXcc		(NATIVE_OP | 0x18)
#define	SUB		(NATIVE_OP | 0x04)
#define SUBcc		(NATIVE_OP | 0x14)
#define SUBX		(NATIVE_OP | 0x0C)
#define SUBXcc		(NATIVE_OP | 0x1C)
#define AND		(NATIVE_OP | 0x01)
#define ANDcc		(NATIVE_OP | 0x11)
#define ANDN		(NATIVE_OP | 0x05)
#define ANDNcc		(NATIVE_OP | 0x15)
#define OR		(NATIVE_OP | 0x02)
#define ORcc 		(NATIVE_OP | 0x12)
#define ORN		(NATIVE_OP | 0x06)
#define ORNcc		(NATIVE_OP | 0x16)
#define XOR		(NATIVE_OP | 0x03)
#define XORcc 		(NATIVE_OP | 0x13)
#define XNOR		(NATIVE_OP | 0x07)
#define XNORcc		(NATIVE_OP | 0x17)
#define SH_LEFT		(NATIVE_OP | 0x25)
#define SH_RIGHT	(NATIVE_OP | 0x26)
#define SH_RIGHT_ARITH	(NATIVE_OP | 0x27)
#define BRANCH		(BRANCH_OP | 0x08)
#define BR_NEVER	(BRANCH_OP | 0x00)
#define BR_NEQ		(BRANCH_OP | 0x09)
#define BR_EQ		(BRANCH_OP | 0x01)
#define BR_GR		(BRANCH_OP | 0x0A)
#define BR_LE		(BRANCH_OP | 0x02)
#define BR_GRE		(BRANCH_OP | 0x0B)
#define BR_L		(BRANCH_OP | 0x03)
#define BR_GU		(BRANCH_OP | 0x0C)
#define BR_LEU		(BRANCH_OP | 0x04)
#define BR_CC		(BRANCH_OP | 0x0D)
#define BR_CS		(BRANCH_OP | 0x05)
#define BR_POS		(BRANCH_OP | 0x0E)
#define BR_NEG		(BRANCH_OP | 0x06)
#define BR_VC		(BRANCH_OP | 0x0F)
#define BR_VS		(BRANCH_OP | 0x07)
#define BR_NZ		(BRANCH_OP | 0x09)
#define BR_Z		(BRANCH_OP | 0x01)
#define OP_LDW		0x00L
#define OP_LDHW		0x02L
#define OP_LDUB		0x01L
#define OP_STW		0x04L
#define OP_STUB		0x05L
#define OP_STHW		0x06L
#define OP_ADD		0x00L
#define OP_ADDcc	0x10L
#define OP_ADDX		0x08L
#define OP_ADDXcc	0x18L
#define	OP_SUB		0x04L
#define OP_SUBcc	0x14L
#define OP_SUBX		0x0CL
#define OP_SUBXcc	0x1CL
#define OP_AND		0x01L
#define OP_ANDcc	0x11L
#define OP_ANDN		0x05L
#define OP_ANDNcc	0x15L
#define OP_OR		0x02L
#define OP_ORcc 	0x12L
#define OP_ORN		0x06L
#define OP_ORNcc	0x16L
#define OP_XOR		0x03L
#define OP_XORcc 	0x13L
#define OP_XNOR		0x07L
#define OP_XNORcc	0x17L
#define OP_SLL		0x25L
#define OP_SRL		0x26L
#define OP_SRA		0x27L
#define OP_SETHI	0x04L
#define OP_JMPL		0x38L
#define OP_SAVE		0x3CL
#define OP_RESTORE	0x3DL
#define IMMEDIATE	1
#define REG_SOURCE	0
#define FMT2_INST(op, opcode, k, rd) 	(((op) << 30) | \
					 ((opcode) << 22) | \
					 ((rd) << 25) | \
					 ((k) & 0x3fffffL))
#define FMT3_INST(op, opcode, rs1, i, rs2, rd) (((op) << 30) | \
						((rd) << 25) | \
						((opcode) << 19) | \
		       				((rs1) << 14) | \
						((i) << 13) | \
						((rs2) & 0x1FFFL))
#define SAVE_REG_IMM(rs1, k, rd)	(FMT3_INST(0x2L, OP_SAVE, (rs1), IMMEDIATE, (k), (rd)))
#define SAVE_REG_REG(rs1, rs2, rd)	(FMT3_INST(0x2L, OP_SAVE, (rs1), REG_SOURCE, (rs2), (rd)))
#define RESTORE				(FMT3_INST(0x2L, OP_RESTORE, REG_G0, REG_SOURCE, REG_G0, REG_G0))
#define RET				(FMT3_INST(0x2L, OP_JMPL, REG_I7, IMMEDIATE, 8, REG_G0))
#define RETL				(FMT3_INST(0x2L, OP_JMPL, REG_O7, IMMEDIATE, 8, REG_G0))
#define CALL_REG(r)			(FMT3_INST(0x2L, OP_JMPL, (r), IMMEDIATE, 0, REG_O7))
#define CALL_REG_IMM(r, k) 		(FMT3_INST(0x2L, OP_JMPL, (r), IMMEDIATE, (k), REG_O7))
#define CALL(disp)			((0x01 << 30) | (((unsigned long) (disp)) >> 2))
#define NOP				(FMT3_INST(0x2L, OP_OR, REG_G0, REG_SOURCE, REG_G0, REG_G0))
#define LDW_REG_IMM(rs1, k, rd) 	(FMT3_INST(0x3L, OP_LDW, rs1, IMMEDIATE, k, rd))
#define LDW_REG_REG(rs1, rs2, rd) 	(FMT3_INST(0x3L, OP_LDW, rs1, REG_SOURCE, rs2, rd))
#define LDHW_REG_IMM(rs1, k, rd) 	(FMT3_INST(0x3L, OP_LDHW, rs1, IMMEDIATE, k, rd))
#define LDHW_REG_REG(rs1, rs2, rd) 	(FMT3_INST(0x3L, OP_LDHW, rs1, REG_SOURCE, rs2, rd))
#define LDUB_REG_IMM(rs1, k, rd) 	(FMT3_INST(0x3L, OP_LDUB, rs1, IMMEDIATE, k, rd))
#define LDUB_REG_REG(rs1, rs2, rd) 	(FMT3_INST(0x3L, OP_LDUB, rs1, REG_SOURCE, rs2, rd))
#define STW_REG_IMM(rs1, k, rd) 	(FMT3_INST(0x3L, OP_STW, rs1, IMMEDIATE, k, rd))
#define STW_REG_REG(rs1, rs2, rd) 	(FMT3_INST(0x3L, OP_STW, rs1, REG_SOURCE, rs2, rd))
#define STHW_REG_IMM(rs1, k, rd) 	(FMT3_INST(0x3L, OP_STHW, rs1, IMMEDIATE, k, rd))
#define STHW_REG_REG(rs1, rs2, rd) 	(FMT3_INST(0x3L, OP_STHW, rs1, REG_SOURCE, rs2, rd))
#define STUB_REG_IMM(rs1, k, rd) 	(FMT3_INST(0x3L, OP_STUB, rs1, IMMEDIATE, k, rd))
#define STUB_REG_REG(rs1, rs2, rd) 	(FMT3_INST(0x3L, OP_STUB, rs1, REG_SOURCE, rs2, rd))
#define ADD_REG_IMM(rs1, k, rd) 	(FMT3_INST(0x2L, OP_ADD, rs1, IMMEDIATE, k, rd))
#define ADD_REG_REG(rs1, rs2, rd) 	(FMT3_INST(0x2L, OP_ADD, rs1, REG_SOURCE, rs2, rd))
#define ADDcc_REG_IMM(rs1, k, rd) 	(FMT3_INST(0x2L, OP_ADDcc, rs1, IMMEDIATE, k, rd))
#define ADDcc_REG_REG(rs1, rs2, rd) 	(FMT3_INST(0x2L, OP_ADDcc, rs1, REG_SOURCE, rs2, rd))
#define ADDX_REG_IMM(rs1, k, rd) 	(FMT3_INST(0x2L, OP_ADDX, rs1, IMMEDIATE, k, rd))
#define ADDX_REG_REG(rs1, rs2, rd) 	(FMT3_INST(0x2L, OP_ADDX, rs1, REG_SOURCE, rs2, rd))
#define ADDXcc_REG_IMM(rs1, k, rd) 	(FMT3_INST(0x2L, OP_ADDXcc, rs1, IMMEDIATE, k, rd))
#define ADDXcc_REG_REG(rs1, rs2, rd) 	(FMT3_INST(0x2L, OP_ADDXcc, rs1, REG_SOURCE, rs2, rd))
#define SUB_REG_IMM(rs1, k, rd) 	(FMT3_INST(0x2L, OP_SUB, rs1, IMMEDIATE, k, rd))
#define SUB_REG_REG(rs1, rs2, rd) 	(FMT3_INST(0x2L, OP_SUB, rs1, REG_SOURCE, rs2, rd))
#define SUBcc_REG_IMM(rs1, k, rd) 	(FMT3_INST(0x2L, OP_SUBcc, rs1, IMMEDIATE, k, rd))
#define SUBcc_REG_REG(rs1, rs2, rd) 	(FMT3_INST(0x2L, OP_SUBcc, rs1, REG_SOURCE, rs2, rd))
#define SUBX_REG_IMM(rs1, k, rd) 	(FMT3_INST(0x2L, OP_SUBX, rs1, IMMEDIATE, k, rd))
#define SUBX_REG_REG(rs1, rs2, rd) 	(FMT3_INST(0x2L, OP_SUBX, rs1, REG_SOURCE, rs2, rd))
#define SUBXcc_REG_IMM(rs1, k, rd) 	(FMT3_INST(0x2L, OP_SUBXcc, rs1, IMMEDIATE, k, rd))
#define SUBXcc_REG_REG(rs1, rs2, rd) 	(FMT3_INST(0x2L, OP_SUBXcc, rs1, REG_SOURCE, rs2, rd))
#define AND_REG_IMM(rs1, k, rd) 	(FMT3_INST(0x2L, OP_AND, rs1, IMMEDIATE, k, rd))
#define AND_REG_REG(rs1, rs2, rd) 	(FMT3_INST(0x2L, OP_AND, rs1, REG_SOURCE, rs2, rd))
#define OR_REG_IMM(rs1, k, rd) 		(FMT3_INST(0x2L, OP_OR, rs1, IMMEDIATE, k, rd))
#define OR_REG_REG(rs1, rs2, rd) 	(FMT3_INST(0x2L, OP_OR, rs1, REG_SOURCE, rs2, rd))
#define XOR_REG_IMM(rs1, k, rd) 	(FMT3_INST(0x2L, OP_XOR, rs1, IMMEDIATE, k, rd))
#define XOR_REG_REG(rs1, rs2, rd) 	(FMT3_INST(0x2L, OP_XOR, rs1, REG_SOURCE, rs2, rd))
#define XNOR_REG_IMM(rs1, k, rd) 	(FMT3_INST(0x2L, OP_XNOR, rs1, IMMEDIATE, k, rd))
#define XNOR_REG_REG(rs1, rs2, rd) 	(FMT3_INST(0x2L, OP_XNOR, rs1, REG_SOURCE, rs2, rd))
#define NOT_REG(r)			(XNOR_REG_REG(r, REG_G0, r))
#define SLL_REG_IMM(rs1, k, rd) 	(FMT3_INST(0x2L, OP_SLL, rs1, IMMEDIATE, k, rd))
#define SLL_REG_REG(rs1, rs2, rd) 	(FMT3_INST(0x2L, OP_SLL, rs1, REG_SOURCE, rs2, rd))
#define SRL_REG_IMM(rs1, k, rd) 	(FMT3_INST(0x2L, OP_SRL, rs1, IMMEDIATE, k, rd))
#define SRL_REG_REG(rs1, rs2, rd) 	(FMT3_INST(0x2L, OP_SRL, rs1, REG_SOURCE, rs2, rd))
#define HI22(k) 			((((unsigned long) (k)) >> 10) & 0x3fffffL)
#define LOW10(k) 			(((unsigned long) (k)) & 0x3ffL)
#define SETHI(k, rd) 			(FMT2_INST(0x0L, OP_SETHI, k, rd))
/******************************************************************************
 * The branch instructions.
 *****************************************************************************/
#define BRANCH_INST(annul, cond, disp)	(((annul) << 29) | ((cond) << 25) | (0x800000) | ((disp) & 0x3FFFFF))
#define BRA(disp)			(BRANCH_INST(0, 0x8, disp))
#define BRN(disp)			(BRANCH_INST(0, 0x0, disp))
#define BRNE(disp)			(BRANCH_INST(0, 0x9, disp))
#define BRE(disp)			(BRANCH_INST(0, 0x1, disp))
#define BRG(disp)			(BRANCH_INST(0, 0xA, disp))
#define BRLE(disp)			(BRANCH_INST(0, 0x2, disp))
#define BRGE(disp)			(BRANCH_INST(0, 0xB, disp))
#define BRL(disp)			(BRANCH_INST(0, 0x3, disp))
#define BRGU(disp)			(BRANCH_INST(0, 0xC, disp))
#define BRLEU(disp)			(BRANCH_INST(0, 0x4, disp))
#define BRCC(disp)			(BRANCH_INST(0, 0xD, disp))
#define BRCS(disp)			(BRANCH_INST(0, 0x5, disp))
#define BRPOS(disp)			(BRANCH_INST(0, 0xE, disp))
#define BRNEG(disp)			(BRANCH_INST(0, 0x6, disp))
#define BRVC(disp)			(BRANCH_INST(0, 0xF, disp))
#define BRVS(disp)			(BRANCH_INST(0, 0x7, disp))
#define BRNZ(disp)			(BRANCH_INST(0, 0x9, disp))
#define BRZ(disp)			(BRANCH_INST(0, 0x1, disp))
/*****************************************************************************/
/*                                                                           */
/* Macros to insert target instructions etc.				     */
/*                                                                           */
/*****************************************************************************/
#define EMIT(inst)			*pcodNext++ = (inst)
#define CURRENT_LOC			(pcodNext)
#define CURRENT_HANDLE			(&pcodNext)
#ifdef DEBUG
#define ASCODE(c)  fprintf(DEBUGFILE, "\t0x%x: %s\n", DASMADDR, c); \
		   fflush(DEBUGFILE)
#define ASNOTE(c)  fprintf(DEBUGFILE, "\t%s\n", c); fflush(DEBUGFILE)
#else DEBUG
#define ASCODE(name)
#define ASNOTE(c)
#endif DEBUG
#ifdef __cplusplus
/*****************************************************************************/
/******************************** TEMPLATES **********************************/
/*****************************************************************************/
/*****************************************************************************/
/*************************** CLASSES & TYPEDEFS ******************************/
/*****************************************************************************/
typedef unsigned short codelabel;
typedef unsigned long code;
typedef code *CODE;
typedef CODE *CODEHANDLE;
typedef unsigned long sregister;
struct tag_regEntry {	/* Describes register contents */
  int16	nVar;			/* Name (index) of variable */
  int16	nPriority;		/* Priority of variable */
  int16	nHeapOffset;		/* Offset into heap of variable */
typedef struct tag_regEntry regentry;
typedef struct regentry *REGENTRY;
struct tag_regQue {
  register rRegQue[MREGS];
  byte bHead;
  byte bTail;
  byte bNumElements;
typedef struct tag_regQue regque;
typedef struct tag_regQue *REGQUE;
/* record of a label */
struct tag_lblrec {
     int16	lblName;
     byte	bValid;
     CODE	lAddress;
     struct tag_lblref *prefFirst;
     struct tag_lblrec *precNext;
typedef struct tag_lblrec labelrec;
typedef struct tag_lblrec *LABELREC;
struct tag_codeblk {
     CODEHANDLE hcodTarget;
     CODE    pcodNext;
     codelabel	lblNext;
     LABELREC plblrecFirst;
     struct tag_CODEBLK pblkPrev;
typedef struct tag_codeblk codeblk;
typedef struct tag_codeblk *CODEBLK;
/* record of a reference to a label */
struct tag_lblref {
     CODE	pcodRefLoc;
     struct tag_lblref *prefNext;
typedef struct tag_lblref labelref;
class Cam8SimSPARCCore : public Cam8SimCore {
public:
  static const char *szRegName[] = {
    "%g0", "%g1", "%g2", "%g3", "%g4", "%g5", "%g6", "%g7",
    "%o0", "%o1", "%o2", "%o3", "%o4", "%o5", "%sp", "%tp",
    "%l0", "%l1", "%l2", "%l3", "%l4", "%l5", "%l6", "%l7",
    "%i0", "%i1", "%i2", "%i3", "%i4", "%i5", "%ds", "%ra"
  };
  static const char *szCCName[] = {
    "NEVER", "EQ", "LE", "L", "LEU", "CS", "NEG", "VS",
    "ALWAYS", "NEQ", "G", "GE", "GU", "CC", "POS", "VC"
  };
  static char registerS[32][64] = {
    "G0", "G1", "G2", "G3", "G4", "G5", "G6", "G7",
    "O0", "O1", "O2", "O3", "O4", "O5", "O6", "O7",
    "L0", "L1", "L2", "L3", "L4", "L5", "L6", "L7",
    "I0", "I1", "I2", "I3", "I4", "I5", "I6", "I7",
  };
  char SYMBOLS[SymbolTableSize][64];
  regentry rCurrWindow[MREGS];
  regque rqueFree;
  regque rqueSpillable[4];		/* Queue of spillable registers */
  LABELREC plblrecFirst;
  CODE pcodScanNoPerm;
  CODE pcodGenUpdate;
  CODE pcodScanner;
  CODE pcodSweep;
  CODE pcodUpdateSite;
  CODE pcodNext;			/* Pointer to location of next inst */
  CODEHANDLE hcodTarget;		/* Handle to Target Code Location */
  codelabel lblNext;			/* Next Label */
  CODEBLK pblkTOS;
  CODE DASMADDR;
#ifdef _INSTRUMENTATION_
  struct timeval tvStart, tvEnd;
  struct timezone tzZone;
#endif
  Cam8SimSPARCCore(void);
  DECL_COPYCONST(Cam8SimSPARCCore);
  virtual ~Cam8SimSPARCCore(void);
  DECL_OPEQ(Cam8SimSPARCCore);
  DECL_BZERO(Cam8SimSPARCCore);
  DECL_BCOPY(Cam8SimSPARCCore);
  DECL_BCMP(Cam8SimSPARCCore);
  void InitSim(void);
  void SimScanNoPerm(CODEHANDLE);
  void SimGeneralScan(CODEHANDLE);
  void SimPrologue(CODEHANDLE);
  void SimEpilogue(CODEHANDLE);
  void SimUpdateSite(void);
  void SimLoadFirstWord(unsigned short []);
  void SimGetNextWord(unsigned short);
  void SimSaveLastWord(unsigned short []);
  void CheckNoPerm(CODEHANDLE);
  void SimUpdateCode(void);
  void SimLoadPlaneWords(void);
  void SimSavePlaneWords(void);
  void MapFunction (short, short, byte);
  void BuildDest(short, short, byte, byte);
  void BuildBitDest(short, short, byte, byte, unsigned short);
  void BuildBitwiseDest(short, short, byte [], byte []);
  short PermuteScanIndex(void);
  void InsertSpillable(sregister);
  void ResetSpillQue(void);
  void PushRegWindow(void);
  void PopRegWindow(CODEHANDLE);
  void FreeReg(sregister);
  void ResetFreeQue(void);
  void AddQueElement(REGQUE, sregister);
  void ResetQue(REGQUE);
  byte NumFreeRegs(void);
  byte NumQueElements(regque);
  register GetFreeReg(void);
  register GetSpillable(void);
  register GetQueElement(REGQUE);
  void NewBlock(CODEHANDLE);
  void EndBlock(void);
  void Emit(int16, byte, long32, byte, long32, byte, long32);
  void PrintAsm(CODE, FILE *);
  void InitRegMgr(void);
  /* flushes rFlush back to memory */
  void FlushReg(sregister, CODEHANDLE);
  /* record all the "live" registers */
  void SaveRegState(void);
  /* returns all regs to state they */
  void RestoreRegState(CODEHANDLE);
  /* allocates a register for nVar */
  register GetReg(int16, CODEHANDLE, bool);
typedef Cam8SimSPARCCore *CAM8SIMSPARCCORE;
/*****************************************************************************/
/********************************* INLINES ***********************************/
/*****************************************************************************/
#endif
/*****************************************************************************/
/******************************* PROTOTYPES **********************************/
/*****************************************************************************/
/*****************************************************************************/
/********************************* GLOBALS ***********************************/
/*****************************************************************************/
#endif

---------------------------------------------------------------------------

#include <CaLibStream++.H>
#include <CaLibError++.H>
#include <CaLibTrace++.H>
#include <CamLib++.H>
#include <Cam8SimJIT++.H>
#include "std++.H"
JIT_SymbolTable::JIT_SymbolTable(unsigned char *heapbase)
  CaLib_tb.ENTER("JIT_SymbolTable::JIT_SymbolTable");
  base = heapbase;
  cnt = 0;
  len = 64;
  tab = Calloc(len, sizeof(JIT_SymbolDetails));
  CaLib_tb.LEAVE();
JIT_SymbolTable::~JIT_SymbolTable(void)
unsigned long AddSymbol(unsigned long size, int priority, int regloc, char name[])
  unsigned long index;
  CaLib_tb.ENTER("JIT_SymbolTable::AddSymbol");
  if (len == cnt) {
    len *= 2;
    tab = Realloc(tab, len * sizeof(JIT_SymbolDetails));
  tab[cnt].priority = priority;
  tab[cnt].offset = (cnt == 0L ? 0L : tab[cnt - 1].offset + size);
  tab[cnt].regloc = regloc;
  tab[cnt].heapaddr = base + tab[cnt].offset;
  strncpy(tab[cnt].name, name, 64);
  index = cnt;
  cnt++;
  CaLib_tb.LEAVE();
  return(index);
unsigned long SymbolOffset(int index)
  CaLib_tb.ENTER("JIT_SymbolTable::SymbolOffset");
  CaLib_tb.LEAVE();
unsigned char *SymbolAddr(int index)
  CaLib_tb.ENTER("JIT_SymbolTable::SymbolAddr");
  CaLib_tb.LEAVE();
int SymbolPriority(int index)
  CaLib_tb.ENTER("JIT_SymbolTable::SymbolPriority");
  CaLib_tb.LEAVE();
int SymbolRegLoc(int index)
  CaLib_tb.ENTER("JIT_SymbolTable::SymbolRegLoc");
  CaLib_tb.LEAVE();
void NewBlock(CODEHANDLE hcodDest)
     void pushblk(void);
     
     /* save code block state */
     pushblk();
     /* point to new code block */
     hcodTarget = hcodDest;
     pcodNext = *hcodDest;
     lblNext = 0;
void EndBlock()
     void popblk(void);
     /* Free up all label records */
     FreeLabels();
     *pcodNext = 0L;
     /* Update caller's code handle */
     *hcodTarget = pcodNext;
     /* Restore previous block state */
     popblk(); 
codelabel NewLabel()
     return (lblNext++);
LABELREC AddLabel(codelabel lblName, CODE pcodLabelLoc, bool bValid)
     labelrec	*plblrecNew;
     plblrecNew = (LABELREC ) MALLOC(sizeof(labelrec), "AddLabel");
     plblrecNew->lblName = lblName;
     if ((plblrecNew->bValid = bValid) == TRUE) {
	  plblrecNew->lAddress = pcodLabelLoc;
     }
     plblrecNew->precNext = plblrecFirst;
     plblrecNew->prefFirst = NULL;
     plblrecFirst = plblrecNew;
     return (plblrecNew);
LABELREC FindLabel(codelabel lblName)
     LABELREC plblrecNext;
     for (plblrecNext = plblrecFirst;
	  (plblrecNext != NULL) && (plblrecNext->lblName != lblName);
	  plblrecNext = plblrecNext->precNext);
     return (plblrecNext);
CODE GetLabelAddress(LABELREC plblrec)
  if (plblrec->bValid)
    return (plblrec->lAddress);
  else
    return (NULL);
void AddLabelRef(LABELREC plblrec, CODE lAddress)
     labelref *prefNew;
     prefNew = (labelref *) MALLOC(sizeof(labelref), "AddLabelRef");
     prefNew->pcodRefLoc = lAddress;
     prefNew->prefNext = plblrec->prefFirst;
     plblrec->prefFirst = prefNew;
void FreeLabels()
     LABELREC plblrec;
     while (plblrecFirst != NULL) {
	  plblrec = plblrecFirst;
	  plblrecFirst = plblrec->precNext;
	  FREE(plblrec, "FreeLabels");
     }
/*****************************************************************************/
/*                                                                           */
/* Simple stack manager for pushing and pop-ing code block states.	     */
/*                                                                           */
/*****************************************************************************/
void pushblk(void)
     CODEBLK pNew;
     pNew = MALLOC(sizeof(codeblk), "icode : pushblk");
     pNew->hcodTarget = hcodTarget;
     pNew->pcodNext = pcodNext;
     pNew->lblNext = lblNext;
     pNew->plblrecFirst = plblrecFirst;
     
     pNew->pblkPrev = pblkTOS;
     pblkTOS = pNew;
     plblrecFirst = NULL;
void popblk(void)
     CODEBLK pblkOld;
     if (!pblkTOS) {
	  CRITICAL_ERROR("I-Code Block stack underflow", "popblk");
     }
     hcodTarget = pblkTOS->hcodTarget;
     pcodNext = pblkTOS->pcodNext;
     lblNext = pblkTOS->lblNext;
     plblrecFirst = pblkTOS->plblrecFirst;
     pblkOld = pblkTOS;
     pblkTOS = pblkTOS->pblkPrev;
     FREE(pblkOld, "popblk");
#include <CaLibStream++.H>
#include <CaLibError++.H>
#include <CaLibTrace++.H>
#include <CamLib++.H>
#include <Cam8Core++.H>
#include <Pipecomm++.H>
#include <Cam8SimPICore++.H>
#include "std++.H"
extern "C" {
#include <stdlib.h>
#include <string.h>
#include <sys/types.h>
#include <sys/ipc.h>
#include <sys/shm.h>
#include <sys/mman.h>
Cam8SimPICore::Cam8SimPICore(void)
  Bzero();
  ShmCnt = 0;
  InitInterface();
Cam8SimPICore::Cam8SimPICore(int mem, int in, int out)
  Bzero();
  ShmCnt = 0;
  sim_memfd = mem;
  sim_infd = in;
  sim_outfd = out;
  InitInterface();
Cam8SimPICore::~Cam8SimPICore(void)
STD_BZERO(Cam8SimPICore)
STD_BCOPY(Cam8SimPICore)
STD_BCMP(Cam8SimPICore)
int Cam8SimPICore::findidx(unsigned char *ptr)
  int i;
  if (ptr) {
    for (i = 0; i < ShmCnt; i++)
      if (ShmTable[i].buf == ptr)
	return(i);
    return(-1);
  else {
    for (i = 0; i < ShmCnt; i++)
      if (ShmTable[i].buf == NULL)
	return(i);
    
    if (ShmCnt == 8192)
      return(-1);
    else
      return(++ShmCnt);
unsigned char * Cam8SimPICore::Malloc(int size)
  int i;
  key_t key;
  int id;
  unsigned char *t;
  CaLib_tb.ENTER("Cam8SimPICore::Malloc");
  CaLibAbort((i = findidx(NULL)) < 0, "Shared memory table full");
  key = random();
  id = shmget(key, size, IPC_CREAT|IPC_EXCL|0777)
  CaLibAbort(id == -1, "shmget failed");
  t = (unsigned char *) shmat(id, NULL, 0);
  CaLibAbort(t == NULL, "shmat failed");
  ShmTable[i].key = key;
  ShmTable[i].id = id;
  ShmTable[i].buf = t;
  CaLib_tb.LEAVE();
  return(t);
unsigned char * Cam8SimPICore::Calloc(int num, int size)
  register unsigned char *t;
  CaLib_tb.ENTER("Cam8SimPICore::Calloc");
  t = Malloc(size * num);
  memset(t, 0, size * num);
  CaLib_tb.LEAVE();
  return(t);
unsigned char * Cam8SimPICore::Realloc(unsigned char *p, int size)
  register unsigned char *t;
  int i;
  CaLib_tb.ENTER("Cam8SimPICore::Realloc");
  CaLibWarning((i = findidx(p) < 0), "Unknown buffer");
  if (i >= 0) {
    CaLibWarning(shmdt(p) == -1, "shmdt failed");
    ShmTable[i].key = 0;
    ShmTable[i].id = 0;
    ShmTable[i].buf = NULL;
  t = Malloc(size);
  CaLib_tb.LEAVE();
  return(t);
void Cam8SimCore::ResetInterface(void)
  CaLib_tb.ENTER("Cam8SimCore::ResetInterface");
  /* Zero everything out to start off */
  bzero((char *) &iregs, sizeof(iregs));
  /* Enable all interrupts and exceptions */
  iregs.RER = CAM_ENABLE_NEWLIST_INT | CAM_ENABLE_TIMEOUT_INT |
              CAM_ENABLE_SBUS_INT | CAM_ENABLE_CAM_INT |
	      CAM_ENABLE_SOFT_INT | CAM_ENABLE_TIMEOUT_EXC |
	      CAM_ENABLE_CAMINT_EXC;
  /* Mark all interrupts as enabled */
  iregs.ISR = CAM_ENABLE_NEWLIST_INT | CAM_ENABLE_TIMEOUT_INT |
              CAM_ENABLE_SBUS_INT | CAM_ENABLE_CAM_INT |
	      CAM_ENABLE_SOFT_INT;
  /* Put us in wait-for-host mode */
  iregs.NLP |= CAM_WAIT_FOR_HOST;
  CaLib_tb.LEAVE();
void Cam8SimPICore::InitInterface(void)
  ResetInterface();
  comm.SetPipeDescriptors(sim_infd, sim_outfd);
  comm.SetPipeCmdTable(simcmds);
  comm.SetPipeMode(CAM_PIPEALL|CAM_PIPESILENT|CAM_PIPEFDPLX);
  newsl = FALSE;
void Cam8SimPICore::Generate_Interrupt(int type)
  CaLib_tb.ENTER("Cam8SimCore::Generate_Interrupt");
  iregs.ISR |= type;
  switch(type) {
  case CAM_CAM_INT_STATUS: {
    if ((iregs.RER & CAM_ENABLE_CAMINT_EXC) &&
	!(iregs.RER & CAM_DISABLE_CAMINT_EXC)) {
      iregs.NLP |= CAM_EXCEPTION_STATUS;
    }
    break;
  case CAM_TIMEOUT_INT_STATUS: {
    if ((iregs.RER & CAM_ENABLE_TIMEOUT_EXC) &&
	!(iregs.RER & CAM_DISABLE_TIMEOUT_EXC)) {
      iregs.NLP |= CAM_EXCEPTION_STATUS;
    }
    break;
  CaLib_tb.LEAVE();
void Cam8SimPICore::ExecuteSteplist(struct steplist_operation & slo)
  CaLib_tb.ENTER("Cam8SimPICore::ExecuteSteplist");
  // Copy slo to local buffer, resizing if needed and then write to NLP
  CaLib_tb.LEAVE();
long32 * Cam8SimPICore::GetNextSteplist(void)
  int rv;
  CaLib_tb.ENTER("Cam8SimPICore::GetNextSteplist");
  while (! newsl) {
    if ((rv = comm.ParsePipeMesg(NULL)) < CAM_PIPEALL) {
      /* There has been a fatal error */
      retv[0] = FATAL;
      comm.SendPipeMesg((unsigned char *) retv);
      CaLibDie("exiting\n");
    }
  newsl = FALSE;
  CaLib_tb.LEAVE();
  return((long32 *) (iregs.NLP & 0xFFFFFFF0));
void Cam8SimPICore::Read_NLP(long32 *v)
  int ecode;
  CaLib_tb.ENTER("Cam8SimPICore::Read_NLP");
  CaLibAbort(!v, "NULL Pointer");
  ecode = comm.TwoWayPipeCmd(NULL, "rdR0", NULL, NULL, (unsigned char *) v);
  CaLibAbort(ecode < 0);
  CaLib_tb.LEAVE()
void Cam8SimPICore::Read_ISR(long32 *v)
  int ecode;
  CaLib_tb.ENTER("Cam8SimPICore::Read_ISR");
  CaLibAbort(!v, "NULL Pointer");
  ecode = comm.TwoWayPipeCmd(NULL, "rdR1", NULL, NULL, (unsigned char *) v);
  CaLibAbort(ecode < 0);
  CaLib_tb.LEAVE()
void Cam8SimPICore::Read_CIP(long32 *v)
  int ecode;
  CaLib_tb.ENTER("Cam8SimPICore::Read_CIP");
  CaLibAbort(!v, "NULL Pointer");
  ecode = comm.TwoWayPipeCmd(NULL, "rdR2", NULL, NULL, (unsigned char *) v);
  CaLibAbort(ecode < 0);
  CaLib_tb.LEAVE()
void Cam8SimPICore::Read_PIP(long32 *v)
  int ecode;
  CaLib_tb.ENTER("Cam8SimPICore::Read_PIP");
  CaLibAbort(!v, "NULL Pointer");
  ecode = comm.TwoWayPipeCmd(NULL, "rdR3", NULL, NULL, (unsigned char *) v);
  CaLibAbort(ecode < 0);
  CaLib_tb.LEAVE()
void Cam8SimPICore::Write_NLP(const long32 *v)
  int ecode;
  CaLib_tb.ENTER("Cam8SimPICore::Write_NLP");
  CaLibAbort(!v, "NULL Pointer");
  ecode = comm.TwoWayPipeCmd(NULL, "wrR0", NULL, NULL, (unsigned char *) v);
  CaLibAbort(ecode < 0);
  CaLib_tb.LEAVE()
void Cam8SimPICore::Write_RER(const long32 *v)
  int ecode;
  CaLib_tb.ENTER("Cam8SimPICore::Write_RER");
  CaLibAbort(!v, "NULL Pointer");
  ecode = comm.TwoWayPipeCmd(NULL, "wrR1", NULL, NULL, (unsigned char *) v);
  CaLibAbort(ecode < 0);
  CaLib_tb.LEAVE()
void Cam8SimPICore::Write_DSL(const long32 *v)
  int ecode;
  CaLib_tb.ENTER("Cam8SimPICore::Write_DSL");
  CaLibAbort(!v, "NULL Pointer");
  ecode = comm.TwoWayPipeCmd(NULL, "wrR2", NULL, NULL, (unsigned char *) v);
  CaLibAbort(ecode < 0);
  CaLib_tb.LEAVE()
void Cam8SimPICore::Write_DBL(const long32 *v)
  int ecode;
  CaLib_tb.ENTER("Cam8SimPICore::Write_DBL");
  CaLibAbort(!v, "NULL Pointer");
  ecode = comm.TwoWayPipeCmd(NULL, "wrR3", NULL, NULL, (unsigned char *) v);
  CaLibAbort(ecode < 0);
  CaLib_tb.LEAVE()
/* PipeComm routines */
unsigned char *SHMAT(char *appdata, unsigned char *o, unsigned char *d)
  int i, shmid = *((int *) d);
  retv[0] = NOERR;
  retv[1] = NOERR;
  CaLibAbort((i = finidx(NULL)) < 0, "Shared memory table full");
  if ((retv[1] = (int) shmat(shmid, (const void *) NULL, NULL)) != -1) {
    ShmTable[i].id = shmid;
    ShmTable[i].buf = (unsigned char *) retv[1];
  return((unsigned char *) retv);
unsigned char *SHMDT(char *appdata, unsigned char *o, unsigned char *d)
  int i;
  unsigned char *p = *((unsigned char **) d);
  retv[0] = NOERR;
  retv[1] = NOERR;
  i = findidx(p);
  if (i < 0) {
    CaLibWarning(TRUE, "Unknown buffer");
    retv[1] = -1;
  else {
    if ((retv[1] = shmdt(p)) != -1) {
      ShmTable[i].key = 0;
      ShmTable[i].id = 0;
      ShmTable[i].buf = NULL;
    }
    else
      CaLibWarning(TRUE, "shdt failed");
  return((unsigned char *) retv);
unsigned char *READR0(char *appdata, unsigned char *o, unsigned char *d)
  retv[0] = NOERR;
  retv[1] = iregs.NLP;
  return((unsigned char *) retv);
unsigned char *READR1(char *appdata, unsigned char *o, unsigned char *d)
  retv[0] = NOERR;
  retv[1] = iregs.ISR;
  /* Turn off interrupt flags and unused bits, leave enables the same */
  iregs.ISR &= 0x00001F00;
  return((unsigned char *) retv);
unsigned char *READR2(char *appdata, unsigned char *o, unsigned char *d)
  retv[0] = NOERR;
  retv[1] = iregs.CIP;
  return((unsigned char *) retv);
unsigned char *READR3(char *appdata, unsigned char *o, unsigned char *d)
  retv[0] = NOERR;
  retv[1] = iregs.PIP;
  return((unsigned char *) retv);
unsigned char *WRITER0(char *appdata, unsigned char *o, unsigned char *d)
  long32 tmp = iregs.NLP & 0xF;
  if (!(iregs.NLP & CAM_EXCEPTION_STATUS)) {
    iregs.NLP = tmp | (*((int *) d) & 0xFFFFFFF0);
    newsl = TRUE;
  retv[0] = NOERR;
  return((unsigned char *) retv);
unsigned char *WRITER1(char *appdata, unsigned char *o, unsigned char *d)
  iregs.RER = *((int *) d);
  if (iregs.RER & CAM_RESET_INTERFACE) {
    ResetInterface();
  if (iregs.RER & CAM_HALT_INTERFACE)
    iregs.NLP |= CAM_INTERFACE_HALTED;
  if (iregs.RER & CAM_ENABLE_TIMEOUT_EXC)
    iregs.NLP &= ~(CAM_EXCEPTION_STATUS);
  /*  This is supposed to also resume after error ack, whatever that is
  if (iregs.RER & CAM_ENABLE_CAMINT_EXC)
  */
  if (iregs.RER & CAM_ENABLE_NEWLIST_INT)
    iregs.ISR |= CAM_ENABLE_NEWLIST_INT;
  if (iregs.RER & CAM_ENABLE_TIMEOUT_INT)
    iregs.ISR |= CAM_ENABLE_TIMEOUT_INT;
  if (iregs.RER & CAM_ENABLE_SBUS_INT)
    iregs.ISR |= CAM_ENABLE_SBUS_INT;
  if (iregs.RER & CAM_ENABLE_CAM_INT)
    iregs.ISR |= CAM_ENABLE_CAM_INT;
  if (iregs.RER & CAM_ENABLE_SOFT_INT)
    iregs.ISR |= CAM_ENABLE_SOFT_INT;
  if (iregs.RER & CAM_DISABLE_NEWLIST_INT)
    iregs.ISR &= ~(CAM_ENABLE_NEWLIST_INT);
  if (iregs.RER & CAM_DISABLE_TIMEOUT_INT)
    iregs.ISR &= ~(CAM_ENABLE_TIMEOUT_INT);
  if (iregs.RER & CAM_DISABLE_SBUS_INT)
    iregs.ISR &= ~(CAM_ENABLE_SBUS_INT);
  if (iregs.RER & CAM_DISABLE_CAM_INT)
    iregs.ISR &= ~(CAM_ENABLE_CAM_INT);
  if (iregs.RER & CAM_ENABLE_SOFT_INT)
    iregs.ISR |= CAM_ENABLE_SOFT_INT;
  retv[0] = NOERR;
  return((unsigned char *) retv);
unsigned char *WRITER2(char *appdata, unsigned char *o, unsigned char *d)
  iregs.DSL = *((int *) d);
  retv[0] = NOERR;
  return((unsigned char *) retv);
unsigned char *WRITER3(char *appdata, unsigned char *o, unsigned char *d)
  iregs.DBL = *((int *) d);
  retv[0] = NOERR;
  return((unsigned char *) retv);
unsigned char *QUIT(char *appdata, unsigned char *o, unsigned char *d)
  retv[0] = NOERR;
  qflag = -1;
  return((unsigned char *) retv);
#include <CaLibStream++.H>
#include <CaLibError++.H>
#include <CaLibTrace++.H>
#include <CamLib++.H>
#include <Cam8SimJIT++.H>
#include <Cam8SimSPARCJIT++.H>
#include "std++.H"
Cam8SimSPARCJIT::Cam8SimSPARCJIT(Cam8SimRegMgr *rm)
  regmgr = rm;
  hcodTarget = NULL;						 /* Handle to Target Code Location   */
  pcodNext = NULL;						 /* Pointer to location of next inst */
  lblNext = 0;							 /* Next Label 			     */
  pblkTOS = NULL;
Cam8SimSPARCJIT::~Cam8SimSPARCJIT(void)
/*****************************************************************************/
/*                                                                           */
/* Translate an intermediate instruction into target code. 		     */
/*                                                                           */
/*****************************************************************************/
void Emit(int16 opcode,
	  byte op1Type, long32 op1,
	  byte op2Type, long32 op2,
	  byte destType, long32 dest)
     char *szFuncName = "Emit";
     
#ifdef DEBUG
     DASMADDR = pcodNext;
#endif
     if (opcode & NATIVE_OP) {							 /* NATIVE INSTRUCTION 		     */
	  register rs1, rs2, rd;						 
	  switch (op1Type) {							 /* Figure out rs1 		     */
	     case NULL_OP:
	       rs1 = REG_G0;
	       break;
	     case REG_OP:
	       rs1 = (register) op1;
	       break;
	     case VAR_OP:
	       rs1 = GetReg(op1, CURRENT_HANDLE, TRUE);
	       break;
	     default:
	       CRITICAL_ERROR("Invalid argument for rs1", szFuncName);
	       break;
	  }
	  switch (destType) {							 /* Figure out the dest register     */
	     case NULL_OP:
	       rs1 = REG_G0;
	       break;
	     case REG_OP:
	       rd = (register) dest;
	       break;
	     case VAR_OP:
	       rd = GetReg(dest, CURRENT_HANDLE, FALSE);
	       break;
	     default:
	       CRITICAL_ERROR("Invalid argument for rd", szFuncName);
	       break;
	  }
	  switch (op2Type) {							 /* Figure out rs2. This is done     */
	     case REG_OP:							 /* last because rs2 might be a      */
	       rs2 = (register) op2;						 /* constant > 13 bits, and we might */
	       break;								 /* have to preload it into the dest */
	     case VAR_OP:
	       rs2 = GetReg(op2, CURRENT_HANDLE, TRUE);
	       break;
	     case CONST_OP:
	       if (((signed long) op2) > 4095 ||				 /* if op2 will not fit in 13 bits   */
		   ((signed long) op2) < -4096) {
		    EMIT( SETHI(HI22(op2), rd) );
		    EMIT( OR_REG_IMM(rd, LOW10(op2), rd) );
		    op2Type = REG_OP;
		    rs2 = rd;
	       }
	       break;
	       
	     default:
	       CRITICAL_ERROR("Invalid argument for rs2", szFuncName);
	       break;
	  }
	  opcode = opcode & NATIVE_OP_MASK;					 /* extract the target's native op-  */
										 /* code... 			     */
	  if (op2Type == CONST_OP) {
	       *pcodNext++ = FMT3_INST(0x02L, opcode, rs1, IMMEDIATE, op2, rd);	 /* and emit the instruction 	     */
	  } else {
	       *pcodNext++ = FMT3_INST(0x02L, opcode, rs1, REG_SOURCE, rs2, rd);
	  }									 /* -------------------------------- */
     } else if (opcode & LD_ST_OP) {						 /* LOAD-STORE INSTRUCTION 	     */
	  register rs1, rs2, rd;
	  switch (opcode) {
	     case LDW_MEM:							 /* bring op1 into a register 	     */
	       if (op1Type == VAR_OP) {
		    rs1 = GetReg(op1, CURRENT_HANDLE, TRUE);
	       } else {
		    CRITICAL_ERROR("Invalid LDW_MEM argument",
				   szFuncName);
	       }
	       break;
	     case LDUB_IND:
	     case LDHW_IND:
	     case LDW_IND:							 /* load indirect : dest <- [op1+op2]*/
	       if (op1Type == VAR_OP) {
		    rs1 = GetReg(op1, CURRENT_HANDLE, TRUE);
	       } else if (op1Type == REG_OP) {
		    rs1 = (register) op1;
	       } else {
		    CRITICAL_ERROR("Invalid LDW_IND argument 1",
				   szFuncName);
	       }
	       if (op2Type == VAR_OP) {
		    rs2 = GetReg(op2, CURRENT_HANDLE, TRUE);
	       } else if (op2Type == REG_OP) {
		    rs2 = (register) op2;
	       } else if (op2Type == CONST_OP) {
		    /* do nothing */
	       } else {
		    CRITICAL_ERROR("Invalid LDW_IND argument 2",
				   szFuncName);
	       }
		    
	       if (destType == VAR_OP) {
		    rd = GetReg(dest, CURRENT_HANDLE, FALSE);
	       } else if (op2Type == REG_OP) {
		    rd = (register) dest;
	       } else {
		    CRITICAL_ERROR("Invalid LDW_IND argument",
				   szFuncName);
	       }
	       
	       if (opcode == LDW_IND) {
		    (op2Type == CONST_OP) ? (EMIT( LDW_REG_IMM(rs1, op2, rd) )) :
		      (EMIT( LDW_REG_REG(rs1, rs2, rd)));
	       } else if (opcode == LDHW_IND) {
		    (op2Type == CONST_OP) ? (EMIT( LDHW_REG_IMM(rs1, op2, rd) )) :
		      (EMIT( LDHW_REG_REG(rs1, rs2, rd)));	
	       } else {
		    (op2Type == CONST_OP) ? (EMIT( LDUB_REG_IMM(rs1, op2, rd) )) :
		      (EMIT( LDUB_REG_REG(rs1, rs2, rd) ));
	       }
	       break;
	       
	     case STW_MEM:							 /* flush op1 to memory 	     */
	       if (op1Type == VAR_OP) {
		    rs1 = GetReg(op1, CURRENT_HANDLE, TRUE);			 /* 	hopefully, op1 is already    */
		    FlushReg(rs1, CURRENT_HANDLE);				 /* 	in a register!		     */
	       } else {
		    CRITICAL_ERROR("Invalid STW_MEM argument",
				   szFuncName);
	       }
	       break;
	     case STUB_IND:
	     case STHW_IND:
	     case STW_IND:							 /* store indirect: [op1+op2] <- dest*/
	       if (op1Type == VAR_OP) {						 /* 	get op1 - var or reg 	     */
		    rs1 = GetReg(op1, CURRENT_HANDLE, TRUE);
	       } else if (op1Type == REG_OP) {
		    rs1 = (register) op1;
	       } else {
		    CRITICAL_ERROR("Invalid STW_IND argument",
				   szFuncName);
	       }
	       if (op2Type == VAR_OP) {						 /* 	get op2 - var, reg, or const */
		    rs2 = GetReg(op2, CURRENT_HANDLE, TRUE);
	       } else if (op2Type == REG_OP) {
		    rs2 = (register) op2;
	       } else if (op2Type == CONST_OP) {
		    /* do nothing */
	       } else {
		    CRITICAL_ERROR("Invalid LDW_IND argument 2",
				   szFuncName);
	       }
		    
	       if (destType == VAR_OP) {					 /* 	get dest - var or reg 	     */
		    rd = GetReg(dest, CURRENT_HANDLE, TRUE);
	       } else if (op2Type == REG_OP) {
		    rd = (register) dest;
	       } else {
		    CRITICAL_ERROR("Invalid STW_IND argument",
				   szFuncName);
	       }
	       if (opcode == STW_IND) {
		    (op2Type == CONST_OP) ? (EMIT( STW_REG_IMM(rs1, op2, rd))) :
		      (EMIT( STW_REG_REG(rs1, rs2, rd)));
	       } else if (opcode == STHW_IND) {
		    (op2Type == CONST_OP) ? (EMIT( STHW_REG_IMM(rs1, op2, rd))) :
		      (EMIT( STHW_REG_REG(rs1, rs2, rd)));
	       } else {
		    (op2Type == CONST_OP) ? (EMIT( STUB_REG_IMM(rs1, op2, rd))) :
		      (EMIT( STUB_REG_REG(rs1, rs2, rd)));
	       }
	       break;
	       
	     default:
	       CRITICAL_ERROR("Unknown Load Store operation",
			      szFuncName);
	       break;
	  }									 /* -------------------------------- */
     } else if (opcode & BRANCH_OP) {						 /* BRANCH INSTRUCTION 		     */
	  labelrec	*plblrecBranch;
	  long32	lDisp;
	  opcode &= NATIVE_OP_MASK;						 /* extract the native branch code   */
	  if (op1Type == LABEL_OP) {
	       if ((plblrecBranch = FindLabel((codelabel) op1)) != NULL) {	 /* if label was encountered before  */
		    CODE pcodBranchLoc = GetLabelAddress(plblrecBranch);	 /*     Get address of branch loc    */
		    if (!pcodBranchLoc) {					 /* 	if label's addrss is unknown */
			 AddLabelRef(plblrecBranch, CURRENT_LOC);		 /* 	   add a ref record. 	     */
			 lDisp = 0;						 /* 	   dummy disp 		     */
		    } else {							 /*     else label's addr is known   */
			 lDisp = pcodBranchLoc - CURRENT_LOC;			 /*        calculate displacement    */
		    }
		    EMIT( BRANCH_INST(0, opcode, lDisp) );			 /* 	Emit branch instruction      */
	       } else {								 /* Label was not encountered before */
		    plblrecBranch = AddLabel((codelabel) op1, 0, FALSE);	 /* 	So create new record 	     */
		    AddLabelRef(plblrecBranch, CURRENT_LOC);			 /* 	add a ref record to it 	     */
		    EMIT( BRANCH_INST(0, opcode, 0) );				 /* 	emit filler branch instr     */
	       }
	  } else {
	       CRITICAL_ERROR("Branch to a non-label", szFuncName);
	  }									 /* -------------------------------- */
     } else {									 /* PSEUDO INSTRUCTION 		     */
	  switch (opcode) {
	     case INSTR:							 /* op1 is a valid sparc instruction */
	       EMIT( op1 );							 /* 	simply insert it 	     */
	       break;								 /* 	useful to fill delay slots   */
	       
	     case ENTER_PROC:							 /* procedure entry prologue 	     */
	       PushRegWindow();							 /*     Inform register manager of   */
	       if (op1Type == CONST_OP) {					 /*     new register window 	     */
		    EMIT( SAVE_REG_IMM(REG_SP, -112-8-op1, REG_SP) );		 /* 	-112 is gcc's local frame    */
	       } else {								 /*     and we need 2 words to save  */
		    EMIT( SAVE_REG_IMM(REG_SP, -112-8, REG_SP) );		 /* 	our own fp and return addr   */
	       }								 /*     registers. 		     */
	       EMIT( STW_REG_IMM(REG_SP, 72, REG_G7) );				 /* 	sp+8 = our fp register       */
	       EMIT( STW_REG_IMM(REG_SP, 68, REG_RA) );				 /* 	sp+4 = our return address    */
	       EMIT( SETHI(HI22(pcHeap), REG_DS) );				 /* 	make ds point to heap base   */
	       if ( LOW10(pcHeap) != 0) {
		    EMIT( OR_REG_IMM(REG_DS, LOW10(pcHeap), REG_DS) );
	       }
	       break;
	       
	     case RETURN_PROC:							 /* return from procedure 	     */
	       PopRegWindow(CURRENT_HANDLE);					 /* 	restore reg. window 	     */
	       EMIT( LDW_REG_IMM(REG_SP, 72, REG_G7) );				 /* 	restore saved fp register    */
	       EMIT( LDW_REG_IMM(REG_SP, 68, REG_RA) );				 /* 	restore our return address   */
	       EMIT( RET );							 /* 	return from procedure	     */
	       EMIT( RESTORE );							 /* 	and restore the reg window   */
	       break;
	       
	     case CALL_PROC:							 /* call a procedure 		     */
	       if (op1Type == ADDR_OP) {
		    op1 -= (long32) pcodNext;
		    EMIT( CALL(op1) );						 /* 	call procedure at addr op1   */
	       } else {
		    CRITICAL_ERROR("Invalid procedure call", szFuncName);
	       }
	       break;
	     case ENTER_LEAF:							 /* leaf procedure entry 	     */
	       SaveRegState();							 /*     Save all the live registers  */
	       break;
	     case RETURN_LEAF:							 /* return from leaf procedure 	     */
	       RestoreRegState(CURRENT_HANDLE);					 /*  	Restore live registers	     */
	       EMIT( RETL );							 /*     return to caller 	     */
	       EMIT( NOP );							 /* 	delay slot 		     */
	       break;
	       
	     case CALL_LEAF:							 /* call a leaf procedure 	     */
	       if (op1Type == ADDR_OP) {
		    EMIT( SETHI(HI22(op1), REG_RA) );
		    EMIT( CALL_REG_IMM(REG_RA, LOW10(op1)) );
	       } else {
		    CRITICAL_ERROR("Invalid leaf procedure call",
				   szFuncName);
	       }
	       break;
	     case CALL_LEAF_IND: {
		  register rs1, rs2, rd;
		  
		  if (op1Type == VAR_OP) {
		       rs1 = GetReg(op1, CURRENT_HANDLE, TRUE);
		  } else {
		       CRITICAL_ERROR("Invalid op1 : indirect leaf procedure call",
				      szFuncName);
		  }
		  if (op2Type == CONST_OP) {
		       /* do nothing */
		  } else if (op2Type != NULL_OP) {
		       CRITICAL_ERROR("Invalid op2 : indirect leaf procedure call",
		       		      szFuncName);
		  } 
		  
		  EMIT( CALL_REG_IMM(rs1, op2) );
	       }
	       break;
		       
		       
	     case ENTER_BASICBLK:
	       SaveRegState();
	       break;
	     case RETURN_BASICBLK:
	       RestoreRegState(CURRENT_HANDLE);
	       break;
	       
	     case ADD_LABEL:							 /* define a label 		     */
	       if (op1Type == LABEL_OP) {
		    LABELREC plblrec;
		    
		    if ((plblrec = FindLabel((codelabel) op1)) == NULL) {	 /* 	if first time seeing label   */
			 AddLabel((codelabel) op1, CURRENT_LOC, TRUE);		 /* 	   add a new label record    */
		    } else {							 /* 	else  			     */
			 ResolveRefs(plblrec, CURRENT_LOC);			 /* 	   resolve all refs to label */
		    }
	       } else {
		    CRITICAL_ERROR("Invalid operand to ADD_LABEL",		
				   szFuncName);
	       }
	       break;
	     case NO_OP:
	       EMIT( NOP );
	       break;
	       
	     default:
	       CRITICAL_ERROR("Unknown pseudo-op", szFuncName);
	       break;
     }
void ResolveRefs(LABELREC plblrec, CODE lAddress)
     if (plblrec->bValid == TRUE) {
	  WARNING("Possible redefinition of label", "ResolveRefs");
     } else {
	  labelref *prefNext;
	  CODE pcodRefLoc;
	  long32 lDisp;
	  plblrec->bValid = TRUE;						 /* update label record for future   */
	  plblrec->lAddress = lAddress;						 /* reference resolutions 	     */
	  do {									 /* Now, update all references.      */
	       prefNext = plblrec->prefFirst;					 /* Assume at least one reference!   */
	       pcodRefLoc = prefNext->pcodRefLoc;				 
	       lDisp = lAddress - pcodRefLoc;					 /* calculate displacement 	     */
	       lDisp &= 0x3FFFFF;						 /* least sig 22 bits only 	     */
	       *pcodRefLoc |= lDisp;						 /* and patch the refering instruct  */
	       plblrec->prefFirst = prefNext->prefNext;
	       FREE(prefNext, "ResolveRefs");					 /* release the reference record     */
	  } while (plblrec->prefFirst != NULL);
     }
     
void PrintAsm(CODE pcodSource, FILE *fOut)
  CODE pcod;
  unsigned short op;
  for (pcod = pcodSource; *pcod != 0; pcod++) {
    
    fprintf(fOut, "0x%x: ", pcod);
    
    op = (*pcod >> 30) & 0x3L;
    switch (op) {
    case 0:
      Fmt2Instr(*pcod, fOut);
      break;
      
    case 1:
      Fmt1Instr(*pcod, fOut);
      break;
      
    case 2:
    case 3:
      Fmt3Instr(*pcod, fOut);
      break;
    }
void Fmt1Instr(INSTRUCTION instr, FILE *fOut)
  fprintf(fOut, "CALL \t%x\n", (instr & 0x3FFFFFFFL));
void Fmt2Instr(INSTRUCTION instr, FILE *fOut)
  unsigned short op2, cc, rd;
  signed long disp;
  op2 = (instr >> 22) & 0x7L;
  if (op2 == 4) {								 /* SETHI 			     */
    unsigned long hi22;
    hi22 = (instr << 10);
    rd = (instr >> 25) & 0x1FL;
    fprintf(fOut,"SETHI \t%s, \t%x (%x)\n", szRegName[rd],
	    (instr & 0x003FFFFFL), hi22);
  } else if (op2 == 2) {							 /* BRANCH 			     */
    cc = (instr >> 25) & 0xFL;
    if (instr & 0x00200000L) {
      disp = instr | 0xFFC00000L;
    } else {
      disp = instr & 0x1FFFFF;
    }
    fprintf(fOut,"BR%s \t%d\n", szCCName[cc], disp);
  } else {
    fprintf(fOut,"UNIMP BR : %x\n", instr);
void Fmt3Instr(INSTRUCTION instr, FILE *fOut)
  unsigned short majorOp, opcode, imm, rs1, rs2, rd;
  signed long lConst;
  majorOp = (instr >> 30) & 0x3L;
  opcode = (instr >> 19) & 0x3FL;
  rd = (instr >> 25) & 0x1FL;
  rs1 = (instr >> 14) & 0x1FL;
  rs2 = instr & 0x1FL;
  imm = (instr >> 13) & 0x1L;
  if (imm) {
    if (instr & 0x00001000L) {
      lConst = (instr | 0xFFFFF000L);
    } else {
      lConst = (instr & 0xFFFL);
    }
  if (majorOp == 3) {							 /* LOAD-STORE 			     */
    switch (opcode) {
    case OP_LDW:
      fprintf(fOut,"LDW ");
      break;
    case OP_LDHW:
      fprintf(fOut,"LDHW ");
      break;
    case OP_LDUB:
      fprintf(fOut,"LDUB ");
      break;
    case OP_STW:
      fprintf(fOut,"STW ");
      break;
    case OP_STUB:
      fprintf(fOut,"STUB ");
      break;
      
    default:
      fprintf(fOut,"UNIMP LOAD-STORE : %x\n", instr);
      return;
      break;
    };
  } else {									 /* ARITHMETIC 			     */
    switch (opcode) {
    case OP_ADD:
      fprintf(fOut,"ADD ");
      break;
    case OP_ADDcc:
      fprintf(fOut,"ADDcc ");
      break;
    case OP_ADDX:
      fprintf(fOut,"ADDX ");
      break;
    case OP_ADDXcc:
      fprintf(fOut,"ADDXcc ");
      break;
      
    case OP_SUB:
      fprintf(fOut,"SUB ");
      break;
    case OP_SUBcc:
      fprintf(fOut,"SUBcc ");
      break;
    case OP_SUBX:
      fprintf(fOut,"SUBX ");
      break;
    case OP_SUBXcc:
      fprintf(fOut,"SUBXcc ");
      break;
      
    case OP_AND:							 /* LOGICAL 			     */
      fprintf(fOut,"AND ");
      break;
    case OP_ANDcc:
      fprintf(fOut,"ANDcc ");
      break;
    case OP_ANDN:
      fprintf(fOut,"ANDN ");
      break;
    case OP_ANDNcc:
      fprintf(fOut,"ANDNcc ");
      break;
      
    case OP_OR:
      fprintf(fOut,"OR ");
      break;
    case OP_ORcc:
      fprintf(fOut,"ORcc ");
      break;
    case OP_ORN:
      fprintf(fOut,"ORN ");
      break;
    case OP_ORNcc:
      fprintf(fOut,"ORNcc ");
      break;
      
    case OP_XOR:
      fprintf(fOut,"XOR ");
      break;
    case OP_XORcc:
      fprintf(fOut,"XORcc ");
      break;
    case OP_XNOR:
      fprintf(fOut,"XNOR ");
      break;
    case OP_XNORcc:
      fprintf(fOut,"XNORcc ");
      break;
      
      
    case OP_SLL:
      fprintf(fOut,"SLL ");
      break;
    case OP_SRL:
      fprintf(fOut,"SRL ");
      break;
    case OP_SRA:
      fprintf(fOut,"SRA ");
      break;
      
    case OP_JMPL:							 /* CONTROL TRANSFER 		     */
      fprintf(fOut,"JMPL ");
      break;
    case OP_SAVE:
      fprintf(fOut,"SAVE ");
      break;
    case OP_RESTORE:
      fprintf(fOut,"RESTOR");
      break;
      
    default:
      fprintf(fOut,"UNIMP LOGICAL-ARITH : %x\n", instr);
      return;
      break;
    };
  if (imm) {
    fprintf(fOut,"\t%s \t%d \t%s\n", szRegName[rs1], lConst, szRegName[rd]);
  } else {
    fprintf(fOut,"\t%s \t%s \t%s\n", szRegName[rs1], szRegName[rs2],
	    szRegName[rd]);
  static char registerS[32][64] = {
  };
    "ALWAYS", "NEQ", "G", "GE", "GU", "CC", "POS", "VC"
    "NEVER", "EQ", "LE", "L", "LEU", "CS", "NEG", "VS",
  static const char *szCCName[] = {
  };
    "%i0", "%i1", "%i2", "%i3", "%i4", "%i5", "%ds", "%ra"
    "%l0", "%l1", "%l2", "%l3", "%l4", "%l5", "%l6", "%l7",
    "%o0", "%o1", "%o2", "%o3", "%o4", "%o5", "%sp", "%tp",
    "%g0", "%g1", "%g2", "%g3", "%g4", "%g5", "%g6", "%g7",
  static const char *szRegName[] = {
public:
class Cam8SimSPARCCore : public Cam8SimCore {
typedef tag_lblref labelref;
     struct tag_lblref *prefNext;
     CODE	pcodRefLoc;
struct tag_lblref {
/* record of a reference to a label */
typedef codeblk *CODEBLK;
typedef tag_codeblk codeblk;
     struct tag_codeblk *pblkPrev;
     labelrec   *plblrecFirst;
     codelabel	lblNext;
     CODE    pcodNext;
     CODEHANDLE hcodTarget;
struct tag_codeblk {
/********************************* GLOBALS ***********************************/
/*****************************************************************************/
/*****************************************************************************/
/******************************* PROTOTYPES **********************************/
/*****************************************************************************/
#endif
/*****************************************************************************/
/********************************* INLINES ***********************************/
/*****************************************************************************/
typedef Cam8SimSPARCCore *CAM8SIMSPARCCORE;
  register GetReg(int16 nVar, CODEHANDLE hcodCurrent, bool bLoad);
  /* allocates a register for nVar */
  void RestoreRegState(CODEHANDLE hcodCurrent);
  /* returns all regs to state they */
  void SaveRegState(void);
  /* record all the "live" registers */
  void FlushReg(register rFlush, CODEHANDLE hcodCurrent);
  /* flushes rFlush back to memory */
  void InitRegMgr(void);
  void PrintAsm(CODE pcodSource, FILE *fOut);
	    byte destType, long32 dest);
  void Emit(int16 opcode, byte op1Type, long32 op1, byte op2Type, long32 op2,
  void EndBlock();
  void NewBlock(CODEHANDLE);
  register GetQueElement(regque *prque);
  register GetSpillable(void);
  register GetFreeReg(void);
  byte NumQueElements(regque rque);
  byte NumFreeRegs(void);
  void ResetQue(regque *prque);
  void AddQueElement(regque *prque, register reg);
  void ResetFreeQue(void);
  void FreeReg(register reg);
  void PopRegWindow(CODEHANDLE hcodCurrent);
  void PushRegWindow(void);
  void ResetSpillQue(void);
  void InsertSpillable(register reg);
  short PermuteScanIndex();
  void BuildBitwiseDest(short nDest, short iDestVar, byte Src[], byte Map[]);
  void BuildBitDest(short nDest, short iHoldReg, byte Src, byte Map, unsigned short nPlane);
  void BuildDest(short nDest, short iDestVar, byte Src, byte Map);
  void MapFunction (short iSrcVar, short iDestVar, byte bMap);
  void SimSavePlaneWords();
  void SimLoadPlaneWords();
  void SimUpdateCode();
  void CheckNoPerm(CODEHANDLE hcodCurrent);
  void SimSaveLastWord(unsigned short nBitOffset[]);
  void SimGetNextWord(unsigned short nPlane);
  void SimLoadFirstWord(unsigned short nBitOffset[]);
  void SimUpdateSite();
  void SimEpilogue(CODEHANDLE hcodCurrent);
  void SimPrologue(CODEHANDLE hcodCurrent);
  void SimGeneralScan(CODEHANDLE hcodCurrent);
  void SimScanNoPerm(CODEHANDLE hcodCurrent);
  void InitSim(void);
  DECL_BCMP(Cam8SimSPARCCore);
  DECL_BCOPY(Cam8SimSPARCCore);
  DECL_BZERO(Cam8SimSPARCCore);
  DECL_OPEQ(Cam8SimSPARCCore);
  virtual ~Cam8SimSPARCCore(void);
  DECL_COPYCONST(Cam8SimSPARCCore);
  Cam8SimSPARCCore(void);
#endif
  struct timezone tzZone;
  struct timeval tvStart, tvEnd;
#ifdef _INSTRUMENTATION_
#endif DEBUG
  CODE DASMADDR;
#ifdef DEBUG
  codeblk *pblkTOS;
  codelabel lblNext;		/* Next Label */
  CODEHANDLE hcodTarget;	/* Handle to Target Code Location */
  CODE pcodNext;		/* Pointer to location of next inst */
  CODE pcodUpdateSite;
  CODE pcodSweep;
  CODE pcodScanner;
  CODE pcodGenUpdate;
  CODE pcodScanNoPerm;
  labelrec *plblrecFirst;
  regque rqueSpillable[4];							 /* Que of spillable registers, one  */
  regque rqueFree;
  REGENTRY rCurrWindow[MREGS];
  char SYMBOLS[SymbolTableSize][64];
  };
    "I0", "I1", "I2", "I3", "I4", "I5", "I6", "I7",
    "L0", "L1", "L2", "L3", "L4", "L5", "L6", "L7",
    "O0", "O1", "O2", "O3", "O4", "O5", "O6", "O7",
    "G0", "G1", "G2", "G3", "G4", "G5", "G6", "G7",
#define LDHW_REG_REG(rs1, rs2, rd) 	(FMT3_INST(0x3L, OP_LDHW, rs1, REG_SOURCE, rs2, rd))
#define LDHW_REG_IMM(rs1, k, rd) 	(FMT3_INST(0x3L, OP_LDHW, rs1, IMMEDIATE, k, rd))
#define LDW_REG_REG(rs1, rs2, rd) 	(FMT3_INST(0x3L, OP_LDW, rs1, REG_SOURCE, rs2, rd))
#define LDW_REG_IMM(rs1, k, rd) 	(FMT3_INST(0x3L, OP_LDW, rs1, IMMEDIATE, k, rd))
#define NOP				(FMT3_INST(0x2L, OP_OR, REG_G0, REG_SOURCE, REG_G0, REG_G0))
#define CALL(disp)			((0x01 << 30) | (((unsigned long) (disp)) >> 2))
#define CALL_REG_IMM(r, k) 		(FMT3_INST(0x2L, OP_JMPL, (r), IMMEDIATE, (k), REG_O7))
#define CALL_REG(r)			(FMT3_INST(0x2L, OP_JMPL, (r), IMMEDIATE, 0, REG_O7))
#define RETL				(FMT3_INST(0x2L, OP_JMPL, REG_O7, IMMEDIATE, 8, REG_G0))
#define RET				(FMT3_INST(0x2L, OP_JMPL, REG_I7, IMMEDIATE, 8, REG_G0))
#define RESTORE				(FMT3_INST(0x2L, OP_RESTORE, REG_G0, REG_SOURCE, REG_G0, REG_G0))
#define SAVE_REG_REG(rs1, rs2, rd)	(FMT3_INST(0x2L, OP_SAVE, (rs1), REG_SOURCE, (rs2), (rd)))
#define SAVE_REG_IMM(rs1, k, rd)	(FMT3_INST(0x2L, OP_SAVE, (rs1), IMMEDIATE, (k), (rd)))
						((rs2) & 0x1FFFL))
						((i) << 13) | \
		       				((rs1) << 14) | \
						((opcode) << 19) | \
						((rd) << 25) | \
#define FMT3_INST(op, opcode, rs1, i, rs2, rd) (((op) << 30) | \
					 ((k) & 0x3fffffL))
					 ((rd) << 25) | \
					 ((opcode) << 22) | \
#define FMT2_INST(op, opcode, k, rd) 	(((op) << 30) | \
#define REG_SOURCE	0
#define IMMEDIATE	1
#define OP_RESTORE	0x3DL
#define OP_SAVE		0x3CL
#define OP_JMPL		0x38L
#define OP_SETHI	0x04L
#define OP_SRA		0x27L
#define OP_SRL		0x26L
#define OP_SLL		0x25L
#define OP_XNORcc	0x17L
#define OP_XNOR		0x07L
#define OP_XORcc 	0x13L
#define OP_XOR		0x03L
#define OP_ORNcc	0x16L
#define OP_ORN		0x06L
#define OP_ORcc 	0x12L
#define OP_OR		0x02L
#define OP_ANDNcc	0x15L
#define OP_ANDN		0x05L
#define OP_ANDcc	0x11L
#define OP_AND		0x01L
#define OP_SUBXcc	0x1CL
#define OP_SUBX		0x0CL
#define OP_SUBcc	0x14L
#define	OP_SUB		0x04L
#define OP_ADDXcc	0x18L
#define OP_ADDX		0x08L
#define OP_ADDcc	0x10L
#define OP_ADD		0x00L
#define OP_STHW		0x06L
#define OP_STUB		0x05L
#define OP_STW		0x04L
#define OP_LDUB		0x01L
#define OP_LDHW		0x02L
#define OP_LDW		0x00L
#define BR_Z		(BRANCH_OP | 0x01)
#define BR_NZ		(BRANCH_OP | 0x09)
#define BR_VS		(BRANCH_OP | 0x07)
#define BR_VC		(BRANCH_OP | 0x0F)
#define BR_NEG		(BRANCH_OP | 0x06)
#define BR_POS		(BRANCH_OP | 0x0E)
#define BR_CS		(BRANCH_OP | 0x05)
#define BR_CC		(BRANCH_OP | 0x0D)
#define BR_LEU		(BRANCH_OP | 0x04)
#define BR_GU		(BRANCH_OP | 0x0C)
#define BR_L		(BRANCH_OP | 0x03)
#define BR_GRE		(BRANCH_OP | 0x0B)
#define BR_LE		(BRANCH_OP | 0x02)
#define BR_GR		(BRANCH_OP | 0x0A)
#define BR_EQ		(BRANCH_OP | 0x01)
#define BR_NEQ		(BRANCH_OP | 0x09)
#define BR_NEVER	(BRANCH_OP | 0x00)
#define BRANCH		(BRANCH_OP | 0x08)
#define SH_RIGHT_ARITH	(NATIVE_OP | 0x27)
#define SH_RIGHT	(NATIVE_OP | 0x26)
#define SH_LEFT		(NATIVE_OP | 0x25)
#define XNORcc		(NATIVE_OP | 0x17)
#define XNOR		(NATIVE_OP | 0x07)
#define XORcc 		(NATIVE_OP | 0x13)
#define XOR		(NATIVE_OP | 0x03)
#define ORNcc		(NATIVE_OP | 0x16)
#define ORN		(NATIVE_OP | 0x06)
#define ORcc 		(NATIVE_OP | 0x12)
#define OR		(NATIVE_OP | 0x02)
#define ANDNcc		(NATIVE_OP | 0x15)
#define ANDN		(NATIVE_OP | 0x05)
#define ANDcc		(NATIVE_OP | 0x11)
#define AND		(NATIVE_OP | 0x01)
#define SUBXcc		(NATIVE_OP | 0x1C)
#define SUBX		(NATIVE_OP | 0x0C)
#define SUBcc		(NATIVE_OP | 0x14)
#define	SUB		(NATIVE_OP | 0x04)
#define ADDXcc		(NATIVE_OP | 0x18)
#define ADDX		(NATIVE_OP | 0x08)
#define ADDcc		(NATIVE_OP | 0x10)
#define ADD		(NATIVE_OP | 0x00)
#define BRN(disp)			(BRANCH_INST(0, 0x0, disp))
#define BRA(disp)			(BRANCH_INST(0, 0x8, disp))
#define BRANCH_INST(annul, cond, disp)	(((annul) << 29) | ((cond) << 25) | (0x800000) | ((disp) & 0x3FFFFF))
 *****************************************************************************/
 * The branch instructions.
/******************************************************************************
#define SETHI(k, rd) 			(FMT2_INST(0x0L, OP_SETHI, k, rd))
#define LOW10(k) 			(((unsigned long) (k)) & 0x3ffL)
#define HI22(k) 			((((unsigned long) (k)) >> 10) & 0x3fffffL)
#define SRL_REG_REG(rs1, rs2, rd) 	(FMT3_INST(0x2L, OP_SRL, rs1, REG_SOURCE, rs2, rd))
#define SRL_REG_IMM(rs1, k, rd) 	(FMT3_INST(0x2L, OP_SRL, rs1, IMMEDIATE, k, rd))
#define SLL_REG_REG(rs1, rs2, rd) 	(FMT3_INST(0x2L, OP_SLL, rs1, REG_SOURCE, rs2, rd))
#define SLL_REG_IMM(rs1, k, rd) 	(FMT3_INST(0x2L, OP_SLL, rs1, IMMEDIATE, k, rd))
#define NOT_REG(r)			(XNOR_REG_REG(r, REG_G0, r))
#define XNOR_REG_REG(rs1, rs2, rd) 	(FMT3_INST(0x2L, OP_XNOR, rs1, REG_SOURCE, rs2, rd))
#define XNOR_REG_IMM(rs1, k, rd) 	(FMT3_INST(0x2L, OP_XNOR, rs1, IMMEDIATE, k, rd))
#define XOR_REG_REG(rs1, rs2, rd) 	(FMT3_INST(0x2L, OP_XOR, rs1, REG_SOURCE, rs2, rd))
#define XOR_REG_IMM(rs1, k, rd) 	(FMT3_INST(0x2L, OP_XOR, rs1, IMMEDIATE, k, rd))
#define OR_REG_REG(rs1, rs2, rd) 	(FMT3_INST(0x2L, OP_OR, rs1, REG_SOURCE, rs2, rd))
#define OR_REG_IMM(rs1, k, rd) 		(FMT3_INST(0x2L, OP_OR, rs1, IMMEDIATE, k, rd))
#define AND_REG_REG(rs1, rs2, rd) 	(FMT3_INST(0x2L, OP_AND, rs1, REG_SOURCE, rs2, rd))
#define AND_REG_IMM(rs1, k, rd) 	(FMT3_INST(0x2L, OP_AND, rs1, IMMEDIATE, k, rd))
#define SUBXcc_REG_REG(rs1, rs2, rd) 	(FMT3_INST(0x2L, OP_SUBXcc, rs1, REG_SOURCE, rs2, rd))
#define SUBXcc_REG_IMM(rs1, k, rd) 	(FMT3_INST(0x2L, OP_SUBXcc, rs1, IMMEDIATE, k, rd))
#define SUBX_REG_REG(rs1, rs2, rd) 	(FMT3_INST(0x2L, OP_SUBX, rs1, REG_SOURCE, rs2, rd))
#define SUBX_REG_IMM(rs1, k, rd) 	(FMT3_INST(0x2L, OP_SUBX, rs1, IMMEDIATE, k, rd))
#define SUBcc_REG_REG(rs1, rs2, rd) 	(FMT3_INST(0x2L, OP_SUBcc, rs1, REG_SOURCE, rs2, rd))
#define SUBcc_REG_IMM(rs1, k, rd) 	(FMT3_INST(0x2L, OP_SUBcc, rs1, IMMEDIATE, k, rd))
#define SUB_REG_REG(rs1, rs2, rd) 	(FMT3_INST(0x2L, OP_SUB, rs1, REG_SOURCE, rs2, rd))
#define SUB_REG_IMM(rs1, k, rd) 	(FMT3_INST(0x2L, OP_SUB, rs1, IMMEDIATE, k, rd))
#define ADDXcc_REG_REG(rs1, rs2, rd) 	(FMT3_INST(0x2L, OP_ADDXcc, rs1, REG_SOURCE, rs2, rd))
#define ADDXcc_REG_IMM(rs1, k, rd) 	(FMT3_INST(0x2L, OP_ADDXcc, rs1, IMMEDIATE, k, rd))
#define ADDX_REG_REG(rs1, rs2, rd) 	(FMT3_INST(0x2L, OP_ADDX, rs1, REG_SOURCE, rs2, rd))
#define ADDX_REG_IMM(rs1, k, rd) 	(FMT3_INST(0x2L, OP_ADDX, rs1, IMMEDIATE, k, rd))
#define ADDcc_REG_REG(rs1, rs2, rd) 	(FMT3_INST(0x2L, OP_ADDcc, rs1, REG_SOURCE, rs2, rd))
#define ADDcc_REG_IMM(rs1, k, rd) 	(FMT3_INST(0x2L, OP_ADDcc, rs1, IMMEDIATE, k, rd))
#define ADD_REG_REG(rs1, rs2, rd) 	(FMT3_INST(0x2L, OP_ADD, rs1, REG_SOURCE, rs2, rd))
#define ADD_REG_IMM(rs1, k, rd) 	(FMT3_INST(0x2L, OP_ADD, rs1, IMMEDIATE, k, rd))
#define STUB_REG_REG(rs1, rs2, rd) 	(FMT3_INST(0x3L, OP_STUB, rs1, REG_SOURCE, rs2, rd))
#define STUB_REG_IMM(rs1, k, rd) 	(FMT3_INST(0x3L, OP_STUB, rs1, IMMEDIATE, k, rd))
#define STHW_REG_REG(rs1, rs2, rd) 	(FMT3_INST(0x3L, OP_STHW, rs1, REG_SOURCE, rs2, rd))
#define STHW_REG_IMM(rs1, k, rd) 	(FMT3_INST(0x3L, OP_STHW, rs1, IMMEDIATE, k, rd))
#define STW_REG_REG(rs1, rs2, rd) 	(FMT3_INST(0x3L, OP_STW, rs1, REG_SOURCE, rs2, rd))
#define STW_REG_IMM(rs1, k, rd) 	(FMT3_INST(0x3L, OP_STW, rs1, IMMEDIATE, k, rd))
#define LDUB_REG_REG(rs1, rs2, rd) 	(FMT3_INST(0x3L, OP_LDUB, rs1, REG_SOURCE, rs2, rd))
#define LDUB_REG_IMM(rs1, k, rd) 	(FMT3_INST(0x3L, OP_LDUB, rs1, IMMEDIATE, k, rd))
                   */
/*****************************************************************************/
LONG32 Cam8SimCore::AddSiteAddress(LONG32 lSrc1, LONG32 lSrc2)
  LONG32 lHighBits1, lHighBits2;
  lHighBits1 = lSrc1 & DCM[0];
  lHighBits2 = lSrc2 & DCM[0];
  lSrc1 &= (~DCM[0]);
  lSrc2 &= (~DCM[0]);
  return( (lSrc1 + lSrc2) ^ lHighBits1 ^ lHighBits2 );
LONG32 Cam8SimCore::SubSiteAddress(LONG32 lSrc1, LONG32 lSrc2)
  LONG32 lSignBitOffset, lSignBitKick, lLowBitsKick;
  lSignBitOffset = lSrc1 & DCM[0];
  lSignBitKick = (~lSrc2) & DCM[0];
  lSrc1 |= DCM[0];
  lLowBitsKick = lSrc2 & (~ DCM[0]);
  lSrc1 -= lLowBitsKick;
  lSignBitOffset = lSignBitOffset ^ lSignBitKick;
  lSrc1 ^= lSignBitOffset;
/*****************************************************************************/
/*                                                                           */
/* Compute the Scan length - the number of sites that will be updated in     */
/* the current scan. Basically, it should be 2^ESCP, but we need to correct  */
/* for the fact that the SIR low-order bits might not be all zero            */
/*                                                                           */
/*****************************************************************************/
LONG32 Cam8SimCore::ScanLength(void)
  LONG32 lCarryOVFBit, lScanLength, lSIRBits;
  lCarryOVFBit = ESC[0];
  lScanLength = (1 << lCarryOVFBit);                                  
  lSIRBits = SIR[0] & (lScanLength - 1);
  lScanLength -= lSIRBits;
  return (lScanLength);
/*****************************************************************************/
/*                                                                           */
/* Determine the sweep length. The sweep length is given by either the low   */
/* bit of the DCMR or the ESCP (End-of-Scan-pointer) or the SFR register.    */
/* This is because the scan could update many lines of the lowest (X) dimen- */
/* sion, or could update just part of 1 line in the X dimension.             */
/*                                                                           */
/*****************************************************************************/
LONG32 Cam8SimCore::SweepLength(LONG32 *lFirstSweep)
  LONG32 lCarryOVFBit, lSweepLength;
  lCarryOVFBit = MIN(ESW[0], lNumXBits);
  lSweepLength = (1 << lCarryOVFBit);
  *lFirstSweep = (SIR[0] & (lSweepLength - 1));
  *lFirstSweep = lSweepLength - *lFirstSweep;
  return (lSweepLength);
/*****************************************************************************/
/*                                                                           */
/* DCMRHighBit returns a long with exactly one of the 32 bits set to 1. This */
/* bit position corresponds to the highest bit in the DCMR that has a 1.     */
/*                                                                           */
/*****************************************************************************/
LONG32 Cam8SimCore::DCMRHighBit(void)
  LONG32 lTemp1, lTemp2;                                                      
  lTemp1 = DCM[0];
  lTemp2 = 1;
  while (lTemp1 > 1) {
    lTemp1 >>= 1;
    lTemp2 <<= 1;
  return (lTemp2);
/*****************************************************************************/
/*                                                                           */
/* DCMRLowBit returns a long with exactly one of the 32 bits set to 1. This  */
/* bit position corresponds to the lowest bit in the DCMR that has a 1. We   */
/* refer to this lowest dimension generically as the X dimension.            */
/*                                                                           */
/*****************************************************************************/
LONG32 Cam8SimCore::DCMRLowBit(void)
  LONG32 lTemp1, lTemp2;
  lTemp1 = DCM[0];
  lTemp2 = 1;
  lNumXBits = 1;
  while ((lTemp1 != 0) && ((lTemp1 & 0x01) == 0)) {
    lTemp1 >>= 1;
    lTemp2 <<= 1;
    lNumXBits++;
  return (lTemp2);
void Cam8SimCore::UpdateDCMR(void)
  lDCMRHighBit = DCMRHighBit();
  lDCMRLowBit = DCMRLowBit();
/*****************************************************************************/
/*                                                                           */
/* The following are general purpose routines that conveniently answer       */
/* queries about the sources and destinations that need to be updated        */
/*                                                                           */
/*****************************************************************************/
/*****************************************************************************/
/*                                                                           */
/* Is a particular source needed? Only checks those planes that will be      */
/* updated or used during the next scan.                                     */
/*                                                                           */
/*****************************************************************************/
BOOL Cam8SimCore::IsSrcNeeded(short nSrc)
  short i, j;
  short nLastDest;
  nLastDest = (nSrc == SRC_TBUS ? DEST_LUT : DEST_DISPLAY);
  for (i = nNumPlanes - 1; i >= 0; i--) {
    for (j = DEST_SITE_DATA; j <= nLastDest; j++) {
      if (bDestSrcMatrix[i][j][nSrc]) {
	return TRUE;
      }
    }
  return FALSE;
/*****************************************************************************/
/*                                                                           */
/* Checks to see if the source/map is the same for all planes for the given  */
/* destination.                                                              */
/*                                                                           */
/*****************************************************************************/
BOOL Cam8SimCore::IsSrcSame(short nDest)
  short i;
  BYTE *src, *map;
  switch (nDest) {
  case DEST_SITE_DATA:
    src = SDS;
    map = SDM;
    break;
  case DEST_EVENT_CT:
    src = ECS;
    map = ECM;
    break;
  case DEST_DISPLAY:
    src = DDS;
    map = DDM;
    break;
  case DEST_LUT:
    src = LAS;
    map = LAM;
    break;
  default:
    return FALSE;
    break;
  for(i = 1; i < nNumPlanes; i++)
    if ((src[0] != src[i]) || (map[0] != map[i]))
      return FALSE;
  return TRUE;
/*****************************************************************************/
/*                                                                           */
/* See if a particular destination will be changed during the current scan   */
/*                                                                           */
/*****************************************************************************/
BOOL Cam8SimCore::IsDestUpdated(short nDest)
  short i, j;
  for (i = nNumPlanes-1; i >= 0; i--)
    for ( j = SRC_SITE_DATA; j <= SRC_CONST_DATA; j++)
      if (bDestSrcMatrix[i][nDest][j])
	return(TRUE);
  return(FALSE);
/*****************************************************************************/
/*                                                                           */
/* Calculate the number of planes that will be updated or used in the next   */
/* scan.                                                                     */
/*                                                                           */
/*****************************************************************************/
unsigned short Cam8SimCore::CalcNumPlanes(void)
  BOOL       bPlaneUsed[CHIPS_PER_MOD];
  short      i, j;
  memset ((char *) bPlaneUsed, 0, CHIPS_PER_MOD * sizeof(BOOL));
  UpdateDestSrcMatrix();
  for (i = CHIPS_PER_MOD-1; i >= 0; i--) {
    for (j = DEST_SITE_DATA; j <= DEST_DISPLAY; j++) {
      if ( bDestSrcMatrix[i][j][SRC_SITE_DATA] || 
	  bDestSrcMatrix[i][j][SRC_GLUED_DATA] ) {
	bPlaneUsed[i] = TRUE;
      }
    }
    
    if (!bPlaneUsed[i]) {
      for (j = SRC_TBUS; j <= SRC_CONST_DATA; j++) {
	if (bDestSrcMatrix[i][DEST_SITE_DATA][j]) {
	  bPlaneUsed[i] = TRUE;
      }
    }
    if (bPlaneUsed[i])

---------------------------------------------------------------------------

  }  
  return ((unsigned short) i + 1);
/*****************************************************************************/
/*                                                                           */
/* Updates a matrix of sources and destinations. There are 5 sources, 4 dest */
/* and 16 planes. In addition, there is a bit per destination indicating     */
/* whether the map field selects an inverse function or just the function.   */
/* Thus, the SrcDestMatrix is a 6x4x16 matrix.                               */
/*                                                                           */
/*****************************************************************************/
void Cam8SimCore::UpdateDestSrcMatrix(void)
  short      i;
  char       *szFuncName = "UpdateDestSrcMatrix";    
  memset((char *) bDestSrcMatrix, 0, CHIPS_PER_MOD*NUM_SRC*NUM_DEST);
  for (i = 0; i < CHIPS_PER_MOD; i++) {
    
    /*
     * If the source for the site is the site then don't bother to generate
     * code for this.  If the map selects only the glue lines then the source
     * selection is irrelevant.  If the map selects MAP_G then this is
     * effectively the same as selecting site as the source.  If the map
     * selects CONST_0 or CONST_1 then we handle this as a special case.
     */
    if (SDS[i] != SRC_SITE_DATA)
      bDestSrcMatrix[i][DEST_SITE_DATA][SDS[i]] = TRUE;
    if ((SDM[i] != MAP_S) && (SDM[i] != MAP_S_BAR)) {
      if (SDM[i] != MAP_G)
	bDestSrcMatrix[i][DEST_SITE_DATA][SRC_GLUED_DATA] = TRUE;
      if ((SDM[i] == MAP_CONST_0) || (SDM[i] == MAP_CONST_1)) {
	bDestSrcMatrix[i][DEST_SITE_DATA][SRC_CONST_DATA] = TRUE;
	bDestSrcMatrix[i][DEST_SITE_DATA][SRC_GLUED_DATA] = FALSE;
	bDestSrcMatrix[i][DEST_SITE_DATA][SDS[i]] = FALSE;
      }
      if ((SDM[i] == MAP_G) || (SDM[i] == MAP_G_BAR))
	bDestSrcMatrix[i][DEST_SITE_DATA][SDS[i]] = FALSE;
    }
    /*
     * If the source for the event counter is constant zero then don't bother
     * to generate code for this.  If the map selects only the glue lines then
     * the source selection is irrelevant.
     */
    bDestSrcMatrix[i][DEST_EVENT_CT][ECS[i]] = TRUE;
    if ((ECM[i] != MAP_S) && (ECM[i] != MAP_S_BAR)) {
      bDestSrcMatrix[i][DEST_EVENT_CT][SRC_GLUED_DATA] = TRUE;
      if ((ECM[i] == MAP_CONST_0) || (ECM[i] == MAP_CONST_1)) {
	if (ECM[i] == MAP_CONST_1)
	  bDestSrcMatrix[i][DEST_EVENT_CT][SRC_CONST_DATA] = TRUE;
	bDestSrcMatrix[i][DEST_EVENT_CT][SRC_GLUED_DATA] = FALSE;
	bDestSrcMatrix[i][DEST_EVENT_CT][ECS[i]] = FALSE;
      }
      if ((ECM[i] == MAP_G) || (ECM[i] == MAP_G_BAR))
 	bDestSrcMatrix[i][DEST_EVENT_CT][ECS[i]] = FALSE;
    }
    /*
     * If the source for the display is the host (tbus) then don't bother to
     * generate code for this.  If the map selects only the glue lines then
     * the source selection is irrelevant.
     */
    if ((DDS[i] != SRC_TBUS))
      bDestSrcMatrix[i][DEST_DISPLAY][DDS[i]] = TRUE;
    if ((DDM[i] != MAP_S) && (DDM[i] != MAP_S_BAR)) {
      bDestSrcMatrix[i][DEST_DISPLAY][SRC_GLUED_DATA] = TRUE;
      if ((DDM[i] == MAP_CONST_0) || (DDM[i] == MAP_CONST_1)) {
	bDestSrcMatrix[i][DEST_DISPLAY][SRC_CONST_DATA] = TRUE;
	bDestSrcMatrix[i][DEST_DISPLAY][SRC_GLUED_DATA] = FALSE;
	bDestSrcMatrix[i][DEST_DISPLAY][DDS[i]] = FALSE;
      }
      if ((DDM[i] == MAP_G) || (DDM[i] == MAP_G_BAR)) {
	bDestSrcMatrix[i][DEST_DISPLAY][DDS[i]] = FALSE;
      }
    }
    /*
     * If the map selects only the glue lines then the source selection is
     * irrelevant.
     */
    bDestSrcMatrix[i][DEST_LUT][LAS[i]] = TRUE;
    if ((LAM[i] != MAP_S) && (LAM[i] != MAP_S_BAR)) {
      bDestSrcMatrix[i][DEST_LUT][SRC_GLUED_DATA] = TRUE;
      if ((LAM[i] == MAP_CONST_0) || (LAM[i] == MAP_CONST_1)) {
	bDestSrcMatrix[i][DEST_LUT][SRC_CONST_DATA] = TRUE;
	bDestSrcMatrix[i][DEST_LUT][SRC_GLUED_DATA] = FALSE;
	bDestSrcMatrix[i][DEST_LUT][LAS[i]] = FALSE;
      }
      if ((LAM[i] == MAP_G) || (LAM[i] == MAP_G_BAR)) {
	bDestSrcMatrix[i][DEST_LUT][LAS[i]] = FALSE;
      }
    }
/* Unpack register of length < 32 bits or register field */
void Cam8SimCore::UnpackState(INT16 *base, int reg_fld, int imm)
  if (BITLEN(reg_fld) > 32) {
    WARNING("Can't unpack a register or field of len > 32", "UnpackState");
    UnpackBits(base, BITOFF(reg_fld), 32, imm, base_type[reg_fld].base,
	       base_type[reg_fld].type);
  else
    UnpackBits(base, BITOFF(reg_fld), BITLEN(reg_fld), imm,
	       base_type[reg_fld].base, base_type[reg_fld].type);
void Cam8SimCore::UnpackStateInto(INT16 *base, int reg_fld, int imm, BYTE *dest, int type)
  if (BITLEN(reg_fld) > 32) {
    WARNING("Can't unpack a register or field of len > 32", "UnpackStateInto");
    UnpackBits(base, BITOFF(reg_fld), 32, imm, dest, type);
  else
    UnpackBits(base, BITOFF(reg_fld), BITLEN(reg_fld), imm, dest, type);
/* Pack register of length < 32 bits or register field */
void Cam8SimCore::PackState(INT16 *base, int reg_fld)
  if (BITLEN(reg_fld) > 32) {
    WARNING("Can't pack a register or field of len > 32", "PackState");
    PackBits(base, BITOFF(reg_fld), 32, base_type[reg_fld].base,
	     base_type[reg_fld].type);
  else
    PackBits(base, BITOFF(reg_fld), BITLEN(reg_fld),
	     base_type[reg_fld].base, base_type[reg_fld].type);
void Cam8SimCore::PackStateFrom(INT16 *base, int reg_fld, BYTE *src, int type)
  if (BITLEN(reg_fld) > 32) {
    WARNING("Can't pack a register or field of len > 32", "PackStateFrom");
    PackBits(base, BITOFF(reg_fld), 32, src, type);
  else
    PackBits(base, BITOFF(reg_fld), BITLEN(reg_fld), src, type);
***********************************************************/
/*                                                                           */
/* This routine adds two longs breaking the carries at positions indicated   */
/* by the Dimension Cut Mask Register (DCMR). The DCMR has a 1 bit at every  */
/* bit position where the carry needs to be cut.                             */
/*                                                                           */
/*****************************************************************************/
LONG32 AddSiteAddress(LONG32 lSrc1, LONG32 lSrc2)
  LONG32 lHighBits1, lHighBits2;
  lHighBits1 = lSrc1 & DCM[0];
  lHighBits2 = lSrc2 & DCM[0];
  lSrc1 &= (~DCM[0]);
  lSrc2 &= (~DCM[0]);
  return( (lSrc1 + lSrc2) ^ lHighBits1 ^ lHighBits2 );
LONG32 SubSiteAddress(LONG32 lSrc1, LONG32 lSrc2)
  LONG32 lSignBitOffset, lSignBitKick, lLowBitsKick;
  lSignBitOffset = lSrc1 & DCM[0];
  lSignBitKick = (~lSrc2) & DCM[0];
  lSrc1 |= DCM[0];
  lLowBitsKick = lSrc2 & (~ DCM[0]);
  lSrc1 -= lLowBitsKick;
  lSignBitOffset = lSignBitOffset ^ lSignBitKick;
  lSrc1 ^= lSignBitOffset;
/*****************************************************************************/
/*                                                                           */
/* Compute the Scan length - the number of sites that will be updated in     */
/* the current scan. Basically, it should be 2^ESCP, but we need to correct  */
/* for the fact that the SIR low-order bits might not be all zero            */
/*                                                                           */
/*****************************************************************************/
LONG32 ScanLength()
  LONG32 lCarryOVFBit, lScanLength, lSIRBits;
  lCarryOVFBit = ESC[0];
  lScanLength = (1 << lCarryOVFBit);                                  
  lSIRBits = SIR[0] & (lScanLength - 1);
  lScanLength -= lSIRBits;
  return (lScanLength);
/*****************************************************************************/
/*                                                                           */
/* Determine the sweep length. The sweep length is given by either the low   */
/* bit of the DCMR or the ESCP (End-of-Scan-pointer) or the SFR register.    */
/* This is because the scan could update many lines of the lowest (X) dimen- */
/* sion, or could update just part of 1 line in the X dimension.             */
/*                                                                           */
/*****************************************************************************/
LONG32 SweepLength(LONG32 *lFirstSweep)
  LONG32 lCarryOVFBit, lSweepLength;
  lCarryOVFBit = MIN(ESW[0], lNumXBits);
  lSweepLength = (1 << lCarryOVFBit);
  *lFirstSweep = (SIR[0] & (lSweepLength - 1));
  *lFirstSweep = lSweepLength - *lFirstSweep;
  return (lSweepLength);
/*****************************************************************************/
/*                                                                           */
/* DCMRHighBit returns a long with exactly one of the 32 bits set to 1. This */
/* bit position corresponds to the highest bit in the DCMR that has a 1.     */
/*                                                                           */
/*****************************************************************************/
LONG32 DCMRHighBit()
  LONG32 lTemp1, lTemp2;                                                      
  lTemp1 = DCM[0];
  lTemp2 = 1;
  while (lTemp1 > 1) {
    lTemp1 >>= 1;
    lTemp2 <<= 1;
  return (lTemp2);
/*****************************************************************************/
/*                                                                           */
/* DCMRLowBit returns a long with exactly one of the 32 bits set to 1. This  */
/* bit position corresponds to the lowest bit in the DCMR that has a 1. We   */
/* refer to this lowest dimension generically as the X dimension.            */
/*                                                                           */
/**********

---------------------------------------------------------------------------

*******************************************************************/
LONG32 DCMRLowBit()
  LONG32 lTemp1, lTemp2;
  lTemp1 = DCM[0];
  lTemp2 = 1;
  lNumXBits = 1;
  while ((lTemp1 != 0) && ((lTemp1 & 0x01) == 0)) {
    lTemp1 >>= 1;
    lTemp2 <<= 1;
    lNumXBits++;
  return (lTemp2);
void UpdateDCMR()
  lDCMRHighBit = DCMRHighBit();
  lDCMRLowBit = DCMRLowBit();
/*****************************************************************************/
/*                                                                           */
/* The following are general purpose routines that conveniently answer       */
/* queries about the sources and destinations that need to be updated        */
/*                                                                           */
/*****************************************************************************/
/*****************************************************************************/
/*                                                                           */
/* Is a particular source needed? Only checks those planes that will be      */
/* updated or used during the next scan.                                     */
/*                                                                           */
/*****************************************************************************/
BOOL IsSrcNeeded(short nSrc)
  short i, j;
  short nLastDest;
  nLastDest = (nSrc == SRC_TBUS ? DEST_LUT : DEST_DISPLAY);
  for (i = nNumPlanes - 1; i >= 0; i--) {
    for (j = DEST_SITE_DATA; j <= nLastDest; j++) {
      if (bDestSrcMatrix[i][j][nSrc]) {
	return TRUE;
      }
    }
  return FALSE;
/*****************************************************************************/
/*                                                                           */
/* Checks to see if the source/map is the same for all planes for the given  */
/* destination.                                                              */
/*                                                                           */
/*****************************************************************************/
BOOL IsSrcSame(short nDest)
  short i;
  BYTE *src, *map;
  switch (nDest) {
  case DEST_SITE_DATA:
    src = SDS;
    map = SDM;
    break;
  case DEST_EVENT_CT:
    src = ECS;
    map = ECM;
    break;
  case DEST_DISPLAY:
    src = DDS;
    map = DDM;
    break;
  case DEST_LUT:
    src = LAS;
    map = LAM;
    break;
  default:
    return FALSE;
    break;
  for(i = 1; i < nNumPlanes; i++)
    if ((src[0] != src[i]) || (map[0] != map[i]))
      return FALSE;
  return TRUE;
/*****************************************************************************/
/*                                                                           */
/* See if a particular destination will be changed during the current scan   */
/*                                                                           */
/*****************************************************************************/
BOOL IsDestUpdated(short nDest)
  short i, j;
  for (i = nNumPlanes-1; i >= 0; i--)
    for ( j = SRC_SITE_DATA; j <= SRC_CONST_DATA; j++)
      if (bDestSrcMatrix[i][nDest][j])
	return(TRUE);
  return(FALSE);
/*****************************************************************************/
/*                                                                           */
/* Calculate the number of planes that will be updated or used in the next   */
/* scan.                                                                     */
/*                                                                           */
/*****************************************************************************/
unsigned short CalcNumPlanes()
  BOOL       bPlaneUsed[CHIPS_PER_MOD];
  short      i, j;
  memset ((char *) bPlaneUsed, 0, CHIPS_PER_MOD * sizeof(BOOL));
  UpdateDestSrcMatrix();
  for (i = CHIPS_PER_MOD-1; i >= 0; i--) {
    for (j = DEST_SITE_DATA; j <= DEST_DISPLAY; j++) {
      if ( bDestSrcMatrix[i][j][SRC_SITE_DATA] || 
	  bDestSrcMatrix[i][j][SRC_GLUED_DATA] ) {
	bPlaneUsed[i] = TRUE;
      }
    }
    
    if (!bPlaneUsed[i]) {
      for (j = SRC_TBUS; j <= SRC_CONST_DATA; j++) {
	if (bDestSrcMatrix[i][DEST_SITE_DATA][j]) {
	  bPlaneUsed[i] = TRUE;
      }
    }
    if (bPlaneUsed[i])
      break;
  }  
  return ((unsigned short) i + 1);
/*****************************************************************************/
/*                                                                           */
/* Updates a matrix of sources and destinations. There are 5 sources, 4 dest */
/* and 16 planes. In addition, there is a bit per destination indicating     */
/* whether the map field selects an inverse function or just the function.   */
/* Thus, the SrcDestMatrix is a 6x4x16 matrix.                               */
/*                                                                           */
/*****************************************************************************/
void UpdateDestSrcMatrix()
  short      i;
  char       *szFuncName = "UpdateDestSrcMatrix";    
  memset((char *) bDestSrcMatrix, 0, CHIPS_PER_MOD*NUM_SRC*NUM_DEST);
  for (i = 0; i < CHIPS_PER_MOD; i++) {
    
    /*
     * If the source for the site is the site then don't bother to generate
     * code for this.  If the map selects only the glue lines then the source
     * selection is irrelevant.  If the map selects MAP_G then this is
     * effectively the same as selecting site as the source.  If the map
     * selects CONST_0 or CONST_1 then we handle this as a special case.
     */
    if (SDS[i] != SRC_SITE_DATA)
      bDestSrcMatrix[i][DEST_SITE_DATA][SDS[i]] = TRUE;
    if ((SDM[i] != MAP_S) && (SDM[i] != MAP_S_BAR)) {
      if (SDM[i] != MAP_G)
	bDestSrcMatrix[i][DEST_SITE_DATA][SRC_GLUED_DATA] = TRUE;
      if ((SDM[i] == MAP_CONST_0) || (SDM[i] == MAP_CONST_1)) {
	bDestSrcMatrix[i][DEST_SITE_DATA][SRC_CONST_DATA] = TRUE;
	bDestSrcMatrix[i][DEST_SITE_DATA][SRC_GLUED_DATA] = FALSE;
	bDestSrcMatrix[i][DEST_SITE_DATA][SDS[i]] = FALSE;
      }
      if ((SDM[i] == MAP_G) || (SDM[i] == MAP_G_BAR))
	bDestSrcMatrix[i][DEST_SITE_DATA][SDS[i]] = FALSE;
    }
    /*
     * If the source for the event counter is constant zero then don't bother
     * to generate code for this.  If the map selects only the glue lines then
     * the source selection is irrelevant.
     */
    bDestSrcMatrix[i][DEST_EVENT_CT][ECS[i]] = TRUE;
    if ((ECM[i] != MAP_S) && (ECM[i] != MAP_S_BAR)) {
      bDestSrcMatrix[i][DEST_EVENT_CT][SRC_GLUED_DATA] = TRUE;
      if ((ECM[i] == MAP_CONST_0) || (ECM[i] == MAP_CONST_1)) {
	if (ECM[i] == MAP_CONST_1)
	  bDestSrcMatrix[i][DEST_EVENT_CT][SRC_CONST_DATA] = TRUE;
	bDestSrcMatrix[i][DEST_EVENT_CT][SRC_GLUED_DATA] = FALSE;
	bDestSrcMatrix[i][DEST_EVENT_CT][ECS[i]] = FALSE;
      }
      if ((ECM[i] == MAP_G) || (ECM[i] == MAP_G_BAR))
 	bDestSrcMatrix[i][DEST_EVENT_CT][ECS[i]] = FALSE;
    }
    /*
     * If the source for the display is the host (tbus) then don't bother to
     * generate code for this.  If the map selects only the glue lines then
     * the source selection is irrelevant.
     */
    if ((DDS[i] != SRC_TBUS))
      bDestSrcMatrix[i][DEST_DISPLAY][DDS[i]] = TRUE;
    if ((DDM[i] != MAP_S) && (DDM[i] != MAP_S_BAR)) {
      bDestSrcMatrix[i][DEST_DISPLAY][SRC_GLUED_DATA] = TRUE;
      if ((DDM[i] == MAP_CONST_0) || (DDM[i] == MAP_CONST_1)) {
	bDestSrcMatrix[i][DEST_DISPLAY][SRC_CONST_DATA] = TRUE;
	bDestSrcMatrix[i][DEST_DISPLAY][SRC_GLUED_DATA] = FALSE;
	bDestSrcMatrix[i][DEST_DISPLAY][DDS[i]] = FALSE;
      }
      if ((DDM[i] == MAP_G) || (DDM[i] == MAP_G_BAR)) {
	bDestSrcMatrix[i][DEST_DISPLAY][DDS[i]] = FALSE;
      }
    }
    /*
     * If the map selects only the glue lines then the source selection is
     * irrelevant.
     */
    bDestSrcMatrix[i][DEST_LUT][LAS[i]] = TRUE;
    if ((LAM[i] != MAP_S) && (LAM[i] != MAP_S_BAR)) {
      bDestSrcMatrix[i][DEST_LUT][SRC_GLUED_DATA] = TRUE;
      if ((LAM[i] == MAP_CONST_0) || (LAM[i] == MAP_CONST_1)) {
	bDestSrcMatrix[i][DEST_LUT][SRC_CONST_DATA] = TRUE;
	bDestSrcMatrix[i][DEST_LUT][SRC_GLUED_DATA] = FALSE;
	bDestSrcMatrix[i][DEST_LUT][LAS[i]] = FALSE;
      }
      if ((LAM[i] == MAP_G) || (LAM[i] == MAP_G_BAR)) {
	bDestSrcMatrix[i][DEST_LUT][LAS[i]] = FALSE;
      }
    }
/* Unpack register of length < 32 bits or register field */
void Cam8SimCore::UnpackState(INT16 *base, int reg_fld, int imm)
  if (BITLEN(reg_fld) > 32) {
    WARNING("Can't unpack a register or field of len > 32", "UnpackState");
    UnpackBits(base, BITOFF(reg_fld), 32, imm, base_type[reg_fld].base,
	       base_type[reg_fld].type);
  else
    UnpackBits(base, BITOFF(reg_fld), BITLEN(reg_fld), imm,
	       base_type[reg_fld].base, base_type[reg_fld].type);
void Cam8SimCore::UnpackStateInto(INT16 *base, int reg_fld, int imm, BYTE *dest, int type)
  if (BITLEN(reg_fld) > 32) {
    WARNING("Can't unpack a register or field of len > 32", "UnpackStateInto");
    UnpackBits(base, BITOFF(reg_fld), 32, imm, dest, type);
  else
    UnpackBits(base, BITOFF(reg_fld), BITLEN(reg_fld), imm, dest, type);
/* Pack register of length < 32 bits or register field */
void Cam8SimCore::PackState(INT16 *base, int reg_fld)
  if (BITLEN(reg_fld) > 32) {
    WARNING("Can't pack a register or field of len > 32", "PackState");
    PackBits(base, BITOFF(reg_fld), 32, base_type[reg_fld].base,
	     base_type[reg_fld].type);
  else
    PackBits(base, BITOFF(reg_fld), BITLEN(reg_fld),
	     base_type[reg_fld].base, base_type[reg_fld].type);
void Cam8SimCore::PackStateFrom(INT16 *base, int reg_fld, BYTE *src, int type)
  if (BITLEN(reg_fld) > 32) {
    WARNING("Can't pack a register or field of len > 32", "PackStateFrom");
    PackBits(base, BITOFF(reg_fld), 32, src, type);
  else
    PackBits(base, BITOFF(reg_fld), BITLEN(reg_fld), src, type);
[i][DEST_EVENT_CT][ECS[i]] = TRUE;
    if ((ECM[i] != MAP_S) && (ECM[i] != MAP_S_BAR)) {
      bDestSrcMatrix[i][DEST_EVENT_CT][SRC_GLUED_DATA] = TRUE;
      if ((ECM[i] == MAP_CONST_0) || (ECM[i] == MAP_CONST_1)) {
	if (ECM[i] == MAP_CONST_1)
	  bDestSrcMatrix[i][DEST_EVENT_CT][SRC_CONST_DATA] = TRUE;
	bDestSrcMatrix[i][DEST_EVENT_CT][SRC_GLUED_DATA] = FALSE;
	bDestSrcMatrix[i][DEST_EVENT_CT][ECS[i]] = FALSE;
      }
      if ((ECM[i] == MAP_G) || (ECM[i] == MAP_G_BAR))
 	bDestSrcMatrix[i][DEST_EVENT_CT][ECS[i]] = FALSE;
    }
    /*
     * If the source for the display is the host (tbus) then don't bother to
     * generate code for this.  If the map selects only the glue lines then
     * the source selection is irrelevant.
     */
    if ((DDS[i] != SRC_TBUS))
      bDestSrcMatrix[i][DEST_DISPLAY][DDS[i]] = TRUE;
    if ((DDM[i] != MAP_S) && (DDM[i] != MAP_S_BAR)) {
      bDestSrcMatrix[i][DEST_DISPLAY][SRC_GLUED_DATA] = TRUE;
      if ((DDM[i] == MAP_CONST_0) || (DDM[i] == MAP_CONST_1)) {
	bDestSrcMatrix[i][DEST_DISPLAY][SRC_CONST_DATA] = TRUE;
	bDestSrcMatrix[i][DEST_DISPLAY][SRC_GLUED_DATA] = FALSE;
	bDestSrcMatrix[i][DEST_DISPLAY][DDS[i]] = FALSE;
      }
      if ((DDM[i] == MAP_G) || (DDM[i] == MAP_G_BAR)) {
	bDestSrcMatrix[i][DEST_DISPLAY][DDS[i]] = FALSE;
      }
    }
    /*
     * If the map selects only the glue lines then the source selection is
     * irrelevant.
     */
    bDestSrcMatrix[i][DEST_LUT][LAS[i]] = TRUE;
    if ((LAM[i] != MAP_S) && (LAM[i] != MAP_S_BAR)) {
      bDestSrcMatrix[i][DEST_LUT][SRC_GLUED_DATA] = TRUE;
      if ((LAM[i] == MAP_CONST_0) || (LAM[i] == MAP_CONST_1)) {
	bDestSrcMatrix[i][DEST_LUT][SRC_CONST_DATA] = TRUE;
	bDestSrcMatrix[i][DEST_LUT][SRC_GLUED_DATA] = FALSE;
	bDestSrcMatrix[i][DEST_LUT][LAS[i]] = FALSE;
      }
      if ((LAM[i] == MAP_G) || (LAM[i] == MAP_G_BAR)) {
	bDestSrcMatrix[i][DEST_LUT][LAS[i]] = FALSE;
      }
    }
/* Unpack register of length < 32 bits or register field */
void Cam8SimCore::UnpackState(INT16 *base, int reg_fld, int imm)
  if (BITLEN(reg_fld) > 32) {
    WARNING("Can't unpack a register or field of len > 32", "UnpackState");
    UnpackBits(base, BITOFF(reg_fld), 32, imm, base_type[reg_fld].base,
	       base_type[reg_fld].type);
  else
    UnpackBits(base, BITOFF(reg_fld), BITLEN(reg_fld), imm,
	       base_type[reg_fld].base, base_type[reg_fld].type);
void Cam8SimCore::UnpackStateInto(INT16 *base, int reg_fld, int imm, BYTE *dest, int type)
  if (BITLEN(reg_fld) > 32) {
    WARNING("Can't unpack a register or field of len > 32", "UnpackStateInto");
    UnpackBits(base, BITOFF(reg_fld), 32, imm, dest, type);
  else
    UnpackBits(base, BITOFF(reg_fld), BITLEN(reg_fld), imm, dest, type);
/* Pack register of length < 32 bits or register field */
void Cam8SimCore::PackState(INT16 *base, int reg_fld)
  if (BITLEN(reg_fld) > 32) {
    WARNING("Can't pack a register or field of len > 32", "PackState");
    PackBits(base, BITOFF(reg_fld), 32, base_type[reg_fld].base,
	     base_type[reg_fld].type);
  else
    PackBits(base, BITOFF(reg_fld), BITLEN(reg_fld),
	     base_type[reg_fld].base, base_type[reg_fld].type);
void Cam8SimCore::PackStateFrom(INT16 *base, int reg_fld, BYTE *src, int type)
  if (BITLEN(reg_fld) > 32) {
    WARNING("Can't pack a register or field of len > 32", "PackStateFrom");
    PackBits(base, BITOFF(reg_fld), 32, src, type);
  else
    PackBits(base, BITOFF(reg_fld), BITLEN(reg_fld), src, type);
         */
/*****************************************************************************/
LONG32 AddSiteAddress(LONG32 lSrc1, LONG32 lSrc2)
  LONG32 lHighBits1, lHighBits2;
  lHighBits1 = lSrc1 & DCM[0];
  lHighBits2 = lSrc2 & DCM[0];
  lSrc1 &= (~DCM[0]);
  lSrc2 &= (~DCM[0]);
  return( (lSrc1 + lSrc2) ^ lHighBits1 ^ lHighBits2 );
LONG32 SubSiteAddress(LONG32 lSrc1, LONG32 lSrc2)
  LONG32 lSignBitOffset, lSignBitKick, lLowBitsKick;
  lSignBitOffset = lSrc1 & DCM[0];
  lSignBitKick = (~lSrc2) & DCM[0];
  lSrc1 |= DCM[0];
  lLowBitsKick = lSrc2 & (~ DCM[0]);
  lSrc1 -= lLowBitsKick;
  lSignBitOffset = lSignBitOffset ^ lSignBitKick;
  lSrc1 ^= lSignBitOffset;
/*****************************************************************************/
/*                                                                           */
/* Compute the Scan length - the number of sites that will be updated in     */
/* the current scan. Basically, it should be 2^ESCP, but we need to correct  */
/* for the fact that the SIR low-order bits might not be all zero            */
/*                                                                           */
/*****************************************************************************/
LONG32 ScanLength()
  LONG32 lCarryOVFBit, lScanLength, lSIRBits;
  lCarryOVFBit = ESC[0];
  lScanLength = (1 << lCarryOVFBit);                                  
  lSIRBits = SIR[0] & (lScanLength - 1);
  lScanLength -= lSIRBits;
  return (lScanLength);
/*****************************************************************************/
/*                                                                           */
/* Determine the sweep length. The sweep length is given by either the low   */
/* bit of the DCMR or the ESCP (End-of-Scan-pointer) or the SFR register.    */
/* This is because the scan could update many lines of the lowest (X) dimen- */
/* sion, or could update just part of 1 line in the X dimension.             */
/*                                                                           */
/*****************************************************************************/
LONG32 SweepLength(LONG32 *lFirstSweep)
  LONG32 lCarryOVFBit, lSweepLength;
  lCarryOVFBit = MIN(ESW[0], lNumXBits);
  lSweepLength = (1 << lCarryOVFBit);
  *lFirstSweep = (SIR[0] & (lSweepLength - 1));
  *lFirstSweep = lSweepLength - *lFirstSweep;
  return (lSweepLength);
/*****************************************************************************/
/*                                                                           */
/* DCMRHighBit returns a long with exactly one of the 32 bits set to 1. This */
/* bit position corresponds to the highest bit in the DCMR that has a 1.     */
/*                                                                           */
/*****************************************************************************/
LONG32 DCMRHighBit()
  LONG32 lTemp1, lTemp2;                                                      
  lTemp1 = DCM[0];
  lTemp2 = 1;
  while (lTemp1 > 1) {
    lTemp1 >>= 1;
    lTemp2 <<= 1;
  return (lTemp2);
/*****************************************************************************/
/*                                                                           */
/* DCMRLowBit returns a long with exactly one of the 32 bits set to 1. This  */
/* bit position corresponds to the lowest bit in the DCMR that has a 1. We   */
/* refer to this lowest dimension generically as the X dimension.            */
/*                                                                           */
/*****************************************************************************/
LONG32 DCMRLowBit()
  LONG32 lTemp1, lTemp2;
  lTemp1 = DCM[0];
  lTemp2 = 1;
  lNumXBits = 1;
  while ((lTemp1 != 0) && ((lTemp1 & 0x01) == 0)) {
    lTemp1 >>= 1;
    lTemp2 <<= 1;
    lNumXBits++;
  return (lTemp2);
void UpdateDCMR()
  lDCMRHighBit = DCMRHighBit();
  lDCMRLowBit = DCMRLowBit();
/*****************************************************************************/
/*                                                                           */
/* The following are general purpose routines that conveniently answer       */
/* queries about the sources and destinations that need to be updated        */
/*                                                                           */
/*****************************************************************************/
/*****************************************************************************/
/*                                                                           */
/* Is a particular source needed? Only checks those planes that will be      */
/* updated or used during the next scan.                                     */
/*                                                                           */
/*****************************************************************************/
BOOL IsSrcNeeded(short nSrc)
  short i, j;
  short nLastDest;
  nLastDest = (nSrc == SRC_TBUS ? DEST_LUT : DEST_DISPLAY);
  for (i = nNumPlanes - 1; i >= 0; i--) {
    for (j = DEST_SITE_DATA; j <= nLastDest; j++) {
      if (bDestSrcMatrix[i][j][nSrc]) {
	return TRUE;
      }
    }
  return FALSE;
/*****************************************************************************/
/*                                                                           */
/* Checks to see if the source/map is the same for all planes for the given  */
/* destination.                                                              */
/*                                                                           */
/*****************************************************************************/
BOOL IsSrcSame(short nDest)
  short i;
  BYTE *src, *map;
  switch (nDest) {
  case DEST_SITE_DATA:
    src = SDS;
    map = SDM;
    break;
  case DEST_EVENT_CT:
    src = ECS;
    map = ECM;
    break;
  case DEST_DISPLAY:
    src = DDS;
    map = DDM;
    break;
  case DEST_LUT:
    src = LAS;
    map = LAM;
    break;
  default:
    return FALSE;
    break;
  for(i = 1; i < nNumPlanes; i++)
    if ((src[0] != src[i]) || (map[0] != map[i]))
      return FALSE;
  return TRUE;
/*****************************************************************************/
/*                                                                           */
/* See if a particular destination will be changed during the current scan   */
/*                                                                           */
/*****************************************************************************/
BOOL IsDestUpdated(short nDest)
  short i, j;
  for (i = nNumPlanes-1; i >= 0; i--)
    for ( j = SRC_SITE_DATA; j <= SRC_CONST_DATA; j++)
      if (bDestSrcMatrix[i][nDest][j])
	return(TRUE);
  return(FALSE);
/*****************************************************************************/
/*                                                                           */
/* Calculate the number of planes that will be updated or used in the next   */
/* scan.                                                                     */
/*                                                                           */
/*****************************************************************************/
unsigned short CalcNumPlanes()
  BOOL       bPlaneUsed[CHIPS_PER_MOD];
  short      i, j;
  memset ((char *) bPlaneUsed, 0, CHIPS_PER_MOD * sizeof(BOOL));
  UpdateDestSrcMatrix();
  for (i = CHIPS_PER_MOD-1; i >= 0; i--) {
    for (j = DEST_SITE_DATA; j <= DEST_DISPLAY; j++) {
      if ( bDestSrcMatrix[i][j][SRC_SITE_DATA] || 
	  bDestSrcMatrix[i][j][SRC_GLUED_DATA] ) {
	bPlaneUsed[i] = TRUE;
      }
    }
    
    if (!bPlaneUsed[i]) {
      for (j = SRC_TBUS; j <= SRC_CONST_DATA; j++) {
	if (bDestSrcMatrix[i][DEST_SITE_DATA][j]) {
	  bPlaneUsed[i] = TRUE;
      }
    }
    if (bPlaneUsed[i])
      break;
  }  
  return ((unsigned short) i + 1);
/*****************************************************************************/
/*                                                                           */
/* Updates a matrix of sources and destinations. There are 5 sources, 4 dest */
/* and 16 planes. In addition, there is a bit per destination indicating     */
/* whether the map field selects an inverse function or just the function.   */
/* Thus, the SrcDestMatrix is a 6x4x16 matrix.                               */
/*                                                                           */
/*****************************************************************************/
void UpdateDestSrcMatrix()
  short      i;
  char       *szFuncName = "UpdateDestSrcMatrix";    
  memset((char *) bDestSrcMatrix, 0, CHIPS_PER_MOD*NUM_SRC*NUM_DEST);
  for (i = 0; i < CHIPS_PER_MOD; i++) {
    
    /*
     * If the source for the site is the site then don't bother to generate
     * code for this.  If the map selects only the glue lines then the source
     * selection is irrelevant.  If the map selects MAP_G then this is
     * effectively the same as selecting site as the source.  If the map
     * selects CONST_0 or CONST_1 then we handle this as a special case.
     */
    if (SDS[i] != SRC_SITE_DATA)
      bDestSrcMatrix[i][DEST_SITE_DATA][SDS[i]] = TRUE;
    if ((SDM[i] != MAP_S) && (SDM[i] != MAP_S_BAR)) {
      if (SDM[i] != MAP_G)
	bDestSrcMatrix[i][DEST_SITE_DATA][SRC_GLUED_DATA] = TRUE;
      if ((SDM[i] == MAP_CONST_0) || (SDM[i] == MAP_CONST_1)) {
	bDestSrcMatrix[i][DEST_SITE_DATA][SRC_CONST_DATA] = TRUE;
	bDestSrcMatrix[i][DEST_SITE_DATA][SRC_GLUED_DATA] = FALSE;
	bDestSrcMatrix[i][DEST_SITE_DATA][SDS[i]] = FALSE;
      }
      if ((SDM[i] == MAP_G) || (SDM[i] == MAP_G_BAR))
	bDestSrcMatrix[i][DEST_SITE_DATA][SDS[i]] = FALSE;
    }
    /*
     * If the source for the event counter is constant zero then don't bother
     * to generate code for this.  If the map selects only the glue lines then
     * the source selection is irrelevant.
     */
    bDestSrcMatrix[i][DEST_EVENT_CT][ECS[i]] = TRUE;
    if ((ECM[i] != MAP_S) && (ECM[i] != MAP_S_BAR)) {
      bDestSrcMatrix[i][DEST_EVENT_CT][SRC_GLUED_DATA] = TRUE;
      if ((ECM[i] == MAP_CONST_0) || (ECM[i] == MAP_CONST_1)) {
	if (ECM[i] == MAP_CONST_1)
	  bDestSrcMatrix[i][DEST_EVENT_CT][SRC_CONST_DATA] = TRUE;
	bDestSrcMatrix[i][DEST_EVENT_CT][SRC_GLUED_DATA] = FALSE;
	bDestSrcMatrix[i][DEST_EVENT_CT][ECS[i]] = FALSE;
      }
      if ((ECM[i] == MAP_G) || (ECM[i] == MAP_G_BAR))
 	bDestSrcMatrix[i][DEST_EVENT_CT][ECS[i]] = FALSE;
    }
    /*
     * If the source for the display is the host (tbus) then don't bother to
     * generate code for this.  If the map selects only the glue lines then
     * the source selection is irrelevant.
     */
    if ((DDS[i] != SRC_TBUS))
      bDestSrcMatrix[i][DEST_DISPLAY][DDS[i]] = TRUE;
    if ((DDM[i] != MAP_S) && (DDM[i] != MAP_S_BAR)) {
      bDestSrcMatrix[i][DEST_DISPLAY][SRC_GLUED_DATA] = TRUE;
      if ((DDM[i] == MAP_CONST_0) || (DDM[i] == MAP_CONST_1)) {
	bDestSrcMatrix[i][DEST_DISPLAY][SRC_CONST_DATA] = TRUE;
	bDestSrcMatrix[i][DEST_DISPLAY][SRC_GLUED_DATA] = FALSE;
	bDestSrcMatrix[i][DEST_DISPLAY][DDS[i]] = FALSE;
      }
      if ((DDM[i] == MAP_G) || (DDM[i] == MAP_G_BAR)) {
	bDestSrcMatrix[i][DEST_DISPLAY][DDS[i]] = FALSE;
      }
    }
    /*
     * If the map selects only the glue lines then the source selection is
     * irrelevant.
     */
    bDestSrcMatrix[i][DEST_LUT][LAS[i]] = TRUE;
    if ((LAM[i] != MAP_S) && (LAM[i] != MAP_S_BAR)) {
      bDestSrcMatrix[i][DEST_LUT][SRC_GLUED_DATA] = TRUE;
      if ((LAM[i] == MAP_CONST_0) || (LAM[i] == MAP_CONST_1)) {
	bDestSrcMatrix[i][DEST_LUT][SRC_CONST_DATA] = TRUE;
	bDestSrcMatrix[i][DEST_LUT][SRC_GLUED_DATA] = FALSE;
	bDestSrcMatrix[i][DEST_LUT][LAS[i]] = FALSE;
      }
      if ((LAM[i] == MAP_G) || (LAM[i] == MAP_G_BAR)) {
	bDestSrcMatrix[i][DEST_LUT][LAS[i]] = FALSE;
      }
    }
/* Unpack register of length < 32 bits or register field */
void Cam8SimCore::UnpackState(INT16 *base, int reg_fld, int imm)
  if (BITLEN(reg_fld) > 32) {
    WARNING("Can't unpack a register or field of len > 32", "UnpackState");
    UnpackBits(base, BITOFF(reg_fld), 32, imm, base_type[reg_fld].base,
	       base_type[reg_fld].type);
  else
    UnpackBits(base, BITOFF(reg_fld), BITLEN(reg_fld), imm,
	       base_type[reg_fld].base, base_type[reg_fld].type);
void Cam8SimCore::UnpackStateInto(INT16 *base, int reg_fld, int imm, BYTE *dest, int type)
  if (BITLEN(reg_fld) > 32) {
    WARNING("Can't unpack a register or field of len > 32", "UnpackStateInto");
    UnpackBits(base, BITOFF(reg_fld), 32, imm, dest, type);
  else
    UnpackBits(base, BITOFF(reg_fld), BITLEN(reg_fld), imm, dest, type);
/* Pack register of length < 32 bits or register field */
void Cam8SimCore::PackState(INT16 *base, int reg_fld)
  if (BITLEN(reg_fld) > 32) {
    WARNING("Can't pack a register or field of len > 32", "PackState");
    PackBits(base, BITOFF(reg_fld), 32, base_type[reg_fld].base,
	     base_type[reg_fld].type);
  else
    PackBits(base, BITOFF(reg_fld), BITLEN(reg_fld),
	     base_type[reg_fld].base, base_type[reg_fld].type);
void Cam8SimCore::PackStateFrom(INT16 *base, int reg_fld, BYTE *src, int type)
  if (BITLEN(reg_fld) > 32) {
    WARNING("Can't pack a register or field of len > 32", "PackStateFrom");
    PackBits(base, BITOFF(reg_fld), 32, src, type);
  else
    PackBits(base, BITOFF(reg_fld), BITLEN(reg_fld), src, type);

---------------------------------------------------------------------------

** Rename everything.
Put steplist parsing in Cam8Sim but leave the execution in
Cam8SimModule.
Problem: A major part of the problem is that the process of parsing
the steplist involves the setting of flags that will be used for
optimization during execution.  To make matters worse each module
object needs to have a private copy of the register set.  These
registers are written to and read from during steplist parsing.  So it
becomes a real pain if the object that handles parsing is different
from the object that handles execution.  The only reason we want a
separate object for execution is so we can simulate CAM8's multiple
modules running in parallel.
IDEAS:
1) We could keep just one object (Cam8Sim) and simulate the multiple
modules with multiple threads.  Each thread would have a private copy
of the register set but there would be some collection of shared data.
2) We could use MPI or PVM to simulate the multiple modules.
3) We could handle the problem of optimization flags by keeping them
in a structure instead of using global variables as we do now.  We
handle the problem of separate copies of the register set similarly.
In fact we can use the same structure for both.  The tricky part is
that modules can be individually selected so we need a separate
structure for each module we simulate and the structures need to be
carefully updates by the object that handles parsing.  This structure
gets passed to the object that handles execution.
** Rename everything.
---------------------------------------------------------------------------
What we really want is one object that handles parsing the steplist
and another that handles compiling and running the steplist.  That way
we can code multiple versions of the object for compiling and
running on different architectures.
Problem: A major part of the problem is that the process of parsing
the steplist involves the setting of flags that will be used for
optimization during execution.  To make matters worse each module
object needs to have a private copy of the register set.  These
registers are written to and read from during steplist parsing.  So it
becomes a real pain if the object that handles parsing is different
from the object that handles execution.  The only reason we want a
separate object for execution is so we can simulate CAM8's multiple
modules running in parallel.
IDEAS:
1) We could keep just one object (Cam8Sim) and simulate the multiple
modules with multiple threads.  Each thread would have a private copy
of the register set but there would be some collection of shared data.
2) We could use MPI or PVM to simulate the multiple modules.
3) We could handle the problem of optimization flags by keeping them
in a structure instead of using global variables as we do now.  We
handle the problem of separate copies of the register set similarly.
In fact we can use the same structure for both.  The tricky part is
that modules can be individually selected so we need a separate
structure for each module we simulate and the structures need to be
carefully updates by the object that handles parsing.  This structure
gets passed to the object that handles execution.  Probably we still
want to use threads to simulate multiple modules.
** Rename everything.
---------------------------------------------------------------------------
What we really want is one object that handles parsing the steplist
and another that handles compiling and running the steplist.  That way
we can code multiple versions of the object for compiling and
running on different architectures.
Problem: A major part of the problem is that the process of parsing
the steplist involves the setting of flags that will be used for
optimization during compilation and execution.  To make matters worse
each object needs to have a private copy of the register set and
flags.  These registers and flags are written to and read from during
steplist parsing.  So it becomes a real pain if the object that
handles parsing is different from the object that handles execution.
IDEAS:
1) We could keep just one object (Cam8Sim) and simulate the multiple
modules with multiple threads.  Each thread would have a private copy
of the register set but there would be some collection of shared data.
2) We could use MPI or PVM to simulate the multiple modules.
3) We could handle the problem of optimization flags by keeping them
in a structure instead of using global variables as we do now.  We
handle the problem of separate copies of the register set similarly.
In fact we can use the same structure for both.  The tricky part is
that modules can be individually selected so we need a separate
structure for each module we simulate and the structures need to be
carefully updates by the object that handles parsing.  This structure
gets passed to the object that handles execution.  Probably we still
want to use threads to simulate multiple modules.
SOLUTION:
Officially we will have two trees of classes.
The first tree will capture the high-level functionality and be used
directly by people coding experiments.  This tree is rooted at the
Cam8 class.  There will be NO Cam8Sim class.  Instead we will handle
the choice between the real hardware and a simulator using the "core"
object described below.
The second tree will capture all of the low-level details of actually
executing CA code.  These are "core" objects and will be rooted at the
Cam8Core class.  The Cam8Core class will define the minimum interface
needed to run the stuff generated by the Cam8 class.  It won't be
abstract so we can provide default versions of the memory allocation
methods.  At a minimum we will need 3 subclasses: Cam8HardwareCore,
Cam8SimCore and Cam8SimPICore.  The Cam8HardwareCore class will
provide access to the real Cam8 hardware.  It will use the device
driver to schedule steplist.  The Cam8SimCore class will provide a
standalone interface to the CAM8 simulator.  With it people can write
experiments that run on any architecture.  This class will also be
used to implement the classic cam8sim program which runs as a
subprocess of the Forth STEP program.  The Cam8SimPICore class will
provide the interface to the cam8sim program (through pipes).  It is
low-priority but usefull for implementing the hybrid STEP program and
when people want to have a separate process for executing their
steplists (this can give a performance increase).
Now the complication is that for the Cam8SimCore class we additionally
want to be able to separate steplist parsing from compilation and
execution.  We want to provide many "backends" for compilation and
execution on many different architectures.  The parsing will be
identical for all of these "backends" so we don't want to duplicate
that code.  To complicate matters even more we want to have an
interpretive version of the simulator core to use on architectures we
haven't developed a compiler for yet.  So 
** Rename everything.
---------------------------------------------------------------------------
What we really want is one object that handles parsing the steplist
and another that handles compiling and running the steplist.  That way
we can code multiple versions of the object for compiling and
running on different architectures.
Problem: A major part of the problem is that the process of parsing
the steplist involves the setting of flags that will be used for
optimization during compilation and execution.  To make matters worse
each object needs to have a private copy of the register set and
flags.  These registers and flags are written to and read from during
steplist parsing.  So it becomes a real pain if the object that
handles parsing is different from the object that handles execution.
IDEAS:
1) We could keep just one object (Cam8Sim) and simulate the multiple
modules with multiple threads.  Each thread would have a private copy
of the register set but there would be some collection of shared data.
2) We could use MPI or PVM to simulate the multiple modules.
3) We could handle the problem of optimization flags by keeping them
in a structure instead of using global variables as we do now.  We
handle the problem of separate copies of the register set similarly.
In fact we can use the same structure for both.  The tricky part is
that modules can be individually selected so we need a separate
structure for each module we simulate and the structures need to be
carefully updated by the object that handles parsing.  This structure
gets passed to the object that handles execution.  Probably we still
want to use threads to simulate multiple modules.
SOLUTION:
Officially we will have two trees of classes.
The first tree will capture the high-level functionality and be used
directly by people coding experiments.  This tree is rooted at the
Cam8 class.  There will be NO Cam8Sim class.  Instead we will handle
the choice between the real hardware and a simulator using the "core"
object described below.
The second tree will capture all of the low-level details of actually
executing CA code.  These are "core" objects and will be rooted at the
Cam8Core class.  The Cam8Core class will define the minimum interface
needed to run the stuff generated by the Cam8 class.  It won't be
abstract so we can provide default versions of the memory allocation
methods.  At a minimum we will need 3 subclasses: Cam8HardwareCore,
Cam8SimCore and Cam8SimPICore.  The Cam8HardwareCore class will
provide access to the real Cam8 hardware.  It will use the device
driver to schedule steplist.  The Cam8SimCore class will provide a
standalone interface to the CAM8 simulator.  With it people can write
experiments that run on any architecture.  This class will also be
used to implement the classic cam8sim program which runs as a
subprocess of the Forth STEP program.  The Cam8SimPICore class will
provide the interface to the cam8sim program (through pipes).  It is
low-priority but usefull for implementing the hybrid STEP program and
when people want to have a separate process for executing their
steplists (this can give a performance increase).
Now the complication is that for the Cam8SimCore class we additionally
want to be able to separate steplist parsing from compilation and
execution.  We want to provide many "backends" for compilation and
execution on many different architectures.  The parsing will be
identical for all of these "backends" so we don't want to duplicate
that code.  To complicate matters even more we want to have an
interpretive version of the simulator core to use on architectures we
haven't developed a compiler for yet.  So we make Cam8SimCore the
interpretive version, put the steplist parsing code there and subclass
it for all the architecture dependent versions.  Using the original
cam8sim code we can implement Cam8SimSPARCCore.

---------------------------------------------------------------------------

#include <CaLibStream++.H>
#include <CaLibError++.H>
#include <CaLibTrace++.H>
#include <CamLib++.H>
#include <Cam8Core++.H>
#include <Cam8SimCore++.H>
#include <Cam8SimSPARCCore++.H>
#include "std++.H"
Cam8SimSPARCCore::Cam8SimSPARCCore(void)
Cam8SimSPARCCore::~Cam8SimSPARCCore(void)
STD_BZERO(Cam8SimSPARCCore)
STD_BCOPY(Cam8SimSPARCCore)
STD_BCMP(Cam8SimSPARCCore)
int Cam8SimSPARCCore::SimCompScan(void)
  int i;
  bool bNoPerm = TRUE;
  bool bNoPermLast5 = TRUE;
  CODE pcodCurrent;
  CODEHANDLE hcodCurrent;
  long32 lLogScanLength = ESC[0] + 1L;
  CaLib_tb.ENTER("SimCompScan");  
  /************************************************************************/
  /* First, parse down the tree to see that we are going to update atleast*/
  /* 32 sites and that the lowest dimension extends over 32 bits. This    */
  /* second requirement is necessary because the optimized code can only  */
  /* handle dimension wraparounds at word boundaries.                     */
  /************************************************************************/
  if (lLogScanLength < 5)
    bNoPerm = bNoPermLast5 = FALSE;
  else if (lNumXBits < 5)
    bNoPerm = bNoPermLast5 = FALSE;
  else
    bNoPerm = bNoPermLast5 = TRUE;
  /************************************************************************/
  /* Now, determine if there is any permutation of the scan index in the  */
  /* bits of the SIR that will be significant over this scan.             */
  /************************************************************************/
  for (i = 0; i < MIN(5, ESC[0]); i++) {
    if (SIPR[i][0] != i) {
      bNoPerm = bNoPermLast5 = FALSE;
      break;
    }
    
    lLogScanLength--;
    
    if (!lLogScanLength)
      break;
  for (i = 5; i < MIN(SCAN_INDEX_LENGTH, ESC[0]); i++) {
    if (SIPR[i][0] != i)
      bNoPerm = FALSE;
    lLogScanLength--;
    if (!lLogScanLength)
      break;
#ifdef _FRAMEBUFFER_
  FRAME = (long32) FRAMEb;
#endif _FRAMEBUFFER_
  pcodCurrent = pcodScanner;
  hcodCurrent = &pcodCurrent;
  SimPrologue(hcodCurrent);
  if (bNoPerm)
    CheckNoPerm(hcodCurrent);
  else if (bNoPermLast5)
    SimGeneralScan(hcodCurrent);
  else
    SimGeneralScan(hcodCurrent);
  SimEpilogue(hcodCurrent);
  CaLib_tb.LEAVE();
/*****************************************************************************/
/*                                                                           */
/* CheckNoPerm is necessary for the following reason - suppose there is no   */
/* permutation of the Scan Index, but suppose the the bits that extend over  */
/* the lowest dimension (ie, the bits to the _right_ of the lowest bit of    */
/* DCMR) are not all zeros. Then, the first sweep will not scan a multiple-  */
/* of-two number of sites, and we cannot do an optimized scan.               */
/*                                                                           */
/*****************************************************************************/
void Cam8SimSPARCCore::CheckNoPerm(CODEHANDLE hcodCurrent)
  long32 lSIRSigBits, lSIR;
  CaLib_tb.ENTER("CheckNoPerm");
  lSIRSigBits = MIN(ESC[0], lNumXBits);
  lSIR = SIR[0] & ~((~0x0) << lSIRSigBits);
  if ((lSIR == 0) && (MIN(lNumXBits, ESC[0]) >= 2)) {
    if (bForceGeneralScan)
      SimGeneralScan(hcodCurrent);
    else
      SimScanNoPerm(hcodCurrent);
  else
    SimGeneralScan(hcodCurrent);
  CaLib_tb.LEAVE();
void Cam8SimSPARCCore::SimPrologue(CODEHANDLE hcodCurrent)
  CaLib_tb.ENTER("SimPrologue");
  NewBlock(hcodCurrent);
  .ENTER_PROC;
  CaLib_tb.LEAVE();
}     
void Cam8SimSPARCCore::SimEpilogue(CODEHANDLE hcodCurrent)
  CaLib_tb.ENTER("SimEpilogue");
 .RETURN_PROC;
  EndBlock();
  CaLib_tb.LEAVE();
void Cam8SimSPARCCore::SimExecScan(void)
  void (*fScan)(void);
  fScan = (void (*)()) pcodScanner;
  (*fScan)();
  ConstantSetAll(SIR, SCAN_INDEX_REG);
void Cam8SimSPARCCore::SimUpdateSite(void)
  short i;
  CODE pcodCurrent = pcodUpdateSite;
  CaLib_tb.ENTER("SimUpdateSite");
#ifdef _INCREMENTAL_COMPILE_     
  if (!(bSourceRegChange || bDestChange)) {
    CaLib_tb.LEAVE();
    return;
  else {
    bSourceRegChange = FALSE;
    bDestChange = FALSE;
#endif
  NewBlock(&pcodCurrent);
  .ENTER_LEAF,   
  if (IsSrcNeeded(SRC_TBUS) &&
      ((CAM8State.WhyScan != RFINDEX(REG_SIOR)) || (!CAM8State.bReadMode))) {
    if (!CAM8State.bImmediate) {
      if (CAM8State.bByteMode) {
	.LDUB_IND   iTbusAddr, #0, iTbusData;
	.ADD iTbusAddr, #1, iTbusAddr;
      } 
      
      else {
	.LDHW_IND iTbusAddr, #0, iTbusData;
	.ADD iTbusAddr, #2, iTbusAddr;
      }
    }
  if (IsSrcNeeded(SRC_SITE_DATA)) {
    .OR %G0, %G0, iUnGlueData;
    for (i = nNumPlanes-1; i >= 0; i--) {      
      .ADDcc (iPlaneWord+i), (iPlaneWord+i), (iPlaneWord+i);
      .ADDX iUnGlueData, iUnGlueData, iUnGlueData;
    }
  }  
  /* For Now glued and unglued data are the same */
  if (IsSrcNeeded(SRC_GLUED_DATA)) {
    if (!IsSrcNeeded(SRC_SITE_DATA)) {
      .OR %G0, %G0, iGlueData;
      for (i = nNumPlanes-1; i >= 0; i--) {      
	.ADDcc (iPlaneWord+i), (iPlaneWord+i), (iPlaneWord+i);
	.ADDX iGlueData, iGlueData, iGlueData;
      }
    }
    else {
      .OR %G0, iUnGlueData, iGlueData;
    }
  if (IsSrcNeeded(SRC_LUT)) {
    .OR   %G0, %G0, iLutData;
    if (IsSrcSame(DEST_LUT))
      BuildDest(DEST_LUT, iLutData, LAS[0], LAM[0]);            
    else
      BuildBitwiseDest(DEST_LUT, iLutData, LAS, LAM);
    .SH_LEFT      iLutData, #1, iLutData;
    .LDHW_IND     iLutAddr, iLutData, iLutData;
  /************************************************************************/
  /*                                                                      */
  /* All the sources needed to update all the destinations should now be  */
  /* in place. Update all the destinations in the following order : EC,   */
  /* Display (ie, scan io reads), and Site Data. Note that Site data      */
  /* must be updated last, because it destroys the Site Data register,    */
  /* which is one of the possible Sources (unglued data).                 */
  /*                                                                      */
  /************************************************************************/
  if (IsDestUpdated(DEST_DISPLAY)) {
    if (IsSrcSame(DEST_DISPLAY))
      BuildDest(DEST_DISPLAY, iTemp1, DDS[0], DDM[0]);
    else
      BuildBitwiseDest(DEST_DISPLAY, iTemp1, DDS, DDM);
#ifdef _FRAMEBUFFER_
    .STUB_IND iFrame, #0, iTemp1;
    .ADD iFrame, #1, iFrame;
#endif
  /* SCAN-IO READ */
  if ((CAM8State.WhyScan == RFINDEX(REG_SIOR)) && CAM8State.bReadMode) {
    if (CAM8State.bByteMode) {
      .STUB_IND iSIOR, #0, iTemp1;
      .ADD iSIOR, #1, iSIOR;
      }
    else {
      .STHW_IND iSIOR, #0, iTemp1;
      .ADD iSIOR, #2, iSIOR;
    }
  if (IsDestUpdated(DEST_EVENT_CT)) {
    if (IsSrcSame(DEST_EVENT_CT))
      BuildDest(DEST_EVENT_CT, iTemp1, ECS[0], ECM[0]);
    else
      BuildBitwiseDest(DEST_EVENT_CT, iTemp1, ECS, ECM);
    
    .SH_LEFT iTemp1, #(32 - nNumPlanes), iTemp1;
    for (i = nNumPlanes-1; i >= 0; i--) {
      .LDW_IND %DS, #(offEventCount+(i<<2)), iTemp2;
      .ADDcc iTemp1, iTemp1, iTemp1;
      .ADDX iTemp2, #0, iTemp2;
      .STW_IND %DS, #(offEventCount+(i<<2)), iTemp2;
    }
  if (IsDestUpdated(DEST_SITE_DATA)) {
    if (IsSrcSame(DEST_SITE_DATA)) {
      if (SDM[0] == MAP_S) {
	switch(SDS[0]) {
	case SRC_SITE_DATA: {
	  .OR %G0, iUnGlueData, iSiteDataSrc;
	  break;
	case SRC_TBUS: {
	  .OR %G0, iTbusData, iSiteDataSrc;
	  break;
	case SRC_LUT: {
	  .OR %G0, iLutData, iSiteDataSrc;
	  break;
	default: {
	  .OR %G0, iTemp1, iSiteDataSrc;
	  break;
      }
      else
	BuildDest(DEST_SITE_DATA, iSiteDataSrc, SDS[0], SDM[0]);
    }    
    else
      BuildBitwiseDest(DEST_SITE_DATA, iSiteDataSrc, SDS, SDM);
    .SH_LEFT iSiteDataSrc, #(32 - nNumPlanes), iSiteDataSrc;
    for (i = nNumPlanes - 1; i >= 0; i--) {                                
      .ADDcc iSiteDataSrc, iSiteDataSrc, iSiteDataSrc;
      
      if ((IsSrcNeeded(SRC_SITE_DATA)) || (IsSrcNeeded(SRC_GLUED_DATA))) {
	.ADDX (iPlaneWord+i), #0, (iPlaneWord+i);
      }
      else {
	.ADDX (iPlaneWord+i), (iPlaneWord+i), (iPlaneWord+i);
      }
    }
  .RETURN_LEAF;
    
  EndBlock();
  CaLib_tb.LEAVE();
void Cam8SimSPARCCore::SimScanNoPerm(CODEHANDLE hcodCurrent)
  long32 lTemp1, lTemp2;
  codelabel lblYLoop, lblAddrLoop, lblSkip;
  const short iPlaneCtr = iTemp1,
  iHeapOffset = iTemp2,
  iWordAddr = iTemp3,
  iHighBit = iTemp4;
  CaLib_tb.ENTER("SimScanNoPerm");
  lblSkip = NewLabel();
  lblYLoop = NewLabel();
  lblAddrLoop = NewLabel();
  /************************************************************************/
  /* Sim assuming the scan index is not permuted. This implies that   */
  /* bits to be updated during this scan are all consecutive.             */
  /************************************************************************/
  /************************************************************************/
  /* compute HIGH_BIT_MASK and X_HIGH_BIT_MASK				  */
  /************************************************************************/
  HIGH_BIT_MASK = lDCMRHighBit >> 3;
  X_HIGH_BIT_MASK = lDCMRLowBit >> 3;
  /************************************************************************/
  /* SITE_CTR is set to how many sweeps are to be done. X_byte_LENGTH is  */
  /* set to how many bytes will be updated per sweep                      */
  /************************************************************************/
  if (ESC[0] < lNumXBits) {
    SITE_CTR = 1;
    X_byte_LENGTH = 1 << (ESC[0] - 3);
  else {
    SITE_CTR = ScanLength() >> lNumXBits;                                  
    X_byte_LENGTH = lDCMRLowBit >> 2;
  nNumPlanes = CalcNumPlanes();
  /************************************************************************/
  /* Code starts here                                                     */
  /************************************************************************/
  .LDW_MEM iSiteCtr;
  .ADD_LABEL :lblYLoop;
  SimSweepCode();
  .CALL_PROC [pcodSweep];
  .NO_OP;
  .ADD %DS, #offNextWordAddr, iHeapOffset;
  .LDW_MEM iHighBitMask;
  .LDW_MEM iXByteLength;
  .ADD %G0, #0, iPlaneCtr;
  .ADD_LABEL :lblAddrLoop;
  .SUBcc iPlaneCtr, #(nNumPlanes*4), %G0;
  .BR_GRE :lblSkip;
  .LDW_IND iHeapOffset, iPlaneCtr, iWordAddr;
  .AND iHighBitMask, iWordAddr, iHighBit;
  .XNOR iHighBitMask, %G0, iHighBitMask;
  .AND iHighBitMask, iWordAddr, iWordAddr;
  .ADD iXByteLength, iWordAddr, iWordAddr;
  .XOR iHighBit, iWordAddr, iWordAddr;
  .STW_IND iHeapOffset, iPlaneCtr, iWordAddr;
  .ADD iPlaneCtr, #4, iPlaneCtr;
  .BRANCH :lblAddrLoop;
  .XNOR iHighBitMask, %G0, iHighBitMask;
  .ADD_LABEL :lblSkip;
  .SH_LEFT iXByteLength, #3, iTemp1;
  .LDW_MEM iScanIndexReg;
  .ADD iScanIndexReg, iTemp1, iScanIndexReg;
  .SUBcc iScanIndexReg, #0xFFFFFF, iTemp1;
  .BR_L :lblSkip;
  .NO_OP;
  .OR %G0, %G0, iScanIndexReg;
  .ADD_LABEL :lblSkip;
  .SUBcc iSiteCtr, #1, iSiteCtr;
  .BR_NZ :lblYLoop;
  .STW_MEM iScanIndexReg;
  CaLib_tb.LEAVE();
void Cam8SimSPARCCore::SimSweepCode(void)
  long32 xWordLength;
  codelabel lblXLoop;
  unsigned short nBitOffset[CHIPS_PER_MOD];
  short i, j;
  CODE pcodCurrent = pcodSweep;
  CaLib_tb.ENTER("SimSweepCode");
  lblXLoop = NewLabel();
  /************************************************************************/
  /* We assume here that the scan index is not permuted to arrive at the  */
  /* site address; however, some bits of the site address could be fixed  */
  /* at constant 0 or 1 as indicated by SIPR. Here, the site address of   */
  /* the first site to be updated is computed.                            */
  /************************************************************************/
  SITE_ADDR = 0;
  for (i = SCAN_INDEX_LENGTH-1; i >= 0; i--) {
    
    SITE_ADDR <<= 1;
    if (SIPR[i][0] == PERM_CONST_1)
      SITE_ADDR |= 0x1;
    else if (SIPR[i][0] != PERM_CONST_0)
      SITE_ADDR |= (SIR[0] >> i) & 0x1;
  /************************************************************************/
  /* Now that we know the site address of the first site to be updated,   */
  /* we compute the address in sparc memory of the word that contains     */
  /* a bit of that site by adding the plane offset to the site address.   */
  /************************************************************************/
  for (i = 0; i < nNumPlanes; i++) {
    NEXT_WORD_ADDR(i) = (AddSiteAddress(SITE_ADDR, OSR[i]) >> 5) << 2;
    NEXT_WORD_ADDR(i) += BIT_PLANE_ADDR(i);
    nBitOffset[i] = OSR[i] & 0x1F;
  xWordLength = X_byte_LENGTH >> 2;
  NewBlock(&pcodCurrent);
  .ENTER_PROC;
  SimLoadFirstWord(nBitOffset);
  if (IsSrcNeeded(SRC_SITE_ADDRESS)) {
    .LDW_MEM iScanIndexReg;
  if (IsSrcNeeded(SRC_LUT)) {
    .LDW_MEM iLutAddr;
  .LDW_MEM iUpdateSiteProc;
  .ADD %G0, #xWordLength, iXCtr;
  .ADD_LABEL :lblXLoop;
  SimUpdateSite();
  for (i = 0; i < 32; i++) {
    .CALL_LEAF_IND iUpdateSiteProc, #4;
    .INSTR *pcodUpdateSite;
    for (j = 0; j < nNumPlanes; j++) {
      if (nBitOffset[j] == (31 - i)) {
	SimGetNextWord(j);
      }
    }
  .SUBcc iXCtr, #1, iXCtr;
  .BR_NZ :lblXLoop;
  .NO_OP;
  SimSaveLastWord(nBitOffset);
  .RETURN_PROC;
  EndBlock();
  CaLib_tb.LEAVE();
void Cam8SimSPARCCore::SimLoadFirstWord(unsigned short nBitOffset[])
  short i;
  const short iSaveBits = iTemp1;
  const short iWordAddr = iTemp1;
  CaLib_tb.ENTER("SimLoadFirstWord");
  for (i = 0; i < nNumPlanes; i++) {
    .LDW_IND %DS, #(offNextWordAddr+(i<<2)), iWordAddr;
    .LDW_IND iWordAddr, #0, (iPlaneWord+i);
    if (nBitOffset[i] != 0) {
      .SH_RIGHT (iPlaneWord+i), #(32 - nBitOffset[i]), iSaveBits;
      .SH_LEFT (iPlaneWord+i), #nBitOffset[i], (iPlaneWord+i);
      .OR (iPlaneWord+i), iSaveBits, (iPlaneWord+i);
    }
  CaLib_tb.LEAVE();
void Cam8SimSPARCCore::SimGetNextWord(unsigned short nPlane)
  const short iAddrHighBit = iTemp1;
  bool bWriteBack = FALSE;
  short i;
  CaLib_tb.ENTER("SimGetNextWord");
  .ENTER_BASICBLK;
  if (IsDestUpdated(DEST_SITE_DATA)) {
    .STW_IND (iNextWordAddr+nPlane), #0, (iPlaneWord+nPlane);
  if (lNumXBits <= 5) {
    .RETURN_BASICBLK;
    CaLib_tb.LEAVE();
    return;
  .AND (iNextWordAddr+nPlane), iXHighBitMask, iAddrHighBit;
  .XNOR iXHighBitMask, %G0, iXHighBitMask;
  .AND (iNextWordAddr+nPlane), iXHighBitMask, (iNextWordAddr+nPlane);
  .ADD (iNextWordAddr+nPlane), #4, (iNextWordAddr+nPlane);
  .XOR iAddrHighBit, (iNextWordAddr+nPlane), iNextWordAddr+nPlane;
  .XNOR iXHighBitMask, %G0, iXHighBitMask;
  .LDW_IND (iNextWordAddr+nPlane), #0, (iPlaneWord+nPlane);
  .STW_MEM (iNextWordAddr+nPlane);
  .RETURN_BASICBLK;
  CaLib_tb.LEAVE();
void Cam8SimSPARCCore::SimSaveLastWord(unsigned short nBitOffset[])
  short i;
  const short iSaveBits = iTemp1;
  CaLib_tb.ENTER("SimSaveLastWord");
  if (IsDestUpdated(DEST_SITE_DATA)) {
    .ENTER_BASICBLK;
    for (i = 0; i < nNumPlanes; i++) {
      if (!nBitOffset[i])
	continue;
      .SH_RIGHT (iPlaneWord+i), #(nBitOffset[i]), iSaveBits;
      .SH_LEFT (iPlaneWord+i), #(32 - nBitOffset[i]), (iPlaneWord+i);
      .OR (iPlaneWord+i), iSaveBits, (iPlaneWord+i);
      .STW_IND (iNextWordAddr+i), #0, (iPlaneWord+i);
    }
    .RETURN_BASICBLK;
  CaLib_tb.LEAVE();
void Cam8SimSPARCCore::SimGeneralScan(CODEHANDLE hcodCurrent)
  /************************************************************************/
  /* Sim making no assumptions - in particular, it is expected that   */
  /* the scan index will be permuted, so that updated sites will not be   */
  /* sequentially located in memory.                                      */
  /************************************************************************/
  short i;
  codelabel lblMainLoop, lblAddrLoop, lblSkip1, lblSkip2;
  const short iPlaneCtr = iTemp1, iOffset = iTemp2, iPlaneBases = iTemp3;
  const short iBitOffset = iTemp4, iNextWord = iTemp5, iWordAddr = iTemp6;
  const short iSiteAddress = iTemp7, iSAHighBits = iTemp8;
  const short iOffHighBits = iTemp9, iScratch = iTemp9, iPlaneAddr = iTemp10;
  const short iSAAndMask = iTemp1, iSAOrMask = iTemp2;
  long32 lSAAndMask, lSAOrMask;
  long32 lSweepLength;
  CaLib_tb.ENTER("SimGeneralScan");
  nNumPlanes = CalcNumPlanes();
  lblMainLoop = NewLabel();
  lblAddrLoop = NewLabel();
  lblSkip1 = NewLabel();
  lblSkip2 = NewLabel();
  /************************************************************************/
  /* First, update things in the heap from where they can be accessed     */
  /* by the compiled code.                                                */
  /************************************************************************/
  /************************************************************************/
  /* Update heap copy of DCMR.						  */
  /************************************************************************/
  DCMR = DCM[0];
  /************************************************************************/
  /* Update heap copy of OFFSETS					  */
  /************************************************************************/
  for(i = 0 ; i < CHIPS_PER_MOD; i++)
    OFFSETS(i) = OSR[i];
  /************************************************************************/
  /* Figure out the site address of the first site to be updated. This is */
  /* needed to update SITE_ADDR for display purposes. Also,               */
  /* compute the SAAndMask and SAOrMask which will be used to do the      */
  /* permutation at execution time.                                       */
  /************************************************************************/
  SITE_ADDR = 0;
  lSAOrMask = lSAAndMask = 0;
  for (i = SCAN_INDEX_LENGTH-1; i >= 0; i--) {
    
    SITE_ADDR <<= 1;
    lSAOrMask <<= 1;
    lSAAndMask <<= 1;
    
    if (SIPR[i][0] < SCAN_INDEX_LENGTH) {
      
      /* Get the correct bit of scan indx */
      SITE_ADDR |= (SIR[0] >> SIPR[i][0]) & 0x1;
      
      if (SIPR[i][0] == i)
	lSAAndMask |= 1;
    }
    
    /* Constant of 1 */
    else if (SIPR[i][0] == PERM_CONST_1) {
      lSAOrMask |= 1;
      SITE_ADDR |= 1;
    }
    
    else if (SIPR[i][0] != PERM_CONST_0)
      WARNING("Invalid SIPR value", "SimGenScan");
    
  /************************************************************************/
  /* Figure out how many sites will be updated, and how many sites/sweep  */
  /************************************************************************/
  SITE_CTR = ScanLength();
  lSweepLength = SweepLength(&X_CTR);
  /************************************************************************/
  /* Next, generate the code. First, permute the scan index register to   */
  /* get the site address.                                                */
  /************************************************************************/
    .LDW_MEM iSiteCtr;
    .LDW_MEM iXCtr;
    .LDW_MEM iXByteLength;
    
    .ADD_LABEL :lblMainLoop;
    
    .ENTER_BASICBLK;
    .LDW_MEM iScanIndexReg;
    
    .ADD %G0, #lSAAndMask, iSAAndMask;
    .ADD %G0, #lSAOrMask, iSAOrMask;
    
    .AND iScanIndexReg, iSAAndMask, iSiteAddress;
    .OR iSAOrMask, iSiteAddress, iSiteAddress;
    
    for (i = SCAN_INDEX_LENGTH-1; i >= 0; i--) {
      if ((SIPR[i][0] < SCAN_INDEX_LENGTH) && (SIPR[i][0] != i)) {
	.SH_LEFT iScanIndexReg, #(31 - SIPR[i][0]), iScratch;
	.ADDcc iScratch, iScratch, iScratch;
	.ADDX %G0, %G0, iTemp10;
	.SH_LEFT iTemp10, #i, iTemp10;
	.OR iTemp10, iSiteAddress, iSiteAddress;
      }
    }
      
    /************************************************************************/
    /* Now, add site address to the offset to get the DRAM address. The     */
    /* addition must break the carries at the dimension cuts. Also, DRAM    */
    /* address must be broken into a SPARC word address and a 5 bit offset  */
    /* into the word                                                        */
    /************************************************************************/
    
    .ADD %DS, #offOffsets, iOffset;
    .ADD %DS, #offBitPlaneAddr, iPlaneBases;
    .ADD %DS, #offBitOffsets, iBitOffset;
    .ADD %DS, #offNextWordAddr, iNextWord;
    
    .LDW_MEM iDcmr;
    .AND iDcmr, iSiteAddress, iSAHighBits;
    .XNOR %G0, iDcmr, iDcmr;
    .AND iDcmr, iSiteAddress, iSiteAddress;
    .AND iDcmr, iSiteAddress, iScratch;
    .AND iScratch, #(SITE_ADDR_MASK), iSiteAddress;
    .XNOR %G0, iDcmr, iDcmr;
    
    .ADD %G0, #0, iPlaneCtr;
    .ADD_LABEL :lblAddrLoop;
    
    .LDW_IND iOffset, iPlaneCtr, iWordAddr;
    .AND iDcmr,  iWordAddr, iOffHighBits;
    .XNOR %G0, iDcmr, iDcmr;
    .AND iDcmr,  iWordAddr, iWordAddr;
    .ADD iSiteAddress, iWordAddr, iWordAddr;
    .XOR iWordAddr, iOffHighBits, iWordAddr;
    .XOR iWordAddr, iSAHighBits, iWordAddr;
    
    .LDW_IND iPlaneBases, iPlaneCtr, iPlaneAddr;
    .SH_RIGHT iWordAddr, #5, iScratch;
    .SH_LEFT iScratch, #2, iScratch;
    .ADD iScratch, iPlaneAddr, iScratch;
    .STW_IND iNextWord, iPlaneCtr, iScratch;
    .AND iWordAddr, #0x1F, iWordAddr;
    .STW_IND iBitOffset, iPlaneCtr, iWordAddr;
    
    .ADD iPlaneCtr, #4, iPlaneCtr;
    .SUBcc iPlaneCtr, #(nNumPlanes * 4), %G0;
    .BR_L :lblAddrLoop;
    .XNOR %G0, iDcmr, iDcmr;
    
    .RETURN_BASICBLK;
    
  /************************************************************************/
  /* Now, the heap has the word addresses and bit offsets for the next    */
  /* site. So go ahead and update the site.                               */
  /************************************************************************/
  SimUpdateCode();
  .CALL_PROC [pcodGenUpdate];
  .NO_OP;
  .LDW_MEM iScanIndexReg;
  .SUBcc iXCtr, #1, iXCtr;
  .BR_NZ :lblSkip1;
  .NO_OP;
  .ADD %G0, #lSweepLength, iXCtr;
  .ADD_LABEL :lblSkip1;
  .ADD iScanIndexReg, #1, iScanIndexReg;
  .SUBcc iScanIndexReg, #(0xFFFFFF), iScratch;
  .BR_L :lblSkip2;
  .NO_OP;
  .OR %G0, %G0, iScanIndexReg;    
  .ADD_LABEL :lblSkip2;
  .SUBcc iSiteCtr, #1, iSiteCtr;
  .BR_NZ :lblMainLoop;
  .STW_MEM iScanIndexReg;
  CaLib_tb.LEAVE();
void Cam8SimSPARCCore::SimUpdateCode()
  CODE pcodCurrent = pcodGenUpdate;
  CaLib_tb.ENTER("SimUpdateCode");
  NewBlock(&pcodCurrent);
  .ENTER_PROC;
  SimLoadPlaneWords();
  SimUpdateSite();
  .CALL_LEAF [pcodUpdateSite];
  .NO_OP;
  SimSavePlaneWords();
     
  .RETURN_PROC;
  EndBlock();
  CaLib_tb.LEAVE();
void Cam8SimSPARCCore::SimLoadPlaneWords(void)
  short i;
  const short iWordAddr = iTemp1;
  const short iBitOffset = iTemp1;
  const short iSaveBits = iTemp2;
  const short iScratch = iTemp3;
  CaLib_tb.ENTER("SimLoadPlaneWords");
  if (!IsSrcNeeded(SRC_SITE_DATA) && !IsSrcNeeded(SRC_GLUED_DATA) &&
      !IsDestUpdated(DEST_SITE_DATA)) {
    CaLib_tb.LEAVE();
    return;
  .ADD %G0, #32, iScratch;
  for (i = 0; i < nNumPlanes; i++) {
    .LDW_IND %DS, #(offNextWordAddr+(i<<2)), iWordAddr;
    .LDW_IND iWordAddr, #0, (iPlaneWord+i);
    .LDW_IND %DS, #(offBitOffsets+(i<<2)), iBitOffset;
    .SUB iScratch, iBitOffset, iBitOffset;
    .SH_RIGHT (iPlaneWord+i), iBitOffset, iSaveBits;
    .SUB iScratch, iBitOffset, iBitOffset;
    .SH_LEFT (iPlaneWord+i), iBitOffset, (iPlaneWord+i);
    .OR (iPlaneWord+i), iSaveBits, (iPlaneWord+i);
  CaLib_tb.LEAVE();
void Cam8SimSPARCCore::SimSavePlaneWords(void)
  short i;
  const short iWordAddr = iTemp1;
  const short iBitOffset = iTemp1;
  const short iSaveBits = iTemp2;
  const short iScratch = iTemp3;
  CaLib_tb.ENTER("SimSavePlaneWords");
  if (!IsDestUpdated(DEST_SITE_DATA)) {
    CaLib_tb.LEAVE();
    return;
  .ADD %G0, #31, iScratch;
  for (i = 0; i < nNumPlanes; i++) {
    .LDW_IND %DS, #(offBitOffsets+(i<<2)), iBitOffset;
    .SUB iScratch, iBitOffset, iBitOffset;
    .SH_LEFT (iPlaneWord+i), iBitOffset, iSaveBits;
    .SUB iScratch, iBitOffset, iBitOffset;
    .ADD iBitOffset, #1, iBitOffset;
    .SH_RIGHT (iPlaneWord+i), iBitOffset, (iPlaneWord+i);
    .OR (iPlaneWord+i), iSaveBits, (iPlaneWord+i);
    .LDW_IND %DS, #(offNextWordAddr+(i<<2)), iWordAddr;
    .STW_IND iWordAddr, #0, (iPlaneWord+i);
  CaLib_tb.LEAVE();
}     
short Cam8SimSPARCCore::PermuteScanIndex(void)
  short i;
  bool bIsPermuted = FALSE;
  CaLib_tb.ENTER("PermuteScanIndex");
  for (i = nNumPlanes - 1; i >= 0; i--) {
    if (SABSR[i] != i) {
      bIsPermuted = TRUE;
      break;
    }
  if (!bIsPermuted) {
    CaLib_tb.LEAVE();
    return (iScanIndexReg);
  .OR %G0, %G0, iTemp6;
  for (i = nNumPlanes-1; i >= 0; i--) {
    if (SABSR[i] < 24) {
      .SH_LEFT iScanIndexReg, #(31 - SABSR[i]), iTemp5;
      .ADDcc iTemp5, iTemp5, iTemp5;
      .ADDXcc iTemp6, iTemp6, iTemp6;
    }
    else if (SABSR[i] == 31) {
      .SH_LEFT iTemp6, #1, iTemp6;
      .ADD iTemp6, #1, iTemp6;
    }
    else if (SABSR[i] == 30) {
      .SH_LEFT iTemp6, #1, iTemp6;
    }
    else {
      WARNING("Invalid SABSR value!", "PermuteScanIndex");
      .SH_LEFT iTemp6, #1, iTemp6;
    }
  CaLib_tb.LEAVE();
  return (iTemp6);
void Cam8SimSPARCCore::MapFunction(short iSrcVar, short iDestVar, byte bMap)
  CaLib_tb.ENTER("MapFunction");
  switch (bMap) {
  case MAP_CONST_0: {
    .OR %G0, %G0, iDestVar;
    break;
    
  case MAP_G_NOR_S: {
    /* Surprizingly, SPARC does not have*/
    /* a native NOR instruction! ORN is */
    /* not NOR!!!                       */
    .OR iGlueData, iSrcVar, iDestVar;
    .XNOR %G0, iDestVar, iDestVar;
    break;
  }    
  case MAP_G_AND_S_BAR: {
    .XNOR %G0, iSrcVar, iDestVar;
    .AND iGlueData, iDestVar, iDestVar;
    break;
    
  case MAP_S_BAR: {
    .XNOR %G0, iSrcVar, iDestVar;
    break;
    
  case MAP_G_BAR_AND_S: {
    .XNOR %G0, iGlueData, iDestVar;
    .AND iSrcVar, iDestVar, iDestVar;
    break;
    
  case MAP_G_BAR: {
    .XNOR %G0, iGlueData, iDestVar;
    break;
    
  case MAP_G_XOR_S: {
    .XOR iGlueData, iSrcVar, iDestVar;
    break;
    
  case MAP_G_NAND_S: {
    /* The SPARC does not have a native NAND */
    /* instruction! ANDN is not NAND */
    .AND iGlueData, iSrcVar, iDestVar;
    .XNOR %G0, iDestVar, iDestVar;
    break;
    
  case MAP_G_AND_S: {
    .AND iGlueData, iSrcVar, iDestVar;
    break;
    
  case MAP_G_EQ_S: {
    .XNOR iGlueData, iSrcVar, iDestVar;
    break;
    
  case MAP_G: {
    .XOR %G0, iGlueData, iDestVar;
    break;
    
  case MAP_G_OR_S_BAR: {
    .XNOR %G0, iSrcVar, iDestVar;
    .OR iGlueData, iDestVar, iDestVar;
    break;
    
  case MAP_S: {
    .XOR %G0, iSrcVar, iDestVar;
    break;
    
  case MAP_G_BAR_OR_S: {
    .XNOR %G0, iGlueData, iDestVar;
    .OR iSrcVar, iDestVar, iDestVar;
    break;
    
  case MAP_G_OR_S: {
    .OR iGlueData, iSrcVar, iDestVar;
    break;
    
  case MAP_CONST_1: {
    .XNOR %G0, %G0, iDestVar;
    break;
  CaLib_tb.LEAVE();
void Cam8SimSPARCCore::BuildDest(short nDest, short iDestVar, byte Src, byte Map)
  short iSrcVar;
  CaLib_tb.ENTER("BuildDest");
  if ((Map != MAP_G) && (Map != MAP_G_BAR)) {
    iSrcVar = (Src == SRC_SITE_DATA ? iUnGlueData :
	       Src == SRC_TBUS ? iTbusData :
	       Src == SRC_LUT ? iLutData : iTemp1);
    if ((nDest == DEST_LUT) && (Src == SRC_SITE_ADDRESS)) {
      iSrcVar = PermuteScanIndex();
    }
  MapFunction(iSrcVar, iDestVar, Map);
  CaLib_tb.LEAVE();
void Cam8SimSPARCCore::BuildBitDest(short nDest, short iHoldReg, byte Src,
				    byte Map, unsigned short nPlane)
{                                                               
     
  CaLib_tb.ENTER("BuildBitDest");
  if ((nDest == DEST_LUT) && (Src == SRC_SITE_ADDRESS)) {
    .OR           %G0, %G0, iTemp6;
    
    if (SABSR[nPlane] < 24) {
      .SH_LEFT iScanIndexReg, #(31 - SABSR[nPlane]), iTemp5;
      .ADDcc iTemp5, iTemp5, iTemp5;
      .ADDXcc iTemp6, iTemp6, iTemp6;
      .SH_LEFT iTemp6, #nPlane, iTemp6;
    }
    else if (SABSR[nPlane] == 31) {
      .SH_LEFT iTemp6, #1, iTemp6;
      .ADD iTemp6, #1, iTemp6;
    }
    else if (SABSR[nPlane] == 30) {
      .SH_LEFT iTemp6, #1, iTemp6;
    }
    else {
      WARNING("Invalid SABSR value", "BuildBitDest");
      .SH_LEFT iTemp6, #1, iTemp6;
    }      
    MapFunction (iTemp6, iHoldReg, Map);
  else
    BuildDest(nDest, iHoldReg, Src, Map);
  CaLib_tb.LEAVE();
void Cam8SimSPARCCore::BuildBitwiseDest(short nDest, short iDestVar, byte Src[],
					byte Map[])
  short i;
  short iHoldReg = iTemp4;
  CaLib_tb.ENTER("BuildBitwiseDest");
  for (i = nNumPlanes - 1; i >= 0; i--) {
    BuildBitDest(nDest, iHoldReg, Src[i], Map[i], i);
    .SH_LEFT iHoldReg, #(31 - i), iHoldReg;
    .ADDcc iHoldReg, iHoldReg, iHoldReg;
    .ADDXcc iDestVar, iDestVar, iDestVar;
  CaLib_tb.LEAVE();

---------------------------------------------------------------------------

#ifndef _CAM8SIMPICORE_H_
#define _CAM8SIMPICORE_H_
#include <CamLib++.H>
#include <Cam8Core++.H>
#include <PipeComm++.H>
#include "std++.H"
extern "C" {
#include <sys/types.h>
#include <sys/ipc.h>
#include <sys/shm.h>
#include <sys/mman.h>
/*****************************************************************************/
/********************************* DEFINES ***********************************/
/*****************************************************************************/
#ifdef __cplusplus
/*****************************************************************************/
/******************************** TEMPLATES **********************************/
/*****************************************************************************/
/*****************************************************************************/
/*************************** CLASSES & TYPEDEFS ******************************/
/*****************************************************************************/
struct interface_regs {
    
  long32 NLP;                          /* Next List Pointer            */
  long32 ISR;                          /* Reset/Interrupt Register     */
  long32 CIP;                          /* Current Instruction Pointer  */
  long32 PIP;                          /* Previous Instruction Pointer */
    
  long32 RER;                          /* Reset/Enable Register        */
  long32 DSL;                          /* Display Scan Length          */
  long32 DBL;                          /* Display Blank Length         */
typedef interface_regs *INTERFACE_REGS;
struct shm_details {
  key_t key;
  int id;
  unsigned char *buf;
class Cam8SimPICore : public Cam8Core {
public:
  interface_regs iregs;
  Cam8SimPICore(void);
  Cam8SimPICore(int, int, int);
  DECL_COPYCONST(Cam8SimPICore);
  virtual ~Cam8SimPICore(void);
  DECL_OPEQ(Cam8SimPICore);
  DECL_BZERO(Cam8SimPICore);
  DECL_BCOPY(Cam8SimPICore);
  DECL_BCMP(Cam8SimPICore);
  unsigned char * Malloc(int);
  unsigned char * Calloc(int, int);
  unsigned char * Realloc(unsigned char *, int);
  void ResetInterface(void);
  void InitInterface(void);
  void ExecuteSteplist(struct steplist_operation &);
  void Read_NLP(long32 *);
  void Read_ISR(long32 *);
  void Read_CIP(long32 *);
  void Read_PIP(long32 *);
  void Write_NLP(const long32 *);
  void Write_RER(const long32 *);
  void Write_DSL(const long32 *);
  void Write_DBL(const long32 *);
  inline void ReadCmdLine(int argc, char *argv[]);
  // These methods are used by the cam8sim subprocess
  void Generate_Interrupt(int);
  long32 * GetNextSteplist(void);
protected:
  static Cmdt simcmds[] = {
    { "smat", SHMAT },
    { "smdt", SHMDT },
    { "rdR0", READR0 },
    { "rdR1", READR1 },
    { "rdR2", READR2 },
    { "rdR3", READR3 },
    { "wrR0", WRITER0 },
    { "wrR1", WRITER1 },
    { "wrR2", WRITER2 },
    { "wrR3", WRITER3 },
    { "quit", QUIT }
  };
  PipeComm comm;
  int ShmCnt;
  int retv[2];
  int newsl;
  int sim_memfd;
  int sim_infd;
  int sim_outfd
  shm_details ShmTable[8192];
  int findidx(unsigned char *);
  unsigned char *SHMAT(char *, unsigned char *, unsigned char *);
  unsigned char *SHMDT(char *, unsigned char *, unsigned char *);
  unsigned char *READR0(char *, unsigned char *, unsigned char *);
  unsigned char *READR1(char *, unsigned char *, unsigned char *);
  unsigned char *READR2(char *, unsigned char *, unsigned char *);
  unsigned char *READR3(char *, unsigned char *, unsigned char *);
  unsigned char *WRITER0(char *, unsigned char *, unsigned char *);
  unsigned char *WRITER1(char *, unsigned char *, unsigned char *);
  unsigned char *WRITER2(char *, unsigned char *, unsigned char *);
  unsigned char *WRITER3(char *, unsigned char *, unsigned char *);
  unsigned char *QUIT(char *, unsigned char *, unsigned char *);
/*****************************************************************************/
/********************************* INLINES ***********************************/
/*****************************************************************************/
inline void Cam8SimPipeInterface::ReadCmdLine(int argc, char *argv[])
  register int i;
  for(i = 1; i < argc; i++) {
    if (strcmp(argv[i], "-fd") == 0) {
      sim_memfd = atoi(argv[i+1]);
      i++;
      continue;
    }
    if (strcmp(argv[i], "-in") == 0) {
      sim_infd = atoi(argv[i+1]);
      i++;
      continue;
    }
    if (strcmp(argv[i], "-out") == 0) {
      sim_outfd = atoi(argv[i+1]);
      i++;
      continue;
    }
    
#endif
/*****************************************************************************/
/******************************* PROTOTYPES **********************************/
/*****************************************************************************/
/*****************************************************************************/
/********************************* GLOBALS ***********************************/
/*****************************************************************************/
#endif
#ifndef _CAM8SIMCORE_H_
#define _CAM8SIMCORE_H_
#include <CamLib++.H>
#include <Cam8Core++.H>
#include "std++.H"
/*****************************************************************************/
/********************************* DEFINES ***********************************/
/*****************************************************************************/
#define PERM_CONST_1            31                                               
#define PERM_CONST_0            30
#define LONG32_SIZE		(sizeof(long32))
#define INT16_SIZE		(sizeof(int16))
#define ACTIVE_LUT_SELECT	0x8000	 /* bit in Hardware Env Reg (HER)    */
#define FLD_SELECT(i)		((i) + 32)
#define FLD_MAP(i)		((i) + 64)
#define NUM_DEST		4
#define NUM_SRC			6
#define SRC_SITE_DATA		0
#define SRC_TBUS		1
#define SRC_FLYWHEEL		2
#define SRC_LUT			3
#define SRC_SITE_ADDRESS	3
#define SRC_GLUED_DATA		4
#define SRC_CONST_DATA		5
#define DEST_SITE_DATA		0
#define DEST_EVENT_CT		1
#define DEST_LUT		2
#define DEST_DISPLAY		3
#define MAP_CONST_0		0
#define MAP_G_NOR_S		1
#define MAP_G_AND_S_BAR		2
#define MAP_S_BAR		3
#define MAP_G_BAR_AND_S		4
#define MAP_G_BAR		5
#define MAP_G_XOR_S		6
#define MAP_G_NAND_S		7
#define MAP_G_AND_S		8
#define MAP_G_EQ_S		9
#define MAP_G			10
#define MAP_G_OR_S_BAR		11
#define MAP_S			12
#define MAP_G_BAR_OR_S		13
#define MAP_G_OR_S		14
#define MAP_CONST_1		15
#define HIGHB(x)		(((x) & 0x80000000) ? 0x1 : 0x0)
#ifdef DEBUG
#define EP(name) fprintf(DEBUGFILE, "ENTER: %s\n", name)
#define LP(name) fprintf(DEBUGFILE, "LEAVE: %s\n", name)
#else DEBUG
#define EP(name)
#define LP(name)
#endif DEBUG
#ifdef __cplusplus
/*****************************************************************************/
/******************************** TEMPLATES **********************************/
/*****************************************************************************/
/*****************************************************************************/
/*************************** CLASSES & TYPEDEFS ******************************/
/*****************************************************************************/
struct interface_regs {
    
  long32 NLP;                          /* Next List Pointer            */
  long32 ISR;                          /* Reset/Interrupt Register     */
  long32 CIP;                          /* Current Instruction Pointer  */
  long32 PIP;                          /* Previous Instruction Pointer */
    
  long32 RER;                          /* Reset/Enable Register        */
  long32 DSL;                          /* Display Scan Length          */
  long32 DBL;                          /* Display Blank Length         */
typedef interface_regs *INTERFACE_REGS;
struct Cam8SimModule {
  /* CAM8 Registers */
  byte MSR[CHIPS_PER_MOD];
  byte SSM[CHIPS_PER_MOD];
  byte RT[CHIPS_PER_MOD];
  byte ECT[CHIPS_PER_MOD];
  byte RPK[CHIPS_PER_MOD];
  byte ALT[CHIPS_PER_MOD];
  long32 KA[CHIPS_PER_MOD];
  byte XKS[CHIPS_PER_MOD];
  byte YKS[CHIPS_PER_MOD];
  byte ZKS[CHIPS_PER_MOD];
  byte XKMF[CHIPS_PER_MOD];
  byte YKMF[CHIPS_PER_MOD];
  byte ZKMF[CHIPS_PER_MOD];
  byte SABSR[CHIPS_PER_MOD];
  byte LAS[CHIPS_PER_MOD];
  byte LAM[CHIPS_PER_MOD];
  byte FOS[CHIPS_PER_MOD];
  byte FOM[CHIPS_PER_MOD];
  byte SDS[CHIPS_PER_MOD];
  byte SDM[CHIPS_PER_MOD];
  byte ECS[CHIPS_PER_MOD];
  byte ECM[CHIPS_PER_MOD];
  byte DDS[CHIPS_PER_MOD];
  byte DDM[CHIPS_PER_MOD];
  byte SSR[CHIPS_PER_MOD];
  long32 ECR[CHIPS_PER_MOD];
  int16 LIR[CHIPS_PER_MOD];
  byte LIPR[CHIPS_PER_MOD];
  int16 *LIOR;
  long32 SIR[CHIPS_PER_MOD];
  byte SSA[24][CHIPS_PER_MOD];
  byte *SIOR;
  byte SM[CHIPS_PER_MOD];
  byte ESC[CHIPS_PER_MOD];
  byte ESW[CHIPS_PER_MOD];
  byte EST[CHIPS_PER_MOD];
  byte SBRC[CHIPS_PER_MOD];
  byte RCL[CHIPS_PER_MOD];
  byte ECL[CHIPS_PER_MOD];
  byte STM[CHIPS_PER_MOD];
  long32 OSR[CHIPS_PER_MOD];
  long32 DCM[CHIPS_PER_MOD];
  byte XDCP[CHIPS_PER_MOD];
  byte YDCP[CHIPS_PER_MOD];
  byte ZDCP[CHIPS_PER_MOD];
  byte LPL[CHIPS_PER_MOD];
  byte FPL[CHIPS_PER_MOD];
  byte DCS[CHIPS_PER_MOD];
  byte TBD[CHIPS_PER_MOD];
  byte TMS[CHIPS_PER_MOD];
  byte NBF[CHIPS_PER_MOD];
  byte SRE[CHIPS_PER_MOD];
  byte ALS[CHIPS_PER_MOD];
  byte MAFS[CHIPS_PER_MOD];
  byte MBFS[CHIPS_PER_MOD];
  byte XMPC[CHIPS_PER_MOD];
  byte XPPC[CHIPS_PER_MOD];
  byte YMPC[CHIPS_PER_MOD];
  byte YPPC[CHIPS_PER_MOD];
  byte ZMPC[CHIPS_PER_MOD];
  byte ZPPC[CHIPS_PER_MOD];
  byte MIDR[CHIPS_PER_MOD];
  byte GIDR[CHIPS_PER_MOD];
  byte BPIE[CHIPS_PER_MOD];
  byte BCIE[CHIPS_PER_MOD];
  byte GCIE[CHIPS_PER_MOD];
  byte MAIE[CHIPS_PER_MOD];
  byte MBIE[CHIPS_PER_MOD];
  byte SSIE[CHIPS_PER_MOD];
  byte XHIE[CHIPS_PER_MOD];
  byte RLIE[CHIPS_PER_MOD];
  byte URIE[CHIPS_PER_MOD];
  byte ISIE[CHIPS_PER_MOD];
  byte BPIF[CHIPS_PER_MOD];
  byte BCIF[CHIPS_PER_MOD];
  byte GCIF[CHIPS_PER_MOD];
  byte MAIF[CHIPS_PER_MOD];
  byte MBIF[CHIPS_PER_MOD];
  byte SSIF[CHIPS_PER_MOD];
  byte XHIF[CHIPS_PER_MOD];
  byte RLIF[CHIPS_PER_MOD];
  byte URIF[CHIPS_PER_MOD];
  byte ISIF[CHIPS_PER_MOD];
  byte VWE[CHIPS_PER_MOD];
  byte VWIE[CHIPS_PER_MOD];
  byte VWIF[CHIPS_PER_MOD];
  byte LDOC[CHIPS_PER_MOD];
  byte HDOC[CHIPS_PER_MOD];
  byte *FRAMEb;							/* FRAME buffer */
  unsigned short nNumPlanes;
  byte WhyScan;
  bool bDestSrcMatrix [CHIPS_PER_MOD][NUM_DEST][NUM_SRC];
  bool bSourceRegChange;
  bool bDestChange;
  bool bForceGeneralScan;
  bool bByteMode;
  bool bImmediate;
  bool bReadMode;
typedef struct {
  char *base;
  int type;
} Bt, *BT;
class Cam8SimCore : public Cam8Core {
public:
  interface_regs iregs;
  int VWECHK;
  char debug;
  Bt base_type[790];
  bool bDestSrcMatrix [CHIPS_PER_MOD][NUM_DEST][NUM_SRC];
  bool bSourceRegChange;
  bool bDestChange;
  bool bForceGeneralScan;
  bool bByteMode;
  bool bImmediate;
  bool bReadMode;
  int16 *LUTb[2];			/* LUT buffers */
  long32 SITE_ADDR;
  long32 lDCMRHighBit;
  long32 lDCMRLowBit;
  long32 lNumXBits;
  long32 bit;
  long32 HIGH_BIT_MASK;
  long32 X_HIGH_BIT_MASK;
  long32 X_byte_LENGTH;
  long32 X_CTR;
  long32 SITE_CTR;
  long32 OFFSETS[CHIPS_PER_MOD];
  long32 BIT_OFFSETS[CHIPS_PER_MOD];
  long32 DCMR;
  long32 SCAN_INDEX_REG;
  long32 LUT_ADDR;
  long32 BIT_PLANE_ADDR[CHIPS_PER_MOD];
  long32 NEXT_WORD_ADDR[CHIPS_PER_MOD];
  long32 PLANE_WORD[CHIPS_PER_MOD];
  long32 EVENT_COUNT[CHIPS_PER_MOD];
  long32 UNGLUE_DATA;
  long32 GLUE_DATA;
  long32 SITE_DATA;
  long32 TBUS_DATA;
  long32 LUT_DATA;
  long32 DISP_DATA;
  long32 TBUS_ADDR;
  long32 FRAME_ADDR;
  long32 TEMP1;
  long32 TEMP2;
  long32 TEMP3;
  long32 TEMP4;
  long32 TEMP5;
  long32 TEMP6;
  long32 TEMP7;
  long32 TEMP8;
  long32 TEMP9;
  long32 TEMP10;
  FILE* DEBUGFILE;
  struct timeval tvStart, tvEnd;
  struct timezone tzZone;
  Cam8SimCore(void);
  DECL_COPYCONST(Cam8SimCore);
  virtual ~Cam8SimCore(void);
  DECL_BZERO(Cam8SimCore);
  DECL_BCOPY(Cam8SimCore);
  DECL_BCMP(Cam8SimCore);
  // These are virtual from Cam8Core
  void ResetInterface(void);
  void InitInterface(void);
  void ExecuteSteplist(struct steplist_operation &);
  void Read_NLP(long32 *);
  void Read_ISR(long32 *);
  void Read_CIP(long32 *);
  void Read_PIP(long32 *);
  void Write_NLP(const long32 *);
  void Write_RER(const long32 *);
  void Write_DSL(const long32 *);
  void Write_DBL(const long32 *);
  void InitSimulator(Cam8Core *);
  void InitStepList(void);
  void UnpackState(int16 *, int, int);
  void UnpackStateInto(int16 *, int, int, byte *, int);
  void PackState(int16 *, int);
  void PackStateFrom(int16 *, int, byte *, int);
  void InitModule(void);
  void SimStepList(long32 *plFirstInstr);
  void SimScan(void);
  void UpdateDCMR(void);
  void UpdateDestSrcMatrix(void);
  void UpdateDCMR();
  void UpdateDestSrcMatrix();
  unsigned short CalcNumPlanes();
  unsigned short CalcNumPlanes(void);
  bool IsSrcNeeded(short nSrc);
  bool IsSrcSame(short nDest);
  bool IsDestUpdated(short nDest);
  bool IsSrcNeeded(short nSrc);
  bool IsSrcSame(short nDest);
  bool IsDestUpdated(short nDest);
  long32 AddSiteAddress(long32 lSrc1, long32 lSrc2);
  long32 SubSiteAddress(long32 lSrc1, long32 lSrc2);
  long32 ScanLength(void);
  long32 SweepLength(long32 *lFirstSweep);
  long32 AddSiteAddress(long32 lSrc1, long32 lSrc2);
  long32 SubSiteAddress(long32 lSrc1, long32 lSrc2);
  long32 ScanLength();
  long32 SweepLength(long32 *lFirstSweep);
  long32 DCMRHighBit();
  long32 DCMRLowBit();
  virtual void SimScanNoPerm(void);
  virtual void SimGeneralScan(void);
  virtual void SimUpdateSite(void);
  virtual void CheckNoPerm(void);
  virtual void SimLoadFirstWord(long32 nBitOffset[]);
  virtual void SimGetNextWord(unsigned short nPlane);
  virtual void SimSaaveLastWord(long32 nBitOffset[]);
  virtual void SimUpdateCode(void);
  virtual void SimLoadPlaneWords(void);
  virtual void SimSavePlaneWords(void);
  virtual void MapFunction(long32 *SrcVar, long32 *DestVar, byte bMap);
  virtual void BuildDest(short nDest, long32 *DestVar, byte Src, byte Map);
  virtual void BuildBitDest(short nDest, long32 *HoldReg, byte Src, byte Map, unsigned short nPlane);
  virtual void BuildBitwiseDest(short nDest, long32 *DestVar, byte Src[], byte Map[]);
  virtual long32 *PermuteScanIndex(void);
  inline void ReadCmdLine(int, char *[]);
  inline void ConstantSetAll(byte r[], byte v);
  inline void ConstantSetAll(int16 r[], int16 v);
  inline void ConstantSetAll(long32 r[], long32 v);
  inline void SetAll(byte r[], byte v[]);
  inline void SetAll(int16 r[], int16 v[]);
  inline void SetAll(long32 r[], long32 v[]);
protected:
  inline void SENTER(int i, char *b, int t);
/*****************************************************************************/
/********************************* INLINES ***********************************/
/*****************************************************************************/
inline void Cam8SimCore::ReadCmdLine(int argc, char *argv[])
  register int i;
  for(i = 1; i < argc; i++) {
    if (strcmp(argv[i], "-g") == 0) {
      bForceGeneralScan = TRUE;
      continue;
    }
inline void Cam8SimCore::SENTER(int i, char *b, int t)
  base_type[i].base = b;
  base_type[i].type = t;
inline void Cam8SimCore::ConstantSetAll(byte r[], byte v)
  register int i;
  for(i = 0; i < CHIPS_PER_MOD; i++)
    r[i]=v;
inline void Cam8SimCore::ConstantSetAll(int16 r[], int16 v)
  register int i;
  for(i = 0; i < CHIPS_PER_MOD; i++)
    r[i]=v;
inline void Cam8SimCore::ConstantSetAll(long32 r[], long32 v)
  register int i;
  for(i = 0; i < CHIPS_PER_MOD; i++)
    r[i]=v;
inline void Cam8SimCore::SetAll(byte r[], byte v[])
  memcpy(r, v, CHIPS_PER_MOD * sizeof(byte));
inline void Cam8SimCore::SetAll(int16 r[], int16 v[])
  memcpy(r, v, CHIPS_PER_MOD * sizeof(byte));
inline void Cam8SimCore::SetAll(long32 r[], long32 v[])
  memcpy(r, v, CHIPS_PER_MOD * sizeof(byte));
#endif
/*****************************************************************************/
/******************************* PROTOTYPES **********************************/
/*****************************************************************************/
/*****************************************************************************/
/********************************* GLOBALS ***********************************/
/*****************************************************************************/
#endif
#ifndef _CAM8SIMSPARCCORE_H_
#define _CAM8SIMSPARCCORE_H_
#include <CamLib++.H>
#include <Cam8Core++.H>
#include <Cam8++.H>
#include <Cam8SimJIT++.H>
#include "std++.H"
/*****************************************************************************/
/********************************* DEFINES ***********************************/
/*****************************************************************************/
#define SCANNER_CODE_SIZE       (1024 * LONG32_SIZE)
#define SWEEP_CODE_SIZE         (1024 * LONG32_SIZE)
#define UPDATE_CODE_SIZE        (1024 * LONG32_SIZE)
#define MREGS	32
/*****************************************************************************/
/*                                                                           */
/* macros for convenient addressing of SPARC registers			     */
/*                                                                           */
/*****************************************************************************/
#define REG_G0	0L
#define REG_G1	1L
#define REG_G2	2L
#define REG_G3	3L
#define REG_G4	4L
#define REG_G5	5L
#define REG_G6	6L
#define REG_G7	7L
#define REG_O0	8L
#define REG_O1	9L
#define REG_O2	10L
#define REG_O3	11L
#define REG_O4	12L
#define REG_O5	13L
#define REG_O6	14L
#define REG_O7	15L
#define REG_L0	16L
#define REG_L1	17L
#define REG_L2	18L
#define REG_L3	19L
#define REG_L4	20L
#define REG_L5	21L
#define REG_L6	22L
#define REG_L7	23L
#define REG_I0	24L
#define REG_I1	25L
#define REG_I2	26L
#define REG_I3	27L
#define REG_I4	28L
#define REG_I5	29L
#define REG_I6	30L
#define REG_I7	31L
#define REG_SP	14L								 /* Stack Pointer 		     */
#define REG_TP	15L								 /* The Temp register 		     */
#define REG_DS	07L								 /* pointer to Heap base	     */
#define REG_FP	30L								 /* Frame Pointer 		     */
#define REG_RA	31L								 /* Return Address 		     */
/*****************************************************************************/
/*                                                                           */
/* operand types to use when calling Emit()				     */
/*                                                                           */
/*****************************************************************************/
#define NULL_OP		0
#define REG_OP		1
#define CONST_OP	2
#define ADDR_OP		3
#define VAR_OP		4
#define LABEL_OP	5
/*****************************************************************************/
/*                                                                           */
/* op codes for emit							     */
/*                                                                           */
/*****************************************************************************/
#define PSEUDO_OP	0x8000
#define NATIVE_OP	0x4000
#define LD_ST_OP	0x2000
#define BRANCH_OP	0x1000
#define NATIVE_OP_MASK	0x3F
#define INSTR		(PSEUDO_OP | 0xFF)
#define ENTER_PROC	(PSEUDO_OP | 0x01)
#define RETURN_PROC	(PSEUDO_OP | 0x02)
#define CALL_PROC	(PSEUDO_OP | 0x03)
#define ENTER_LEAF	(PSEUDO_OP | 0x04)
#define RETURN_LEAF	(PSEUDO_OP | 0x05)
#define CALL_LEAF	(PSEUDO_OP | 0x06)
#define CALL_LEAF_IND	(PSEUDO_OP | 0x07)
#define ENTER_BASICBLK	(PSEUDO_OP | 0x08)
#define RETURN_BASICBLK	(PSEUDO_OP | 0x09)
#define ADD_LABEL	(PSEUDO_OP | 0x0A)
#define NO_OP		(PSEUDO_OP | 0x0B)
#define LDW_MEM		(LD_ST_OP | 0x00)
#define LDW_IND		(LD_ST_OP | 0x01)
#define LDHW_IND	(LD_ST_OP | 0x02)
#define LDUB_IND	(LD_ST_OP | 0x03)
#define STW_MEM		(LD_ST_OP | 0x06)
#define STW_IND		(LD_ST_OP | 0x07)
#define STHW_IND	(LD_ST_OP | 0x08)
#define STUB_IND	(LD_ST_OP | 0x09)
#define ADD		(NATIVE_OP | 0x00)
#define ADDcc		(NATIVE_OP | 0x10)
#define ADDX		(NATIVE_OP | 0x08)
#define ADDXcc		(NATIVE_OP | 0x18)
#define	SUB		(NATIVE_OP | 0x04)
#define SUBcc		(NATIVE_OP | 0x14)
#define SUBX		(NATIVE_OP | 0x0C)
#define SUBXcc		(NATIVE_OP | 0x1C)
#define AND		(NATIVE_OP | 0x01)
#define ANDcc		(NATIVE_OP | 0x11)
#define ANDN		(NATIVE_OP | 0x05)
#define ANDNcc		(NATIVE_OP | 0x15)
#define OR		(NATIVE_OP | 0x02)
#define ORcc 		(NATIVE_OP | 0x12)
#define ORN		(NATIVE_OP | 0x06)
#define ORNcc		(NATIVE_OP | 0x16)
#define XOR		(NATIVE_OP | 0x03)
#define XORcc 		(NATIVE_OP | 0x13)
#define XNOR		(NATIVE_OP | 0x07)
#define XNORcc		(NATIVE_OP | 0x17)
#define SH_LEFT		(NATIVE_OP | 0x25)
#define SH_RIGHT	(NATIVE_OP | 0x26)
#define SH_RIGHT_ARITH	(NATIVE_OP | 0x27)
#define BRANCH		(BRANCH_OP | 0x08)
#define BR_NEVER	(BRANCH_OP | 0x00)
#define BR_NEQ		(BRANCH_OP | 0x09)
#define BR_EQ		(BRANCH_OP | 0x01)
#define BR_GR		(BRANCH_OP | 0x0A)
#define BR_LE		(BRANCH_OP | 0x02)
#define BR_GRE		(BRANCH_OP | 0x0B)
#define BR_L		(BRANCH_OP | 0x03)
#define BR_GU		(BRANCH_OP | 0x0C)
#define BR_LEU		(BRANCH_OP | 0x04)
#define BR_CC		(BRANCH_OP | 0x0D)
#define BR_CS		(BRANCH_OP | 0x05)
#define BR_POS		(BRANCH_OP | 0x0E)
#define BR_NEG		(BRANCH_OP | 0x06)
#define BR_VC		(BRANCH_OP | 0x0F)
#define BR_VS		(BRANCH_OP | 0x07)
#define BR_NZ		(BRANCH_OP | 0x09)
#define BR_Z		(BRANCH_OP | 0x01)
#define OP_LDW		0x00L
#define OP_LDHW		0x02L
#define OP_LDUB		0x01L
#define OP_STW		0x04L
#define OP_STUB		0x05L
#define OP_STHW		0x06L
#define OP_ADD		0x00L
#define OP_ADDcc	0x10L
#define OP_ADDX		0x08L
#define OP_ADDXcc	0x18L
#define	OP_SUB		0x04L
#define OP_SUBcc	0x14L
#define OP_SUBX		0x0CL
#define OP_SUBXcc	0x1CL
#define OP_AND		0x01L
#define OP_ANDcc	0x11L
#define OP_ANDN		0x05L
#define OP_ANDNcc	0x15L
#define OP_OR		0x02L
#define OP_ORcc 	0x12L
#define OP_ORN		0x06L
#define OP_ORNcc	0x16L
#define OP_XOR		0x03L
#define OP_XORcc 	0x13L
#define OP_XNOR		0x07L
#define OP_XNORcc	0x17L
#define OP_SLL		0x25L
#define OP_SRL		0x26L
#define OP_SRA		0x27L
#define OP_SETHI	0x04L
#define OP_JMPL		0x38L
#define OP_SAVE		0x3CL
#define OP_RESTORE	0x3DL
#define IMMEDIATE	1
#define REG_SOURCE	0
#define FMT2_INST(op, opcode, k, rd) 	(((op) << 30) | \
					 ((opcode) << 22) | \
					 ((rd) << 25) | \
					 ((k) & 0x3fffffL))
#define FMT3_INST(op, opcode, rs1, i, rs2, rd) (((op) << 30) | \
						((rd) << 25) | \
						((opcode) << 19) | \
		       				((rs1) << 14) | \
						((i) << 13) | \
						((rs2) & 0x1FFFL))
#define SAVE_REG_IMM(rs1, k, rd)	(FMT3_INST(0x2L, OP_SAVE, (rs1), IMMEDIATE, (k), (rd)))
#define SAVE_REG_REG(rs1, rs2, rd)	(FMT3_INST(0x2L, OP_SAVE, (rs1), REG_SOURCE, (rs2), (rd)))
#define RESTORE				(FMT3_INST(0x2L, OP_RESTORE, REG_G0, REG_SOURCE, REG_G0, REG_G0))
#define RET				(FMT3_INST(0x2L, OP_JMPL, REG_I7, IMMEDIATE, 8, REG_G0))
#define RETL				(FMT3_INST(0x2L, OP_JMPL, REG_O7, IMMEDIATE, 8, REG_G0))
#define CALL_REG(r)			(FMT3_INST(0x2L, OP_JMPL, (r), IMMEDIATE, 0, REG_O7))
#define CALL_REG_IMM(r, k) 		(FMT3_INST(0x2L, OP_JMPL, (r), IMMEDIATE, (k), REG_O7))
#define CALL(disp)			((0x01 << 30) | (((unsigned long) (disp)) >> 2))
#define NOP				(FMT3_INST(0x2L, OP_OR, REG_G0, REG_SOURCE, REG_G0, REG_G0))
#define LDW_REG_IMM(rs1, k, rd) 	(FMT3_INST(0x3L, OP_LDW, rs1, IMMEDIATE, k, rd))
#define LDW_REG_REG(rs1, rs2, rd) 	(FMT3_INST(0x3L, OP_LDW, rs1, REG_SOURCE, rs2, rd))
#define LDHW_REG_IMM(rs1, k, rd) 	(FMT3_INST(0x3L, OP_LDHW, rs1, IMMEDIATE, k, rd))
#define LDHW_REG_REG(rs1, rs2, rd) 	(FMT3_INST(0x3L, OP_LDHW, rs1, REG_SOURCE, rs2, rd))
#define LDUB_REG_IMM(rs1, k, rd) 	(FMT3_INST(0x3L, OP_LDUB, rs1, IMMEDIATE, k, rd))
#define LDUB_REG_REG(rs1, rs2, rd) 	(FMT3_INST(0x3L, OP_LDUB, rs1, REG_SOURCE, rs2, rd))
#define STW_REG_IMM(rs1, k, rd) 	(FMT3_INST(0x3L, OP_STW, rs1, IMMEDIATE, k, rd))
#define STW_REG_REG(rs1, rs2, rd) 	(FMT3_INST(0x3L, OP_STW, rs1, REG_SOURCE, rs2, rd))
#define STHW_REG_IMM(rs1, k, rd) 	(FMT3_INST(0x3L, OP_STHW, rs1, IMMEDIATE, k, rd))
#define STHW_REG_REG(rs1, rs2, rd) 	(FMT3_INST(0x3L, OP_STHW, rs1, REG_SOURCE, rs2, rd))
#define STUB_REG_IMM(rs1, k, rd) 	(FMT3_INST(0x3L, OP_STUB, rs1, IMMEDIATE, k, rd))
#define STUB_REG_REG(rs1, rs2, rd) 	(FMT3_INST(0x3L, OP_STUB, rs1, REG_SOURCE, rs2, rd))
#define ADD_REG_IMM(rs1, k, rd) 	(FMT3_INST(0x2L, OP_ADD, rs1, IMMEDIATE, k, rd))
#define ADD_REG_REG(rs1, rs2, rd) 	(FMT3_INST(0x2L, OP_ADD, rs1, REG_SOURCE, rs2, rd))
#define ADDcc_REG_IMM(rs1, k, rd) 	(FMT3_INST(0x2L, OP_ADDcc, rs1, IMMEDIATE, k, rd))
#define ADDcc_REG_REG(rs1, rs2, rd) 	(FMT3_INST(0x2L, OP_ADDcc, rs1, REG_SOURCE, rs2, rd))
#define ADDX_REG_IMM(rs1, k, rd) 	(FMT3_INST(0x2L, OP_ADDX, rs1, IMMEDIATE, k, rd))
#define ADDX_REG_REG(rs1, rs2, rd) 	(FMT3_INST(0x2L, OP_ADDX, rs1, REG_SOURCE, rs2, rd))
#define ADDXcc_REG_IMM(rs1, k, rd) 	(FMT3_INST(0x2L, OP_ADDXcc, rs1, IMMEDIATE, k, rd))
#define ADDXcc_REG_REG(rs1, rs2, rd) 	(FMT3_INST(0x2L, OP_ADDXcc, rs1, REG_SOURCE, rs2, rd))
#define SUB_REG_IMM(rs1, k, rd) 	(FMT3_INST(0x2L, OP_SUB, rs1, IMMEDIATE, k, rd))
#define SUB_REG_REG(rs1, rs2, rd) 	(FMT3_INST(0x2L, OP_SUB, rs1, REG_SOURCE, rs2, rd))
#define SUBcc_REG_IMM(rs1, k, rd) 	(FMT3_INST(0x2L, OP_SUBcc, rs1, IMMEDIATE, k, rd))
#define SUBcc_REG_REG(rs1, rs2, rd) 	(FMT3_INST(0x2L, OP_SUBcc, rs1, REG_SOURCE, rs2, rd))
#define SUBX_REG_IMM(rs1, k, rd) 	(FMT3_INST(0x2L, OP_SUBX, rs1, IMMEDIATE, k, rd))
#define SUBX_REG_REG(rs1, rs2, rd) 	(FMT3_INST(0x2L, OP_SUBX, rs1, REG_SOURCE, rs2, rd))
#define SUBXcc_REG_IMM(rs1, k, rd) 	(FMT3_INST(0x2L, OP_SUBXcc, rs1, IMMEDIATE, k, rd))
#define SUBXcc_REG_REG(rs1, rs2, rd) 	(FMT3_INST(0x2L, OP_SUBXcc, rs1, REG_SOURCE, rs2, rd))
#define AND_REG_IMM(rs1, k, rd) 	(FMT3_INST(0x2L, OP_AND, rs1, IMMEDIATE, k, rd))
#define AND_REG_REG(rs1, rs2, rd) 	(FMT3_INST(0x2L, OP_AND, rs1, REG_SOURCE, rs2, rd))
#define OR_REG_IMM(rs1, k, rd) 		(FMT3_INST(0x2L, OP_OR, rs1, IMMEDIATE, k, rd))
#define OR_REG_REG(rs1, rs2, rd) 	(FMT3_INST(0x2L, OP_OR, rs1, REG_SOURCE, rs2, rd))
#define XOR_REG_IMM(rs1, k, rd) 	(FMT3_INST(0x2L, OP_XOR, rs1, IMMEDIATE, k, rd))
#define XOR_REG_REG(rs1, rs2, rd) 	(FMT3_INST(0x2L, OP_XOR, rs1, REG_SOURCE, rs2, rd))
#define XNOR_REG_IMM(rs1, k, rd) 	(FMT3_INST(0x2L, OP_XNOR, rs1, IMMEDIATE, k, rd))
#define XNOR_REG_REG(rs1, rs2, rd) 	(FMT3_INST(0x2L, OP_XNOR, rs1, REG_SOURCE, rs2, rd))
#define NOT_REG(r)			(XNOR_REG_REG(r, REG_G0, r))
#define SLL_REG_IMM(rs1, k, rd) 	(FMT3_INST(0x2L, OP_SLL, rs1, IMMEDIATE, k, rd))
#define SLL_REG_REG(rs1, rs2, rd) 	(FMT3_INST(0x2L, OP_SLL, rs1, REG_SOURCE, rs2, rd))
#define SRL_REG_IMM(rs1, k, rd) 	(FMT3_INST(0x2L, OP_SRL, rs1, IMMEDIATE, k, rd))
#define SRL_REG_REG(rs1, rs2, rd) 	(FMT3_INST(0x2L, OP_SRL, rs1, REG_SOURCE, rs2, rd))
#define HI22(k) 			((((unsigned long) (k)) >> 10) & 0x3fffffL)
#define LOW10(k) 			(((unsigned long) (k)) & 0x3ffL)
#define SETHI(k, rd) 			(FMT2_INST(0x0L, OP_SETHI, k, rd))
/******************************************************************************
 * The branch instructions.
 *****************************************************************************/
#define BRANCH_INST(annul, cond, disp)	(((annul) << 29) | ((cond) << 25) | (0x800000) | ((disp) & 0x3FFFFF))
#define BRA(disp)			(BRANCH_INST(0, 0x8, disp))
#define BRN(disp)			(BRANCH_INST(0, 0x0, disp))
#define BRNE(disp)			(BRANCH_INST(0, 0x9, disp))
#define BRE(disp)			(BRANCH_INST(0, 0x1, disp))
#define BRG(disp)			(BRANCH_INST(0, 0xA, disp))
#define BRLE(disp)			(BRANCH_INST(0, 0x2, disp))
#define BRGE(disp)			(BRANCH_INST(0, 0xB, disp))
#define BRL(disp)			(BRANCH_INST(0, 0x3, disp))
#define BRGU(disp)			(BRANCH_INST(0, 0xC, disp))
#define BRLEU(disp)			(BRANCH_INST(0, 0x4, disp))
#define BRCC(disp)			(BRANCH_INST(0, 0xD, disp))
#define BRCS(disp)			(BRANCH_INST(0, 0x5, disp))
#define BRPOS(disp)			(BRANCH_INST(0, 0xE, disp))
#define BRNEG(disp)			(BRANCH_INST(0, 0x6, disp))
#define BRVC(disp)			(BRANCH_INST(0, 0xF, disp))
#define BRVS(disp)			(BRANCH_INST(0, 0x7, disp))
#define BRNZ(disp)			(BRANCH_INST(0, 0x9, disp))
#define BRZ(disp)			(BRANCH_INST(0, 0x1, disp))
/*****************************************************************************/
/*                                                                           */
/* Macros to insert target instructions etc.				     */
/*                                                                           */
/*****************************************************************************/
#define EMIT(inst)			*pcodNext++ = (inst)
#define CURRENT_LOC			(pcodNext)
#define CURRENT_HANDLE			(&pcodNext)
#ifdef DEBUG
#define ASCODE(c)  fprintf(DEBUGFILE, "\t0x%x: %s\n", DASMADDR, c); fflush(DEBUGFILE)
#define ASNOTE(c)  fprintf(DEBUGFILE, "\t%s\n", c); fflush(DEBUGFILE)
#else DEBUG
#define ASCODE(name)
#define ASNOTE(c)
#endif DEBUG
#ifdef __cplusplus
/*****************************************************************************/
/******************************** TEMPLATES **********************************/
/*****************************************************************************/
/*****************************************************************************/
/*************************** CLASSES & TYPEDEFS ******************************/
/*****************************************************************************/
typedef unsigned short codelabel;
typedef unsigned long code;
typedef code *CODE;
typedef CODE *CODEHANDLE;
typedef unsigned long register;
struct tag_regEntry {	/* Describes register contents */
  int16	nVar;			/* Name (index) of variable */
  int16	nPriority;		/* Priority of variable */
  int16	nHeapOffset;		/* Offset into heap of variable */
typedef struct tag_regEntry regentry;
typedef regentry *REGENTRY;
struct tag_regQue {
  register rRegQue[MREGS];
  byte bHead;
  byte bTail;
  byte bNumElements;
typedef struct tag_regQue regque;
/* record of a label */
struct tag_lblrec {
     int16	lblName;
     byte	bValid;
     CODE	lAddress;
     struct tag_lblref *prefFirst;
     struct tag_lblrec *precNext;
typedef tag_lblrec labelrec;
typedef LABELREC LABELREC;
struct tag_codeblk {
     CODEHANDLE hcodTarget;
     CODE    pcodNext;
     codelabel	lblNext;
     LABELREC plblrecFirst;
     struct tag_CODEBLK pblkPrev;
typedef tag_codeblk codeblk;
typedef CODEBLK CODEBLK;
/* record of a reference to a label */
struct tag_lblref {
     CODE	pcodRefLoc;
     struct tag_lblref *prefNext;
typedef tag_lblref labelref;
class Cam8SimSPARCCore : public Cam8SimCore {
public:
  static const char *szRegName[] = {
    "%g0", "%g1", "%g2", "%g3", "%g4", "%g5", "%g6", "%g7",
    "%o0", "%o1", "%o2", "%o3", "%o4", "%o5", "%sp", "%tp",
    "%l0", "%l1", "%l2", "%l3", "%l4", "%l5", "%l6", "%l7",
    "%i0", "%i1", "%i2", "%i3", "%i4", "%i5", "%ds", "%ra"
  };
  static const char *szCCName[] = {
    "NEVER", "EQ", "LE", "L", "LEU", "CS", "NEG", "VS",
    "ALWAYS", "NEQ", "G", "GE", "GU", "CC", "POS", "VC"
  };
  static char registerS[32][64] = {
    "G0", "G1", "G2", "G3", "G4", "G5", "G6", "G7",
    "O0", "O1", "O2", "O3", "O4", "O5", "O6", "O7",
    "L0", "L1", "L2", "L3", "L4", "L5", "L6", "L7",
    "I0", "I1", "I2", "I3", "I4", "I5", "I6", "I7",
  };
  char SYMBOLS[SymbolTableSize][64];
  regentry rCurrWindow[MREGS];
  regque rqueFree;
  regque rqueSpillable[4];							 /* Que of spillable registers, one  */
  LABELREC plblrecFirst;
  CODE pcodScanNoPerm;
  CODE pcodGenUpdate;
  CODE pcodScanner;
  CODE pcodSweep;
  CODE pcodUpdateSite;
  CODE pcodNext;		/* Pointer to location of next inst */
  CODEHANDLE hcodTarget;	/* Handle to Target Code Location */
  codelabel lblNext;		/* Next Label */
  CODEBLK pblkTOS;
#ifdef DEBUG
  CODE DASMADDR;
#endif DEBUG
#ifdef _INSTRUMENTATION_
  struct timeval tvStart, tvEnd;
  struct timezone tzZone;
#endif
  Cam8SimSPARCCore(void);
  DECL_COPYCONST(Cam8SimSPARCCore);
  virtual ~Cam8SimSPARCCore(void);
  DECL_OPEQ(Cam8SimSPARCCore);
  DECL_BZERO(Cam8SimSPARCCore);
  DECL_BCOPY(Cam8SimSPARCCore);
  DECL_BCMP(Cam8SimSPARCCore);
  void InitSim(void);
  void SimScanNoPerm(CODEHANDLE hcodCurrent);
  void SimGeneralScan(CODEHANDLE hcodCurrent);
  void SimPrologue(CODEHANDLE hcodCurrent);
  void SimEpilogue(CODEHANDLE hcodCurrent);
  void SimUpdateSite();
  void SimLoadFirstWord(unsigned short nBitOffset[]);
  void SimGetNextWord(unsigned short nPlane);
  void SimSaveLastWord(unsigned short nBitOffset[]);
  void CheckNoPerm(CODEHANDLE hcodCurrent);
  void SimUpdateCode();
  void SimLoadPlaneWords();
  void SimSavePlaneWords();
  void MapFunction (short iSrcVar, short iDestVar, byte bMap);
  void BuildDest(short nDest, short iDestVar, byte Src, byte Map);
  void BuildBitDest(short nDest, short iHoldReg, byte Src, byte Map, unsigned short nPlane);
  void BuildBitwiseDest(short nDest, short iDestVar, byte Src[], byte Map[]);
  short PermuteScanIndex();
  void InsertSpillable(register reg);
  void ResetSpillQue(void);
  void PushRegWindow(void);
  void PopRegWindow(CODEHANDLE hcodCurrent);
  void FreeReg(register reg);
  void ResetFreeQue(void);
  void AddQueElement(regque *prque, register reg);
  void ResetQue(regque *prque);
  byte NumFreeRegs(void);
  byte NumQueElements(regque rque);
  register GetFreeReg(void);
  register GetSpillable(void);
  register GetQueElement(regque *prque);
  void NewBlock(CODEHANDLE);
  void EndBlock();
  void Emit(int16 opcode, byte op1Type, long32 op1, byte op2Type, long32 op2,
	    byte destType, long32 dest);
  void PrintAsm(CODE pcodSource, FILE *fOut);
  void InitRegMgr(void);
  /* flushes rFlush back to memory */
  void FlushReg(register rFlush, CODEHANDLE hcodCurrent);
  /* record all the "live" registers */
  void SaveRegState(void);
  /* returns all regs to state they */
  void RestoreRegState(CODEHANDLE hcodCurrent);
  /* allocates a register for nVar */
  register GetReg(int16 nVar, CODEHANDLE hcodCurrent, bool bLoad);
typedef Cam8SimSPARCCore *CAM8SIMSPARCCORE;
/*****************************************************************************/
/********************************* INLINES ***********************************/
/*****************************************************************************/
#endif
/*****************************************************************************/
/******************************* PROTOTYPES **********************************/
/*****************************************************************************/
/*****************************************************************************/
/********************************* GLOBALS ***********************************/
/*****************************************************************************/
#endif
#ifndef _CAM8SIMCORE_H_
#define _CAM8SIMCORE_H_
#include <CamLib++.H>
#include <Cam8Core++.H>
#include "std++.H"
/*****************************************************************************/
/********************************* DEFINES ***********************************/
/*****************************************************************************/
#define PERM_CONST_1            31                                               
#define PERM_CONST_0            30
#define LONG32_SIZE		(sizeof(long32))
#define INT16_SIZE		(sizeof(int16))
#define ACTIVE_LUT_SELECT	0x8000	 /* bit in Hardware Env Reg (HER)    */
#define FLD_SELECT(i)		((i) + 32)
#define FLD_MAP(i)		((i) + 64)
#define NUM_DEST		4
#define NUM_SRC			6
#define SRC_SITE_DATA		0
#define SRC_TBUS		1
#define SRC_FLYWHEEL		2
#define SRC_LUT			3
#define SRC_SITE_ADDRESS	3
#define SRC_GLUED_DATA		4
#define SRC_CONST_DATA		5
#define DEST_SITE_DATA		0
#define DEST_EVENT_CT		1
#define DEST_LUT		2
#define DEST_DISPLAY		3
#define MAP_CONST_0		0
#define MAP_G_NOR_S		1
#define MAP_G_AND_S_BAR		2
#define MAP_S_BAR		3
#define MAP_G_BAR_AND_S		4
#define MAP_G_BAR		5
#define MAP_G_XOR_S		6
#define MAP_G_NAND_S		7
#define MAP_G_AND_S		8
#define MAP_G_EQ_S		9
#define MAP_G			10
#define MAP_G_OR_S_BAR		11
#define MAP_S			12
#define MAP_G_BAR_OR_S		13
#define MAP_G_OR_S		14
#define MAP_CONST_1		15
#define HIGHB(x)		(((x) & 0x80000000) ? 0x1 : 0x0)
#ifdef DEBUG
#define EP(name) fprintf(DEBUGFILE, "ENTER: %s\n", name)
#define LP(name) fprintf(DEBUGFILE, "LEAVE: %s\n", name)
#else DEBUG
#define EP(name)
#define LP(name)
#endif DEBUG
#ifdef __cplusplus
/*****************************************************************************/
/******************************** TEMPLATES **********************************/
/*****************************************************************************/
/*****************************************************************************/
/*************************** CLASSES & TYPEDEFS ******************************/
/*****************************************************************************/
typedef unsigned char byte;
typedef byte *BYTE;
typedef unsigned char bool;
typedef bool *BOOL;
typedef unsigned short int16;
typedef int16 *INT16;
struct interface_regs {
    
  long32 NLP;                          /* Next List Pointer            */
  long32 ISR;                          /* Reset/Interrupt Register     */
  long32 CIP;                          /* Current Instruction Pointer  */
  long32 PIP;                          /* Previous Instruction Pointer */
    
  long32 RER;                          /* Reset/Enable Register        */
  long32 DSL;                          /* Display Scan Length          */
  long32 DBL;                          /* Display Blank Length         */
typedef interface_regs *INTERFACE_REGS;
struct Cam8SimModule {
  /* CAM8 Registers */
  byte MSR[CHIPS_PER_MOD];
  byte SSM[CHIPS_PER_MOD];
  byte RT[CHIPS_PER_MOD];
  byte ECT[CHIPS_PER_MOD];
  byte RPK[CHIPS_PER_MOD];
  byte ALT[CHIPS_PER_MOD];
  long32 KA[CHIPS_PER_MOD];
  byte XKS[CHIPS_PER_MOD];
  byte YKS[CHIPS_PER_MOD];
  byte ZKS[CHIPS_PER_MOD];
  byte XKMF[CHIPS_PER_MOD];
  byte YKMF[CHIPS_PER_MOD];
  byte ZKMF[CHIPS_PER_MOD];
  byte SABSR[CHIPS_PER_MOD];
  byte LAS[CHIPS_PER_MOD];
  byte LAM[CHIPS_PER_MOD];
  byte FOS[CHIPS_PER_MOD];
  byte FOM[CHIPS_PER_MOD];
  byte SDS[CHIPS_PER_MOD];
  byte SDM[CHIPS_PER_MOD];
  byte ECS[CHIPS_PER_MOD];
  byte ECM[CHIPS_PER_MOD];
  byte DDS[CHIPS_PER_MOD];
  byte DDM[CHIPS_PER_MOD];
  byte SSR[CHIPS_PER_MOD];
  long32 ECR[CHIPS_PER_MOD];
  int16 LIR[CHIPS_PER_MOD];
  byte LIPR[CHIPS_PER_MOD];
  int16 *LIOR;
  long32 SIR[CHIPS_PER_MOD];
  byte SSA[24][CHIPS_PER_MOD];
  byte *SIOR;
  byte SM[CHIPS_PER_MOD];
  byte ESC[CHIPS_PER_MOD];
  byte ESW[CHIPS_PER_MOD];
  byte EST[CHIPS_PER_MOD];
  byte SBRC[CHIPS_PER_MOD];
  byte RCL[CHIPS_PER_MOD];
  byte ECL[CHIPS_PER_MOD];
  byte STM[CHIPS_PER_MOD];
  long32 OSR[CHIPS_PER_MOD];
  long32 DCM[CHIPS_PER_MOD];
  byte XDCP[CHIPS_PER_MOD];
  byte YDCP[CHIPS_PER_MOD];
  byte ZDCP[CHIPS_PER_MOD];
  byte LPL[CHIPS_PER_MOD];
  byte FPL[CHIPS_PER_MOD];
  byte DCS[CHIPS_PER_MOD];
  byte TBD[CHIPS_PER_MOD];
  byte TMS[CHIPS_PER_MOD];
  byte NBF[CHIPS_PER_MOD];
  byte SRE[CHIPS_PER_MOD];
  byte ALS[CHIPS_PER_MOD];
  byte MAFS[CHIPS_PER_MOD];
  byte MBFS[CHIPS_PER_MOD];
  byte XMPC[CHIPS_PER_MOD];
  byte XPPC[CHIPS_PER_MOD];
  byte YMPC[CHIPS_PER_MOD];
  byte YPPC[CHIPS_PER_MOD];
  byte ZMPC[CHIPS_PER_MOD];
  byte ZPPC[CHIPS_PER_MOD];
  byte MIDR[CHIPS_PER_MOD];
  byte GIDR[CHIPS_PER_MOD];
  byte BPIE[CHIPS_PER_MOD];
  byte BCIE[CHIPS_PER_MOD];
  byte GCIE[CHIPS_PER_MOD];
  byte MAIE[CHIPS_PER_MOD];
  byte MBIE[CHIPS_PER_MOD];
  byte SSIE[CHIPS_PER_MOD];
  byte XHIE[CHIPS_PER_MOD];
  byte RLIE[CHIPS_PER_MOD];
  byte URIE[CHIPS_PER_MOD];
  byte ISIE[CHIPS_PER_MOD];
  byte BPIF[CHIPS_PER_MOD];
  byte BCIF[CHIPS_PER_MOD];
  byte GCIF[CHIPS_PER_MOD];
  byte MAIF[CHIPS_PER_MOD];
  byte MBIF[CHIPS_PER_MOD];
  byte SSIF[CHIPS_PER_MOD];
  byte XHIF[CHIPS_PER_MOD];
  byte RLIF[CHIPS_PER_MOD];
  byte URIF[CHIPS_PER_MOD];
  byte ISIF[CHIPS_PER_MOD];
  byte VWE[CHIPS_PER_MOD];
  byte VWIE[CHIPS_PER_MOD];
  byte VWIF[CHIPS_PER_MOD];
  byte LDOC[CHIPS_PER_MOD];
  byte HDOC[CHIPS_PER_MOD];
  byte *FRAMEb;							/* FRAME buffer */
  unsigned short nNumPlanes;
  byte WhyScan;
  bool bDestSrcMatrix [CHIPS_PER_MOD][NUM_DEST][NUM_SRC];
  bool bSourceRegChange;
  bool bDestChange;
  bool bForceGeneralScan;
  bool bByteMode;
  bool bImmediate;
  bool bReadMode;
typedef struct {
  char *base;
  int type;
} Bt, *BT;
class Cam8SimCore : public Cam8Core {
public:
  interface_regs iregs;
  int VWECHK;
  char debug;
  Bt base_type[790];
  bool bDestSrcMatrix [CHIPS_PER_MOD][NUM_DEST][NUM_SRC];
  bool bSourceRegChange;
  bool bDestChange;
  bool bForceGeneralScan;
  bool bByteMode;
  bool bImmediate;
  bool bReadMode;
  int16 *LUTb[2];			/* LUT buffers */
  long32 SITE_ADDR;
  long32 lDCMRHighBit;
  long32 lDCMRLowBit;
  long32 lNumXBits;
  long32 bit;
  long32 HIGH_BIT_MASK;
  long32 X_HIGH_BIT_MASK;
  long32 X_byte_LENGTH;
  long32 X_CTR;
  long32 SITE_CTR;
  long32 OFFSETS[CHIPS_PER_MOD];
  long32 BIT_OFFSETS[CHIPS_PER_MOD];
  long32 DCMR;
  long32 SCAN_INDEX_REG;
  long32 LUT_ADDR;
  long32 BIT_PLANE_ADDR[CHIPS_PER_MOD];
  long32 NEXT_WORD_ADDR[CHIPS_PER_MOD];
  long32 PLANE_WORD[CHIPS_PER_MOD];
  long32 EVENT_COUNT[CHIPS_PER_MOD];
  long32 UNGLUE_DATA;
  long32 GLUE_DATA;
  long32 SITE_DATA;
  long32 TBUS_DATA;
  long32 LUT_DATA;
  long32 DISP_DATA;
  long32 TBUS_ADDR;
  long32 FRAME_ADDR;
  long32 TEMP1;
  long32 TEMP2;
  long32 TEMP3;
  long32 TEMP4;
  long32 TEMP5;
  long32 TEMP6;
  long32 TEMP7;
  long32 TEMP8;
  long32 TEMP9;
  long32 TEMP10;
  FILE* DEBUGFILE;
  struct timeval tvStart, tvEnd;
  struct timezone tzZone;
  Cam8SimCore(void);
  DECL_COPYCONST(Cam8SimCore);
  virtual ~Cam8SimCore(void);
  DECL_BZERO(Cam8SimCore);
  DECL_BCOPY(Cam8SimCore);
  DECL_BCMP(Cam8SimCore);
  // These are virtual from Cam8Core
  void ResetInterface(void);
  void InitInterface(void);
  void ExecuteSteplist(struct steplist_operation &);
  void Read_NLP(long32 *);
  void Read_ISR(long32 *);
  void Read_CIP(long32 *);
  void Read_PIP(long32 *);
  void Write_NLP(const long32 *);
  void Write_RER(const long32 *);
  void Write_DSL(const long32 *);
  void Write_DBL(const long32 *);
  void InitSimulator(Cam8Core *);
  void InitStepList(void);
  void UnpackState(int16 *, int, int);
  void UnpackStateInto(int16 *, int, int, byte *, int);
  void PackState(int16 *, int);
  void PackStateFrom(int16 *, int, byte *, int);
  void InitModule(void);
  void SimStepList(long32 *plFirstInstr);
  void SimScan(void);
  void UpdateDCMR(void);
  void UpdateDestSrcMatrix(void);
  void UpdateDCMR();
  void UpdateDestSrcMatrix();
  unsigned short CalcNumPlanes();
  unsigned short CalcNumPlanes(void);
  bool IsSrcNeeded(short nSrc);
  bool IsSrcSame(short nDest);
  bool IsDestUpdated(short nDest);
  bool IsSrcNeeded(short nSrc);
  bool IsSrcSame(short nDest);
  bool IsDestUpdated(short nDest);
  long32 AddSiteAddress(long32 lSrc1, long32 lSrc2);
  long32 SubSiteAddress(long32 lSrc1, long32 lSrc2);
  long32 ScanLength(void);
  long32 SweepLength(long32 *lFirstSweep);
  long32 AddSiteAddress(long32 lSrc1, long32 lSrc2);
  long32 SubSiteAddress(long32 lSrc1, long32 lSrc2);
  long32 ScanLength();
  long32 SweepLength(long32 *lFirstSweep);
  long32 DCMRHighBit();
  long32 DCMRLowBit();
  virtual void SimScanNoPerm(void);
  virtual void SimGeneralScan(void);
  virtual void SimUpdateSite(void);
  virtual void CheckNoPerm(void);
  virtual void SimLoadFirstWord(long32 nBitOffset[]);
  virtual void SimGetNextWord(unsigned short nPlane);
  virtual void SimSaaveLastWord(long32 nBitOffset[]);
  virtual void SimUpdateCode(void);
  virtual void SimLoadPlaneWords(void);
  virtual void SimSavePlaneWords(void);
  virtual void MapFunction(long32 *SrcVar, long32 *DestVar, byte bMap);
  virtual void BuildDest(short nDest, long32 *DestVar, byte Src, byte Map);
  virtual void BuildBitDest(short nDest, long32 *HoldReg, byte Src, byte Map, unsigned short nPlane);
  virtual void BuildBitwiseDest(short nDest, long32 *DestVar, byte Src[], byte Map[]);
  virtual long32 *PermuteScanIndex(void);
  inline void ReadCmdLine(int, char *[]);
  inline void ConstantSetAll(byte r[], byte v);
  inline void ConstantSetAll(int16 r[], int16 v);
  inline void ConstantSetAll(long32 r[], long32 v);
  inline void SetAll(byte r[], byte v[]);
  inline void SetAll(int16 r[], int16 v[]);
  inline void SetAll(long32 r[], long32 v[]);
protected:
  inline void SENTER(int i, char *b, int t);
/*****************************************************************************/
/********************************* INLINES ***********************************/
/*****************************************************************************/
inline void Cam8SimCore::ReadCmdLine(int argc, char *argv[])
  register int i;
  for(i = 1; i < argc; i++) {
    if (strcmp(argv[i], "-g") == 0) {
      bForceGeneralScan = TRUE;
      continue;
    }
inline void Cam8SimCore::SENTER(int i, char *b, int t)
  base_type[i].base = b;
  base_type[i].type = t;
inline void Cam8SimCore::ConstantSetAll(byte r[], byte v)
  register int i;
  for(i = 0; i < CHIPS_PER_MOD; i++)
    r[i]=v;
inline void Cam8SimCore::ConstantSetAll(int16 r[], int16 v)
  register int i;
  for(i = 0; i < CHIPS_PER_MOD; i++)
    r[i]=v;
inline void Cam8SimCore::ConstantSetAll(long32 r[], long32 v)
  register int i;
  for(i = 0; i < CHIPS_PER_MOD; i++)
    r[i]=v;
inline void Cam8SimCore::SetAll(byte r[], byte v[])
  memcpy(r, v, CHIPS_PER_MOD * sizeof(byte));
inline void Cam8SimCore::SetAll(int16 r[], int16 v[])
  memcpy(r, v, CHIPS_PER_MOD * sizeof(byte));
inline void Cam8SimCore::SetAll(long32 r[], long32 v[])
  memcpy(r, v, CHIPS_PER_MOD * sizeof(byte));
#endif
/*****************************************************************************/
/******************************* PROTOTYPES **********************************/
/*****************************************************************************/
/*****************************************************************************/
/********************************* GLOBALS ***********************************/
/*****************************************************************************/
#endif
 ORNcc		(NATIVE_OP | 0x16)
#define XOR		(NATIVE_OP | 0x03)
#define XORcc 		(NATIVE_OP | 0x13)
#define XNOR		(NATIVE_OP | 0x07)
#define XNORcc		(NATIVE_OP | 0x17)
#define SH_LEFT		(NATIVE_OP | 0x25)
#define SH_RIGHT	(NATIVE_OP | 0x26)
#define SH_RIGHT_ARITH	(NATIVE_OP | 0x27)
#define BRANCH		(BRANCH_OP | 0x08)
#define BR_NEVER	(BRANCH_OP | 0x00)
#define BR_NEQ		(BRANCH_OP | 0x09)
#define BR_EQ		(BRANCH_OP | 0x01)
#define BR_GR		(BRANCH_OP | 0x0A)
#define BR_LE		(BRANCH_OP | 0x02)
#define BR_GRE		(BRANCH_OP | 0x0B)
#define BR_L		(BRANCH_OP | 0x03)
#define BR_GU		(BRANCH_OP | 0x0C)
#define BR_LEU		(BRANCH_OP | 0x04)
#define BR_CC		(BRANCH_OP | 0x0D)
#define BR_CS		(BRANCH_OP | 0x05)
#define BR_POS		(BRANCH_OP | 0x0E)
#define BR_NEG		(BRANCH_OP | 0x06)
#define BR_VC		(BRANCH_OP | 0x0F)
#define BR_VS		(BRANCH_OP | 0x07)
#define BR_NZ		(BRANCH_OP | 0x09)
#define BR_Z		(BRANCH_OP | 0x01)
#define OP_LDW		0x00L
#define OP_LDHW		0x02L
#define OP_LDUB		0x01L
#define OP_STW		0x04L
#define OP_STUB		0x05L
#define OP_STHW		0x06L
#define OP_ADD		0x00L
#define OP_ADDcc	0x10L
#define OP_ADDX		0x08L
#define OP_ADDXcc	0x18L
#define	OP_SUB		0x04L
#define OP_SUBcc	0x14L
#define OP_SUBX		0x0CL
#define OP_SUBXcc	0x1CL
#define OP_AND		0x01L
#define OP_ANDcc	0x11L
#define OP_ANDN		0x05L
#define OP_ANDNcc	0x15L
#define OP_OR		0x02L
#define OP_ORcc 	0x12L
#define OP_ORN		0x06L
#define OP_ORNcc	0x16L
#define OP_XOR		0x03L
#define OP_XORcc 	0x13L
#define OP_XNOR		0x07L
#define OP_XNORcc	0x17L
#define OP_SLL		0x25L
#define OP_SRL		0x26L
#define OP_SRA		0x27L
#define OP_SETHI	0x04L
#define OP_JMPL		0x38L
#define OP_SAVE		0x3CL
#define OP_RESTORE	0x3DL
#define IMMEDIATE	1
#define REG_SOURCE	0
#define FMT2_INST(op, opcode, k, rd) 	(((op) << 30) | \
					 ((opcode) << 22) | \
					 ((rd) << 25) | \
					 ((k) & 0x3fffffL))
#define FMT3_INST(op, opcode, rs1, i, rs2, rd) (((op) << 30) | \
						((rd) << 25) | \
						((opcode) << 19) | \
		       				((rs1) << 14) | \
						((i) << 13) | \
						((rs2) & 0x1FFFL))
#define SAVE_REG_IMM(rs1, k, rd)	(FMT3_INST(0x2L, OP_SAVE, (rs1), IMMEDIATE, (k), (rd)))
#define SAVE_REG_REG(rs1, rs2, rd)	(FMT3_INST(0x2L, OP_SAVE, (rs1), REG_SOURCE, (rs2), (rd)))
#define RESTORE				(FMT3_INST(0x2L, OP_RESTORE, REG_G0, REG_SOURCE, REG_G0, REG_G0))
#define RET				(FMT3_INST(0x2L, OP_JMPL, REG_I7, IMMEDIATE, 8, REG_G0))
#define RETL				(FMT3_INST(0x2L, OP_JMPL, REG_O7, IMMEDIATE, 8, REG_G0))
#define CALL_REG(r)			(FMT3_INST(0x2L, OP_JMPL, (r), IMMEDIATE, 0, REG_O7))
#define CALL_REG_IMM(r, k) 		(FMT3_INST(0x2L, OP_JMPL, (r), IMMEDIATE, (k), REG_O7))
#define CALL(disp)			((0x01 << 30) | (((unsigned long) (disp)) >> 2))
#define NOP				(FMT3_INST(0x2L, OP_OR, REG_G0, REG_SOURCE, REG_G0, REG_G0))
#define LDW_REG_IMM(rs1, k, rd) 	(FMT3_INST(0x3L, OP_LDW, rs1, IMMEDIATE, k, rd))
#define LDW_REG_REG(rs1, rs2, rd) 	(FMT3_INST(0x3L, OP_LDW, rs1, REG_SOURCE, rs2, rd))
#define LDHW_REG_IMM(rs1, k, rd) 	(FMT3_INST(0x3L, OP_LDHW, rs1, IMMEDIATE, k, rd))
#define LDHW_REG_REG(rs1, rs2, rd) 	(FMT3_INST(0x3L, OP_LDHW, rs1, REG_SOURCE, rs2, rd))
#define LDUB_REG_IMM(rs1, k, rd) 	(FMT3_INST(0x3L, OP_LDUB, rs1, IMMEDIATE, k, rd))
#define LDUB_REG_REG(rs1, rs2, rd) 	(FMT3_INST(0x3L, OP_LDUB, rs1, REG_SOURCE, rs2, rd))
#define STW_REG_IMM(rs1, k, rd) 	(FMT3_INST(0x3L, OP_STW, rs1, IMMEDIATE, k, rd))
#define STW_REG_REG(rs1, rs2, rd) 	(FMT3_INST(0x3L, OP_STW, rs1, REG_SOURCE, rs2, rd))
#define STHW_REG_IMM(rs1, k, rd) 	(FMT3_INST(0x3L, OP_STHW, rs1, IMMEDIATE, k, rd))
#define STHW_REG_REG(rs1, rs2, rd) 	(FMT3_INST(0x3L, OP_STHW, rs1, REG_SOURCE, rs2, rd))
#define STUB_REG_IMM(rs1, k, rd) 	(FMT3_INST(0x3L, OP_STUB, rs1, IMMEDIATE, k, rd))
#define STUB_REG_REG(rs1, rs2, rd) 	(FMT3_INST(0x3L, OP_STUB, rs1, REG_SOURCE, rs2, rd))
#define ADD_REG_IMM(rs1, k, rd) 	(FMT3_INST(0x2L, OP_ADD, rs1, IMMEDIATE, k, rd))
#define ADD_REG_REG(rs1, rs2, rd) 	(FMT3_INST(0x2L, OP_ADD, rs1, REG_SOURCE, rs2, rd))
#define ADDcc_REG_IMM(rs1, k, rd) 	(FMT3_INST(0x2L, OP_ADDcc, rs1, IMMEDIATE, k, rd))
#define ADDcc_REG_REG(rs1, rs2, rd) 	(FMT3_INST(0x2L, OP_ADDcc, rs1, REG_SOURCE, rs2, rd))
#define ADDX_REG_IMM(rs1, k, rd) 	(FMT3_INST(0x2L, OP_ADDX, rs1, IMMEDIATE, k, rd))
#define ADDX_REG_REG(rs1, rs2, rd) 	(FMT3_INST(0x2L, OP_ADDX, rs1, REG_SOURCE, rs2, rd))
#define ADDXcc_REG_IMM(rs1, k, rd) 	(FMT3_INST(0x2L, OP_ADDXcc, rs1, IMMEDIATE, k, rd))
#define ADDXcc_REG_REG(rs1, rs2, rd) 	(FMT3_INST(0x2L, OP_ADDXcc, rs1, REG_SOURCE, rs2, rd))
#define SUB_REG_IMM(rs1, k, rd) 	(FMT3_INST(0x2L, OP_SUB, rs1, IMMEDIATE, k, rd))
#define SUB_REG_REG(rs1, rs2, rd) 	(FMT3_INST(0x2L, OP_SUB, rs1, REG_SOURCE, rs2, rd))
#define SUBcc_REG_IMM(rs1, k, rd) 	(FMT3_INST(0x2L, OP_SUBcc, rs1, IMMEDIATE, k, rd))
#define SUBcc_REG_REG(rs1, rs2, rd) 	(FMT3_INST(0x2L, OP_SUBcc, rs1, REG_SOURCE, rs2, rd))
#define SUBX_REG_IMM(rs1, k, rd) 	(FMT3_INST(0x2L, OP_SUBX, rs1, IMMEDIATE, k, rd))
#define SUBX_REG_REG(rs1, rs2, rd) 	(FMT3_INST(0x2L, OP_SUBX, rs1, REG_SOURCE, rs2, rd))
#define SUBXcc_REG_IMM(rs1, k, rd) 	(FMT3_INST(0x2L, OP_SUBXcc, rs1, IMMEDIATE, k, rd))
#define SUBXcc_REG_REG(rs1, rs2, rd) 	(FMT3_INST(0x2L, OP_SUBXcc, rs1, REG_SOURCE, rs2, rd))
#define AND_REG_IMM(rs1, k, rd) 	(FMT3_INST(0x2L, OP_AND, rs1, IMMEDIATE, k, rd))
#define AND_REG_REG(rs1, rs2, rd) 	(FMT3_INST(0x2L, OP_AND, rs1, REG_SOURCE, rs2, rd))
#define OR_REG_IMM(rs1, k, rd) 		(FMT3_INST(0x2L, OP_OR, rs1, IMMEDIATE, k, rd))
#define OR_REG_REG(rs1, rs2, rd) 	(FMT3_INST(0x2L, OP_OR, rs1, REG_SOURCE, rs2, rd))
#define XOR_REG_IMM(rs1, k, rd) 	(FMT3_INST(0x2L, OP_XOR, rs1, IMMEDIATE, k, rd))
#define XOR_REG_REG(rs1, rs2, rd) 	(FMT3_INST(0x2L, OP_XOR, rs1, REG_SOURCE, rs2, rd))
#define XNOR_REG_IMM(rs1, k, rd) 	(FMT3_INST(0x2L, OP_XNOR, rs1, IMMEDIATE, k, rd))
#define XNOR_REG_REG(rs1, rs2, rd) 	(FMT3_INST(0x2L, OP_XNOR, rs1, REG_SOURCE, rs2, rd))
#define NOT_REG(r)			(XNOR_REG_REG(r, REG_G0, r))
#define SLL_REG_IMM(rs1, k, rd) 	(FMT3_INST(0x2L, OP_SLL, rs1, IMMEDIATE, k, rd))
#define SLL_REG_REG(rs1, rs2, rd) 	(FMT3_INST(0x2L, OP_SLL, rs1, REG_SOURCE, rs2, rd))
#define SRL_REG_IMM(rs1, k, rd) 	(FMT3_INST(0x2L, OP_SRL, rs1, IMMEDIATE, k, rd))
#define SRL_REG_REG(rs1, rs2, rd) 	(FMT3_INST(0x2L, OP_SRL, rs1, REG_SOURCE, rs2, rd))
#define HI22(k) 			((((unsigned long) (k)) >> 10) & 0x3fffffL)
#define LOW10(k) 			(((unsigned long) (k)) & 0x3ffL)
#define SETHI(k, rd) 			(FMT2_INST(0x0L, OP_SETHI, k, rd))
/******************************************************************************
 * The branch instructions.
 *****************************************************************************/
#define BRANCH_INST(annul, cond, disp)	(((annul) << 29) | ((cond) << 25) | (0x800000) | ((disp) & 0x3FFFFF))
#define BRA(disp)			(BRANCH_INST(0, 0x8, disp))
#define BRN(disp)			(BRANCH_INST(0, 0x0, disp))
#define BRNE(disp)			(BRANCH_INST(0, 0x9, disp))
#define BRE(disp)			(BRANCH_INST(0, 0x1, disp))
#define BRG(disp)			(BRANCH_INST(0, 0xA, disp))
#define BRLE(disp)			(BRANCH_INST(0, 0x2, disp))
#define BRGE(disp)			(BRANCH_INST(0, 0xB, disp))
#define BRL(disp)			(BRANCH_INST(0, 0x3, disp))
#define BRGU(disp)			(BRANCH_INST(0, 0xC, disp))
#define BRLEU(disp)			(BRANCH_INST(0, 0x4, disp))
#define BRCC(disp)			(BRANCH_INST(0, 0xD, disp))
#define BRCS(disp)			(BRANCH_INST(0, 0x5, disp))
#define BRPOS(disp)			(BRANCH_INST(0, 0xE, disp))
#define BRNEG(disp)			(BRANCH_INST(0, 0x6, disp))
#define BRVC(disp)			(BRANCH_INST(0, 0xF, disp))
#define BRVS(disp)			(BRANCH_INST(0, 0x7, disp))
#define BRNZ(disp)			(BRANCH_INST(0, 0x9, disp))
#define BRZ(disp)			(BRANCH_INST(0, 0x1, disp))
/*****************************************************************************/
/*                                                                           */
/* Macros to insert target instructions etc.				     */
/*                                                                           */
/*****************************************************************************/
#define EMIT(inst)			*pcodNext++ = (inst)
#define CURRENT_LOC			(pcodNext)
#define CURRENT_HANDLE			(&pcodNext)
#ifdef DEBUG
#define ASCODE(c)  fprintf(DEBUGFILE, "\t0x%x: %s\n", DASMADDR, c); fflush(DEBUGFILE)
#define ASNOTE(c)  fprintf(DEBUGFILE, "\t%s\n", c); fflush(DEBUGFILE)
#else DEBUG
#define ASCODE(name)
#define ASNOTE(c)
#endif DEBUG
#ifdef __cplusplus
/*****************************************************************************/
/******************************** TEMPLATES **********************************/
/*****************************************************************************/
/*****************************************************************************/
/*************************** CLASSES & TYPEDEFS ******************************/
/*****************************************************************************/
typedef unsigned short codelabel;
typedef unsigned long code;
typedef code *CODE;
typedef CODE *CODEHANDLE;
typedef unsigned long register;
struct tag_regEntry {	/* Describes register contents */
  int16	nVar;			/* Name (index) of variable */
  int16	nPriority;		/* Priority of variable */
  int16	nHeapOffset;		/* Offset into heap of variable */
typedef struct tag_regEntry regentry;
typedef regentry *REGENTRY;
struct tag_regQue {
  register rRegQue[MREGS];
  byte bHead;
  byte bTail;
  byte bNumElements;
typedef struct tag_regQue regque;
/* record of a label */
struct tag_lblrec {
     int16	lblName;
     byte	bValid;
     CODE	lAddress;
     struct tag_lblref *prefFirst;
     struct tag_lblrec *precNext;
typedef tag_lblrec labelrec;
typedef labelrec *LABELREC;
struct tag_codeblk {
     CODEHANDLE hcodTarget;
     CODE    pcodNext;
     codelabel	lblNext;
     labelrec   *plblrecFirst;
     struct tag_codeblk *pblkPrev;
typedef tag_codeblk codeblk;
typedef codeblk *CODEBLK;
/* record of a reference to a label */
struct tag_lblref {
     CODE	pcodRefLoc;
     struct tag_lblref *prefNext;
typedef tag_lblref labelref;
class Cam8SimSPARCCore : public Cam8SimCore {
public:
  static const char *szRegName[] = {
    "%g0", "%g1", "%g2", "%g3", "%g4", "%g5", "%g6", "%g7",
    "%o0", "%o1", "%o2", "%o3", "%o4", "%o5", "%sp", "%tp",
    "%l0", "%l1", "%l2", "%l3", "%l4", "%l5", "%l6", "%l7",
    "%i0", "%i1", "%i2", "%i3", "%i4", "%i5", "%ds", "%ra"
  };
  static const char *szCCName[] = {
    "NEVER", "EQ", "LE", "L", "LEU", "CS", "NEG", "VS",
    "ALWAYS", "NEQ", "G", "GE", "GU", "CC", "POS", "VC"
  };
  static char registerS[32][64] = {
    "G0", "G1", "G2", "G3", "G4", "G5", "G6", "G7",
    "O0", "O1", "O2", "O3", "O4", "O5", "O6", "O7",
    "L0", "L1", "L2", "L3", "L4", "L5", "L6", "L7",
    "I0", "I1", "I2", "I3", "I4", "I5", "I6", "I7",
  };
  char SYMBOLS[SymbolTableSize][64];
  regentry rCurrWindow[MREGS];
  regque rqueFree;
  regque rqueSpillable[4];							 /* Que of spillable registers, one  */
  labelrec *plblrecFirst;
  CODE pcodScanNoPerm;
  CODE pcodGenUpdate;
  CODE pcodScanner;
  CODE pcodSweep;
  CODE pcodUpdateSite;
  CODE pcodNext;		/* Pointer to location of next inst */
  CODEHANDLE hcodTarget;	/* Handle to Target Code Location */
  codelabel lblNext;		/* Next Label */
  codeblk *pblkTOS;
#ifdef DEBUG
  CODE DASMADDR;
#endif DEBUG
#ifdef _INSTRUMENTATION_
  struct timeval tvStart, tvEnd;
  struct timezone tzZone;
#endif
  Cam8SimSPARCCore(void);
  DECL_COPYCONST(Cam8SimSPARCCore);
  virtual ~Cam8SimSPARCCore(void);
  DECL_OPEQ(Cam8SimSPARCCore);
  DECL_BZERO(Cam8SimSPARCCore);
  DECL_BCOPY(Cam8SimSPARCCore);
  DECL_BCMP(Cam8SimSPARCCore);
  void InitSim(void);
  void SimScanNoPerm(CODEHANDLE hcodCurrent);
  void SimGeneralScan(CODEHANDLE hcodCurrent);
  void SimPrologue(CODEHANDLE hcodCurrent);
  void SimEpilogue(CODEHANDLE hcodCurrent);
  void SimUpdateSite();
  void SimLoadFirstWord(unsigned short nBitOffset[]);
  void SimGetNextWord(unsigned short nPlane);
  void SimSaveLastWord(unsigned short nBitOffset[]);
  void CheckNoPerm(CODEHANDLE hcodCurrent);
  void SimUpdateCode();
  void SimLoadPlaneWords();
  void SimSavePlaneWords();
  void MapFunction (short iSrcVar, short iDestVar, byte bMap);
  void BuildDest(short nDest, short iDestVar, byte Src, byte Map);
  void BuildBitDest(short nDest, short iHoldReg, byte Src, byte Map, unsigned short nPlane);
  void BuildBitwiseDest(short nDest, short iDestVar, byte Src[], byte Map[]);
  short PermuteScanIndex();
  void InsertSpillable(register reg);
  void ResetSpillQue(void);
  void PushRegWindow(void);
  void PopRegWindow(CODEHANDLE hcodCurrent);
  void FreeReg(register reg);
  void ResetFreeQue(void);
  void AddQueElement(regque *prque, register reg);
  void ResetQue(regque *prque);
  byte NumFreeRegs(void);
  byte NumQueElements(regque rque);
  register GetFreeReg(void);
  register GetSpillable(void);
  register GetQueElement(regque *prque);
  void NewBlock(CODEHANDLE);
  void EndBlock();
  void Emit(int16 opcode, byte op1Type, long32 op1, byte op2Type, long32 op2,
	    byte destType, long32 dest);
  void PrintAsm(CODE pcodSource, FILE *fOut);
  void InitRegMgr(void);
  /* flushes rFlush back to memory */
  void FlushReg(register rFlush, CODEHANDLE hcodCurrent);
  /* record all the "live" registers */
  void SaveRegState(void);
  /* returns all regs to state they */
  void RestoreRegState(CODEHANDLE hcodCurrent);
  /* allocates a register for nVar */
  register GetReg(int16 nVar, CODEHANDLE hcodCurrent, bool bLoad);
typedef Cam8SimSPARCCore *CAM8SIMSPARCCORE;
/*****************************************************************************/
/********************************* INLINES ***********************************/
/*****************************************************************************/
#endif
/*****************************************************************************/
/******************************* PROTOTYPES **********************************/
/*****************************************************************************/
/*****************************************************************************/
/********************************* GLOBALS ***********************************/
/*****************************************************************************/
#endif

---------------------------------------------------------------------------

** Rename everything.
---------------------------------------------------------------------------
What we really want is one object that handles parsing the steplist
and another that handles compiling and running the steplist.  That way
we can code multiple versions of the object for compiling and
running on different architectures.
Problem: A major part of the problem is that the process of parsing
the steplist involves the setting of flags that will be used for
optimization during compilation and execution.  To make matters worse
each object needs to have a private copy of the register set and
flags.  These registers and flags are written to and read from during
steplist parsing.  So it becomes a real pain if the object that
handles parsing is different from the object that handles execution.
IDEAS:
1) We could keep just one object (Cam8Sim) and simulate the multiple
modules with multiple threads.  Each thread would have a private copy
of the register set but there would be some collection of shared data.
2) We could use MPI or PVM to simulate the multiple modules.
3) We could handle the problem of optimization flags by keeping them
in a structure instead of using global variables as we do now.  We
handle the problem of separate copies of the register set similarly.
In fact we can use the same structure for both.  The tricky part is
that modules can be individually selected so we need a separate
structure for each module we simulate and the structures need to be
carefully updates by the object that handles parsing.  This structure
gets passed to the object that handles execution.  Probably we still
want to use threads to simulate multiple modules.
SOLUTION:
Officially we will have two trees of classes.  One will capture the
high-level functionality and be used directly by people coding
experiments.  This tree is rooted at the Cam8 class.  There will be NO
Cam8Sim class.  Instead we will handle the choice between the real
hardware and a simulator using the "core" object described below.
The second tree will capture all of the low-level details of actually
executing CA code.  These are "core" objects and will be rooted at the
Cam8Core class.  The Cam8Core class will define the minimum interface
needed to run the stuff generated by the Cam8 class.  It won't be
abstract so we can provide default versions of the memory allocation
methods.  At a minimum we will need 3 subclasses: Cam8HardwareCore,
Cam8SimCore and Cam8SimPICore.  The Cam8HardwareCore class will
provide access to the real Cam8 hardware.  It will use the device
driver to schedule steplist.  The Cam8SimCore class will provide a
standalone interface to the CAM8 simulator.  With it people can write
experiments that run on any architecture.  This class will also be
used to implement the classic cam8sim program which runs as a
subprocess of the Forth STEP program.  The Cam8SimPICore class will
provide the interface to the cam8sim program (through pipes).  It is
low-priority but usefull for implementin the hybrid STEP program
** Rename everything.
---------------------------------------------------------------------------
What we really want is one object that handles parsing the steplist
and another that handles compiling and running the steplist.  That way
we can code multiple versions of the object for compiling and
running on different architectures.
Problem: A major part of the problem is that the process of parsing
the steplist involves the setting of flags that will be used for
optimization during compilation and execution.  To make matters worse
each object needs to have a private copy of the register set and
flags.  These registers and flags are written to and read from during
steplist parsing.  So it becomes a real pain if the object that
handles parsing is different from the object that handles execution.
IDEAS:
1) We could keep just one object (Cam8Sim) and simulate the multiple
modules with multiple threads.  Each thread would have a private copy
of the register set but there would be some collection of shared data.
2) We could use MPI or PVM to simulate the multiple modules.
3) We could handle the problem of optimization flags by keeping them
in a structure instead of using global variables as we do now.  We
handle the problem of separate copies of the register set similarly.
In fact we can use the same structure for both.  The tricky part is
that modules can be individually selected so we need a separate
structure for each module we simulate and the structures need to be
carefully updates by the object that handles parsing.  This structure
gets passed to the object that handles execution.  Probably we still
want to use threads to simulate multiple modules.
SOLUTION:
Officially we will have two trees of classes.
The first tree will capture the high-level functionality and be used
directly by people coding experiments.  This tree is rooted at the
Cam8 class.  There will be NO Cam8Sim class.  Instead we will handle
the choice between the real hardware and a simulator using the "core"
object described below.
The second tree will capture all of the low-level details of actually
executing CA code.  These are "core" objects and will be rooted at the
Cam8Core class.  The Cam8Core class will define the minimum interface
needed to run the stuff generated by the Cam8 class.  It won't be
abstract so we can provide default versions of the memory allocation
methods.  At a minimum we will need 3 subclasses: Cam8HardwareCore,
Cam8SimCore and Cam8SimPICore.  The Cam8HardwareCore class will
provide access to the real Cam8 hardware.  It will use the device
driver to schedule steplist.  The Cam8SimCore class will provide a
standalone interface to the CAM8 simulator.  With it people can write
experiments that run on any architecture.  This class will also be
used to implement the classic cam8sim program which runs as a
subprocess of the Forth STEP program.  The Cam8SimPICore class will
provide the interface to the cam8sim program (through pipes).  It is
low-priority but usefull for implementing the hybrid STEP program and
when people want to have a separate process for executing their
steplists (this can give a performance increase).
Now the complication is that for the Cam8SimCore class we additionally
want to be able to separate steplist parsing from compilation and
execution.  We want to provide many "backends" for compilation and
execution on many different architectures.  The parsing will be
identical for all of these "backends" so we don't want to duplicate
that code.  To complicate matters even more we want to have an
interpretive version of the simulator core to use on architectures we
haven't developed a compiler for yet.

---------------------------------------------------------------------------

#ifndef _CAM8SIMSPARCCORE_H_
#define _CAM8SIMSPARCCORE_H_
#include <CamLib++.H>
#include <Cam8Core++.H>
#include <Cam8++.H>
#include <Cam8SimJIT++.H>
#include "std++.H"
/*****************************************************************************/
/********************************* DEFINES ***********************************/
/*****************************************************************************/
#define SCANNER_CODE_SIZE       (1024 * LONG32_SIZE)
#define SWEEP_CODE_SIZE         (1024 * LONG32_SIZE)
#define UPDATE_CODE_SIZE        (1024 * LONG32_SIZE)
/*****************************************************************************/
/*                                                                           */
/* operand types to use when calling Emit()				     */
/*                                                                           */
/*****************************************************************************/
#define NULL_OP		0
#define REG_OP		1
#define CONST_OP	2
#define ADDR_OP		3
#define VAR_OP		4
#define LABEL_OP	5
/*****************************************************************************/
/*                                                                           */
/* op codes for emit							     */
/*                                                                           */
/*****************************************************************************/
#define PSEUDO_OP	0x8000
#define NATIVE_OP	0x4000
#define LD_ST_OP	0x2000
#define BRANCH_OP	0x1000
#define NATIVE_OP_MASK	0x3F
#define INSTR		(PSEUDO_OP | 0xFF)
#define ENTER_PROC	(PSEUDO_OP | 0x01)
#define RETURN_PROC	(PSEUDO_OP | 0x02)
#define CALL_PROC	(PSEUDO_OP | 0x03)
#define ENTER_LEAF	(PSEUDO_OP | 0x04)
#define RETURN_LEAF	(PSEUDO_OP | 0x05)
#define CALL_LEAF	(PSEUDO_OP | 0x06)
#define CALL_LEAF_IND	(PSEUDO_OP | 0x07)
#define ENTER_BASICBLK	(PSEUDO_OP | 0x08)
#define RETURN_BASICBLK	(PSEUDO_OP | 0x09)
#define ADD_LABEL	(PSEUDO_OP | 0x0A)
#define NO_OP		(PSEUDO_OP | 0x0B)
#define LDW_MEM		(LD_ST_OP | 0x00)
#define LDW_IND		(LD_ST_OP | 0x01)
#define LDHW_IND	(LD_ST_OP | 0x02)
#define LDUB_IND	(LD_ST_OP | 0x03)
#define STW_MEM		(LD_ST_OP | 0x06)
#define STW_IND		(LD_ST_OP | 0x07)
#define STHW_IND	(LD_ST_OP | 0x08)
#define STUB_IND	(LD_ST_OP | 0x09)
#define ADD		(NATIVE_OP | 0x00)
#define ADDcc		(NATIVE_OP | 0x10)
#define ADDX		(NATIVE_OP | 0x08)
#define ADDXcc		(NATIVE_OP | 0x18)
#define	SUB		(NATIVE_OP | 0x04)
#define SUBcc		(NATIVE_OP | 0x14)
#define SUBX		(NATIVE_OP | 0x0C)
#define SUBXcc		(NATIVE_OP | 0x1C)
#define AND		(NATIVE_OP | 0x01)
#define ANDcc		(NATIVE_OP | 0x11)
#define ANDN		(NATIVE_OP | 0x05)
#define ANDNcc		(NATIVE_OP | 0x15)
#define OR		(NATIVE_OP | 0x02)
#define ORcc 		(NATIVE_OP | 0x12)
#define ORN		(NATIVE_OP | 0x06)
#define ORNcc		(NATIVE_OP | 0x16)
#define XOR		(NATIVE_OP | 0x03)
#define XORcc 		(NATIVE_OP | 0x13)
#define XNOR		(NATIVE_OP | 0x07)
#define XNORcc		(NATIVE_OP | 0x17)
#define SH_LEFT		(NATIVE_OP | 0x25)
#define SH_RIGHT	(NATIVE_OP | 0x26)
#define SH_RIGHT_ARITH	(NATIVE_OP | 0x27)
#define BRANCH		(BRANCH_OP | 0x08)
#define BR_NEVER	(BRANCH_OP | 0x00)
#define BR_NEQ		(BRANCH_OP | 0x09)
#define BR_EQ		(BRANCH_OP | 0x01)
#define BR_GR		(BRANCH_OP | 0x0A)
#define BR_LE		(BRANCH_OP | 0x02)
#define BR_GRE		(BRANCH_OP | 0x0B)
#define BR_L		(BRANCH_OP | 0x03)
#define BR_GU		(BRANCH_OP | 0x0C)
#define BR_LEU		(BRANCH_OP | 0x04)
#define BR_CC		(BRANCH_OP | 0x0D)
#define BR_CS		(BRANCH_OP | 0x05)
#define BR_POS		(BRANCH_OP | 0x0E)
#define BR_NEG		(BRANCH_OP | 0x06)
#define BR_VC		(BRANCH_OP | 0x0F)
#define BR_VS		(BRANCH_OP | 0x07)
#define BR_NZ		(BRANCH_OP | 0x09)
#define BR_Z		(BRANCH_OP | 0x01)
#ifdef DEBUG
#define ASCODE(c)  fprintf(DEBUGFILE, "\t0x%x: %s\n", DASMADDR, c); fflush(DEBUGFILE)
#define ASNOTE(c)  fprintf(DEBUGFILE, "\t%s\n", c); fflush(DEBUGFILE)
#else DEBUG
#define ASCODE(name)
#define ASNOTE(c)
#endif DEBUG
#ifdef __cplusplus
/*****************************************************************************/
/******************************** TEMPLATES **********************************/
/*****************************************************************************/
/*****************************************************************************/
/*************************** CLASSES & TYPEDEFS ******************************/
/*****************************************************************************/
typedef unsigned long   CODE;
typedef unsigned short	CODELABEL;
typedef CODE            *CODEPTR;
typedef CODEPTR         *CODEHANDLE;
struct tag_codeblk {
     CODEHANDLE hcodTarget;
     CODEPTR    pcodNext;
     CODELABEL	lblNext;
     LABELREC   *plblrecFirst;
     struct tag_codeblk *pblkPrev;
typedef tag_codeblk CODEBLK;
/* record of a reference to a label */
struct tag_lblref {
     CODEPTR	pcodRefLoc;
     struct tag_lblref *prefNext;
typedef tag_lblref LABELREF;
/* record of a label */
struct tag_lblrec {
     INT16	lblName;
     BYTE	bValid;
     CODEPTR	lAddress;
     struct tag_lblref *prefFirst;
     struct tag_lblrec *precNext;
typedef tag_lblrec LABELREC;
class Cam8SimSPARCCore : public Cam8SimCore {
public:
  LABELREC *plblrecFirst;
  CODE *pcodScanNoPerm;
  CODEPTR pcodGenUpdate;
  CODEPTR pcodScanner;
  CODEPTR pcodSweep;
  CODEPTR pcodUpdateSite;
  CODEPTR pcodNext;		/* Pointer to location of next inst */
  CODEHANDLE hcodTarget;	/* Handle to Target Code Location */
  CODELABEL lblNext;		/* Next Label */
  CODEBLK *pblkTOS;
#ifdef DEBUG
  CODEPTR DASMADDR;
#endif DEBUG
#ifdef _INSTRUMENTATION_
  struct timeval tvStart, tvEnd;
  struct timezone tzZone;
#endif
  Cam8SimSPARCCore(void);
  DECL_COPYCONST(Cam8SimSPARCCore);
  virtual ~Cam8SimSPARCCore(void);
  DECL_OPEQ(Cam8SimSPARCCore);
  DECL_BZERO(Cam8SimSPARCCore);
  DECL_BCOPY(Cam8SimSPARCCore);
  DECL_BCMP(Cam8SimSPARCCore);
  void InitSim(void);
  void SimScanNoPerm(CODEHANDLE hcodCurrent);
  void SimGeneralScan(CODEHANDLE hcodCurrent);
  void SimPrologue(CODEHANDLE hcodCurrent);
  void SimEpilogue(CODEHANDLE hcodCurrent);
  void SimUpdateSite();
  void SimLoadFirstWord(unsigned short nBitOffset[]);
  void SimGetNextWord(unsigned short nPlane);
  void SimSaveLastWord(unsigned short nBitOffset[]);
  void CheckNoPerm(CODEHANDLE hcodCurrent);
  void SimUpdateCode();
  void SimLoadPlaneWords();
  void SimSavePlaneWords();
  void MapFunction (short iSrcVar, short iDestVar, BYTE bMap);
  void BuildDest(short nDest, short iDestVar, BYTE Src, BYTE Map);
  void BuildBitDest(short nDest, short iHoldReg, BYTE Src, BYTE Map, unsigned short nPlane);
  void BuildBitwiseDest(short nDest, short iDestVar, BYTE Src[], BYTE Map[]);
  short PermuteScanIndex();
typedef Cam8SimSPARCCore *CAM8SIMSPARCCORE;
/*****************************************************************************/
/********************************* INLINES ***********************************/
/*****************************************************************************/
#endif
/*****************************************************************************/
/******************************* PROTOTYPES **********************************/
/*****************************************************************************/
/*****************************************************************************/
/********************************* GLOBALS ***********************************/
/*****************************************************************************/
#endif
#ifndef _CAM8SIMSPARCJIT_H_
#define _CAM8SIMSPARCJIT_H_
#include <CamLib++.H>
#include <Cam8SimSPARCRegMgr++.H>
#include "std++.H"
/*****************************************************************************/
/********************************* DEFINES ***********************************/
/*****************************************************************************/
#define OP_LDW		0x00L
#define OP_LDHW		0x02L
#define OP_LDUB		0x01L
#define OP_STW		0x04L
#define OP_STUB		0x05L
#define OP_STHW		0x06L
#define OP_ADD		0x00L
#define OP_ADDcc	0x10L
#define OP_ADDX		0x08L
#define OP_ADDXcc	0x18L
#define	OP_SUB		0x04L
#define OP_SUBcc	0x14L
#define OP_SUBX		0x0CL
#define OP_SUBXcc	0x1CL
#define OP_AND		0x01L
#define OP_ANDcc	0x11L
#define OP_ANDN		0x05L
#define OP_ANDNcc	0x15L
#define OP_OR		0x02L
#define OP_ORcc 	0x12L
#define OP_ORN		0x06L
#define OP_ORNcc	0x16L
#define OP_XOR		0x03L
#define OP_XORcc 	0x13L
#define OP_XNOR		0x07L
#define OP_XNORcc	0x17L
#define OP_SLL		0x25L
#define OP_SRL		0x26L
#define OP_SRA		0x27L
#define OP_SETHI	0x04L
#define OP_JMPL		0x38L
#define OP_SAVE		0x3CL
#define OP_RESTORE	0x3DL
#define IMMEDIATE	1
#define REG_SOURCE	0
#define FMT2_INST(op, opcode, k, rd) 	(((op) << 30) | \
					 ((opcode) << 22) | \
					 ((rd) << 25) | \
					 ((k) & 0x3fffffL))
#define FMT3_INST(op, opcode, rs1, i, rs2, rd) (((op) << 30) | \
						((rd) << 25) | \
						((opcode) << 19) | \
		       				((rs1) << 14) | \
						((i) << 13) | \
						((rs2) & 0x1FFFL))
#define SAVE_REG_IMM(rs1, k, rd)	(FMT3_INST(0x2L, OP_SAVE, (rs1), IMMEDIATE, (k), (rd)))
#define SAVE_REG_REG(rs1, rs2, rd)	(FMT3_INST(0x2L, OP_SAVE, (rs1), REG_SOURCE, (rs2), (rd)))
#define RESTORE				(FMT3_INST(0x2L, OP_RESTORE, REG_G0, REG_SOURCE, REG_G0, REG_G0))
#define RET				(FMT3_INST(0x2L, OP_JMPL, REG_I7, IMMEDIATE, 8, REG_G0))
#define RETL				(FMT3_INST(0x2L, OP_JMPL, REG_O7, IMMEDIATE, 8, REG_G0))
#define CALL_REG(r)			(FMT3_INST(0x2L, OP_JMPL, (r), IMMEDIATE, 0, REG_O7))
#define CALL_REG_IMM(r, k) 		(FMT3_INST(0x2L, OP_JMPL, (r), IMMEDIATE, (k), REG_O7))
#define CALL(disp)			((0x01 << 30) | (((unsigned long) (disp)) >> 2))
#define NOP				(FMT3_INST(0x2L, OP_OR, REG_G0, REG_SOURCE, REG_G0, REG_G0))
#define LDW_REG_IMM(rs1, k, rd) 	(FMT3_INST(0x3L, OP_LDW, rs1, IMMEDIATE, k, rd))
#define LDW_REG_REG(rs1, rs2, rd) 	(FMT3_INST(0x3L, OP_LDW, rs1, REG_SOURCE, rs2, rd))
#define LDHW_REG_IMM(rs1, k, rd) 	(FMT3_INST(0x3L, OP_LDHW, rs1, IMMEDIATE, k, rd))
#define LDHW_REG_REG(rs1, rs2, rd) 	(FMT3_INST(0x3L, OP_LDHW, rs1, REG_SOURCE, rs2, rd))
#define LDUB_REG_IMM(rs1, k, rd) 	(FMT3_INST(0x3L, OP_LDUB, rs1, IMMEDIATE, k, rd))
#define LDUB_REG_REG(rs1, rs2, rd) 	(FMT3_INST(0x3L, OP_LDUB, rs1, REG_SOURCE, rs2, rd))
#define STW_REG_IMM(rs1, k, rd) 	(FMT3_INST(0x3L, OP_STW, rs1, IMMEDIATE, k, rd))
#define STW_REG_REG(rs1, rs2, rd) 	(FMT3_INST(0x3L, OP_STW, rs1, REG_SOURCE, rs2, rd))
#define STHW_REG_IMM(rs1, k, rd) 	(FMT3_INST(0x3L, OP_STHW, rs1, IMMEDIATE, k, rd))
#define STHW_REG_REG(rs1, rs2, rd) 	(FMT3_INST(0x3L, OP_STHW, rs1, REG_SOURCE, rs2, rd))
#define STUB_REG_IMM(rs1, k, rd) 	(FMT3_INST(0x3L, OP_STUB, rs1, IMMEDIATE, k, rd))
#define STUB_REG_REG(rs1, rs2, rd) 	(FMT3_INST(0x3L, OP_STUB, rs1, REG_SOURCE, rs2, rd))
#define ADD_REG_IMM(rs1, k, rd) 	(FMT3_INST(0x2L, OP_ADD, rs1, IMMEDIATE, k, rd))
#define ADD_REG_REG(rs1, rs2, rd) 	(FMT3_INST(0x2L, OP_ADD, rs1, REG_SOURCE, rs2, rd))
#define ADDcc_REG_IMM(rs1, k, rd) 	(FMT3_INST(0x2L, OP_ADDcc, rs1, IMMEDIATE, k, rd))
#define ADDcc_REG_REG(rs1, rs2, rd) 	(FMT3_INST(0x2L, OP_ADDcc, rs1, REG_SOURCE, rs2, rd))
#define ADDX_REG_IMM(rs1, k, rd) 	(FMT3_INST(0x2L, OP_ADDX, rs1, IMMEDIATE, k, rd))
#define ADDX_REG_REG(rs1, rs2, rd) 	(FMT3_INST(0x2L, OP_ADDX, rs1, REG_SOURCE, rs2, rd))
#define ADDXcc_REG_IMM(rs1, k, rd) 	(FMT3_INST(0x2L, OP_ADDXcc, rs1, IMMEDIATE, k, rd))
#define ADDXcc_REG_REG(rs1, rs2, rd) 	(FMT3_INST(0x2L, OP_ADDXcc, rs1, REG_SOURCE, rs2, rd))
#define SUB_REG_IMM(rs1, k, rd) 	(FMT3_INST(0x2L, OP_SUB, rs1, IMMEDIATE, k, rd))
#define SUB_REG_REG(rs1, rs2, rd) 	(FMT3_INST(0x2L, OP_SUB, rs1, REG_SOURCE, rs2, rd))
#define SUBcc_REG_IMM(rs1, k, rd) 	(FMT3_INST(0x2L, OP_SUBcc, rs1, IMMEDIATE, k, rd))
#define SUBcc_REG_REG(rs1, rs2, rd) 	(FMT3_INST(0x2L, OP_SUBcc, rs1, REG_SOURCE, rs2, rd))
#define SUBX_REG_IMM(rs1, k, rd) 	(FMT3_INST(0x2L, OP_SUBX, rs1, IMMEDIATE, k, rd))
#define SUBX_REG_REG(rs1, rs2, rd) 	(FMT3_INST(0x2L, OP_SUBX, rs1, REG_SOURCE, rs2, rd))
#define SUBXcc_REG_IMM(rs1, k, rd) 	(FMT3_INST(0x2L, OP_SUBXcc, rs1, IMMEDIATE, k, rd))
#define SUBXcc_REG_REG(rs1, rs2, rd) 	(FMT3_INST(0x2L, OP_SUBXcc, rs1, REG_SOURCE, rs2, rd))
#define AND_REG_IMM(rs1, k, rd) 	(FMT3_INST(0x2L, OP_AND, rs1, IMMEDIATE, k, rd))
#define AND_REG_REG(rs1, rs2, rd) 	(FMT3_INST(0x2L, OP_AND, rs1, REG_SOURCE, rs2, rd))
#define OR_REG_IMM(rs1, k, rd) 		(FMT3_INST(0x2L, OP_OR, rs1, IMMEDIATE, k, rd))
#define OR_REG_REG(rs1, rs2, rd) 	(FMT3_INST(0x2L, OP_OR, rs1, REG_SOURCE, rs2, rd))
#define XOR_REG_IMM(rs1, k, rd) 	(FMT3_INST(0x2L, OP_XOR, rs1, IMMEDIATE, k, rd))
#define XOR_REG_REG(rs1, rs2, rd) 	(FMT3_INST(0x2L, OP_XOR, rs1, REG_SOURCE, rs2, rd))
#define XNOR_REG_IMM(rs1, k, rd) 	(FMT3_INST(0x2L, OP_XNOR, rs1, IMMEDIATE, k, rd))
#define XNOR_REG_REG(rs1, rs2, rd) 	(FMT3_INST(0x2L, OP_XNOR, rs1, REG_SOURCE, rs2, rd))
#define NOT_REG(r)			(XNOR_REG_REG(r, REG_G0, r))
#define SLL_REG_IMM(rs1, k, rd) 	(FMT3_INST(0x2L, OP_SLL, rs1, IMMEDIATE, k, rd))
#define SLL_REG_REG(rs1, rs2, rd) 	(FMT3_INST(0x2L, OP_SLL, rs1, REG_SOURCE, rs2, rd))
#define SRL_REG_IMM(rs1, k, rd) 	(FMT3_INST(0x2L, OP_SRL, rs1, IMMEDIATE, k, rd))
#define SRL_REG_REG(rs1, rs2, rd) 	(FMT3_INST(0x2L, OP_SRL, rs1, REG_SOURCE, rs2, rd))
#define HI22(k) 			((((unsigned long) (k)) >> 10) & 0x3fffffL)
#define LOW10(k) 			(((unsigned long) (k)) & 0x3ffL)
#define SETHI(k, rd) 			(FMT2_INST(0x0L, OP_SETHI, k, rd))
/******************************************************************************
 * The branch instructions.
 *****************************************************************************/
#define BRANCH_INST(annul, cond, disp)	(((annul) << 29) | ((cond) << 25) | (0x800000) | ((disp) & 0x3FFFFF))
#define BRA(disp)			(BRANCH_INST(0, 0x8, disp))
#define BRN(disp)			(BRANCH_INST(0, 0x0, disp))
#define BRNE(disp)			(BRANCH_INST(0, 0x9, disp))
#define BRE(disp)			(BRANCH_INST(0, 0x1, disp))
#define BRG(disp)			(BRANCH_INST(0, 0xA, disp))
#define BRLE(disp)			(BRANCH_INST(0, 0x2, disp))
#define BRGE(disp)			(BRANCH_INST(0, 0xB, disp))
#define BRL(disp)			(BRANCH_INST(0, 0x3, disp))
#define BRGU(disp)			(BRANCH_INST(0, 0xC, disp))
#define BRLEU(disp)			(BRANCH_INST(0, 0x4, disp))
#define BRCC(disp)			(BRANCH_INST(0, 0xD, disp))
#define BRCS(disp)			(BRANCH_INST(0, 0x5, disp))
#define BRPOS(disp)			(BRANCH_INST(0, 0xE, disp))
#define BRNEG(disp)			(BRANCH_INST(0, 0x6, disp))
#define BRVC(disp)			(BRANCH_INST(0, 0xF, disp))
#define BRVS(disp)			(BRANCH_INST(0, 0x7, disp))
#define BRNZ(disp)			(BRANCH_INST(0, 0x9, disp))
#define BRZ(disp)			(BRANCH_INST(0, 0x1, disp))
/*****************************************************************************/
/*                                                                           */
/* Macros to insert target instructions etc.				     */
/*                                                                           */
/*****************************************************************************/
#define EMIT(inst)			*pcodNext++ = (inst)
#define CURRENT_LOC			(pcodNext)
#define CURRENT_HANDLE			(&pcodNext)
#ifdef __cplusplus
/*****************************************************************************/
/******************************** TEMPLATES **********************************/
/*****************************************************************************/
/*****************************************************************************/
/*************************** CLASSES & TYPEDEFS ******************************/
/*****************************************************************************/
typedef unsigned long INSTRUCTION;
class Cam8SimSPARCJIT : Cam8SimJIT {
public:
  static const char *szRegName[] = {
    "%g0", "%g1", "%g2", "%g3", "%g4", "%g5", "%g6", "%g7",
    "%o0", "%o1", "%o2", "%o3", "%o4", "%o5", "%sp", "%tp",
    "%l0", "%l1", "%l2", "%l3", "%l4", "%l5", "%l6", "%l7",
    "%i0", "%i1", "%i2", "%i3", "%i4", "%i5", "%ds", "%ra"
  };
  static const char *szCCName[] = {
    "NEVER", "EQ", "LE", "L", "LEU", "CS", "NEG", "VS",
    "ALWAYS", "NEQ", "G", "GE", "GU", "CC", "POS", "VC"
  };
  void NewBlock(CODEHANDLE);
  void EndBlock();
  void Emit(INT16 opcode, BYTE op1Type, LONG32 op1, BYTE op2Type, LONG32 op2,
	    BYTE destType, LONG32 dest);
  void PrintAsm(CODEPTR pcodSource, FILE *fOut);
/*****************************************************************************/
/********************************* INLINES ***********************************/
/*****************************************************************************/
#endif
/*****************************************************************************/
/******************************* PROTOTYPES **********************************/
/*****************************************************************************/
/*****************************************************************************/
/********************************* GLOBALS ***********************************/
/*****************************************************************************/
#endif

---------------------------------------------------------------------------

These are the stages for converting the current C CAM8 library into a
general purpose CAM library that supports CAM8 and all future generation
machines as well as other CA architectures (like purely software systems).
Status:		DONE
1) Compile current C CAMlib with a C++ compiler and link with current
software suite as a first order consistency check.
2) Recode C structures as C++ classes with a public interface.  Write
simple constructor and destructor members.  Make current C procedures
into members.  Write C wrappers that call C++ counterparts.  Repeat link
test.
	2a) Separate general, CA general, CAM general and CAM8
	specific code.
	2b) Add new functionality to the library (cam8sim, campat,
	camgen, etc).
	2c) Separate the STEP specific code in CAMlib from the CAM8
	specific code.  This is a non-trivial task since a lot of the
	functionality in STEP crosses the boundary (like fields and
	subcells).
3) Design new abstractions: what a cellular automata is and what a
cellular automata machine is.  These will be the basis for the C++
library.  Implemented these abstractions as generic classes that
define their interface and subclass then for specific cases.
4) Rewrite C procedures as wrappers to the new C++ classes.  There
will not be a one-to-one mapping from the new classes to the old C
structures.  All of the old functionality will however be captured in
the new library.  These wrappers will use the new classes and methods
to provide the same resources and functionality.  Might have to design
a back-compatibility mode into the C++ classes to aid in this process.
	4a) Recompile working example code using the wrapped C++
	libraries to verify correctness.
	4b) Recode example code in C++ using new C++ library and
	concepts.
5) Redesign C wrappers discarding the old design concepts and
abstractions.  These wrappers will simply be C versions of C++
procedures.  They will be used in conjunction will packages, like DLD,
that need "plain ole unmangled" function names for dynamic linking.
NOTE: It was my intention to complete stages 3, 4 and 5 as part of my
graduate school research.  Stage 3 in particular is likely to be a
difficult problem and suitable for advanced research work.  Recently I
have decided that stage 3 amounts to the underpinings of a CA compiler
that is targeted to a virtual cellular automata machine.  Many of the
classes that support abstractions for CA and CAMs can compliment the
intermediate language of such a compiler.

---------------------------------------------------------------------------

The following software is Copyright (c) 1990 - 1997:
	STEP Research Inc.
	MIT Laboratory for Computer Science - Information Mechanics Group
Various people have contributed to the design and implementation of these
programs as noted below.  This code comprises the programming environment
for the CAM8 computer.
CAMlib		- HL Gilliam, D Risacher, M Muzumdar
XCAM		- HL Gilliam
cam8sim		- M Shah, HL Gilliam
cam8utils	- N Margolus, D Risacher, HL Gilliam
campat		- D Risacher, M Muzumdar, HL Gilliam
demos		- N Margolus, T Toffoli, D Risacher, R D'Sousa, HL Gilliam, etc
devdri		- K Streeter, HL Gilliam
ppmtools	- D Risacher
pystep		- HL Gilliam
step		- N Margolus, T Toffoli, HL Gilliam, D Risacher
All rights reserved.
Permission to use, copy, modify, and distribute this software and its
associated documentation for any purpose and without fee is hereby
granted, provided that the above copyright notice appears in all
copies, and that both that copyright notice and this permission notice
appear in supporting documentation, and that the name of the author
not be used in advertising or publicity pertaining to distribution of
the software without specific, written prior permission.
THE AUTHORS DISCLAIM ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS.  IN
NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY SPECIAL, INDIRECT OR
CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF
USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.


---------------------------------------------------------------------------

/***********************************************************************
 * The following software is Copyright (c) 1990 - 1997:
 * 	STEP Research Inc.
 * 	MIT Laboratory for Computer Science - Information Mechanics Group
 * All rights reserved.
 * Permission to use, copy, modify, and distribute this software and its
 * associated documentation for any purpose and without fee is hereby
 * granted, provided that the above copyright notice appears in all
 * copies, and that both that copyright notice and this permission notice
 * appear in supporting documentation, and that the name of the author
 * not be used in advertising or publicity pertaining to distribution of
 * the software without specific, written prior permission.
 * THE AUTHORS DISCLAIM ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
 * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS.  IN
 * NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY SPECIAL, INDIRECT OR
 * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF
 * USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
 * OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
 * PERFORMANCE OF THIS SOFTWARE.
 ***********************************************************************/

---------------------------------------------------------------------------

emacs CAMlib/conversion_path.txt CAMlib/stage2/cam8sim/conversion_path.txt CAMlib/stage2/PLAN CAMlib/stage2/cam8sim/NOTES CAMlib/stage2/*++.X[HC] CAMlib/stage2/cam8sim/*++.X[HC] &

---------------------------------------------------------------------------

#include <string.h>
#if 0
#include <CAM/CAM.xh>
#include <CAM/CAM_instr.xh>
#endif
#include "copyright.h"
/* Defines */
#define VNEXT		vals[vidx++]
#define VCURR		vals[vidx]
#define VRST		vidx = 0
#define SKIP_SPACE(p)		while((isspace(*(p))) && (*(p))) (p)++
#define SKIP_TO_SPACE(p)	while((!isspace(*(p))) && (*(p))) (p)++
#define SKIP_PAST_SPACE(p)	SKIP_SPACE(p); SKIP_TO_SPACE(p); SKIP_SPACE(p);
#define LOWER_CASE(p)		while(*(p)++) *(p) = \
				(isupper(*(p)) ? tolower(*(p)) : *(p))
/* Global Variables */
char vals[32][128], lmask[128], sarg[128];
char *sel, *map, *fld;
int lmask_wait, sarg_wait;
long vidx;
static int paren_level = 0;
static char tmp[128];
static int dowhile = 0;
extern FILE *c8cpp_in;
/* Procedure Prototypes */
int c8cpp_wrap();
void do_field(char *);
void do_prefix(char *);
void do_reg_fld_store(char *);
DIGIT		[0-9]
ODIGIT		[0-7]
HDIGIT		[0-9a-fA-F]
DNUM		{DIGIT}+
HNUM		"0x"{HDIGIT}+
ONUM		"0"{ODIGIT}+
NUMBER		[+-]?{DNUM}|{HNUM}|{ONUM}
FSTR		[0-9A-Za-z\055]+
CSTR		[\055\133\135!%^&*()_+=|~A-Za-z0-9:<>?/]+
WHITE		[ \t\n]+
OWHITE		[ \t\n]*
%x directive
%x pragma
%x equation
  printf("%s", c8cpp_text);
"\n" {
  printf("\n");
[ \t]*"%all-layers"{OWHITE} {
  BEGIN(pragma); sarg_wait = 0; lmask_wait = 0;
[ \t]*"%16-layers"{OWHITE} {
  BEGIN(pragma); strcpy(sarg, ", N_SINGLE_ARG"); sarg_wait = -1;
[ \t]*"%layer"{WHITE}{CSTR} {
  SKIP_PAST_SPACE(c8cpp_text);
  sprintf(lmask, ", LAYER_MASK, 0x1 << (%s)", c8cpp_text); lmask_wait = -1;
  sarg_wait = 0; BEGIN(pragma);
[ \t]*"%layers"{WHITE}{CSTR} {
  SKIP_PAST_SPACE(c8cpp_text); sprintf(lmask, ", LAYER_MASK, %s", c8cpp_text);
  lmask_wait = -1; sarg_wait = 0; BEGIN(pragma);
<pragma>";" {
  BEGIN(INITIAL);
<pragma>{OWHITE} {
  /* ignore whitespace */
<equation>"(" {
  strcat(VCURR, "("); paren_level++;
<equation>")" {
  strcat(VCURR, ")"); if (--paren_level == 0) { BEGIN(directive); vidx++; }
<equation>";" {
  fprintf(stderr, "Error parsing parenthesized equation\n"); exit(0);
<equation>. {
  strcat(VCURR, c8cpp_text);
<equation>"\n" {
  /* Ignore carrage return */
<directive>"(" {
  BEGIN(equation); paren_level = 1; strcpy(VCURR, "(");
<directive>[ \t\n]+ {
  /* ignore whitespace */
<directive>{NUMBER} {
  strcpy(VNEXT, yytext);
<directive>"read" {
printf(", READ_MODE"); VRST;
<directive>{FSTR}{WHITE}"field" {
  char *tmp = c8cpp_text; SKIP_TO_SPACE(c8cpp_text); *c8cpp_text = '\0';
  do_field(tmp); VRST;
<directive>"x-" {
  strcpy(VNEXT, "0");
<directive>"x+" {
strcpy(VNEXT, "1");
<directive>"y-" {
  strcpy(VNEXT, "2");
<directive>"y+" {
  strcpy(VNEXT, "3");
<directive>"z-" {
strcpy(VNEXT, "4");
<directive>"z+" {
strcpy(VNEXT, "5");
<directive>"reg!" {
  do_reg_fld_store(NULL); VRST;
<directive>";" {
  int i;
  BEGIN(INITIAL); for (i = 0; i < vidx; i++) printf(", %s", vals[i]);
  printf(", END_ARGS);"); VRST;
  if (dowhile) {
    printf(" }while(0);");
    dowhile = 0;
[ \t]*"%select" {
do_prefix("REG_MSR"); BEGIN(directive); VRST;
<directive>"don't-care" {
  printf(", LAYER_MASK, %s, REG_STORE, 7, ALL_LAYERS", vals[0]); VRST;
<directive>"dont-care" {
  printf(", LAYER_MASK, %s, REG_STORE, 7, ALL_LAYERS", vals[0]); VRST;
<directive>"sequential" {
  printf(", LAYER_MASK, %s, FLD_TA, 2, ALL_LAYERS", vals[0]); VRST;
<directive>"group" {
  printf(", FLD_TA, BIT_MASK, %s, ALL_LAYERS, FLD_GMS, 1", vals[0]); VRST;
<directive>"module" {
  printf(", FLD_TA, BIT_MASK, %s, FLD_GMS, 0", vals[0]); VRST;
<directive>"sequential-by-module-id" {
  printf(", REG_STORE, 4"); VRST;
<directive>"sequential-by-group-id" {
  printf(", REG_STORE, 5"); VRST;
<directive>"glue" {
  printf(", REG_STORE, 6"); VRST;
<directive>"all" {
  printf(", REG_STORE, 7"); VRST;
<directive>"*module" {
  printf(", FLD_TA, BIT_MASK, 1, ALL_LAYERS, FLD_GMS, 0, LAYER_MASK, 0xFFFE");
  printf(", REG_STORE, 7, ALL_LAYERS"); VRST;
<directive>"ta!" {
  do_reg_fld_store("FLD_TA"); VRST;
<directive>"gms!" {
  do_reg_fld_store("FLD_GMS"); VRST;
[ \t]*"%run" {
  do_prefix("REG_RMR") ; BEGIN(directive); VRST;
<directive>"no-scan" {
  printf(", FLD_SSM, 0"); VRST;
<directive>"frame" {
  printf(", FLD_SSM, 1, LAYER_MASK, 1<<5, FLD_RT, 1"); VRST;
<directive>"line" {
  printf(", FLD_SSM, 2, LAYER_MASK, 1<<10, FLD_RT, 1"); VRST;
<directive>"free" {
  printf(", FLD_SSM, 3, FLD_RT, 0"); VRST;
<directive>"continue-count" {
  printf(", FLD_ECT, 0"); VRST;
<directive>"new-count" {
  printf(", FLD_ECT, 1"); VRST;
<directive>"no-kick" {
  printf(", FLD_RPK, 0"); VRST;
<directive>"repeat-kick" {
  printf(", FLD_RPK, 1"); VRST;
<directive>"same-table" {
  printf(", FLD_ALT, 0"); VRST;
<directive>"new-table" {
  printf(", FLD_ALT, 1"); VRST;
<directive>"ssm!" {
  do_reg_fld_store("FLD_SSM"); VRST;
<directive>"rt!" {
  do_reg_fld_store("FLD_RT"); VRST;
<directive>"ect!" {
  do_reg_fld_store("FLD_ECT"); VRST;
<directive>"rpk!" {
  do_reg_fld_store("FLD_RPK"); VRST;
<directive>"alt!" {
  do_reg_fld_store("FLD_ALT"); VRST;
[ \t]*"%kick" {
  do_prefix("REG_KR"); BEGIN(directive); VRST;
<directive>"x" {
  printf(", KICK_X, %s", vals[0]); VRST;
<directive>"y" {
  printf(", KICK_Y, %s", vals[0]); VRST;
<directive>"z" {
  printf(", KICK_Z, %s", vals[0]); VRST;
<directive>"xn" {
  printf(", KICK_N, %s, %s", vals[1], vals[0]); VRST;
<directive>"ka!" {
  do_reg_fld_store("FLD_KA"); VRST;
<directive>"xks!" {
  do_reg_fld_store("FLD_XKS"); VRST;
<directive>"yks!" {
  do_reg_fld_store("FLD_YKS"); VRST;
<directive>"zks!" {
  do_reg_fld_store("FLD_ZKS"); VRST;
<directive>"xkmf!" {
  do_reg_fld_store("FLD_XKMF"); VRST;
<directive>"ykmf!" {
  do_reg_fld_store("FLD_YKMF"); VRST;
<directive>"zkmf!" {
  do_reg_fld_store("FLD_ZKMF"); VRST;
[ \t]*"%sa-bit" {
  do_prefix("REG_SABSR"); BEGIN(directive); VRST;
[ \t]*"%lut-src" {
  do_prefix("REG_LASR"); sel = "FLD_LAS"; map = "FLD_LAM"; BEGIN(directive);
  VRST;
<directive>"las!" {
  do_reg_fld_store("FLD_LAS"); VRST;
<directive>"lam!" {
  do_reg_fld_store("FLD_LAM"); VRST;
[ \t]*"%fly-src" {
  do_prefix("REG_FOSR"); sel = "FLD_FOS"; map = "FLD_FOM"; BEGIN(directive);
  VRST;
<directive>"fos!" {
  do_reg_fld_store("FLD_FOS"); VRST;
<directive>"fom!" {
  do_reg_fld_store("FLD_FOM"); VRST;
[ \t]*"%site-src" {
  do_prefix("REG_SDSR"); sel = "FLD_SDS"; map = "FLD_SDM"; BEGIN(directive);
  VRST;
<directive>"sds!" {
  do_reg_fld_store("FLD_SDS"); VRST;
<directive>"sdm!" {
  do_reg_fld_store("FLD_SDM"); VRST;
[ \t]*"%event-src" {
  do_prefix("REG_ECSR"); sel = "FLD_ECS"; map = "FLD_ECM"; BEGIN(directive);
  VRST;
<directive>"ecs!" {
  do_reg_fld_store("FLD_ECS"); VRST;
<directive>"ecm!" {
  do_reg_fld_store("FLD_ECM"); VRST;
[ \t]*"%display" {
  do_prefix("REG_DSR"); sel = "FLD_DDS"; map = "FLD_DDM"; BEGIN(directive);
  VRST;
<directive>"dds!" {
  do_reg_fld_store("FLD_DDS"); VRST;
<directive>"ddm!" {
  do_reg_fld_store("FLD_DDM"); VRST;
<directive>"sel!" {
  do_reg_fld_store(sel); VRST;
<directive>"map!" {
  do_reg_fld_store(map); VRST;
<directive>"site" {
  printf(", %s, 10", map); VRST;
<directive>"unglued" {
  printf(", %s, 0, %s, 12", sel, map); VRST;
<directive>"host" {
  printf(", %s, 1, %s, 12", sel, map); VRST;
<directive>"fly" {
  printf(", %s, 2, %s, 12", sel, map); VRST;
<directive>"address" {
  printf(", %s, 3, %s, 12", sel, map); VRST;
<directive>"lut" {
  printf(", %s, 3, %s, 12", sel, map); VRST;
[ \t]*"%show-scan" {
  do_prefix("REG_SSR"); BEGIN(directive); VRST;
<directive>"enable" {
  printf(", REG_STORE, 1"); VRST;
[ \t]*"%event" {
  do_prefix("REG_ECR"); BEGIN(directive); VRST;
[ \t]*"%lut-index" {
  do_prefix("REG_LIR"); BEGIN(directive); VRST;
[ \t]*"%lut-perm" {
  do_prefix("REG_LIPR"); BEGIN(directive); VRST;
[ \t]*"%lut-io" {
  do_prefix("REG_LIOR"); BEGIN(directive); VRST;
[ \t]*"%scan-index" {
  do_prefix("REG_SIR"); BEGIN(directive); VRST;
[ \t]*"%scan-perm" {
  do_prefix("REG_SIPR"); BEGIN(directive); VRST;
<directive>"sa0!" {
  do_reg_fld_store("FLD_SSA0"); VRST;
<directive>"sa1!" {
  do_reg_fld_store("FLD_SSA1"); VRST;
<directive>"sa2!" {
  do_reg_fld_store("FLD_SSA2"); VRST;
<directive>"sa3!" {
  do_reg_fld_store("FLD_SSA3"); VRST;
<directive>"sa4!" {
  do_reg_fld_store("FLD_SSA4"); VRST;
<directive>"sa5!" {
  do_reg_fld_store("FLD_SSA5"); VRST;
<directive>"sa6!" {
  do_reg_fld_store("FLD_SSA6"); VRST;
<directive>"sa7!" {
  do_reg_fld_store("FLD_SSA7"); VRST;
<directive>"sa8!" {
  do_reg_fld_store("FLD_SSA8"); VRST;
<directive>"sa9!" {
  do_reg_fld_store("FLD_SSA9"); VRST;
<directive>"sa10!" {
  do_reg_fld_store("FLD_SSA10"); VRST;
<directive>"sa11!" {
  do_reg_fld_store("FLD_SSA11"); VRST;
<directive>"sa12!" {
  do_reg_fld_store("FLD_SSA12"); VRST;
<directive>"sa13!" {
  do_reg_fld_store("FLD_SSA13"); VRST;
<directive>"sa14!" {
  do_reg_fld_store("FLD_SSA14"); VRST;
<directive>"sa15!" {
  do_reg_fld_store("FLD_SSA15"); VRST;
<directive>"sa16!" {
  do_reg_fld_store("FLD_SSA16"); VRST;
<directive>"sa17!" {
  do_reg_fld_store("FLD_SSA17"); VRST;
<directive>"sa18!" {
  do_reg_fld_store("FLD_SSA18"); VRST;
<directive>"sa19!" {
  do_reg_fld_store("FLD_SSA19"); VRST;
<directive>"sa20!" {
  do_reg_fld_store("FLD_SSA20"); VRST;
<directive>"sa21!" {
  do_reg_fld_store("FLD_SSA21"); VRST;
<directive>"sa22!" {
  do_reg_fld_store("FLD_SSA22"); VRST;
<directive>"sa23!" {
  do_reg_fld_store("FLD_SSA23"); VRST;
<directive>"sa!" {
  sprintf(tmp, "FLD_SSA(%s)", vals[--vidx]);
  do_reg_fld_store(tmp); VRST;
[ \t]*"%scan-io" {
  do_prefix("REG_SIOR"); BEGIN(directive); VRST;
[ \t]*"%scan-format" {
  do_prefix("REG_SFR"); BEGIN(directive); VRST;
<directive>"sm!" {
  do_reg_fld_store("FLD_SM"); VRST;
<directive>"esc!" {
  do_reg_fld_store("FLD_ESC"); VRST;
<directive>"esw!" {
  do_reg_fld_store("FLD_ESW"); VRST;
<directive>"est!" {
  do_reg_fld_store("FLD_EST"); VRST;
<directive>"sbrc!" {
  do_reg_fld_store("FLD_SBRC"); VRST;
<directive>"rcl!" {
  do_reg_fld_store("FLD_RCL"); VRST;
<directive>"ecl!" {
  do_reg_fld_store("FLD_ECL"); VRST;
<directive>"stm!" {
  do_reg_fld_store("FLD_STM"); VRST;
<directive>"escp!" {
  sprintf(tmp, "(%s) + 1", vals[0]);
  strcpy(vals[0], tmp);
  do_reg_fld_store("FLD_ESC"); VRST;
<directive>"eswp!" {
  sprintf(tmp, "(%s) + 1", vals[0]);
  strcpy(vals[0], tmp);
  do_reg_fld_store("FLD_ESW"); VRST;
<directive>"estp!" {
  sprintf(tmp, "(%s) + 1", vals[0]);
  strcpy(vals[0], tmp);
  do_reg_fld_store("FLD_EST"); VRST;
[ \t]*"%offset" {
  do_prefix("REG_OSR"); BEGIN(directive); VRST;
[ \t]*"%dimension" {
  do_prefix("REG_DR"); BEGIN(directive); VRST;
<directive>"dcm!" {
  do_reg_fld_store("FLD_DCM"); VRST;
<directive>"xdcp!" {
  do_reg_fld_store("FLD_XDCP"); VRST;
<directive>"ydcp!" {
  do_reg_fld_store("FLD_YDCP"); VRST;
<directive>"zdcp!" {
  do_reg_fld_store("FLD_ZDCP"); VRST;
<directive>"dcp!" {
  sprintf(tmp, "choose_dcp(%s)", vals[--vidx]);
  do_reg_fld_store(tmp); VRST;
[ \t]*"%environment" {
  do_prefix("REG_HER"); BEGIN(directive); VRST;
<directive>"lpl!" {
  do_reg_fld_store("FLD_LPL"); VRST;
<directive>"fpl!" {
  do_reg_fld_store("FLD_FPL"); VRST;
<directive>"dcs!" {
  do_reg_fld_store("FLD_DCS"); VRST;
<directive>"tbd!" {
  do_reg_fld_store("FLD_TBD"); VRST;
<directive>"tms!" {
  do_reg_fld_store("FLD_TMS"); VRST;
<directive>"nbf!" {
  do_reg_fld_store("FLD_NBF"); VRST;
<directive>"sre!" {
  do_reg_fld_store("FLD_SRE"); VRST;
<directive>"als!" {
  do_reg_fld_store("FLD_ALS"); VRST;
[ \t]*"%multi" {
  do_prefix("REG_MPCR"); BEGIN(directive); VRST;
<directive>"A.scan-input" {
  printf(", FLD_MAFS, 1"); VRST;
<directive>"A.status" {
  printf(", FLD_MAFS, 2"); VRST;
<directive>"A.box-enable" {
  printf(", FLD_MAFS, 3"); VRST;
<directive>"A.scan-in-progress" {
  printf(", FLD_MAFS, 4"); VRST;
<directive>"A.display-output-valid" {
  printf(", FLD_MAFS, 5"); VRST;
<directive>"A.site-address" {
  printf(", FLD_MAFS, 6"); VRST;
<directive>"A.unglued-data" {
  printf(", FLD_MAFS, 7"); VRST;
<directive>"A.host-data" {
  printf(", FLD_MAFS, 8"); VRST;
<directive>"A.lut-address-source" {
  printf(", FLD_MAFS, 9"); VRST;
<directive>"A.node-enable" {
  printf(", FLD_MAFS, 10"); VRST;
<directive>"A.test-output" {
  printf(", FLD_MAFS, 11"); VRST;
<directive>"A.regsel-29" {
  printf(", FLD_MAFS, 12"); VRST;
<directive>"A.regsel-30" {
  printf(", FLD_MAFS, 13"); VRST;
<directive>"A.zero" {
  printf(", FLD_MAFS, 14"); VRST;
<directive>"A.one" {
  printf(", FLD_MAFS, 15"); VRST;
<directive>"A.lut0-chip-select" {
  printf(", FLD_MAFS, 16"); VRST;
<directive>"A.lut1-chip-select" {
  printf("FLD_MAFS, 24"); VRST;
<directive>"B.status-input" {
  printf("FLD_MBFS, 0"); VRST;
<directive>"B.interrupt-input" {
  printf("FLD_MBFS, 1"); VRST;
<directive>"B.scan-active" {
  printf("FLD_MBFS, 2"); VRST;
<directive>"B.node-direction" {
  printf("FLD_MBFS, 3"); VRST;
<directive>"B.run-type" {
  printf("FLD_MBFS, 4"); VRST;
<directive>"B.lut-input-valid" {
  printf("FLD_MBFS, 5"); VRST;
<directive>"B.event-count-source" {
  printf("FLD_MBFS, 6"); VRST;
<directive>"B.site-data-source" {
  printf("FLD_MBFS, 7"); VRST;
<directive>"B.active-lut-output" {
  printf("FLD_MBFS, 8"); VRST;
<directive>"B.active-lut-select" {
  printf("FLD_MBFS, 9"); VRST;
<directive>"B.module-id" {
  printf("FLD_MBFS, 10"); VRST;
<directive>"B.interrupt-output" {
  printf("FLD_MBFS, 11"); VRST;
<directive>"B.modsel" {
  printf("FLD_MBFS, 12"); VRST;
<directive>"B.latch-glue-direction" {
  printf("FLD_MBFS, 13"); VRST;
<directive>"B.zero" {
  printf("FLD_MBFS, 14"); VRST;
<directive>"B.one" {
  printf("FLD_MBFS, 15"); VRST;
<directive>"B.lut0-write-enable" {
  printf("FLD_MBFS, 16"); VRST;
<directive>"B.lut1-write-enable" {
  printf("FLD_MBFS, 24"); VRST;
<directive>"mafs!" {
  do_reg_fld_store("FLD_MAFS"); VRST;
<directive>"mbfs!" {
  do_reg_fld_store("FLD_MBFS"); VRST;
[ \t]*"%connect" {
  do_prefix("REG_GPCR"); BEGIN(directive); VRST;
<directive>"xmpc!" {
  do_reg_fld_store("FLD_XMPC"); VRST;
<directive>"xppc!" {
  do_reg_fld_store("FLD_XPPC"); VRST;
<directive>"ympc!" {
  do_reg_fld_store("FLD_YMPC"); VRST;
<directive>"yppc!" {
  do_reg_fld_store("FLD_YPPC"); VRST;
<directive>"zmpc!" {
  do_reg_fld_store("FLD_ZMPC"); VRST;
<directive>"zppc!" {
  do_reg_fld_store("FLD_ZPPC"); VRST;
<directive>"+xn!" {
  sprintf(tmp, "((%s)+6)", vals[vidx - 2]);
  strcpy(vals[vidx - 2], tmp);
  sprintf(tmp, "choose_ppc(%s)", vals[--vidx]);
  do_reg_fld_store(tmp); VRST;
<directive>"-xn!" {
  sprintf(tmp, "choose_mpc(%s)", vals[--vidx]);
  do_reg_fld_store(tmp); VRST;
[ \t]*"%module-id" {
  do_prefix("REG_MIDR"); BEGIN(directive); VRST;
[ \t]*"%group-id" {
  do_prefix("REG_GIDR"); BEGIN(directive); VRST;
<directive>"id" {
  printf(", REG_STORE, BIT_MASK, %s, ALL_LAYERS", vals[0]); VRST;
[ \t]*"%int-enable" {
  do_prefix("REG_IER"); BEGIN(directive); VRST;
<directive>"bpie!" {
  do_reg_fld_store("FLD_BPIE"); VRST;
<directive>"bcie!" {
  do_reg_fld_store("FLD_BCIE"); VRST;
<directive>"gcie!" {
  do_reg_fld_store("FLD_GCIE"); VRST;
<directive>"maie!" {
  do_reg_fld_store("FLD_MAIE"); VRST;
<directive>"mbie!" {
  do_reg_fld_store("FLD_MBIE"); VRST;
<directive>"ssie!" {
  do_reg_fld_store("FLD_SSIE"); VRST;
<directive>"xhie!" {
  do_reg_fld_store("FLD_XHIE"); VRST;
<directive>"rlie!" {
  do_reg_fld_store("FLD_RLIE"); VRST;
<directive>"urie!" {
  do_reg_fld_store("FLD_URIE"); VRST;
<directive>"isie!" {
  do_reg_fld_store("FLD_ISIE"); VRST;
[ \t]*"%int-flags" {
  do_prefix("REG_IFR"); BEGIN(directive); VRST;
<directive>"bpif!" {
  do_reg_fld_store("FLD_BPIF"); VRST;
<directive>"bcif!" {
  do_reg_fld_store("FLD_BCIF"); VRST;
<directive>"gcif!" {
  do_reg_fld_store("FLD_GCIF"); VRST;
<directive>"maif!" {
  do_reg_fld_store("FLD_MAIF"); VRST;
<directive>"mbif!" {
  do_reg_fld_store("FLD_MBIF"); VRST;
<directive>"ssif!" {
  do_reg_fld_store("FLD_SSIF"); VRST;
<directive>"xhif!" {
  do_reg_fld_store("FLD_XHIF"); VRST;
<directive>"rlif!" {
  do_reg_fld_store("FLD_RLIF"); VRST;
<directive>"urif!" {
  do_reg_fld_store("FLD_URIF"); VRST;
<directive>"isif!" {
  do_reg_fld_store("FLD_ISIF"); VRST;
[ \t]*"%verify" {
  do_prefix("REG_VWR"); BEGIN(directive); VRST;
<directive>"begin" {
  printf(", FLD_VWE, 1, FLD_VWIE, 1, FLD_VWIF, 0"); VRST;
<directive>"end" {
  printf(", FLD_VWE, 0, FLD_VWIE, 0, FLD_VWIF, 0"); VRST;
<directive>"vwe!" {
  do_reg_fld_store("FLD_VWE"); VRST;
<directive>"vwie!" {
  do_reg_fld_store("FLD_VWIE"); VRST;
<directive>"vwif!" {
  do_reg_fld_store("FLD_VWIF"); VRST;
[ \t]*"%dram-count" {
  do_prefix("REG_DOCR"); BEGIN(directive); VRST;
<directive>"ldoc!" {
  do_reg_fld_store("FLD_LDOC"); VRST;
<directive>"hdoc!" {
  do_reg_fld_store("FLD_HDOC"); VRST;
<directive>"ones" {
  printf(", REG_LENGTH, %s, IMMED_MODE, REG_BUFFER, -1", vals[0]); VRST;
<directive>"zeroes" {
  printf(", REG_LENGTH, %s, IMMED_MODE, REG_BUFFER, 0", vals[0]); VRST;
<directive>"reads" {
  printf(", READ_MODE, INLINE_BUFFER, (%s) * 2", vals[0]); VRST;
<directive>"byte-reads" {
  printf(", BYTE_MODE, READ_MODE, INLINE_BUFFER, (%s) + 1, REG_LENGTH, %s",
	 vals[0], vals[0]); VRST;
<directive>"immediate-word" {
  printf(", IMMED_MODE, REG_BUFFER, (%s<<16), REG_LENGTH, 1", vals[0]); VRST;
<directive>"immediate-long" {
  printf(", IMMED_MODE, REG_BUFFER, %s, REG_LENGTH, 2", vals[0]); VRST;
[ \t]*"%delay" {
  printf("CAM_reg(cam8, REG_MIDR, IMMED_MODE, READ_MODE"); VRST;
  BEGIN(directive);
<directive>"clocks" {
  printf(", REG_LENGTH, %s", vals[0]); VRST;
[ \t]*"%lut-data"{WHITE} {
  SKIP_PAST_SPACE(c8cpp_text);
  dowhile = -1;
  printf("do {CAM_reg(cam8, REG_LIPR, END_ARGS); ");
  printf("CAM_reg(cam8, REG_LIR, END_ARGS); ");
  printf("CAM_reg(cam8, REG_SIOR, REG_BUFFER");  VRST; BEGIN(directive);
[ \t]*"%step"{OWHITE}";" {
  printf("CAM_step(cam8);");
[ \t]*"%*step*"{OWHITE}";" {
  printf("do {CAM_step(cam8); CAM_stop(cam8);}while(0);");
[ \t]*"%?jump"{OWHITE}";" {
  printf("CAM_reg(cam8, REG_MIDR, IMMED_MODE, READ_MODE, JUMP_POINT, END_ARGS);");
  VRST;
[ \t]*"%begin-defaults"{OWHITE}";" {
  printf("CAM_begin_defaults(cam8);"); VRST;
[ \t]*"%end-defaults"{OWHITE}";" {
  printf("CAM_end_defaults(cam8);"); VRST;
[ \t]*"%switch-luts"{OWHITE}";" {
  printf("CAM_reg(cam8, REG_RMR, FLD_SSM, 0, FLD_ECT, 0, FLD_ALT, 1, END_ARGS);");
  VRST;
int main(int argc, char *argv[])
  c8cpp_in = stdin;
  c8cpp_lex();
  exit(0);
int c8cpp_wrap()
  return 1;
void do_field(char *name)
void do_prefix(char *reg)
  printf("CAM_reg(cam8, %s", reg);
  if (lmask_wait)
    printf("%s", lmask);
  if (sarg_wait) {
    printf("%s", sarg);
    sarg_wait = 0;
void do_reg_fld_store(char *name)
  register int i;
  if (name == NULL)
    printf(", REG_STORE");
  else
    printf(", %s", name);
  for(i = 0; i < vidx; i++)
    printf(", %s", vals[i]);

#include <string.h>
#if 0
#include <CAM/CAM.xh>
#include <CAM/CAM_instr.xh>
#endif
#include "copyright.h"
/* Defines */
#define VNEXT		vals[vidx++]
#define VCURR		vals[vidx]
#define VRST		vidx = 0
#define SKIP_SPACE(p)		while((isspace(*(p))) && (*(p))) (p)++
#define SKIP_TO_SPACE(p)	while((!isspace(*(p))) && (*(p))) (p)++
#define SKIP_PAST_SPACE(p)	SKIP_SPACE(p); SKIP_TO_SPACE(p); SKIP_SPACE(p);
#define LOWER_CASE(p)		while(*(p)++) *(p) = \
				(isupper(*(p)) ? tolower(*(p)) : *(p))
/* Global Variables */
char vals[32][128], lmask[128], sarg[128];
char *sel, *map, *fld;
int lmask_wait, sarg_wait;
long vidx;
static int paren_level = 0;
static char tmp[128];
static int dowhile = 0;
extern FILE *c8cpp_in;
/* Procedure Prototypes */
int c8cpp_wrap();
void do_field(char *);
void do_prefix(char *);
void do_reg_fld_store(char *);
DIGIT		[0-9]
ODIGIT		[0-7]
HDIGIT		[0-9a-fA-F]
DNUM		{DIGIT}+
HNUM		"0x"{HDIGIT}+
ONUM		"0"{ODIGIT}+
NUMBER		[+-]?{DNUM}|{HNUM}|{ONUM}
FSTR		[0-9A-Za-z\055]+
CSTR		[\055\133\135!%^&*()_+=|~A-Za-z0-9:<>?/]+
WHITE		[ \t\n]+
OWHITE		[ \t\n]*
%x directive
%x pragma
%x equation
  printf("%s", c8cpp_text);
"\n" {
  printf("\n");
[ \t]*"%all-layers"{OWHITE} {
  BEGIN(pragma); sarg_wait = 0; lmask_wait = 0;
[ \t]*"%16-layers"{OWHITE} {
  BEGIN(pragma); strcpy(sarg, ", N_SINGLE_ARG"); sarg_wait = -1;
[ \t]*"%layer"{WHITE}{CSTR} {
  SKIP_PAST_SPACE(c8cpp_text);
  sprintf(lmask, ", LAYER_MASK, 0x1 << (%s)", c8cpp_text); lmask_wait = -1;
  sarg_wait = 0; BEGIN(pragma);
[ \t]*"%layers"{WHITE}{CSTR} {
  SKIP_PAST_SPACE(c8cpp_text); sprintf(lmask, ", LAYER_MASK, %s", c8cpp_text);
  lmask_wait = -1; sarg_wait = 0; BEGIN(pragma);
<pragma>";" {
  BEGIN(INITIAL);
<pragma>{OWHITE} {
  /* ignore whitespace */
<equation>"(" {
  strcat(VCURR, "("); paren_level++;
<equation>")" {
  strcat(VCURR, ")"); if (--paren_level == 0) { BEGIN(directive); vidx++; }
<equation>";" {
  fprintf(stderr, "Error parsing parenthesized equation\n"); exit(0);
<equation>. {
  strcat(VCURR, c8cpp_text);
<equation>"\n" {
  /* Ignore carrage return */
<directive>"(" {
  BEGIN(equation); paren_level = 1; strcpy(VCURR, "(");
<directive>[ \t\n]+ {
  /* ignore whitespace */
<directive>{NUMBER} {
  strcpy(VNEXT, yytext);
<directive>"read" {
printf(", READ_MODE"); VRST;
<directive>{FSTR}{WHITE}"field" {
  char *tmp = c8cpp_text; SKIP_TO_SPACE(c8cpp_text); *c8cpp_text = '\0';
  do_field(tmp); VRST;
<directive>"x-" {
  strcpy(VNEXT, "0");
<directive>"x+" {
strcpy(VNEXT, "1");
<directive>"y-" {
  strcpy(VNEXT, "2");
<directive>"y+" {
  strcpy(VNEXT, "3");
<directive>"z-" {
strcpy(VNEXT, "4");
<directive>"z+" {
strcpy(VNEXT, "5");
<directive>"reg!" {
  do_reg_fld_store(NULL); VRST;
<directive>";" {
  int i;
  BEGIN(INITIAL); for (i = 0; i < vidx; i++) printf(", %s", vals[i]);
  printf(", END_ARGS);"); VRST;
  if (dowhile) {
    printf(" }while(0);");
    dowhile = 0;
[ \t]*"%select" {
do_prefix("REG_MSR"); BEGIN(directive); VRST;
<directive>"don't-care" {
  printf(", LAYER_MASK, %s, REG_STORE, 7, ALL_LAYERS", vals[0]); VRST;
<directive>"dont-care" {
  printf(", LAYER_MASK, %s, REG_STORE, 7, ALL_LAYERS", vals[0]); VRST;
<directive>"sequential" {
  printf(", LAYER_MASK, %s, FLD_TA, 2, ALL_LAYERS", vals[0]); VRST;
<directive>"group" {
  printf(", FLD_TA, BIT_MASK, %s, ALL_LAYERS, FLD_GMS, 1", vals[0]); VRST;
<directive>"module" {
  printf(", FLD_TA, BIT_MASK, %s, FLD_GMS, 0", vals[0]); VRST;
<directive>"sequential-by-module-id" {
  printf(", REG_STORE, 4"); VRST;
<directive>"sequential-by-group-id" {
  printf(", REG_STORE, 5"); VRST;
<directive>"glue" {
  printf(", REG_STORE, 6"); VRST;
<directive>"all" {
  printf(", REG_STORE, 7"); VRST;
<directive>"*module" {
  printf(", FLD_TA, BIT_MASK, 1, ALL_LAYERS, FLD_GMS, 0, LAYER_MASK, 0xFFFE");
  printf(", REG_STORE, 7, ALL_LAYERS"); VRST;
<directive>"ta!" {
  do_reg_fld_store("FLD_TA"); VRST;
<directive>"gms!" {
  do_reg_fld_store("FLD_GMS"); VRST;
[ \t]*"%run" {
  do_prefix("REG_RMR") ; BEGIN(directive); VRST;
<directive>"no-scan" {
  printf(", FLD_SSM, 0"); VRST;
<directive>"frame" {
  printf(", FLD_SSM, 1, LAYER_MASK, 1<<5, FLD_RT, 1"); VRST;
<directive>"line" {
  printf(", FLD_SSM, 2, LAYER_MASK, 1<<10, FLD_RT, 1"); VRST;
<directive>"free" {
  printf(", FLD_SSM, 3, FLD_RT, 0"); VRST;
<directive>"continue-count" {
  printf(", FLD_ECT, 0"); VRST;
<directive>"new-count" {
  printf(", FLD_ECT, 1"); VRST;
<directive>"no-kick" {
  printf(", FLD_RPK, 0"); VRST;
<directive>"repeat-kick" {
  printf(", FLD_RPK, 1"); VRST;
<directive>"same-table" {
  printf(", FLD_ALT, 0"); VRST;
<directive>"new-table" {
  printf(", FLD_ALT, 1"); VRST;
<directive>"ssm!" {
  do_reg_fld_store("FLD_SSM"); VRST;
<directive>"rt!" {
  do_reg_fld_store("FLD_RT"); VRST;
<directive>"ect!" {
  do_reg_fld_store("FLD_ECT"); VRST;
<directive>"rpk!" {
  do_reg_fld_store("FLD_RPK"); VRST;
<directive>"alt!" {
  do_reg_fld_store("FLD_ALT"); VRST;
[ \t]*"%kick" {
  do_prefix("REG_KR"); BEGIN(directive); VRST;
<directive>"x" {
  printf(", KICK_X, %s", vals[0]); VRST;
<directive>"y" {
  printf(", KICK_Y, %s", vals[0]); VRST;
<directive>"z" {
  printf(", KICK_Z, %s", vals[0]); VRST;
<directive>"xn" {
  printf(", KICK_N, %s, %s", vals[1], vals[0]); VRST;
<directive>"ka!" {
  do_reg_fld_store("FLD_KA"); VRST;
<directive>"xks!" {
  do_reg_fld_store("FLD_XKS"); VRST;
<directive>"yks!" {
  do_reg_fld_store("FLD_YKS"); VRST;
<directive>"zks!" {
  do_reg_fld_store("FLD_ZKS"); VRST;
<directive>"xkmf!" {
  do_reg_fld_store("FLD_XKMF"); VRST;
<directive>"ykmf!" {
  do_reg_fld_store("FLD_YKMF"); VRST;
<directive>"zkmf!" {
  do_reg_fld_store("FLD_ZKMF"); VRST;
[ \t]*"%sa-bit" {
  do_prefix("REG_SABSR"); BEGIN(directive); VRST;
[ \t]*"%lut-src" {
  do_prefix("REG_LASR"); sel = "FLD_LAS"; map = "FLD_LAM"; BEGIN(directive);
  VRST;
<directive>"las!" {
  do_reg_fld_store("FLD_LAS"); VRST;
<directive>"lam!" {
  do_reg_fld_store("FLD_LAM"); VRST;
[ \t]*"%fly-src" {
  do_prefix("REG_FOSR"); sel = "FLD_FOS"; map = "FLD_FOM"; BEGIN(directive);
  VRST;
<directive>"fos!" {
  do_reg_fld_store("FLD_FOS"); VRST;
<directive>"fom!" {
  do_reg_fld_store("FLD_FOM"); VRST;
[ \t]*"%site-src" {
  do_prefix("REG_SDSR"); sel = "FLD_SDS"; map = "FLD_SDM"; BEGIN(directive);
  VRST;
<directive>"sds!" {
  do_reg_fld_store("FLD_SDS"); VRST;
<directive>"sdm!" {
  do_reg_fld_store("FLD_SDM"); VRST;
[ \t]*"%event-src" {
  do_prefix("REG_ECSR"); sel = "FLD_ECS"; map = "FLD_ECM"; BEGIN(directive);
  VRST;
<directive>"ecs!" {
  do_reg_fld_store("FLD_ECS"); VRST;
<directive>"ecm!" {
  do_reg_fld_store("FLD_ECM"); VRST;
[ \t]*"%display" {
  do_prefix("REG_DSR"); sel = "FLD_DDS"; map = "FLD_DDM"; BEGIN(directive);
  VRST;
<directive>"dds!" {
  do_reg_fld_store("FLD_DDS"); VRST;
<directive>"ddm!" {
  do_reg_fld_store("FLD_DDM"); VRST;
<directive>"sel!" {
  do_reg_fld_store(sel); VRST;
<directive>"map!" {
  do_reg_fld_store(map); VRST;
<directive>"site" {
  printf(", %s, 10", map); VRST;
<directive>"unglued" {
  printf(", %s, 0, %s, 12", sel, map); VRST;
<directive>"host" {
  printf(", %s, 1, %s, 12", sel, map); VRST;
<directive>"fly" {
  printf(", %s, 2, %s, 12", sel, map); VRST;
<directive>"address" {
  printf(", %s, 3, %s, 12", sel, map); VRST;
<directive>"lut" {
  printf(", %s, 3, %s, 12", sel, map); VRST;
[ \t]*"%show-scan" {
  do_prefix("REG_SSR"); BEGIN(directive); VRST;
<directive>"enable" {
  printf(", REG_STORE, 1"); VRST;
[ \t]*"%event" {
  do_prefix("REG_ECR"); BEGIN(directive); VRST;
[ \t]*"%lut-index" {
  do_prefix("REG_LIR"); BEGIN(directive); VRST;
[ \t]*"%lut-perm" {
  do_prefix("REG_LIPR"); BEGIN(directive); VRST;
[ \t]*"%lut-io" {
  do_prefix("REG_LIOR"); BEGIN(directive); VRST;
[ \t]*"%scan-index" {
  do_prefix("REG_SIR"); BEGIN(directive); VRST;
[ \t]*"%scan-perm" {
  do_prefix("REG_SIPR"); BEGIN(directive); VRST;
<directive>"sa0!" {
  do_reg_fld_store("FLD_SSA0"); VRST;
<directive>"sa1!" {
  do_reg_fld_store("FLD_SSA1"); VRST;
<directive>"sa2!" {
  do_reg_fld_store("FLD_SSA2"); VRST;
<directive>"sa3!" {
  do_reg_fld_store("FLD_SSA3"); VRST;
<directive>"sa4!" {
  do_reg_fld_store("FLD_SSA4"); VRST;
<directive>"sa5!" {
  do_reg_fld_store("FLD_SSA5"); VRST;
<directive>"sa6!" {
  do_reg_fld_store("FLD_SSA6"); VRST;
<directive>"sa7!" {
  do_reg_fld_store("FLD_SSA7"); VRST;
<directive>"sa8!" {
  do_reg_fld_store("FLD_SSA8"); VRST;
<directive>"sa9!" {
  do_reg_fld_store("FLD_SSA9"); VRST;
<directive>"sa10!" {
  do_reg_fld_store("FLD_SSA10"); VRST;
<directive>"sa11!" {
  do_reg_fld_store("FLD_SSA11"); VRST;
<directive>"sa12!" {
  do_reg_fld_store("FLD_SSA12"); VRST;
<directive>"sa13!" {
  do_reg_fld_store("FLD_SSA13"); VRST;
<directive>"sa14!" {
  do_reg_fld_store("FLD_SSA14"); VRST;
<directive>"sa15!" {
  do_reg_fld_store("FLD_SSA15"); VRST;
<directive>"sa16!" {
  do_reg_fld_store("FLD_SSA16"); VRST;
<directive>"sa17!" {
  do_reg_fld_store("FLD_SSA17"); VRST;
<directive>"sa18!" {
  do_reg_fld_store("FLD_SSA18"); VRST;
<directive>"sa19!" {
  do_reg_fld_store("FLD_SSA19"); VRST;
<directive>"sa20!" {
  do_reg_fld_store("FLD_SSA20"); VRST;
<directive>"sa21!" {
  do_reg_fld_store("FLD_SSA21"); VRST;
<directive>"sa22!" {
  do_reg_fld_store("FLD_SSA22"); VRST;
<directive>"sa23!" {
  do_reg_fld_store("FLD_SSA23"); VRST;
<directive>"sa!" {
  sprintf(tmp, "FLD_SSA(%s)", vals[--vidx]);
  do_reg_fld_store(tmp); VRST;
[ \t]*"%scan-io" {
  do_prefix("REG_SIOR"); BEGIN(directive); VRST;
[ \t]*"%scan-format" {
  do_prefix("REG_SFR"); BEGIN(directive); VRST;
<directive>"sm!" {
  do_reg_fld_store("FLD_SM"); VRST;
<directive>"esc!" {
  do_reg_fld_store("FLD_ESC"); VRST;
<directive>"esw!" {
  do_reg_fld_store("FLD_ESW"); VRST;
<directive>"est!" {
  do_reg_fld_store("FLD_EST"); VRST;
<directive>"sbrc!" {
  do_reg_fld_store("FLD_SBRC"); VRST;
<directive>"rcl!" {
  do_reg_fld_store("FLD_RCL"); VRST;
<directive>"ecl!" {
  do_reg_fld_store("FLD_ECL"); VRST;
<directive>"stm!" {
  do_reg_fld_store("FLD_STM"); VRST;
<directive>"escp!" {
  sprintf(tmp, "(%s) + 1", vals[0]);
  strcpy(vals[0], tmp);
  do_reg_fld_store("FLD_ESC"); VRST;
<directive>"eswp!" {
  sprintf(tmp, "(%s) + 1", vals[0]);
  strcpy(vals[0], tmp);
  do_reg_fld_store("FLD_ESW"); VRST;
<directive>"estp!" {
  sprintf(tmp, "(%s) + 1", vals[0]);
  strcpy(vals[0], tmp);
  do_reg_fld_store("FLD_EST"); VRST;
[ \t]*"%offset" {
  do_prefix("REG_OSR"); BEGIN(directive); VRST;
[ \t]*"%dimension" {
  do_prefix("REG_DR"); BEGIN(directive); VRST;
<directive>"dcm!" {
  do_reg_fld_store("FLD_DCM"); VRST;
<directive>"xdcp!" {
  do_reg_fld_store("FLD_XDCP"); VRST;
<directive>"ydcp!" {
  do_reg_fld_store("FLD_YDCP"); VRST;
<directive>"zdcp!" {
  do_reg_fld_store("FLD_ZDCP"); VRST;
<directive>"dcp!" {
  sprintf(tmp, "choose_dcp(%s)", vals[--vidx]);
  do_reg_fld_store(tmp); VRST;
[ \t]*"%environment" {
  do_prefix("REG_HER"); BEGIN(directive); VRST;
<directive>"lpl!" {
  do_reg_fld_store("FLD_LPL"); VRST;
<directive>"fpl!" {
  do_reg_fld_store("FLD_FPL"); VRST;
<directive>"dcs!" {
  do_reg_fld_store("FLD_DCS"); VRST;
<directive>"tbd!" {
  do_reg_fld_store("FLD_TBD"); VRST;
<directive>"tms!" {
  do_reg_fld_store("FLD_TMS"); VRST;
<directive>"nbf!" {
  do_reg_fld_store("FLD_NBF"); VRST;
<directive>"sre!" {
  do_reg_fld_store("FLD_SRE"); VRST;
<directive>"als!" {
  do_reg_fld_store("FLD_ALS"); VRST;
[ \t]*"%multi" {
  do_prefix("REG_MPCR"); BEGIN(directive); VRST;
<directive>"A.scan-input" {
  printf(", FLD_MAFS, 1"); VRST;
<directive>"A.status" {
  printf(", FLD_MAFS, 2"); VRST;
<directive>"A.box-enable" {
  printf(", FLD_MAFS, 3"); VRST;
<directive>"A.scan-in-progress" {
  printf(", FLD_MAFS, 4"); VRST;
<directive>"A.display-output-valid" {
  printf(", FLD_MAFS, 5"); VRST;
<directive>"A.site-address" {
  printf(", FLD_MAFS, 6"); VRST;
<directive>"A.unglued-data" {
  printf(", FLD_MAFS, 7"); VRST;
<directive>"A.host-data" {
  printf(", FLD_MAFS, 8"); VRST;
<directive>"A.lut-address-source" {
  printf(", FLD_MAFS, 9"); VRST;
<directive>"A.node-enable" {
  printf(", FLD_MAFS, 10"); VRST;
<directive>"A.test-output" {
  printf(", FLD_MAFS, 11"); VRST;
<directive>"A.regsel-29" {
  printf(", FLD_MAFS, 12"); VRST;
<directive>"A.regsel-30" {
  printf(", FLD_MAFS, 13"); VRST;
<directive>"A.zero" {
  printf(", FLD_MAFS, 14"); VRST;
<directive>"A.one" {
  printf(", FLD_MAFS, 15"); VRST;
<directive>"A.lut0-chip-select" {
  printf(", FLD_MAFS, 16"); VRST;
<directive>"A.lut1-chip-select" {
  printf("FLD_MAFS, 24"); VRST;
<directive>"B.status-input" {
  printf("FLD_MBFS, 0"); VRST;
<directive>"B.interrupt-input" {
  printf("FLD_MBFS, 1"); VRST;
<directive>"B.scan-active" {
  printf("FLD_MBFS, 2"); VRST;
<directive>"B.node-direction" {
  printf("FLD_MBFS, 3"); VRST;
<directive>"B.run-type" {
  printf("FLD_MBFS, 4"); VRST;
<directive>"B.lut-input-valid" {
  printf("FLD_MBFS, 5"); VRST;
<directive>"B.event-count-source" {
  printf("FLD_MBFS, 6"); VRST;
<directive>"B.site-data-source" {
  printf("FLD_MBFS, 7"); VRST;
<directive>"B.active-lut-output" {
  printf("FLD_MBFS, 8"); VRST;
<directive>"B.active-lut-select" {
  printf("FLD_MBFS, 9"); VRST;
<directive>"B.module-id" {
  printf("FLD_MBFS, 10"); VRST;
<directive>"B.interrupt-output" {
  printf("FLD_MBFS, 11"); VRST;
<directive>"B.modsel" {
  printf("FLD_MBFS, 12"); VRST;
<directive>"B.latch-glue-direction" {
  printf("FLD_MBFS, 13"); VRST;
<directive>"B.zero" {
  printf("FLD_MBFS, 14"); VRST;
<directive>"B.one" {
  printf("FLD_MBFS, 15"); VRST;
<directive>"B.lut0-write-enable" {
  printf("FLD_MBFS, 16"); VRST;
<directive>"B.lut1-write-enable" {
  printf("FLD_MBFS, 24"); VRST;
<directive>"mafs!" {
  do_reg_fld_store("FLD_MAFS"); VRST;
<directive>"mbfs!" {
  do_reg_fld_store("FLD_MBFS"); VRST;
[ \t]*"%connect" {
  do_prefix("REG_GPCR"); BEGIN(directive); VRST;
<directive>"xmpc!" {
  do_reg_fld_store("FLD_XMPC"); VRST;
<directive>"xppc!" {
  do_reg_fld_store("FLD_XPPC"); VRST;
<directive>"ympc!" {
  do_reg_fld_store("FLD_YMPC"); VRST;
<directive>"yppc!" {
  do_reg_fld_store("FLD_YPPC"); VRST;
<directive>"zmpc!" {
  do_reg_fld_store("FLD_ZMPC"); VRST;
<directive>"zppc!" {
  do_reg_fld_store("FLD_ZPPC"); VRST;
<directive>"+xn!" {
  sprintf(tmp, "((%s)+6)", vals[vidx - 2]);
  strcpy(vals[vidx - 2], tmp);
  sprintf(tmp, "choose_ppc(%s)", vals[--vidx]);
  do_reg_fld_store(tmp); VRST;
<directive>"-xn!" {
  sprintf(tmp, "choose_mpc(%s)", vals[--vidx]);
  do_reg_fld_store(tmp); VRST;
[ \t]*"%module-id" {
  do_prefix("REG_MIDR"); BEGIN(directive); VRST;
[ \t]*"%group-id" {
  do_prefix("REG_GIDR"); BEGIN(directive); VRST;
<directive>"id" {
  printf(", REG_STORE, BIT_MASK, %s, ALL_LAYERS", vals[0]); VRST;
[ \t]*"%int-enable" {
  do_prefix("REG_IER"); BEGIN(directive); VRST;
<directive>"bpie!" {
  do_reg_fld_store("FLD_BPIE"); VRST;
<directive>"bcie!" {
  do_reg_fld_store("FLD_BCIE"); VRST;
<directive>"gcie!" {
  do_reg_fld_store("FLD_GCIE"); VRST;
<directive>"maie!" {
  do_reg_fld_store("FLD_MAIE"); VRST;
<directive>"mbie!" {
  do_reg_fld_store("FLD_MBIE"); VRST;
<directive>"ssie!" {
  do_reg_fld_store("FLD_SSIE"); VRST;
<directive>"xhie!" {
  do_reg_fld_store("FLD_XHIE"); VRST;
<directive>"rlie!" {
  do_reg_fld_store("FLD_RLIE"); VRST;
<directive>"urie!" {
  do_reg_fld_store("FLD_URIE"); VRST;
<directive>"isie!" {
  do_reg_fld_store("FLD_ISIE"); VRST;
[ \t]*"%int-flags" {
  do_prefix("REG_IFR"); BEGIN(directive); VRST;
<directive>"bpif!" {
  do_reg_fld_store("FLD_BPIF"); VRST;
<directive>"bcif!" {
  do_reg_fld_store("FLD_BCIF"); VRST;
<directive>"gcif!" {
  do_reg_fld_store("FLD_GCIF"); VRST;
<directive>"maif!" {
  do_reg_fld_store("FLD_MAIF"); VRST;
<directive>"mbif!" {
  do_reg_fld_store("FLD_MBIF"); VRST;
<directive>"ssif!" {
  do_reg_fld_store("FLD_SSIF"); VRST;
<directive>"xhif!" {
  do_reg_fld_store("FLD_XHIF"); VRST;
<directive>"rlif!" {
  do_reg_fld_store("FLD_RLIF"); VRST;
<directive>"urif!" {
  do_reg_fld_store("FLD_URIF"); VRST;
<directive>"isif!" {
  do_reg_fld_store("FLD_ISIF"); VRST;
[ \t]*"%verify" {
  do_prefix("REG_VWR"); BEGIN(directive); VRST;
<directive>"begin" {
  printf(", FLD_VWE, 1, FLD_VWIE, 1, FLD_VWIF, 0"); VRST;
<directive>"end" {
  printf(", FLD_VWE, 0, FLD_VWIE, 0, FLD_VWIF, 0"); VRST;
<directive>"vwe!" {
  do_reg_fld_store("FLD_VWE"); VRST;
<directive>"vwie!" {
  do_reg_fld_store("FLD_VWIE"); VRST;
<directive>"vwif!" {
  do_reg_fld_store("FLD_VWIF"); VRST;
[ \t]*"%dram-count" {
  do_prefix("REG_DOCR"); BEGIN(directive); VRST;
<directive>"ldoc!" {
  do_reg_fld_store("FLD_LDOC"); VRST;
<directive>"hdoc!" {
  do_reg_fld_store("FLD_HDOC"); VRST;
<directive>"ones" {
  printf(", REG_LENGTH, %s, IMMED_MODE, REG_BUFFER, -1", vals[0]); VRST;
<directive>"zeroes" {
  printf(", REG_LENGTH, %s, IMMED_MODE, REG_BUFFER, 0", vals[0]); VRST;
<directive>"reads" {
  printf(", READ_MODE, INLINE_BUFFER, (%s) * 2", vals[0]); VRST;
<directive>"byte-reads" {
  printf(", BYTE_MODE, READ_MODE, INLINE_BUFFER, (%s) + 1, REG_LENGTH, %s",
	 vals[0], vals[0]); VRST;
<directive>"immediate-word" {
  printf(", IMMED_MODE, REG_BUFFER, (%s<<16), REG_LENGTH, 1", vals[0]); VRST;
<directive>"immediate-long" {
  printf(", IMMED_MODE, REG_BUFFER, %s, REG_LENGTH, 2", vals[0]); VRST;
[ \t]*"%delay" {
  printf("CAM_reg(cam8, REG_MIDR, IMMED_MODE, READ_MODE"); VRST;
  BEGIN(directive);
<directive>"clocks" {
  printf(", REG_LENGTH, %s", vals[0]); VRST;
[ \t]*"%lut-data"{WHITE} {
  SKIP_PAST_SPACE(c8cpp_text);
  dowhile = -1;
  printf("do {CAM_reg(cam8, REG_LIPR, END_ARGS); ");
  printf("CAM_reg(cam8, REG_LIR, END_ARGS); ");
  printf("CAM_reg(cam8, REG_SIOR, REG_BUFFER");  VRST; BEGIN(directive);
[ \t]*"%step"{OWHITE}";" {
  printf("CAM_step(cam8);");
[ \t]*"%*step*"{OWHITE}";" {
  printf("do {CAM_step(cam8); CAM_stop(cam8);}while(0);");
[ \t]*"%?jump"{OWHITE}";" {
  printf("CAM_reg(cam8, REG_MIDR, IMMED_MODE, READ_MODE, JUMP_POINT, END_ARGS);");
  VRST;
[ \t]*"%begin-defaults"{OWHITE}";" {
  printf("CAM_begin_defaults(cam8);"); VRST;
[ \t]*"%end-defaults"{OWHITE}";" {
  printf("CAM_end_defaults(cam8);"); VRST;
[ \t]*"%switch-luts"{OWHITE}";" {
  printf("CAM_reg(cam8, REG_RMR, FLD_SSM, 0, FLD_ECT, 0, FLD_ALT, 1, END_ARGS);");
  VRST;
int main(int argc, char *argv[])
  c8cpp_in = stdin;
  c8cpp_lex();
  exit(0);
int c8cpp_wrap()
  return 1;
void do_field(char *name)
void do_prefix(char *reg)
  printf("CAM_reg(cam8, %s", reg);
  if (lmask_wait)
    printf("%s", lmask);
  if (sarg_wait) {
    printf("%s", sarg);
    sarg_wait = 0;
void do_reg_fld_store(char *name)
  register int i;
  if (name == NULL)
    printf(", REG_STORE");
  else
    printf(", %s", name);
  for(i = 0; i < vidx; i++)
    printf(", %s", vals[i]);

---------------------------------------------------------------------------

