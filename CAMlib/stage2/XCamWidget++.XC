//
// Implements a XCAM widget.  Used to display images generated by CAM8.
// Has commands for dumping the contents to a file in xwd format.
//
#include <CAM++.H>
#include <CaLibStream++.H>
#include <CaLibError++.H>
#include <CaLibTrace++.H>
#include <Pipecomm++.H>

#include <XCamWidget++.H>

#include "std++.H"

extern "C" {
#include <stdio.h>
#include <signal.h>
#include <sys/types.h>
#include <sys/ipc.h>
#include <sys/shm.h>
#include <sys/mman.h>
#include <X11/Xos.h>
#include <X11/Xlib.h>
#include <X11/Xutil.h>
#include <X11/Xlib.h>
#include <X11/keysym.h>
#include <X11/DECkeysym.h>
#include <X11/XWDFile.h>
#ifdef XSHM
#include <X11/extensions/XShm.h>
#endif
#include <ppm.h>
#include <tcl.h>
#include <tk.h>

  int shmget(key_t, int, int);
  char * shmat(int, char *, int );
  int shmdt(char *);
  int shmctl(int, int, struct shmid_ds *);
  int munmap(caddr_t, size_t);
  FILE *popen(const char *, const char *);
  int pclose (FILE *);

  static int XCAMWidgetCmd(ClientData, Tcl_Interp *, int, char **);
  static void XCAMDestroy(char *);
  static void XCAMEventProc(ClientData, XEvent *);
  static void XCAMKeyProc(ClientData, XEvent *);
  static void XCAMInputFDProc(ClientData, int);

  static unsigned char * XCAMSetupSHMI(void *, unsigned char *, unsigned char *);
  static unsigned char * XCAMSetupSHMC(void *, unsigned char *, unsigned char *);
  static unsigned char * XCAMSetupKERI(void *, unsigned char *, unsigned char *);
  static unsigned char * XCAMSetupKERC(void *, unsigned char *, unsigned char *);
  static unsigned char * XCAMSetGLBX(void *, unsigned char *, unsigned char *);
  static unsigned char * XCAMSetGLBY(void *, unsigned char *, unsigned char *);
  static unsigned char * XCAMApply(void *, unsigned char *, unsigned char *);
  static unsigned char * XCAMFree(void *, unsigned char *, unsigned char *);
  static unsigned char * XCAMFreeAndExit(void *, unsigned char *, unsigned char *);
  static unsigned char * XCAMNullCmmd(void *, unsigned char *, unsigned char *);
}

#define PIPERET return((unsigned char *) retv)
#define XCAMRET return(retv[1])

static void pipedeath(int, void (*)());
static _swapshort(register char *, register unsigned);
static _swaplong(register char *, register unsigned);

//
//###########################################################################
//###########################################################################
//###########################################################################
// Copyright 1987 by Digital Equipment Corporation, Maynard, Massachusetts.
//
//                         All Rights Reserved
//
// Permission to use, copy, modify, and distribute this software and its
// documentation for any purpose and without fee is hereby granted,
// provided that the above copyright notice appear in all copies and that
// both that copyright notice and this permission notice appear in
// supporting documentation, and that the name of Digital Equipment
// Corporation not be used in advertising or publicity pertaining to
// distribution of the software without specific, written prior permission.
//
//
// DIGITAL DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
// ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL
// DIGITAL BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR
// ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
// WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
// ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
// SOFTWARE.
//
// HLG: This code was stripped from the xterm widget source.  It has been
//	MAJORLY butchered for use in the CAM Library (CAMLib).  It was taken
//	from the X11R6 release of the files input.c, charproc.c and ptyx.h
//
#if XlibSpecificationRelease != 6
#define XK_KP_Insert    0xFF9E
#define XK_KP_Delete    0xFF9F
#define XK_KP_Home      0xFF95
#define XK_KP_Begin     0xFF9D
#endif

/* define masks for flags */
#define CAPS_LOCK	0x01
#define KYPD_APL	0x02
#define CURSOR_APL	0x04

#define LINEFEED        0x2000  /* true if in auto linefeed mode */

/*
 * ANSI emulation.
 */
#define INQ	0x05
#define	FF	0x0C			/* C0, C1 control names		*/
#define	LS1	0x0E
#define	LS0	0x0F
#define	CAN	0x18
#define	SUB	0x1A
#define	ESC	0x1B
#define US	0x1F
#define	DEL	0x7F
#define HTS     ('H'+0x40)
#define	SS2	0x8E
#define	SS3	0x8F
#define	DCS	0x90
#define	OLDID	0x9A			/* ESC Z			*/
#define	CSI	0x9B
#define	ST	0x9C
#define	OSC	0x9D
#define	PM	0x9E
#define	APC	0x9F
#define	RDEL	0xFF

#define NPARAM  10                      /* Max. parameters              */

#define STRBUFSIZE 100

typedef char Boolean;

typedef struct {
  unsigned char	a_type;
  unsigned char	a_pintro;
  unsigned char	a_final;
  unsigned char	a_inters;
  char	a_nparam;		/* # of parameters		*/
  char	a_dflt[NPARAM];		/* Default value flags		*/
  short	a_param[NPARAM];	/* Parameters			*/
  char	a_nastyf;		/* Error flag			*/
} ANSI;

typedef struct {
  Boolean input_eight_bits;/* use 8th bit instead of ESC prefix */
} TScreen;

typedef struct
{
  unsigned flags;
} TKeyboard;

static char *kypd_num = " XXXXXXXX\tXXX\rXXXxxxxXXXXXXXXXXXXXXXXXXXXX*+,-./0123456789XXX=";
static char *kypd_apl = " ABCDEFGHIJKLMNOPQRSTUVWXYZ??????abcdefghijklmnopqrstuvwxyzXXX";
static char *xterm_cur = "DACB";
static unsigned term_flags = 0;
static Boolean sunFunctionKeys = TRUE;

static int funcvalue(int);
static int sunfuncvalue(int);
static void unparseputc(char, FILE *);
static void unparsefputs(register char *, FILE *);
static void unparseputn(unsigned int, FILE *);
static void unparseseq(register ANSI *, FILE *);
//
//###########################################################################
//###########################################################################
//###########################################################################
//

/* Descriptor types */
#define IMAG         'i'
#define SHMIMAG      'I'
#define XSHMIMAG     'X'
#define CMAP         'c'
#define SHMCMAP      'C'

/* Capture flags */
#define FALSE		0
#define TO_FILES	-1
#define START_STREAM	-100
#define CONTINUE_STREAM	-200
#define FINISH_STREAM	-300
#define UNLIMITED	-1

/*
 * Information used for argv parsing.
 */
static Tk_ConfigSpec configSpecs[] = {
  {TK_CONFIG_ACTIVE_CURSOR, "-cursor", "cursor", "Cursor",
     "top_left_arrow", Tk_Offset(XCamWidget, cur), TK_CONFIG_NULL_OK},
  {TK_CONFIG_PIXELS, "-height", "height", "Height",
     "512", Tk_Offset(XCamWidget, height), 0},
  {TK_CONFIG_PIXELS, "-width", "width", "Width",
     "512", Tk_Offset(XCamWidget, width), 0},
  {TK_CONFIG_END, (char *) NULL, (char *) NULL, (char *) NULL,
     (char *) NULL, 0, 0}
};

/*
 * Pipecomm callback command table
 */
static Cmdt ctbl[] = {
  { "quit", XCAMFreeAndExit },
  { "shmi", XCAMSetupSHMI },
  { "shmc", XCAMSetupSHMC },
  { "keri", XCAMSetupKERI },
  { "kerc", XCAMSetupKERC },
  { "glbx", XCAMSetGLBX },
  { "glby", XCAMSetGLBY },
  { "aply", XCAMApply },
  { "free", XCAMFree },
  { "null", XCAMNullCmmd },
  { "", NULL }
};


XCamWidget::XCamWidget(int ifd, int ofd, int cfd)
{
  Bzero();
  camfd = cfd;
  pc = new Pipecomm(ifd, ofd);
}

XCamWidget::~XCamWidget(void)
{
  delete pc;
}

STD_BZERO(XCamWidget)




//
// TCL Command procedures
//
int XCamWidget::XCmd(ClientData clientData, Tcl_Interp *interp, int argc, char **argv)
{
  Tk_Window main = (Tk_Window) clientData;
  XColor p[256];
  long i;
#ifdef XSHM
  char dn[128], hn[128];
  long int a1 = 0, a2 = 0;
  struct hostent *htmp;
#endif
  char fifoname[32];
  FILE *tf;
  CAM_tb.ENTER("XCamWidget::XCmd");

  /* Try to die gracefully on broken pipe */
  signal(SIGPIPE, pipedeath);

  if (argc < 2) {
    Tcl_AppendResult(interp, "wrong # args:  should be \"",
		     argv[0], " pathName ?options?\"", (char *) NULL);
    CAM_tb.LEAVE();
    return(TCL_ERROR);
  }
  
  tkwin = Tk_CreateWindowFromPath(interp, main, argv[1], (char *) NULL);

  if (tkwin == NULL) {
    CAM_tb.LEAVE();
    return(TCL_ERROR);
  }

  Tk_MakeWindowExist(tkwin);
  Tk_SetClass(tkwin, "XCAM");
  
  /*
   * Initialize the widget record.
   */
  ti = interp;
  dpy = Tk_Display(tkwin);
  s = Tk_ScreenNumber(tkwin);
  w = Tk_WindowId(tkwin);
  v = Tk_Visual(tkwin);
  cmap = XCreateColormap(dpy, w, v, AllocAll);
  pcmap = Tk_Colormap(Tk_Parent(tkwin));
  cur = None;
  gc = Tk_GetGC(tkwin, 0, 0);
  width = 0;
  height = 0;
  black = FindClosestColor(pcmap, 0, 0, 0);
  memset(dtbl, 0, sizeof(XCam_Desc) * DESCTBLSZ);
  glbx = 512;
  glby = 512;
  locx = 0;
  locy = 0;
  lid = -1;
  lcu = -1;
  pmode = CAM_PIPEALL;
  capture = FALSE;
  ftot = 0;
  fcnt = 0;
  fcmd = NULL;
  forth_fifo = NULL;
  retv[0] = 0;
  retv[1] = 0;

  pc->SetPipeCmdTable(ctbl);
  pc->SetPipeMode(CAM_PIPEALL);

#ifdef XSHM
  xshmok = XShmQueryExtension(dpy);
  strcpy(dn, DisplayString(dpy));
  if (dn[0] != ':') {

    for(i = 0; i < 128; i++) {
      
      if (dn[i] != ':')
	continue;
      else {
	memset(dn + i, 0, 128 - i); 
	break;
      }
    }
    
    gethostname(hn, 128);
    
    htmp = gethostbyname(hn);
    if (htmp != NULL)
      memcpy(&a1, htmp->h_addr_list[0], htmp->h_length);

    htmp = gethostbyname(dn);
    if (htmp != NULL)
      memcpy(&a2, htmp->h_addr_list[0], htmp->h_length);

    if ((a1 == 0) || (a2 == 0)) {
      CamMessage(TRUE, "\nCan't determine if X Shared Memory is okay\n");
      CamMessage(TRUE, "Assuming it is not\n");
      xshmok = False;
    }

    if (a1 != a2) {
      xshmok = False;
      CompType = XShmGetEventBase(dpy) + ShmCompletion;
    }
  }
#endif

  CopyColormap(pcmap, cmap);

  Tk_SetWindowColormap(tkwin, cmap);

  Tk_SetWindowBackground(tkwin, black);

  Tk_CreateEventHandler(tkwin,
			ExposureMask|StructureNotifyMask|ColormapChangeMask|
			PointerMotionMask,
			XCAMEventProc, (ClientData) this);

  if ( ((tf = fopen("/tmp/fifoname", "r")) != NULL) &&
       (fscanf(tf, "%s", fifoname) == 1) && (fclose(tf) == 0) &&
       ((forth_fifo = fopen(fifoname, "w")) != NULL) )
    Tk_CreateEventHandler(tkwin, KeyPressMask, XCAMKeyProc, (ClientData) this);

  Tk_CreateFileHandler(pc->infd, TK_READABLE, XCAMInputFDProc, (ClientData) this);

  Tcl_CreateCommand(interp, Tk_PathName(tkwin), XCAMWidgetCmd,
		    (ClientData) this, (void (*)(void *)) NULL);
  
  if (Configure(interp, argc-2, argv+2, 0) != TCL_OK) {
    Tk_DestroyWindow(tkwin);
    CAM_tb.LEAVE();
    return(TCL_ERROR);
  }
  
  interp->result = Tk_PathName(tkwin);
  CAM_tb.LEAVE();
  return(TCL_OK);
}

int XCamWidget::WidgetCmd(Tcl_Interp *interp, int argc, char **argv)
{
  int result = TCL_OK;
  int length;

  
  if (argc < 2) {
    Tcl_AppendResult(interp, "wrong # args: should be \"",
		     argv[0], " option ?arg arg ...?\"", (char *) NULL);
    return(TCL_ERROR);
  }
  
  Tk_Preserve((ClientData) this);
  length = strlen(argv[1]);

  if (strncmp(argv[1], "configure", length) == 0) {
    switch(argc) {

    case 2: {
      result = Tk_ConfigureInfo(interp, tkwin, configSpecs, (char *) this,
				(char *) NULL, 0);
      break;
    }

    case 3: {
      result = Tk_ConfigureInfo(interp, tkwin, configSpecs, (char *) this,
				argv[2], 0);
      break;
    }

    default: {    
      result = Configure(interp, argc - 2, argv + 2, 0);
    }
    }
  }

  else if (strncmp(argv[1], "pipe", length) == 0)
    result = PipeImag(interp, argc - 2, argv + 2);

  else if (strncmp(argv[1], "wimag", length) == 0)
    result = WriteImag(interp, argc - 2, argv + 2);

  else if (strncmp(argv[1], "wcmap", length) == 0)
    result = WriteCmap(interp, argc - 2, argv + 2);

  else if (strncmp(argv[1], "resize", length) == 0)
    result = ResizeWindow(interp, argc - 2, argv + 2);

  else if (strncmp(argv[1], "ignore", length) == 0)
    pc->SetPipeMode(pmode = CAM_PIPENONE);

  else if (strncmp(argv[1], "pause", length) == 0)
    pc->SetPipeMode(pmode = CAM_PIPEPAUSE);

  else if (strncmp(argv[1], "cont", length) == 0)
    pc->SetPipeMode(pmode = CAM_PIPEALL);

  else if (strncmp(argv[1], "menucmap", length) == 0)
    Tk_SetWindowColormap(Tk_NameToWindow(ti, ".", tkwin), pcmap);

  else if (strncmp(argv[1], "imagcmap", length) == 0)
    Tk_SetWindowColormap(Tk_NameToWindow(ti, ".", tkwin), cmap);

  else if (strncmp(argv[1], "capture", length) == 0)
    result = ToggleCaptureFrames(interp, argc - 2, argv + 2);

  else {
    Tcl_AppendResult(interp, "bad option \"", argv[1],
		     "\":  must be configure, position, or size",(char *) NULL);
    goto error;
  }

  Tk_Release((ClientData) this);
  return(result);
  
 error:
  Tk_Release((ClientData) this);
  return(TCL_ERROR);
}

int XCamWidget::Configure(Tcl_Interp *interp, int argc, char **argv, int flags)
{
  if (Tk_ConfigureWidget(interp, tkwin, configSpecs, argc, argv,
			 (char *) this, flags) != TCL_OK) {
    return(TCL_ERROR);
  }
  
  /*
   * Register the desired geometry for the window.  Then arrange for
   * the window to be redisplayed.
   */
  
  Tk_GeometryRequest(tkwin, width, height);

  return(TCL_OK);
}

int XCamWidget::PipeImag(Tcl_Interp *interp, int argc, char **argv)
{
  FILE *fp;
  register int i;
  int win_name_size;
  int header_size;
  unsigned int buffer_size;
  unsigned long swaptest = 1;
  char *win_name;
  XColor colors[256];
  Bool got_win_name;
  XImage *image;
  Window dummywin;
  XWDFileHeader header;
  CARD32 *tptr;
    


  if (argc < 1) {
    Tcl_SetResult(interp, "need_args", TCL_STATIC);
    return(TCL_OK);
  }

  if (lid == -1) {
    Tcl_SetResult(interp, "no_image", TCL_STATIC);
    return(TCL_OK);
  }

  if ((fp = popen(argv[0], "w")) == NULL) {
    Tcl_SetResult(interp, "command_failed", TCL_STATIC);
    return(TCL_OK);
  }

  XFetchName(dpy, w, &win_name);
  if (!win_name || !win_name[0]) {
    win_name = "xwdump";
    got_win_name = False;
  }
  else
    got_win_name = True;

  /* sizeof(char) is included for the null string terminator. */
  win_name_size = strlen(win_name) + sizeof(char);

  image = dtbl[lid].obj.i;

  /*
   * Determine the pixmap size.
   */
  buffer_size = Image_Size(image);

  Get_XColors(colors);

  /*
   * Calculate header size.
   */
  header_size = sizeof(header) + win_name_size;

  /*
   * Write out header information.
   */
  header.header_size = (CARD32) header_size;
  header.file_version = (CARD32) XWD_FILE_VERSION;
  header.pixmap_format = (CARD32) ZPixmap;
  header.pixmap_depth = (CARD32) image->depth;
  header.pixmap_width = (CARD32) image->width;
  header.pixmap_height = (CARD32) image->height;
  header.xoffset = (CARD32) image->xoffset;
  header.byte_order = (CARD32) image->byte_order;
  header.bitmap_unit = (CARD32) image->bitmap_unit;
  header.bitmap_bit_order = (CARD32) image->bitmap_bit_order;
  header.bitmap_pad = (CARD32) image->bitmap_pad;
  header.bits_per_pixel = (CARD32) image->bits_per_pixel;
  header.bytes_per_line = (CARD32) image->bytes_per_line;

  /*
   * This hack is equivalent to:
   *	  header.visual_class = (CARD32) v->class;
   *
   * Its necessary because class in a keyword in C++
   */
  tptr = (CARD32 *) (&(image->bytes_per_line) + 1);
  header.visual_class = *tptr;

  header.red_mask = (CARD32) v->red_mask;
  header.green_mask = (CARD32) v->green_mask;
  header.blue_mask = (CARD32) v->blue_mask;
  header.bits_per_rgb = (CARD32) v->bits_per_rgb;
  header.colormap_entries = (CARD32) v->map_entries;
  header.ncolors = 256;
  header.window_width = (CARD32) image->width;
  header.window_height = (CARD32) image->height;
  header.window_x = 0;
  header.window_y = 0;
  header.window_bdrwidth = (CARD32) 0;
  
  if (*(char *) &swaptest) {
    _swaplong((char *) &header, sizeof(header));
    for (i = 0; i < 256; i++) {
      _swaplong((char *) &(colors[i].pixel), sizeof(long));
      _swapshort((char *) &(colors[i].red), 3 * sizeof(short));
    }
  }

  (void) fwrite((char *)&header, sizeof(header), 1, fp);
  (void) fwrite(win_name, win_name_size, 1, fp);
  
  /*
   * Write out the color maps, if any
   */
  (void) fwrite((char *) colors, sizeof(XColor), 256, fp);

  /*
   * Write out the buffer.
   *
   *    This copying of the bit stream (data) to a file is to be replaced
   *  by an Xlib call which hasn't been written yet.  It is not clear
   *  what other functions of xwd will be taken over by this (as yet)
   *  non-existant X function.
   */
  (void) fwrite(image->data, (int) buffer_size, 1, fp);

  /*
   * Free window name string.
   */
  if (got_win_name) XFree(win_name);

  fflush(fp);
  pclose(fp);

  Tcl_SetResult(interp, "complete", TCL_STATIC);
  return(TCL_OK);
}

int XCamWidget::WriteImag(Tcl_Interp *interp, int argc, char **argv)
{
  int f;
  register int nb;


  if (argc < 1) {
    Tcl_SetResult(interp, "need_args", TCL_STATIC);
    return(TCL_OK);
  }

  if (lid == -1) {
    Tcl_SetResult(interp, "no_image", TCL_STATIC);
    return(TCL_OK);
  }

  if ((f = open(argv[0], O_CREAT|O_WRONLY, 0744)) == -1) {
    Tcl_SetResult(interp, "cannot_open", TCL_STATIC);
    return(TCL_OK);
  }

  nb = dtbl[lid].obj.i->width * dtbl[lid].obj.i->height;

  if (WriteBytes(f, (unsigned char *) dtbl[lid].obj.i->data, nb) != nb) {
    Tcl_SetResult(interp, "write_failed", TCL_STATIC);
    return(TCL_OK);
  }

  close(f);

  Tcl_SetResult(interp, "complete", TCL_STATIC);
  return(TCL_OK);
}

int XCamWidget::WriteCmap(Tcl_Interp *interp, int argc, char **argv)
{
  int f;
  register int i;
  CamCm cm;
  XColor p[256];


  if (argc < 1) {
    Tcl_SetResult(interp, "need_args", TCL_STATIC);
    return(TCL_OK);
  }

  if ((f = open(argv[0], O_CREAT|O_WRONLY, 0744)) == -1) {
    Tcl_SetResult(interp, "cannot_open", TCL_STATIC);
    return(TCL_OK);
  }

  Get_XColors(p);

  for (i = 0; i < 256; i++) {

    cm.p = p[i].pixel;
    cm.r = p[i].red / 257;
    cm.g = p[i].green / 257;
    cm.b = p[i].blue / 257;

    if (WriteBytes(f, (unsigned char *) &cm, sizeof(CamCm)) != sizeof(CamCm)) {
      Tcl_SetResult(interp, "write_failed", TCL_STATIC);
      return(TCL_OK);
    }
  }

  close(f);
  Tcl_SetResult(interp, "complete", TCL_STATIC);
  return(TCL_OK);
}

int XCamWidget::ResizeWindow(Tcl_Interp *interp, int argc, char **argv)
{
  int x, y, mw, mh;
  Tk_Window root, topbar;

  root = Tk_NameToWindow(ti, ".", tkwin);
  topbar = Tk_NameToWindow(ti, ".topbar", tkwin);

  if (argc < 1) {

    mw = glbx;
    mh = Tk_Height(topbar) + glby;

    /* Resize to global X and Y settings */
    Tk_ResizeWindow(root, mw, mh);

    Tcl_SetResult(interp, "complete", TCL_STATIC);
    return(TCL_OK);
  }

  else {

    /* Dimensions specified */

    if (argc < 2) {
      Tcl_SetResult(interp, "need_args", TCL_STATIC);
      return(TCL_OK);
    }

    x = atoi(argv[0]);
    y = atoi(argv[1]);

    if ((x > 0) && (y > 0)) {

      Tk_ResizeWindow(tkwin, x, y);

      Tcl_SetResult(interp, "complete", TCL_STATIC);
      return(TCL_OK);
    }

    else {

      Tcl_SetResult(interp, "command_failed", TCL_STATIC);
      return(TCL_OK);
    }
  }
}

int XCamWidget::ToggleCaptureFrames(Tcl_Interp *interp, int argc, char **argv)
{

  if (argc < 2) {
      Tcl_SetResult(interp, "need_args", TCL_STATIC);
      return(TCL_OK);
    }

  switch(capture) {

  case TO_FILES: {

    fcnt = ftot = 0;
    free(fcmd);
    fcmd = NULL;
    capture = FALSE;
    break;
  }

  case FALSE: {

    capture = TO_FILES;
    ftot = atoi(argv[0]);
    fcmd = strdup(argv[1]);
    fcnt = 0;
    break;
  }
  }

  Tcl_SetResult(interp, "ok", TCL_STATIC);
  return(TCL_OK);
}

void XCamWidget::Destroy(void)
{
  Tk_FreeOptions(configSpecs, (char *) this, dpy, 0);
  Tk_FreeGC(dpy, gc);
  delete this;
}

//
// TCL Event callback procedures
//
void XCamWidget::InputFDProc(int mask)
{
  int rv;

  if ((rv = pc->ParsePipeMesg((char *) this)) < CAM_PIPEALL)
    pc->sendmesg(rv);

  (void) Tcl_Eval(ti, "update idletasks");
}

void XCamWidget::EventProc(XEvent *eventPtr)
{
  static int argc = 1;
  Bool *tptr;
  
  switch(eventPtr->type) {

  case Expose: {
    if (eventPtr->xexpose.count == 0) {
      if (lid == -1)
	XClearWindow(dpy, w);
      else
	if ((this->*dtbl[lid].Apply)((void *) this, &(dtbl[lid])) != 0)
	  lid = -1;
    }
    break;
  }

  case ConfigureNotify: {

    Tk_MapWindow(tkwin);
    break;
  }

  case DestroyNotify: {
    Tcl_DeleteCommand(ti, Tk_PathName(tkwin));
    tkwin = NULL;

    Tk_EventuallyFree((ClientData) this, (Tcl_FreeProc *) XCAMDestroy);
    break;
  }

  case ColormapNotify: {
  /*
   * This hack is equivalent to:
   *	  if ((eventPtr->xcolormap.new == True) ||
   *
   * Its necessary because new is a keyword in C++
   */
    tptr = (Bool *) (&(eventPtr->xcolormap.colormap) + 1);
    if ((*tptr == True) || (eventPtr->xcolormap.state == ColormapInstalled)) {
      black = FindClosestColor(eventPtr->xcolormap.colormap, 0, 0, 0);
      Tk_SetWindowBackground(tkwin, black);
    }
    break;
  }

  }
}

void XCamWidget::KeyProc(XEvent *eventPtr)
{
  static char buf[16];
  static int len, i;
  static KeySym ks;

  if (forth_fifo != NULL) {

    switch(eventPtr->type) {

    case KeyPress: {
      if (pc->infd != fileno(stdin))
	SendKeyString((XKeyEvent *) eventPtr, forth_fifo);
      break;
    }
    }

  }
}

void XCamWidget::Get_XColors(XColor *colors)
{
  register int i;


#ifdef CORRECTCMAP
  if (v->class == DirectColor || v->class == TrueColor) {
    Pixel red, green, blue, red1, green1, blue1;
    
    red = green = blue = 0;
    red1 = lowbit(v->red_mask);
    green1 = lowbit(v->green_mask);
    blue1 = lowbit(v->blue_mask);

    for (i = 0; i < ncolors; i++) {
      colors[i].pixel = red|green|blue;
      colors[i].pad = 0;
      red += red1;
      if (red > v->red_mask)
	red = 0;
	green += green1;
      if (green > v->green_mask)
	green = 0;
      blue += blue1;
      if (blue > v->blue_mask)
	blue = 0;
    }
  }

  else
#endif
    
    {
      for (i = 0; i < 256; i++) {
	colors[i].pixel = i;
	colors[i].pad = 0;
      }
    }

  XQueryColors(dpy, cmap, colors, 256);
}

int XCamWidget::desc_idx(char *b)
{
  int d = *((int *) b);

  if (d > DESCTBLSZ)
    return(-1);

  if ( dtbl[d].Apply == (DESC_APPLY_FUNC) NULL)
    return(-1);

  return(d);
}

void XCamWidget::CopyColormap(Colormap s, Colormap d)
{
  register int i;
  XColor p[256];

  for(i = 0; i < 256; i++) {
    p[i].pixel = i;
    p[i].pad = 0;
  }

  XQueryColors(dpy, s, p, 256);
  XStoreColors(dpy, d, p, 256);
}

int XCamWidget::FindClosestColor(Colormap cm, unsigned short r,
			    unsigned short b, unsigned short g)
{
  register int i;
  XColor p[256];
  int rv;
  unsigned short dist, mindist;

  for(i = 0; i < 256; i++) {
    p[i].pixel = i;
    p[i].pad = 0;
  }

  XQueryColors(dpy, cm, p, 256);

  mindist = abs(p[0].red - r) + abs(p[0].green - g) + abs(p[0].blue - b);
  rv = 0;

  for(i = 1; i < 256; i++) {

    dist = abs(p[i].red - r) + abs(p[i].green - g) + abs(p[i].blue - b);
    if (dist < mindist) {

      mindist = dist;
      rv = i;
    }
  }

  return(rv);
}

void XCamWidget::CaptureFrame(XCAM_DESC ds)
{
  XColor cm[256];
  CAM_tb.ENTER("XCamWidget::CaptureFrame");

  Get_XColors(cm);

  switch(capture) {

  case TO_FILES: {

    char cmd[128];
    int x, y;
    unsigned char r, g, b, p, *d;
    XColor cm[256];
    FILE *f;

    sprintf(cmd, fcmd, fcnt);
  
    if ((f = popen(cmd, "w")) == NULL) {
      CamMessage(TRUE, "Can't pipe to capture command: %s\n", cmd);
      CamMessage(TRUE, "Capture aborted\n");
      ftot = fcnt = 0;
      free(fcmd);
      fcmd = NULL;
      capture = FALSE;
    }

    else {

      Get_XColors(cm);
      d = (unsigned char *) ds->obj.i->data;

      ppm_writeppminit(f, glbx, glby, 255, 0);

      for(y = 0; y < glby; y++)
	for(x = 0; x < glbx; x++) {
	  
	  p = d[x + y * glbx];
	  r = cm[p].red / 257;
	  g = cm[p].green / 257;
	  b = cm[p].blue / 257;

	  fwrite(&r, sizeof(unsigned char), 1, f);
	  fwrite(&g, sizeof(unsigned char), 1, f);
	  fwrite(&b, sizeof(unsigned char), 1, f);
	}
 
      pclose(f);
      fcnt++;

      if ((ftot != UNLIMITED) && (fcnt) == ftot) {
	ftot = fcnt = 0;
	free(fcmd);
	fcmd = NULL;
	capture = FALSE;
      }
    }

    break;
  }


  case START_STREAM: {

    /*******************************************************************/
    /* Need to send command to mpeg_encode process to start the stream */
    /*******************************************************************/

    capture = CONTINUE_STREAM;
    break;
  }


  case CONTINUE_STREAM: {

    /**********************************************************************/
    /* Need to send command to mpeg_encode process to continue the stream */
    /**********************************************************************/

    fcnt++;

    if ((ftot != UNLIMITED) && (fcnt == ftot))
      capture = FINISH_STREAM;

    break;
  }

  case FINISH_STREAM: {

    /********************************************************************/
    /* Need to send command to mpeg_encode process to finish the stream */
    /********************************************************************/


    capture = FALSE;
    break;
  }
  }
  CAM_tb.LEAVE();
}

/****************************************************************************/
/*		    Begining of Command Table Procedures	            */
/****************************************************************************/

unsigned char * XCamWidget::SetupSHMI(unsigned char *o, unsigned char *b)
{
  register int i;
  register XCAM_DESC p;
  int nd;
  caddr_t ptr;
  CAM_tb.ENTER("XCamWidget::SetupSHMI");

  FindNxt(nd);
  
  if (nd >= 0)
    p = &(dtbl[nd]);

  else {
    CAM_tb.LEAVE();
    SETRETV(-1000, -1);
    PIPERET;
  }

  p->shm.id = *((int *) b);

  for(i = 0; i < nd; i++)
    if (dtbl[i].shm.id == p->shm.id)
      p->shm.cnt = dtbl[i].shm.cnt + 1;
  
#ifdef XSHM
  if (xshmok) {
    p->shm.info.shmid = p->shm.id;
    p->type = XSHMIMAG;
    p->obj.i = XShmCreateImage(dpy, v, 8, ZPixmap, 0, &(p->shm.info), glbx, glby);
  }

  else
#endif
    {
    normximage:
      p->type = SHMIMAG;
      p->obj.i = XCreateImage(dpy, v, 8, ZPixmap, 0, NULL, glbx, glby, 8, 0);
    }

  if ((ptr = (caddr_t) shmat(p->shm.id, 0, SHM_RDONLY)) == (caddr_t) -1) {

    CamMessage(TRUE, "Error trying to attach to shmid %d\n", p->shm.id);

    XDestroyImage(p->obj.i);
    CAM_tb.LEAVE();
    SETRETV(-1000, -1);
    PIPERET;
  }

  p->obj.i->data = (char *) (ptr + HEADER_LENGTH);

#ifdef XSHM
  if (xshmok) {
    p->shm.info.shmaddr = p->obj.i->data;
    p->shm.info.readOnly = True;
    p->Apply = &(XCamWidget::DispXSHMImage);

    if (XShmAttach(dpy, &(p->shm.info)) == False) {
      CamMessage(TRUE, "X Shared Memory Extension error...\n");
      CamMessage(TRUE, "Using normal XLIB calls.\n");
      xshmok = False;
      XDestroyImage(p->obj.i);
      shmdt(p->shm.info.shmaddr);
      goto normximage;
    }
  }

  else
#endif

    p->Apply = &(XCamWidget::DispXImage);

  CAM_tb.LEAVE();
  SETRETV(0, nd);
  PIPERET;
}

unsigned char * XCamWidget::SetupSHMC(unsigned char *o, unsigned char *b)
{
  register int i;
  register XCAM_DESC p;
  int nd;
  caddr_t ptr;
  CAM_tb.ENTER("XCamWidget::SetupSHMC");


  FindNxt(nd);
  
  if (nd >= 0)
    p = &(dtbl[nd]);

  else {
    CAM_tb.LEAVE();
    SETRETV(-1000, -1);
    PIPERET;
  }


  p->shm.id = *((int *) b);
  p->type = SHMCMAP;
  
  for(i = 0; i < nd; i++)
    if (dtbl[i].shm.id == p->shm.id)
      p->shm.cnt = dtbl[i].shm.cnt + 1;

  if ((ptr = (caddr_t) shmat(p->shm.id, 0, SHM_RDONLY)) == (caddr_t) -1) {

    CamMessage(TRUE, "Error trying to attach to shmid %d\n", p->shm.id);
    CAM_tb.LEAVE();
    SETRETV(-1000, -1);
    PIPERET;
  }

  p->obj.c = (CAMCM) (ptr + HEADER_LENGTH);
  p->Apply = &(XCamWidget::AllocCmap);

  CAM_tb.LEAVE();
  SETRETV(0, nd);
  PIPERET;
}

unsigned char * XCamWidget::SetupKERI(unsigned char *o, unsigned char *b)
{
  register int i;
  register XCAM_DESC p;
  int nd;
  char *ip = *((char **) b);
  CAM_tb.ENTER("XCamWidget::SetupKERI");

  FindNxt(nd);
  
  if (nd >= 0)
    p = &(dtbl[nd]);

  else {
    CAM_tb.LEAVE();
    SETRETV(-1000, -1);
    PIPERET;
  }

  ip = mmap(0, glbx * glby + HEADER_LENGTH, PROT_READ, MAP_SHARED, camfd,
	    (off_t) ip);

  if (ip == (char *) -1) {
    CAM_tb.LEAVE();
    SETRETV(-1000, -1);
    PIPERET;
  }

  p->type = IMAG;
  p->obj.i = XCreateImage(dpy, v, 8, ZPixmap, 0,
			  (ip + HEADER_LENGTH),
			  glbx, glby, 8, 0);
  p->Apply = &(XCamWidget::DispXImage);

  CAM_tb.LEAVE();
  SETRETV(0, nd);
  PIPERET;
}

unsigned char * XCamWidget::SetupKERC(unsigned char *o, unsigned char *b)
{
  register int i;
  register XCAM_DESC p;
  int nd;
  char *cp = *((char **) b);
  CAM_tb.ENTER("XCamWidget::SetupKERC");

  FindNxt(nd);
  
  if (nd >= 0)
    p = &(dtbl[nd]);

  else {
    CAM_tb.LEAVE();
    SETRETV(-1000, -1);
    PIPERET;
  }

  cp = mmap(0, 256 * sizeof(CamCm) + HEADER_LENGTH, PROT_READ, MAP_SHARED, camfd,
	    (off_t) cp);

  if (cp == (char *) -1) {
    CAM_tb.LEAVE();
    CamMessage.Perror(CAMerr, NULL);
    SETRETV(-1000, -1);
    PIPERET;
  }

  p->type = CMAP;
  p->obj.c = (CAMCM) (cp + HEADER_LENGTH);
  p->Apply = &(XCamWidget::AllocCmap);

  CAM_tb.LEAVE();
  SETRETV(0, nd);
  PIPERET;
}

unsigned char * XCamWidget::SetGLBX(unsigned char *o, unsigned char *b)
{
  int x = *((int *) b);
  CAM_tb.ENTER("XCamWidget::SetGLBX");

  if (x < 0) {
    CAM_tb.LEAVE();
    SETRETV(-1000, -1);
    PIPERET;
  }
  else {
    glbx = x;
    CAM_tb.LEAVE();
    SETRETV(0, 0);
    PIPERET;
  }
}

unsigned char * XCamWidget::SetGLBY(unsigned char *o, unsigned char *b)
{
  int y = *((int *) b);
  CAM_tb.ENTER("XCamWidget::SetGLBY");

  if (y < 0) {
    CAM_tb.LEAVE();
    SETRETV(-1000, -1);
    PIPERET;
  }
  else {
    glby = y;
    CAM_tb.LEAVE();
    SETRETV(0, 0);
    PIPERET;
  }
}

unsigned char * XCamWidget::Apply(unsigned char *o, unsigned char *b)
{
  int d;
  CAM_tb.ENTER("XCamWidget::Apply");

  if ((d = desc_idx((char *) b)) == -1) {
    CAM_tb.LEAVE();
    SETRETV(d, d);
    PIPERET;
  }

  if ((dtbl[d].type == IMAG) || (dtbl[d].type == SHMIMAG) ||
      (dtbl[d].type == XSHMIMAG)) {

    /* if we are not displaying from the same buffer then clear screen */
    if (lid != d)
      XClearWindow(dpy, w);

    lid = d;
  }

  if ((dtbl[d].type == CMAP) || (dtbl[d].type == SHMCMAP))
    lcu = d;
   
  (this->*dtbl[d].Apply)((void *) this, &(dtbl[d]));
  CAM_tb.LEAVE();
  PIPERET;
}

unsigned char * XCamWidget::Free(unsigned char *o, unsigned char *b)
{
  int d;
  CAM_tb.ENTER("XCamWidget::Free");

  if ((d = desc_idx((char *) b)) == -1) {
    CAM_tb.LEAVE();
    SETRETV(d, d);
    PIPERET;
  }

  if (d == lid) {
    lid = -1;
    XClearWindow(dpy, w);
  }

  else if (d == lcu) {
    lcu = -1;
    CopyColormap(pcmap, cmap);
  }


  if (dtbl[d].type == IMAG)
    munmap(dtbl[d].obj.i->data, dtbl[d].obj.i->width * dtbl[d].obj.i->height);

  else if (dtbl[d].type == CMAP)
    munmap((char *) dtbl[d].obj.c, 256 * sizeof(CamCm));


#ifdef XSHM
  if ((xshmok) && (dtbl[d].type == XSHMIMAG))
    XShmDetach(dpy, &(dtbl[d].shm.info));    
#endif

  if ((dtbl[d].type < 'a') && (dtbl[d].shm.cnt == 0)) {
    if ((dtbl[d].type == SHMIMAG) || (dtbl[d].type == XSHMIMAG))
      shmdt((char *) dtbl[d].obj.i);
    else
      shmdt((char *) dtbl[d].obj.c);
  }

  memset(&(dtbl[d]), 0, sizeof(XCam_Desc));

  CAM_tb.LEAVE();
  SETRETV(0, 0);
  PIPERET;
}

unsigned char * XCamWidget::FreeAndExit(unsigned char *o, unsigned char *b)
{
  int i;
  CAM_tb.ENTER("XCamWidget::FreeAndExit");

  for(i = 0; i < DESCTBLSZ; i++)
    if (dtbl[i].type != 0)
      Free(0, (unsigned char *) &i);

  if (forth_fifo)
    fclose(forth_fifo);

  Tk_DestroyWindow(Tk_NameToWindow(ti, ".", tkwin));

  CAM_tb.LEAVE();
  PIPERET;
}

unsigned char * XCamWidget::NullCmmd(unsigned char *o, unsigned char *b)
{
  SETRETV(0, 0);
  PIPERET;
}

/****************************************************************************/
/*		     Begining of XCAM operations                            */
/****************************************************************************/

int XCamWidget::AllocCmap(void *p)
{
  XCAM_DESC ds = (XCAM_DESC) p;
  register int i;
  XColor xcolor[256];
  CAM_tb.ENTER("int AllocCmap");

  for (i=0; i<256; i++) {

    xcolor[i].flags = DoRed | DoGreen | DoBlue;
/*  xcolor[i].pixel = (unsigned long) ds->obj.c[i].p; */
    xcolor[i].pixel = (unsigned long) i;
    xcolor[i].red = ds->obj.c[i].r * 257;
    xcolor[i].green = ds->obj.c[i].g * 257;
    xcolor[i].blue = ds->obj.c[i].b * 257;
  }

  if(XStoreColors(dpy, cmap, xcolor, 256) == 0) {
    CamMessage(TRUE, "Cannot store colors in private colormap!!\n");
    FATALERROR();
    FreeAndExit(0, 0);
  }

#ifdef DEBUG
  DUMPCMAP("Image", cmap, dpy);
#endif

  CAM_tb.LEAVE();
  SETRETV(0, 0);
  XCAMRET;
}

int XCamWidget::DispXImage(void *p)
{
  XCAM_DESC ds = (XCAM_DESC) p;

  XPutImage(dpy, w,gc, ds->obj.i, 0, 0, 0, 0, ds->obj.i->width,
	    ds->obj.i->height); 
  XSync(dpy, 0);

  if (capture)
    CaptureFrame(ds);

  SETRETV(0, 0);
  XCAMRET;
}

int XCamWidget::DispXSHMImage(void *p)
{
  XCAM_DESC ds = (XCAM_DESC) p;

#ifdef XSHM
  if (xshmok) {

    XShmPutImage(dpy, w, gc, ds->obj.i, 0, 0, 0, 0,
		 ds->obj.i->width, ds->obj.i->height, True);
    XSync(dpy, 0);
  }

  else
#endif

    {

      XPutImage(dpy, w, gc, ds->obj.i, 0, 0, 0, 0,
		ds->obj.i->width, ds->obj.i->height);
      XSync(dpy, 0);
      ds->Apply = &(XCamWidget::DispXImage);
    }

  if (capture)
    CaptureFrame(ds);

  SETRETV(0, 0);
  XCAMRET;
}

void XCamWidget::SendKeyString(XKeyEvent *event, FILE *filep)
{
  static TKeyboard keyboard = { KYPD_APL };
  static TScreen screen = { FALSE };
  static Bool eightbit = FALSE;
  char strbuf[STRBUFSIZE];
  register char *string;
  register int key = FALSE;
  int nbytes;
  KeySym keysym = 0;
  ANSI reply;
  XComposeStatus status_return;



  nbytes = XLookupString(event, strbuf, STRBUFSIZE, &keysym, &status_return);
  
  string = &strbuf[0];
  reply.a_pintro = 0;
  reply.a_final = 0;
  reply.a_nparam = 0;
  reply.a_inters = 0;

  if (keysym >= XK_KP_Home && keysym <= XK_KP_Begin) {
    keysym += XK_Home - XK_KP_Home;
  }

  if (IsPFKey(keysym)) {
    reply.a_type = SS3;
    unparseseq(&reply, filep);
    unparseputc((char)(keysym-XK_KP_F1+'P'), filep);
    key = TRUE;
  }
  else if (IsCursorKey(keysym) &&
	   keysym != XK_Prior && keysym != XK_Next) {
    if (keyboard.flags & CURSOR_APL) {
      reply.a_type = SS3;
      unparseseq(&reply, filep);
      unparseputc(xterm_cur[keysym-XK_Left], filep);
    }
    else {
      reply.a_type = CSI;
      reply.a_final = xterm_cur[keysym-XK_Left];
      unparseseq(&reply, filep);
    }
    key = TRUE;
  }
  else if (IsFunctionKey(keysym) || IsMiscFunctionKey(keysym) ||
	   keysym == XK_Prior || keysym == XK_Next ||
	   keysym == DXK_Remove || keysym == XK_KP_Delete ||
	   keysym == XK_KP_Insert) {
    reply.a_type = CSI;
    reply.a_nparam = 1;

    if (sunFunctionKeys) {
      reply.a_param[0] = sunfuncvalue (keysym);
      reply.a_final = 'z';
    }
    else {
      reply.a_param[0] = funcvalue (keysym);
      reply.a_final = '~';
    }

    if (reply.a_param[0] > 0)
      unparseseq(&reply, filep);
    key = TRUE;
  }
  else if (IsKeypadKey(keysym)) {
    if (keyboard.flags & KYPD_APL)	{
      reply.a_type   = SS3;
      unparseseq(&reply, filep);
      unparseputc(kypd_apl[keysym-XK_KP_Space], filep);
    }
    else
      unparseputc(kypd_num[keysym-XK_KP_Space], filep);
    key = TRUE;
  }
  else if (nbytes > 0) {
    if ((nbytes == 1) && eightbit) {
      if (screen.input_eight_bits)
	*string |= 0x80;	/* turn on eighth bit */
      else
	unparseputc (033, filep);  /* escape */
    }

    while (nbytes-- > 0)
      unparseputc(*string++, filep);
    key = TRUE;
  }

  return;
}


//
// Miscelaneous C and wrapper routines
//
static void pipedeath(int sig, void (*func)())
{
  CAM_tb.ENTER("pipedeath");
  CamMessage(TRUE, "connection lost\n");
  exit(0);
}

static _swapshort(register char *bp, register unsigned n)
{
  register char c;
  register char *ep = bp + n;

  while (bp < ep) {
    c = *bp;
    *bp = *(bp + 1);
    bp++;
    *bp++ = c;
  }
}

static _swaplong(register char *bp, register unsigned n)
{
  register char c;
  register char *ep = bp + n;
  register char *sp;
  
  while (bp < ep) {
    sp = bp + 3;
    c = *sp;
    *sp = *bp;
    *bp++ = c;
    sp = bp + 1;
    c = *sp;
    *sp = *bp;
    *bp++ = c;
    bp += 2;
  }
}
  
static int XCAMWidgetCmd(ClientData clientData, Tcl_Interp *interp,
			 int argc, char **argv)
{
  XCAMWIDGET xc = (XCAMWIDGET) clientData;
  return(xc->WidgetCmd(interp, argc, argv));
}

static void XCAMDestroy(char *p)
{
  XCAMWIDGET xc = (XCAMWIDGET) p;
  xc->Destroy();
}

static void XCAMEventProc(ClientData cd, XEvent *e)
{
  XCAMWIDGET xc = (XCAMWIDGET) cd;
  xc->EventProc(e);
}

static void XCAMKeyProc(ClientData cd, XEvent *e)
{
  XCAMWIDGET xc = (XCAMWIDGET) cd;
  xc->KeyProc(e);
}

static void XCAMInputFDProc(ClientData cd, int v)
{
  XCAMWIDGET xc = (XCAMWIDGET) cd;
  xc->InputFDProc(v);
}

static unsigned char * XCAMSetupSHMI(void *p, unsigned char *o, unsigned char *b)
{
  XCAMWIDGET xc = (XCAMWIDGET) p;
  return(xc->SetupSHMI(o, b));
}

static unsigned char * XCAMSetupSHMC(void *p, unsigned char *o, unsigned char *b)
{
  XCAMWIDGET xc = (XCAMWIDGET) p;
  return(xc->SetupSHMC(o, b));
}

static unsigned char * XCAMSetupKERI(void *p, unsigned char *o, unsigned char *b)
{
  XCAMWIDGET xc = (XCAMWIDGET) p;
  return(xc->SetupKERI(o, b));
}

static unsigned char * XCAMSetupKERC(void *p, unsigned char *o, unsigned char *b)
{
  XCAMWIDGET xc = (XCAMWIDGET) p;
  return(xc->SetupKERC(o, b));
}

static unsigned char * XCAMSetGLBX(void *p, unsigned char *o, unsigned char *b)
{
  XCAMWIDGET xc = (XCAMWIDGET) p;
  return(xc->SetGLBX(o, b));
}

static unsigned char * XCAMSetGLBY(void *p, unsigned char *o, unsigned char *b)
{
  XCAMWIDGET xc = (XCAMWIDGET) p;
  return(xc->SetGLBY(o, b));
}

static unsigned char * XCAMApply(void *p, unsigned char *o, unsigned char *b)
{
  XCAMWIDGET xc = (XCAMWIDGET) p;
  return(xc->Apply(o, b));
}

static unsigned char * XCAMFree(void *p, unsigned char *o, unsigned char *b)
{
  XCAMWIDGET xc = (XCAMWIDGET) p;
  return(xc->Free(o, b));
}

static unsigned char * XCAMFreeAndExit(void *p, unsigned char *o, unsigned char *b)
{
  XCAMWIDGET xc = (XCAMWIDGET) p;
  return(xc->FreeAndExit(o, b));
}

static unsigned char * XCAMNullCmmd(void *p, unsigned char *o, unsigned char *b)
{
  XCAMWIDGET xc = (XCAMWIDGET) p;
  return(xc->NullCmmd(o, b));
}

//
//	$XConsortium: input.c /main/20 1996/01/14 16:52:52 kaleb $
//

//
// Copyright 1987 by Digital Equipment Corporation, Maynard, Massachusetts.
//
//                         All Rights Reserved
//
// Permission to use, copy, modify, and distribute this software and its
// documentation for any purpose and without fee is hereby granted,
// provided that the above copyright notice appear in all copies and that
// both that copyright notice and this permission notice appear in
// supporting documentation, and that the name of Digital Equipment
// Corporation not be used in advertising or publicity pertaining to
// distribution of the software without specific, written prior permission.
//
//
// DIGITAL DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
// ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL
// DIGITAL BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR
// ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
// WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
// ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
// SOFTWARE.
//
// HLG: This code was stripped from the xterm widget source.  It has been
//	MAJORLY butchered for use in the CAM Library (CAMLib).  It was taken
//	from the X11R6 release of the files input.c, charproc.c and ptyx.h
//
static void unparseputc(char c, FILE *filep)
{
  char	buf[2];
  register i = 1;



  if((buf[0] = c) == '\r' && (term_flags & LINEFEED)) {
    buf[1] = '\n';
    i++;
  }

  fwrite(buf, i, 1, filep);
  fflush(filep);
}

static void unparsefputs(register char *s, FILE *filep)
{
  if (s)
    while (*s)
      unparseputc(*s++, filep);
}

static void unparseputn(unsigned int n, FILE *filep)
{
  unsigned int	q;

  q = n/10;

  if (q != 0)
    unparseputn(q, filep);

  unparseputc((char) ('0' + (n%10)), filep);
}

static void unparseseq(register ANSI *ap, FILE *filep)
{
  register int	c;
  register int	i;
  register int	inters;



  c = ap->a_type;
  if (c>=0x80 && c<=0x9F) {
    unparseputc(ESC, filep);
    c -= 0x40;
  }

  unparseputc(c, filep);

  c = ap->a_type;

  if (c==ESC || c==DCS || c==CSI || c==OSC || c==PM || c==APC) {
    if (ap->a_pintro != 0)
      unparseputc((char) ap->a_pintro, filep);

    for (i=0; i<ap->a_nparam; ++i) {
      if (i != 0)
	unparseputc(';', filep);
      unparseputn((unsigned int) ap->a_param[i], filep);
    }

    inters = ap->a_inters;

    for (i=3; i>=0; --i) {
      c = (inters >> (8*i)) & 0xff;
      if (c != 0)
	unparseputc(c, filep);
    }

    unparseputc((char) ap->a_final, filep);
  }
}

static int funcvalue(int keycode)
{
  switch (keycode) {
  case XK_F1:	return(11);
  case XK_F2:	return(12);
  case XK_F3:	return(13);
  case XK_F4:	return(14);
  case XK_F5:	return(15);
  case XK_F6:	return(17);
  case XK_F7:	return(18);
  case XK_F8:	return(19);
  case XK_F9:	return(20);
  case XK_F10:	return(21);
  case XK_F11:	return(23);
  case XK_F12:	return(24);
  case XK_F13:	return(25);
  case XK_F14:	return(26);
  case XK_F15:	return(28);
  case XK_Help:	return(28);
  case XK_F16:	return(29);
  case XK_Menu:	return(29);
  case XK_F17:	return(31);
  case XK_F18:	return(32);
  case XK_F19:	return(33);
  case XK_F20:	return(34);

  case XK_Find :	return(1);
  case XK_Insert:	return(2);
  case XK_KP_Insert: return(2);
  case XK_Delete:	return(3);
  case XK_KP_Delete: return(3);
  case DXK_Remove: return(3);
  case XK_Select:	return(4);
  case XK_Prior:	return(5);
  case XK_Next:	return(6);
  default:	return(-1);
  }
}


static int sunfuncvalue(int keycode)
{
  switch (keycode) {
  case XK_F1:	return(224);
  case XK_F2:	return(225);
  case XK_F3:	return(226);
  case XK_F4:	return(227);
  case XK_F5:	return(228);
  case XK_F6:	return(229);
  case XK_F7:	return(230);
  case XK_F8:	return(231);
  case XK_F9:	return(232);
  case XK_F10:	return(233);
  case XK_F11:	return(192);
  case XK_F12:	return(193);
  case XK_F13:	return(194);
  case XK_F14:	return(195);
  case XK_F15:	return(196);
  case XK_Help:	return(196);
  case XK_F16:	return(197);
  case XK_Menu:	return(197);
  case XK_F17:	return(198);
  case XK_F18:	return(199);
  case XK_F19:	return(200);
  case XK_F20:	return(201);

  case XK_R1:	return(208);
  case XK_R2:	return(209);
  case XK_R3:	return(210);
  case XK_R4:	return(211);
  case XK_R5:	return(212);
  case XK_R6:	return(213);
  case XK_R7:	return(214);
  case XK_R8:	return(215);
  case XK_R9:	return(216);
  case XK_R10:	return(217);
  case XK_R11:	return(218);
  case XK_R12:	return(219);
  case XK_R13:	return(220);
  case XK_R14:	return(221);
  case XK_R15:	return(222);
  
  case XK_Find :	return(1);
  case XK_Insert:	return(2);
  case XK_KP_Insert: return(2);
  case XK_Delete:	return(3);
  case XK_KP_Delete: return(3);
  case DXK_Remove: return(3);
  case XK_Select:	return(4);
  case XK_Prior:	return(5);
  case XK_Next:	return(6);
  default:	return(-1);
  }
}



