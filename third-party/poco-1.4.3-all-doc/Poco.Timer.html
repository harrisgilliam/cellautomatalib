<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>Class Poco::Timer</title>
<meta http-equiv="content-type" content="text/html; charset=utf-8"/>
<meta name="author" content="Applied Informatics Software Engineering GmbH and Contributors"/>
<meta name="publisher" content="Applied Informatics Software Engineering GmbH and Contributors"/>
<meta name="copyright" content="Copyright (c) 2012, Applied Informatics Software Engineering GmbH and Contributors"/>
<meta name="language" content="en"/>
<meta name="date" content="2012-01-15"/>
<meta name="generator" content="PocoDoc"/>
<link rel="stylesheet" href="css/styles.css" type="text/css"/>
</head>
<body bgcolor="#ffffff" leftmargin="0" topmargin="0">
<div class="header">
<h1 class="namespace"><a href="Poco.html" class="namespace">Poco</a></h1>
<h1 class="symbol">class Timer</h1>
</div>
<div class="body">
<p>
<b>Library:</b> Foundation<br />
<b>Package:</b> Threading<br />
<b>Header:</b> Poco/Timer.h</p>
<h2>Description</h2>
<div class="description">
<p>This class implements a thread-based timer. A timer starts a thread that first waits for a given start interval. Once that interval expires, the timer callback is called repeatedly in the given periodic interval. If the interval is 0, the timer is only called once. The timer callback method can stop the timer by setting the  timer's periodic interval to 0. </p>
<p>The timer callback runs in its own thread, so multithreading issues (proper synchronization) have to be considered when writing  the callback method. </p>
<p>The exact interval at which the callback is called depends on many  factors like operating system, CPU performance and system load and may differ from the specified interval. </p>
<p>The time needed to execute the timer callback is not included in the interval between invocations. For example, if the interval is 500 milliseconds, and the callback needs 400 milliseconds to execute, the callback function is nevertheless called every 500 milliseconds. If the callback takes longer to execute than the interval, the callback function will not be called until the next proper interval. The number of skipped invocations since the last invocation will be recorded and can be obtained by the callback by calling <a href="Poco.Timer.html#11247" title="Poco::Timer::skipped()">skipped</a>(). </p>
<p>The timer thread is taken from a thread pool, so there is a limit to the number of available concurrent timers. </p>
</div>
<h2>Inheritance</h2>
<p><b>Direct Base Classes: </b><a href="Poco.Runnable.html" title="class Poco::Runnable">Runnable</a></p>
<p><b>All Base Classes: </b><a href="Poco.Runnable.html" title="class Poco::Runnable">Runnable</a></p>
<h2>Member Summary</h2>
<p><b>Member Functions: </b><a href="Poco.Timer.html#11244" title="Poco::Timer::getPeriodicInterval()">getPeriodicInterval</a>, <a href="Poco.Timer.html#11241" title="Poco::Timer::getStartInterval()">getStartInterval</a>, <a href="Poco.Timer.html#11238" title="Poco::Timer::restart()">restart</a>, <a href="Poco.Timer.html#11248" title="Poco::Timer::run()">run</a>, <a href="Poco.Timer.html#11245" title="Poco::Timer::setPeriodicInterval()">setPeriodicInterval</a>, <a href="Poco.Timer.html#11242" title="Poco::Timer::setStartInterval()">setStartInterval</a>, <a href="Poco.Timer.html#11247" title="Poco::Timer::skipped()">skipped</a>, <a href="Poco.Timer.html#11225" title="Poco::Timer::start()">start</a>, <a href="Poco.Timer.html#11237" title="Poco::Timer::stop()">stop</a></p>
<p><b>Inherited Functions: </b><a href="Poco.Runnable.html#9982" title="Poco::Runnable::run()">run</a></p>
<h2>Constructors</h2>
<h3><a name="11221">Timer</a></h3>
<p class="decl"><a href="Poco.Timer.html" title="class Poco::Timer">Timer</a>(<br />&nbsp;&nbsp;&nbsp;&nbsp;long startInterval = 0,<br />&nbsp;&nbsp;&nbsp;&nbsp;long periodicInterval = 0<br />);</p>
<div class="description">
<p>Creates a new timer object. StartInterval and periodicInterval are given in milliseconds. If a periodicInterval of zero is  specified, the callback will only be called once, after the startInterval expires. To start the timer, call the Start() method. </p>
</div>
<h2>Destructor</h2>
<h3><a name="11224">~Timer</a> <img src="images/virtual.gif" alt="virtual" title="virtual" style="vertical-align:baseline;" border="0" /> </h3>
<p class="decl">virtual ~<a href="Poco.Timer.html" title="class Poco::Timer">Timer</a>();</p>
<div class="description">
<p>Stops and destroys the timer. </p>
</div>
<h2>Member Functions</h2>
<h3><a name="11244">getPeriodicInterval</a></h3>
<p class="decl">long getPeriodicInterval() const;</p>
<div class="description">
<p>Returns the periodic interval. </p>
</div>
<h3><a name="11241">getStartInterval</a></h3>
<p class="decl">long getStartInterval() const;</p>
<div class="description">
<p>Returns the start interval. </p>
</div>
<h3><a name="11238">restart</a></h3>
<p class="decl">void restart();</p>
<div class="description">
<p>Restarts the periodic interval. If the callback method is already running, nothing will happen. </p>
</div>
<h3><a name="11239">restart</a></h3>
<p class="decl">void restart(<br />&nbsp;&nbsp;&nbsp;&nbsp;long milliseconds<br />);</p>
<div class="description">
<p>Sets a new periodic interval and restarts the timer. An interval of 0 will stop the timer. </p>
</div>
<h3><a name="11245">setPeriodicInterval</a></h3>
<p class="decl">void setPeriodicInterval(<br />&nbsp;&nbsp;&nbsp;&nbsp;long milliseconds<br />);</p>
<div class="description">
<p>Sets the periodic interval. If the timer is already running the new interval will be effective when the current interval expires. </p>
</div>
<h3><a name="11242">setStartInterval</a></h3>
<p class="decl">void setStartInterval(<br />&nbsp;&nbsp;&nbsp;&nbsp;long milliseconds<br />);</p>
<div class="description">
<p>Sets the start interval. Will only be  effective before <a href="Poco.Timer.html#11225" title="Poco::Timer::start()">start</a>() is called. </p>
</div>
<h3><a name="11247">skipped</a></h3>
<p class="decl">long skipped() const;</p>
<div class="description">
<p>Returns the number of skipped invocations since the last invocation. Skipped invocations happen if the timer callback function takes longer to execute than the timer interval. </p>
</div>
<h3><a name="11225">start</a></h3>
<p class="decl">void start(<br />&nbsp;&nbsp;&nbsp;&nbsp;const <a href="Poco.AbstractTimerCallback.html" title="class Poco::AbstractTimerCallback">AbstractTimerCallback</a> &amp; method<br />);</p>
<div class="description">
<p>Starts the timer. Create the <a href="Poco.TimerCallback.html" title="class Poco::TimerCallback">TimerCallback</a> as follows: </p>
<pre>TimerCallback&lt;MyClass&gt; callback(*this, &amp;MyClass::onTimer);
timer.start(callback);
</pre>
<p>The timer thread is taken from the global default thread pool. </p>
</div>
<h3><a name="11227">start</a></h3>
<p class="decl">void start(<br />&nbsp;&nbsp;&nbsp;&nbsp;const <a href="Poco.AbstractTimerCallback.html" title="class Poco::AbstractTimerCallback">AbstractTimerCallback</a> &amp; method,<br />&nbsp;&nbsp;&nbsp;&nbsp;<a href="Poco.Thread.html#11044" title="enum  Poco::Thread::Priority">Thread::Priority</a> priority<br />);</p>
<div class="description">
<p>Starts the timer in a thread with the given priority. Create the <a href="Poco.TimerCallback.html" title="class Poco::TimerCallback">TimerCallback</a> as follows: </p>
<pre>TimerCallback&lt;MyClass&gt; callback(*this, &amp;MyClass::onTimer);
timer.start(callback);
</pre>
<p>The timer thread is taken from the global default thread pool. </p>
</div>
<h3><a name="11230">start</a></h3>
<p class="decl">void start(<br />&nbsp;&nbsp;&nbsp;&nbsp;const <a href="Poco.AbstractTimerCallback.html" title="class Poco::AbstractTimerCallback">AbstractTimerCallback</a> &amp; method,<br />&nbsp;&nbsp;&nbsp;&nbsp;<a href="Poco.ThreadPool.html" title="class Poco::ThreadPool">ThreadPool</a> &amp; threadPool<br />);</p>
<div class="description">
<p>Starts the timer. Create the <a href="Poco.TimerCallback.html" title="class Poco::TimerCallback">TimerCallback</a> as follows: </p>
<pre>TimerCallback&lt;MyClass&gt; callback(*this, &amp;MyClass::onTimer);
timer.start(callback);
</pre>
</div>
<h3><a name="11233">start</a></h3>
<p class="decl">void start(<br />&nbsp;&nbsp;&nbsp;&nbsp;const <a href="Poco.AbstractTimerCallback.html" title="class Poco::AbstractTimerCallback">AbstractTimerCallback</a> &amp; method,<br />&nbsp;&nbsp;&nbsp;&nbsp;<a href="Poco.Thread.html#11044" title="enum  Poco::Thread::Priority">Thread::Priority</a> priority,<br />&nbsp;&nbsp;&nbsp;&nbsp;<a href="Poco.ThreadPool.html" title="class Poco::ThreadPool">ThreadPool</a> &amp; threadPool<br />);</p>
<div class="description">
<p>Starts the timer in a thread with the given priority. Create the <a href="Poco.TimerCallback.html" title="class Poco::TimerCallback">TimerCallback</a> as follows: </p>
<pre>TimerCallback&lt;MyClass&gt; callback(*this, &amp;MyClass::onTimer);
timer.start(callback);
</pre>
</div>
<h3><a name="11237">stop</a></h3>
<p class="decl">void stop();</p>
<div class="description">
<p>Stops the timer. If the callback method is currently running it will be allowed to finish first. WARNING: Never call this method from within the callback method, as a deadlock would result. To stop the timer from within the callback method, call <a href="Poco.Timer.html#11238" title="Poco::Timer::restart()">restart</a>(0). </p>
</div>
<h3><a name="11248">run</a> <img src="images/protected.gif" alt="protected" title="protected" style="vertical-align:baseline;" border="0" />  <img src="images/virtual.gif" alt="virtual" title="virtual" style="vertical-align:baseline;" border="0" /> </h3>
<p class="decl">void run();</p>
<div class="description">
<p></p>
</div>
<div class="description"><p><b>See also:</b> <a href="Poco.Runnable.html#9982" title="Poco::Runnable::run()">Poco::Runnable::run()</a></p></div>
<p class="footer">POCO C++ Libraries 1.4.3-all<br />
Copyright &copy; 2012, <a href="http://pocoproject.org/" target="_blank">Applied Informatics Software Engineering GmbH and Contributors</a></p>

</div>
</body>
</html>
