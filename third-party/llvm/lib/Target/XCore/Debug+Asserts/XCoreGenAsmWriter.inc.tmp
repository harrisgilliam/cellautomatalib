//===- TableGen'erated file -------------------------------------*- C++ -*-===//
//
// Assembly Writer Source Fragment
//
// Automatically generated file, do not edit!
//
//===----------------------------------------------------------------------===//

/// printInstruction - This method is automatically generated by tablegen
/// from the instruction set description.
void XCoreAsmPrinter::printInstruction(const MachineInstr *MI, raw_ostream &O) {
  static const unsigned OpInfo[] = {
    0U,	// PHI
    0U,	// INLINEASM
    0U,	// PROLOG_LABEL
    0U,	// EH_LABEL
    0U,	// GC_LABEL
    0U,	// KILL
    0U,	// EXTRACT_SUBREG
    0U,	// INSERT_SUBREG
    0U,	// IMPLICIT_DEF
    0U,	// SUBREG_TO_REG
    0U,	// COPY_TO_REGCLASS
    1U,	// DBG_VALUE
    0U,	// REG_SEQUENCE
    0U,	// COPY
    11U,	// BUNDLE
    536870930U,	// ADD_2rus
    536870930U,	// ADD_3r
    1090519063U,	// ADJCALLSTACKDOWN
    1107296279U,	// ADJCALLSTACKUP
    542113816U,	// ANDNOT_2r
    536870944U,	// AND_3r
    536870949U,	// ASHR_l2rus
    536870949U,	// ASHR_l3r
    587202603U,	// BAU_1r
    537919536U,	// BITREV_l2r
    587202616U,	// BLA_1r
    587202621U,	// BL_lu10
    587202621U,	// BL_u10
    537919553U,	// BRBF_lru6
    537919553U,	// BRBF_ru6
    537919557U,	// BRBT_lru6
    537919557U,	// BRBT_ru6
    587202633U,	// BRBU_lu6
    587202633U,	// BRBU_u6
    537919553U,	// BRFF_lru6
    537919553U,	// BRFF_ru6
    537919557U,	// BRFT_lru6
    537919557U,	// BRFT_ru6
    587202633U,	// BRFU_lu6
    587202633U,	// BRFU_u6
    1686110285U,	// BR_JT
    1690304589U,	// BR_JT32
    537919570U,	// BYTEREV_l2r
    621805659U,	// CHKCT_2r
    621805659U,	// CHKCT_rus
    102U,	// CLRE_0R
    587202667U,	// CLRSR_branch_lu6
    587202667U,	// CLRSR_branch_u6
    587202667U,	// CLRSR_lu6
    587202667U,	// CLRSR_u6
    537919602U,	// CLZ_l2r
    537264247U,	// CRC8_l4r
    541327485U,	// CRC_l3r
    536871044U,	// DIVS_l3r
    536871050U,	// DIVU_l3r
    587202704U,	// ECALLF_1r
    587202712U,	// ECALLT_1r
    637534368U,	// EEU_1r
    654311593U,	// ENDIN_l2r
    587202736U,	// ENTSP_lu6
    587202736U,	// ENTSP_u6
    536871095U,	// EQ_2rus
    536871095U,	// EQ_3r
    587202747U,	// EXTSP_lu6
    587202747U,	// EXTSP_u6
    637534402U,	// FREER_1r
    205U,	// GETED_0R
    217U,	// GETET_0R
    229U,	// GETID_0R
    671088881U,	// GETPS_l2r
    537919734U,	// GETR_rus
    654311676U,	// GETST_2r
    654311683U,	// GETTS_2r
    654311690U,	// INCT_2r
    687866128U,	// INITCP_2r
    704643344U,	// INITDP_2r
    721420560U,	// INITLR_l2r
    738197776U,	// INITPC_2r
    754974992U,	// INITSP_2r
    654311704U,	// INSHR_2r
    654311711U,	// INT_2r
    654311716U,	// IN_2r
    537067816U,	// LADD_l5r
    538968366U,	// LD16S_3r
    538968373U,	// LD8U_3r
    540016955U,	// LDA16B_l3r
    538968379U,	// LDA16F_l3r
    587202882U,	// LDAP_lu10
    587202882U,	// LDAP_lu10_ba
    587202882U,	// LDAP_u10
    540016973U,	// LDAWB_l2rus
    540016973U,	// LDAWB_l3r
    2147483987U,	// LDAWCP_lu6
    2147483987U,	// LDAWCP_u6
    771752269U,	// LDAWDP_lru6
    771752269U,	// LDAWDP_ru6
    1325400087U,	// LDAWFI
    538968397U,	// LDAWF_l2rus
    538968397U,	// LDAWF_l3r
    805306701U,	// LDAWSP_lru6
    805306701U,	// LDAWSP_lru6_RRegs
    805306701U,	// LDAWSP_ru6
    805306701U,	// LDAWSP_ru6_RRegs
    537919841U,	// LDC_lru6
    537919841U,	// LDC_ru6
    537067878U,	// LDIV_l5r
    822083948U,	// LDWCP_lru6
    822083948U,	// LDWCP_ru6
    771752300U,	// LDWDP_lru6
    771752300U,	// LDWDP_ru6
    1375731735U,	// LDWFI
    805306732U,	// LDWSP_lru6
    805306732U,	// LDWSP_ru6
    538968428U,	// LDW_2rus
    538968428U,	// LDW_3r
    537100657U,	// LMUL_l6r
    536871287U,	// LSS_3r
    537067900U,	// LSUB_l5r
    536871298U,	// LSU_3r
    537395591U,	// MACCS_l4r
    537395598U,	// MACCU_l4r
    637534613U,	// MJOIN_1r
    537919904U,	// MKMSK_2r
    537919904U,	// MKMSK_rus
    637534631U,	// MSYNC_1r
    536871346U,	// MUL_l3r
    537919927U,	// NEG
    537919932U,	// NOT
    536871361U,	// OR_3r
    621806021U,	// OUTCT_2r
    621806021U,	// OUTCT_rus
    1699742160U,	// OUTSHR_2r
    621806044U,	// OUTT_2r
    621806054U,	// OUT_2r
    654311919U,	// PEEK_l2r
    536871413U,	// REMS_l3r
    536871419U,	// REMU_l3r
    587203073U,	// RETSP_lu6
    587203073U,	// RETSP_u6
    1392508951U,	// SELECT_CC
    621806088U,	// SETCLK_l2r
    621806100U,	// SETC_l2r
    621806100U,	// SETC_lru6
    621806100U,	// SETC_ru6
    621806110U,	// SETD_2r
    872415784U,	// SETEV_1r
    621806131U,	// SETPSC_l2r
    621806143U,	// SETPS_l2r
    621806151U,	// SETPT_2r
    621806162U,	// SETRDY_l2r
    587203166U,	// SETSP_1r
    587203175U,	// SETSR_branch_lu6
    587203175U,	// SETSR_branch_u6
    587203175U,	// SETSR_lu6
    587203175U,	// SETSR_u6
    621806190U,	// SETTW_l2r
    872415865U,	// SETV_1r
    542114435U,	// SEXT_2r
    542114435U,	// SEXT_rus
    536871561U,	// SHL_2rus
    536871561U,	// SHL_3r
    536871566U,	// SHR_2rus
    536871566U,	// SHR_3r
    659U,	// SSYNC_0r
    538968729U,	// ST16_l3r
    538968735U,	// ST8_l3r
    771752612U,	// STWDP_lru6
    771752612U,	// STWDP_ru6
    1426063383U,	// STWFI
    805307044U,	// STWSP_lru6
    805307044U,	// STWSP_ru6
    538968740U,	// STW_2rus
    538968740U,	// STW_3r
    536871593U,	// SUB_2rus
    536871593U,	// SUB_3r
    637534894U,	// SYNCR_1r
    654312121U,	// TESTCT_2r
    654312129U,	// TESTWCT_2r
    714U,	// WAITEU_0R
    536871633U,	// XOR_l3r
    542114518U,	// ZEXT_2r
    542114518U,	// ZEXT_rus
    0U
  };

  const char *AsmStrs = 
    "DBG_VALUE\000BUNDLE\000add \000\000andnot \000and \000ashr \000bau \000"
    "bitrev \000bla \000bl \000bf \000bt \000bu \000bru \000byterev \000chkc"
    "t res[\000clre\000clrsr \000clz \000crc8 \000crc32 \000divs \000divu \000"
    "ecallf \000ecallt \000eeu res[\000endin \000entsp \000eq \000extsp \000"
    "freer res[\000get r11, ed\000get r11, et\000get r11, id\000get \000getr"
    " \000getst \000getts \000inct \000init t[\000inshr \000int \000in \000l"
    "add \000ld16s \000ld8u \000lda16 \000ldap r11, \000ldaw \000ldaw r11, c"
    "p[\000ldc \000ldiv \000ldw \000lmul \000lss \000lsub \000lsu \000maccs "
    "\000maccu \000mjoin res[\000mkmsk \000msync res[\000mul \000neg \000not"
    " \000or \000outct res[\000outshr res[\000outt res[\000out res[\000peek "
    "\000rems \000remu \000retsp \000setclk res[\000setc res[\000setd res[\000"
    "setev res[\000setpsc res[\000set ps[\000setpt res[\000setrdy res[\000se"
    "t sp, \000setsr \000settw res[\000setv res[\000sext \000shl \000shr \000"
    "ssync\000st16 \000st8 \000stw \000sub \000syncr res[\000testct \000test"
    "wct \000waiteu\000xor \000zext \000";

  O << "\t";

  // Emit the opcode for the instruction.
  unsigned Bits = OpInfo[MI->getOpcode()];
  assert(Bits != 0 && "Cannot print this instruction.");
  O << AsmStrs+(Bits & 1023)-1;


  // Fragment 0 encoded into 3 bits for 5 unique commands.
  switch ((Bits >> 29) & 7) {
  default:   // unreachable.
  case 0:
    // DBG_VALUE, BUNDLE, CLRE_0R, GETED_0R, GETET_0R, GETID_0R, SSYNC_0r, WA...
    return;
    break;
  case 1:
    // ADD_2rus, ADD_3r, ANDNOT_2r, AND_3r, ASHR_l2rus, ASHR_l3r, BAU_1r, BIT...
    printOperand(MI, 0, O); 
    break;
  case 2:
    // ADJCALLSTACKDOWN, ADJCALLSTACKUP, LDAWFI, LDWFI, SELECT_CC, STWFI
    PrintSpecial(MI, O, "comment"); 
    break;
  case 3:
    // BR_JT, BR_JT32, OUTSHR_2r
    printOperand(MI, 1, O); 
    break;
  case 4:
    // LDAWCP_lu6, LDAWCP_u6
    printMemOperand(MI, 0, O); 
    O << ']'; 
    return;
    break;
  }


  // Fragment 1 encoded into 5 bits for 22 unique commands.
  switch ((Bits >> 24) & 31) {
  default:   // unreachable.
  case 0:
    // ADD_2rus, ADD_3r, ANDNOT_2r, AND_3r, ASHR_l2rus, ASHR_l3r, BITREV_l2r,...
    O << ", "; 
    break;
  case 1:
    // ADJCALLSTACKDOWN
    O << " ADJCALLSTACKDOWN "; 
    printOperand(MI, 0, O); 
    return;
    break;
  case 2:
    // ADJCALLSTACKUP
    O << " ADJCALLSTACKUP "; 
    printOperand(MI, 0, O); 
    return;
    break;
  case 3:
    // BAU_1r, BLA_1r, BL_lu10, BL_u10, BRBU_lu6, BRBU_u6, BRFU_lu6, BRFU_u6,...
    return;
    break;
  case 4:
    // BR_JT, BR_JT32
    O << "\n"; 
    break;
  case 5:
    // CHKCT_2r, CHKCT_rus, OUTCT_2r, OUTCT_rus, OUTSHR_2r, OUTT_2r, OUT_2r, ...
    O << "], "; 
    break;
  case 6:
    // EEU_1r, FREER_1r, MJOIN_1r, MSYNC_1r, SYNCR_1r
    O << ']'; 
    return;
    break;
  case 7:
    // ENDIN_l2r, GETST_2r, GETTS_2r, INCT_2r, INSHR_2r, INT_2r, IN_2r, PEEK_...
    O << ", res["; 
    printOperand(MI, 1, O); 
    O << ']'; 
    return;
    break;
  case 8:
    // GETPS_l2r
    O << ", ps["; 
    printOperand(MI, 1, O); 
    O << ']'; 
    return;
    break;
  case 9:
    // INITCP_2r
    O << "]:cp, "; 
    printOperand(MI, 1, O); 
    return;
    break;
  case 10:
    // INITDP_2r
    O << "]:dp, "; 
    printOperand(MI, 1, O); 
    return;
    break;
  case 11:
    // INITLR_l2r
    O << "]:lr, "; 
    printOperand(MI, 1, O); 
    return;
    break;
  case 12:
    // INITPC_2r
    O << "]:pc, "; 
    printOperand(MI, 1, O); 
    return;
    break;
  case 13:
    // INITSP_2r
    O << "]:sp, "; 
    printOperand(MI, 1, O); 
    return;
    break;
  case 14:
    // LDAWDP_lru6, LDAWDP_ru6, LDWDP_lru6, LDWDP_ru6, STWDP_lru6, STWDP_ru6
    O << ", dp["; 
    printMemOperand(MI, 1, O); 
    O << ']'; 
    return;
    break;
  case 15:
    // LDAWFI
    O << " LDAWFI "; 
    printOperand(MI, 0, O); 
    O << ", "; 
    printMemOperand(MI, 1, O); 
    return;
    break;
  case 16:
    // LDAWSP_lru6, LDAWSP_lru6_RRegs, LDAWSP_ru6, LDAWSP_ru6_RRegs, LDWSP_lr...
    O << ", sp["; 
    printOperand(MI, 1, O); 
    O << ']'; 
    return;
    break;
  case 17:
    // LDWCP_lru6, LDWCP_ru6
    O << ", cp["; 
    printOperand(MI, 1, O); 
    O << ']'; 
    return;
    break;
  case 18:
    // LDWFI
    O << " LDWFI "; 
    printOperand(MI, 0, O); 
    O << ", "; 
    printMemOperand(MI, 1, O); 
    return;
    break;
  case 19:
    // SELECT_CC
    O << " SELECT_CC PSEUDO!"; 
    return;
    break;
  case 20:
    // SETEV_1r, SETV_1r
    O << "], r11"; 
    return;
    break;
  case 21:
    // STWFI
    O << " STWFI "; 
    printOperand(MI, 0, O); 
    O << ", "; 
    printMemOperand(MI, 1, O); 
    return;
    break;
  }


  // Fragment 2 encoded into 2 bits for 4 unique commands.
  switch ((Bits >> 22) & 3) {
  default:   // unreachable.
  case 0:
    // ADD_2rus, ADD_3r, AND_3r, ASHR_l2rus, ASHR_l3r, BITREV_l2r, BRBF_lru6,...
    printOperand(MI, 1, O); 
    break;
  case 1:
    // ANDNOT_2r, CRC_l3r, OUTSHR_2r, SEXT_2r, SEXT_rus, ZEXT_2r, ZEXT_rus
    printOperand(MI, 2, O); 
    break;
  case 2:
    // BR_JT
    printInlineJT(MI, 0, O); 
    return;
    break;
  case 3:
    // BR_JT32
    printInlineJT32(MI, 0, O); 
    return;
    break;
  }


  // Fragment 3 encoded into 2 bits for 4 unique commands.
  switch ((Bits >> 20) & 3) {
  default:   // unreachable.
  case 0:
    // ADD_2rus, ADD_3r, AND_3r, ASHR_l2rus, ASHR_l3r, CRC8_l4r, CRC_l3r, DIV...
    O << ", "; 
    break;
  case 1:
    // ANDNOT_2r, BITREV_l2r, BRBF_lru6, BRBF_ru6, BRBT_lru6, BRBT_ru6, BRFF_...
    return;
    break;
  case 2:
    // LD16S_3r, LD8U_3r, LDA16F_l3r, LDAWF_l2rus, LDAWF_l3r, LDW_2rus, LDW_3...
    O << '['; 
    printOperand(MI, 2, O); 
    O << ']'; 
    return;
    break;
  case 3:
    // LDA16B_l3r, LDAWB_l2rus, LDAWB_l3r
    O << "[-"; 
    printOperand(MI, 2, O); 
    O << ']'; 
    return;
    break;
  }


  // Fragment 4 encoded into 2 bits for 3 unique commands.
  switch ((Bits >> 18) & 3) {
  default:   // unreachable.
  case 0:
    // ADD_2rus, ADD_3r, AND_3r, ASHR_l2rus, ASHR_l3r, DIVS_l3r, DIVU_l3r, EQ...
    printOperand(MI, 2, O); 
    break;
  case 1:
    // CRC8_l4r, CRC_l3r
    printOperand(MI, 3, O); 
    break;
  case 2:
    // MACCS_l4r, MACCU_l4r
    printOperand(MI, 4, O); 
    O << ", "; 
    printOperand(MI, 5, O); 
    return;
    break;
  }


  // Fragment 5 encoded into 1 bits for 2 unique commands.
  if ((Bits >> 17) & 1) {
    // CRC8_l4r, LADD_l5r, LDIV_l5r, LMUL_l6r, LSUB_l5r
    O << ", "; 
  } else {
    // ADD_2rus, ADD_3r, AND_3r, ASHR_l2rus, ASHR_l3r, CRC_l3r, DIVS_l3r, DIV...
    return;
  }


  // Fragment 6 encoded into 1 bits for 2 unique commands.
  if ((Bits >> 16) & 1) {
    // LADD_l5r, LDIV_l5r, LMUL_l6r, LSUB_l5r
    printOperand(MI, 3, O); 
    O << ", "; 
    printOperand(MI, 4, O); 
  } else {
    // CRC8_l4r
    printOperand(MI, 4, O); 
    return;
  }


  // Fragment 7 encoded into 1 bits for 2 unique commands.
  if ((Bits >> 15) & 1) {
    // LMUL_l6r
    O << ", "; 
    printOperand(MI, 5, O); 
    return;
  } else {
    // LADD_l5r, LDIV_l5r, LSUB_l5r
    return;
  }

}


/// getRegisterName - This method is automatically generated by tblgen
/// from the register set description.  This returns the assembler name
/// for the specified register.
const char *XCoreAsmPrinter::getRegisterName(unsigned RegNo) {
  assert(RegNo && RegNo < 17 && "Invalid register number!");

  static const unsigned RegAsmOffset[] = {
    0, 3, 6, 9, 12, 15, 18, 21, 24, 27, 30, 33, 36, 39,
    43, 47, 0
  };

  const char *AsmStrs =
    "cp\000dp\000lr\000r0\000r1\000r2\000r3\000r4\000r5\000r6\000r7\000r8\000"
    "r9\000r10\000r11\000sp\000";
  assert (*(AsmStrs+RegAsmOffset[RegNo-1]) &&
          "Invalid alt name index for register!");
  return AsmStrs+RegAsmOffset[RegNo-1];
}


#ifdef GET_INSTRUCTION_NAME
#undef GET_INSTRUCTION_NAME

/// getInstructionName: This method is automatically generated by tblgen
/// from the instruction set description.  This returns the enum name of the
/// specified instruction.
const char *XCoreAsmPrinter::getInstructionName(unsigned Opcode) {
  assert(Opcode < 182 && "Invalid instruction number!");

  static const unsigned InstAsmOffset[] = {
    0, 4, 14, 27, 36, 45, 50, 65, 79, 92, 106, 123, 133, 146, 
    151, 158, 167, 174, 191, 206, 216, 223, 234, 243, 250, 261, 268, 276, 
    283, 293, 302, 312, 321, 330, 338, 348, 357, 367, 376, 385, 393, 399, 
    407, 419, 428, 438, 446, 463, 479, 489, 498, 506, 515, 523, 532, 541, 
    551, 561, 568, 578, 588, 597, 605, 611, 621, 630, 639, 648, 657, 666, 
    676, 685, 694, 703, 711, 721, 731, 742, 752, 762, 771, 778, 784, 793, 
    802, 810, 821, 832, 842, 855, 864, 876, 886, 897, 907, 919, 930, 937, 
    949, 959, 971, 989, 1000, 1017, 1026, 1034, 1043, 1054, 1064, 1075, 1085, 1091, 
    1102, 1112, 1121, 1128, 1137, 1144, 1153, 1160, 1170, 1180, 1189, 1198, 1208, 1217, 
    1225, 1229, 1233, 1239, 1248, 1258, 1268, 1276, 1283, 1292, 1301, 1310, 1320, 1329, 
    1339, 1350, 1359, 1369, 1378, 1386, 1395, 1406, 1416, 1425, 1436, 1445, 1462, 1478, 
    1488, 1497, 1507, 1515, 1523, 1532, 1541, 1548, 1557, 1564, 1573, 1582, 1590, 1601, 
    1611, 1617, 1628, 1638, 1647, 1654, 1663, 1670, 1679, 1689, 1700, 1710, 1718, 1726, 0
  };

  const char *Strs =
    "PHI\000INLINEASM\000PROLOG_LABEL\000EH_LABEL\000GC_LABEL\000KILL\000EXT"
    "RACT_SUBREG\000INSERT_SUBREG\000IMPLICIT_DEF\000SUBREG_TO_REG\000COPY_T"
    "O_REGCLASS\000DBG_VALUE\000REG_SEQUENCE\000COPY\000BUNDLE\000ADD_2rus\000"
    "ADD_3r\000ADJCALLSTACKDOWN\000ADJCALLSTACKUP\000ANDNOT_2r\000AND_3r\000"
    "ASHR_l2rus\000ASHR_l3r\000BAU_1r\000BITREV_l2r\000BLA_1r\000BL_lu10\000"
    "BL_u10\000BRBF_lru6\000BRBF_ru6\000BRBT_lru6\000BRBT_ru6\000BRBU_lu6\000"
    "BRBU_u6\000BRFF_lru6\000BRFF_ru6\000BRFT_lru6\000BRFT_ru6\000BRFU_lu6\000"
    "BRFU_u6\000BR_JT\000BR_JT32\000BYTEREV_l2r\000CHKCT_2r\000CHKCT_rus\000"
    "CLRE_0R\000CLRSR_branch_lu6\000CLRSR_branch_u6\000CLRSR_lu6\000CLRSR_u6"
    "\000CLZ_l2r\000CRC8_l4r\000CRC_l3r\000DIVS_l3r\000DIVU_l3r\000ECALLF_1r"
    "\000ECALLT_1r\000EEU_1r\000ENDIN_l2r\000ENTSP_lu6\000ENTSP_u6\000EQ_2ru"
    "s\000EQ_3r\000EXTSP_lu6\000EXTSP_u6\000FREER_1r\000GETED_0R\000GETET_0R"
    "\000GETID_0R\000GETPS_l2r\000GETR_rus\000GETST_2r\000GETTS_2r\000INCT_2"
    "r\000INITCP_2r\000INITDP_2r\000INITLR_l2r\000INITPC_2r\000INITSP_2r\000"
    "INSHR_2r\000INT_2r\000IN_2r\000LADD_l5r\000LD16S_3r\000LD8U_3r\000LDA16"
    "B_l3r\000LDA16F_l3r\000LDAP_lu10\000LDAP_lu10_ba\000LDAP_u10\000LDAWB_l"
    "2rus\000LDAWB_l3r\000LDAWCP_lu6\000LDAWCP_u6\000LDAWDP_lru6\000LDAWDP_r"
    "u6\000LDAWFI\000LDAWF_l2rus\000LDAWF_l3r\000LDAWSP_lru6\000LDAWSP_lru6_"
    "RRegs\000LDAWSP_ru6\000LDAWSP_ru6_RRegs\000LDC_lru6\000LDC_ru6\000LDIV_"
    "l5r\000LDWCP_lru6\000LDWCP_ru6\000LDWDP_lru6\000LDWDP_ru6\000LDWFI\000L"
    "DWSP_lru6\000LDWSP_ru6\000LDW_2rus\000LDW_3r\000LMUL_l6r\000LSS_3r\000L"
    "SUB_l5r\000LSU_3r\000MACCS_l4r\000MACCU_l4r\000MJOIN_1r\000MKMSK_2r\000"
    "MKMSK_rus\000MSYNC_1r\000MUL_l3r\000NEG\000NOT\000OR_3r\000OUTCT_2r\000"
    "OUTCT_rus\000OUTSHR_2r\000OUTT_2r\000OUT_2r\000PEEK_l2r\000REMS_l3r\000"
    "REMU_l3r\000RETSP_lu6\000RETSP_u6\000SELECT_CC\000SETCLK_l2r\000SETC_l2"
    "r\000SETC_lru6\000SETC_ru6\000SETD_2r\000SETEV_1r\000SETPSC_l2r\000SETP"
    "S_l2r\000SETPT_2r\000SETRDY_l2r\000SETSP_1r\000SETSR_branch_lu6\000SETS"
    "R_branch_u6\000SETSR_lu6\000SETSR_u6\000SETTW_l2r\000SETV_1r\000SEXT_2r"
    "\000SEXT_rus\000SHL_2rus\000SHL_3r\000SHR_2rus\000SHR_3r\000SSYNC_0r\000"
    "ST16_l3r\000ST8_l3r\000STWDP_lru6\000STWDP_ru6\000STWFI\000STWSP_lru6\000"
    "STWSP_ru6\000STW_2rus\000STW_3r\000SUB_2rus\000SUB_3r\000SYNCR_1r\000TE"
    "STCT_2r\000TESTWCT_2r\000WAITEU_0R\000XOR_l3r\000ZEXT_2r\000ZEXT_rus\000";
  return Strs+InstAsmOffset[Opcode];
}

#endif
