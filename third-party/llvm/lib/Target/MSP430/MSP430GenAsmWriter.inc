//===- TableGen'erated file -------------------------------------*- C++ -*-===//
//
// Assembly Writer Source Fragment
//
// Automatically generated file, do not edit!
//
//===----------------------------------------------------------------------===//

/// printInstruction - This method is automatically generated by tablegen
/// from the instruction set description.
void MSP430InstPrinter::printInstruction(const MCInst *MI, raw_ostream &O) {
  static const unsigned OpInfo[] = {
    0U,	// PHI
    0U,	// INLINEASM
    0U,	// PROLOG_LABEL
    0U,	// EH_LABEL
    0U,	// GC_LABEL
    0U,	// KILL
    0U,	// EXTRACT_SUBREG
    0U,	// INSERT_SUBREG
    0U,	// IMPLICIT_DEF
    0U,	// SUBREG_TO_REG
    0U,	// COPY_TO_REGCLASS
    1U,	// DBG_VALUE
    0U,	// REG_SEQUENCE
    0U,	// COPY
    11U,	// BUNDLE
    268435474U,	// ADC16mi
    570425362U,	// ADC16mm
    268435474U,	// ADC16mr
    285212690U,	// ADC16ri
    603979794U,	// ADC16rm
    285212690U,	// ADC16rr
    268435482U,	// ADC8mi
    570425370U,	// ADC8mm
    268435482U,	// ADC8mr
    285212698U,	// ADC8ri
    603979802U,	// ADC8rm
    285212698U,	// ADC8rr
    268435490U,	// ADD16mi
    570425378U,	// ADD16mm
    268435490U,	// ADD16mr
    285212706U,	// ADD16ri
    603979810U,	// ADD16rm
    805306409U,	// ADD16rm_POST
    285212706U,	// ADD16rr
    268435505U,	// ADD8mi
    570425393U,	// ADD8mm
    268435505U,	// ADD8mr
    285212721U,	// ADD8ri
    603979825U,	// ADD8rm
    805306424U,	// ADD8rm_POST
    285212721U,	// ADD8rr
    64U,	// ADJCALLSTACKDOWN
    82U,	// ADJCALLSTACKUP
    268435554U,	// AND16mi
    570425442U,	// AND16mm
    268435554U,	// AND16mr
    285212770U,	// AND16ri
    603979874U,	// AND16rm
    805306473U,	// AND16rm_POST
    285212770U,	// AND16rr
    268435569U,	// AND8mi
    570425457U,	// AND8mm
    268435569U,	// AND8mr
    285212785U,	// AND8ri
    603979889U,	// AND8rm
    805306488U,	// AND8rm_POST
    285212785U,	// AND8rr
    570425472U,	// BIC16mm
    268435584U,	// BIC16mr
    603979904U,	// BIC16rm
    285212800U,	// BIC16rr
    570425479U,	// BIC8mm
    268435591U,	// BIC8mr
    603979911U,	// BIC8rm
    285212807U,	// BIC8rr
    268435598U,	// BIT16mi
    570425486U,	// BIT16mm
    268435598U,	// BIT16mr
    1073741966U,	// BIT16ri
    1342177422U,	// BIT16rm
    1073741966U,	// BIT16rr
    268435605U,	// BIT8mi
    570425493U,	// BIT8mm
    268435605U,	// BIT8mr
    1073741973U,	// BIT8ri
    1342177429U,	// BIT8rm
    1073741973U,	// BIT8rr
    1711276188U,	// Bi
    1879048352U,	// Bm
    1744830624U,	// Br
    1711276199U,	// CALLi
    2147483815U,	// CALLm
    1711276199U,	// CALLr
    268435629U,	// CMP16mi
    268435629U,	// CMP16mr
    1073741997U,	// CMP16ri
    1342177453U,	// CMP16rm
    1073741997U,	// CMP16rr
    268435636U,	// CMP8mi
    268435636U,	// CMP8mr
    1073742004U,	// CMP8ri
    1342177460U,	// CMP8rm
    1073742004U,	// CMP8rr
    2415919291U,	// JCC
    2684354749U,	// JMP
    268435616U,	// MOV16mi
    570425504U,	// MOV16mm
    268435616U,	// MOV16mr
    1073741984U,	// MOV16ri
    1342177440U,	// MOV16rm
    436207810U,	// MOV16rm_POST
    1073741984U,	// MOV16rr
    268435658U,	// MOV8mi
    570425546U,	// MOV8mm
    268435658U,	// MOV8mr
    1073742026U,	// MOV8ri
    1342177482U,	// MOV8rm
    436207825U,	// MOV8rm_POST
    1073742026U,	// MOV8rr
    1342177482U,	// MOVZX16rm8
    1073742026U,	// MOVZX16rr8
    217U,	// NOP
    268435677U,	// OR16mi
    570425565U,	// OR16mm
    268435677U,	// OR16mr
    285212893U,	// OR16ri
    603979997U,	// OR16rm
    805306596U,	// OR16rm_POST
    285212893U,	// OR16rr
    268435692U,	// OR8mi
    570425580U,	// OR8mm
    268435692U,	// OR8mr
    285212908U,	// OR8ri
    603980012U,	// OR8rm
    805306611U,	// OR8rm_POST
    285212908U,	// OR8rr
    1711276283U,	// POP16r
    1711276290U,	// PUSH16r
    266U,	// RET
    270U,	// RETI
    1711276307U,	// SAR16r1
    1711276314U,	// SAR16r1c
    1711276327U,	// SAR8r1
    1711276334U,	// SAR8r1c
    268435771U,	// SBC16mi
    570425659U,	// SBC16mm
    268435771U,	// SBC16mr
    285212987U,	// SBC16ri
    603980091U,	// SBC16rm
    285212987U,	// SBC16rr
    268435779U,	// SBC8mi
    570425667U,	// SBC8mm
    268435779U,	// SBC8mr
    285212995U,	// SBC8ri
    603980099U,	// SBC8rm
    285212995U,	// SBC8rr
    1711276363U,	// SEXT16r
    1711276368U,	// SHL16r1
    1711276375U,	// SHL8r1
    268435806U,	// SUB16mi
    570425694U,	// SUB16mm
    268435806U,	// SUB16mr
    285213022U,	// SUB16ri
    603980126U,	// SUB16rm
    805306725U,	// SUB16rm_POST
    285213022U,	// SUB16rr
    268435821U,	// SUB8mi
    570425709U,	// SUB8mm
    268435821U,	// SUB8mr
    285213037U,	// SUB8ri
    603980141U,	// SUB8rm
    805306740U,	// SUB8rm_POST
    285213037U,	// SUB8rr
    1711276412U,	// SWPB16r
    386U,	// Select16
    404U,	// Select8
    421U,	// Shl16
    436U,	// Shl8
    450U,	// Sra16
    465U,	// Sra8
    479U,	// Srl16
    494U,	// Srl8
    268435964U,	// XOR16mi
    570425852U,	// XOR16mm
    268435964U,	// XOR16mr
    285213180U,	// XOR16ri
    603980284U,	// XOR16rm
    805306883U,	// XOR16rm_POST
    285213180U,	// XOR16rr
    268435979U,	// XOR8mi
    570425867U,	// XOR8mm
    268435979U,	// XOR8mr
    285213195U,	// XOR8ri
    603980299U,	// XOR8rm
    805306898U,	// XOR8rm_POST
    285213195U,	// XOR8rr
    1073742026U,	// ZEXT16r
    0U
  };

  const char *AsmStrs = 
    "DBG_VALUE\000BUNDLE\000addc.w\t\000addc.b\t\000add.w\t\000add.w\t@\000a"
    "dd.b\t\000add.b\t@\000#ADJCALLSTACKDOWN\000#ADJCALLSTACKUP\000and.w\t\000"
    "and.w\t@\000and.b\t\000and.b\t@\000bic.w\t\000bic.b\t\000bit.w\t\000bit"
    ".b\t\000br\t\000mov.w\t\000call\t\000cmp.w\t\000cmp.b\t\000j\000jmp\t\000"
    "mov.w\t@\000mov.b\t\000mov.b\t@\000nop\000bis.w\t\000bis.w\t@\000bis.b\t"
    "\000bis.b\t@\000pop.w\t\000push.w\t\000ret\000reti\000rra.w\t\000clrc\n"
    "\trrc.w\t\000rra.b\t\000clrc\n\trrc.b\t\000subc.w\t\000subc.b\t\000sxt\t"
    "\000rla.w\t\000rla.b\t\000sub.w\t\000sub.w\t@\000sub.b\t\000sub.b\t@\000"
    "swpb\t\000# Select16 PSEUDO\000# Select8 PSEUDO\000# Shl16 PSEUDO\000# "
    "Shl8 PSEUDO\000# Sra16 PSEUDO\000# Sra8 PSEUDO\000# Srl16 PSEUDO\000# S"
    "rl8 PSEUDO\000xor.w\t\000xor.w\t@\000xor.b\t\000xor.b\t@\000";

  O << "\t";

  // Emit the opcode for the instruction.
  unsigned Bits = OpInfo[MI->getOpcode()];
  assert(Bits != 0 && "Cannot print this instruction.");
  O << AsmStrs+(Bits & 1023)-1;


  // Fragment 0 encoded into 4 bits for 11 unique commands.
  switch ((Bits >> 28) & 15) {
  default:   // unreachable.
  case 0:
    // DBG_VALUE, BUNDLE, ADJCALLSTACKDOWN, ADJCALLSTACKUP, NOP, RET, RETI, S...
    return;
    break;
  case 1:
    // ADC16mi, ADC16mr, ADC16ri, ADC16rr, ADC8mi, ADC8mr, ADC8ri, ADC8rr, AD...
    printOperand(MI, 2, O); 
    break;
  case 2:
    // ADC16mm, ADC16rm, ADC8mm, ADC8rm, ADD16mm, ADD16rm, ADD8mm, ADD8rm, AN...
    printSrcMemOperand(MI, 2, O); 
    O << ", "; 
    break;
  case 3:
    // ADD16rm_POST, ADD8rm_POST, AND16rm_POST, AND8rm_POST, OR16rm_POST, OR8...
    printOperand(MI, 3, O); 
    O << "+, "; 
    printOperand(MI, 0, O); 
    return;
    break;
  case 4:
    // BIT16ri, BIT16rr, BIT8ri, BIT8rr, CMP16ri, CMP16rr, CMP8ri, CMP8rr, MO...
    printOperand(MI, 1, O); 
    O << ", "; 
    printOperand(MI, 0, O); 
    return;
    break;
  case 5:
    // BIT16rm, BIT8rm, CMP16rm, CMP8rm, MOV16rm, MOV8rm, MOVZX16rm8
    printSrcMemOperand(MI, 1, O); 
    O << ", "; 
    printOperand(MI, 0, O); 
    return;
    break;
  case 6:
    // Bi, Br, CALLi, CALLr, POP16r, PUSH16r, SAR16r1, SAR16r1c, SAR8r1, SAR8...
    printOperand(MI, 0, O); 
    break;
  case 7:
    // Bm
    printSrcMemOperand(MI, 0, O); 
    O << ", pc"; 
    return;
    break;
  case 8:
    // CALLm
    printSrcMemOperand(MI, 0, O, "mem"); 
    return;
    break;
  case 9:
    // JCC
    printCCOperand(MI, 1, O); 
    O << "\t"; 
    printPCRelImmOperand(MI, 0, O); 
    return;
    break;
  case 10:
    // JMP
    printPCRelImmOperand(MI, 0, O); 
    return;
    break;
  }


  // Fragment 1 encoded into 3 bits for 6 unique commands.
  switch ((Bits >> 25) & 7) {
  default:   // unreachable.
  case 0:
    // ADC16mi, ADC16mr, ADC16ri, ADC16rr, ADC8mi, ADC8mr, ADC8ri, ADC8rr, AD...
    O << ", "; 
    break;
  case 1:
    // ADC16mm, ADC8mm, ADD16mm, ADD8mm, AND16mm, AND8mm, BIC16mm, BIC8mm, BI...
    printSrcMemOperand(MI, 0, O); 
    return;
    break;
  case 2:
    // ADC16rm, ADC8rm, ADD16rm, ADD8rm, AND16rm, AND8rm, BIC16rm, BIC8rm, OR...
    printOperand(MI, 0, O); 
    return;
    break;
  case 3:
    // Bi, CALLi, CALLr, POP16r, PUSH16r, SAR16r1, SAR16r1c, SAR8r1, SAR8r1c,...
    return;
    break;
  case 4:
    // Br
    O << ", pc"; 
    return;
    break;
  case 5:
    // MOV16rm_POST, MOV8rm_POST
    O << "+, "; 
    printOperand(MI, 0, O); 
    return;
    break;
  }


  // Fragment 2 encoded into 1 bits for 2 unique commands.
  if ((Bits >> 24) & 1) {
    // ADC16ri, ADC16rr, ADC8ri, ADC8rr, ADD16ri, ADD16rr, ADD8ri, ADD8rr, AN...
    printOperand(MI, 0, O); 
    return;
  } else {
    // ADC16mi, ADC16mr, ADC8mi, ADC8mr, ADD16mi, ADD16mr, ADD8mi, ADD8mr, AN...
    printSrcMemOperand(MI, 0, O); 
    return;
  }

}


/// getRegisterName - This method is automatically generated by tblgen
/// from the register set description.  This returns the assembler name
/// for the specified register.
const char *MSP430InstPrinter::getRegisterName(unsigned RegNo) {
  assert(RegNo && RegNo < 33 && "Invalid register number!");

  static const unsigned RegAsmOffset[] = {
    0, 3, 6, 6, 9, 9, 12, 12, 15, 15, 18, 18, 21, 21,
    24, 24, 27, 27, 31, 31, 35, 35, 39, 39, 43, 43, 47, 47,
    51, 51, 54, 54, 0
  };

  const char *AsmStrs =
    "r3\000r3\000r4\000r0\000r5\000r6\000r7\000r8\000r9\000r10\000r11\000r12"
    "\000r13\000r14\000r15\000r1\000r2\000";
  assert (*(AsmStrs+RegAsmOffset[RegNo-1]) &&
          "Invalid alt name index for register!");
  return AsmStrs+RegAsmOffset[RegNo-1];
}


#ifdef GET_INSTRUCTION_NAME
#undef GET_INSTRUCTION_NAME

/// getInstructionName: This method is automatically generated by tblgen
/// from the instruction set description.  This returns the enum name of the
/// specified instruction.
const char *MSP430InstPrinter::getInstructionName(unsigned Opcode) {
  assert(Opcode < 187 && "Invalid instruction number!");

  static const unsigned InstAsmOffset[] = {
    0, 4, 14, 27, 36, 45, 50, 65, 79, 92, 106, 123, 133, 146, 
    151, 158, 166, 174, 182, 190, 198, 206, 213, 220, 227, 234, 241, 248, 
    256, 264, 272, 280, 288, 301, 309, 316, 323, 330, 337, 344, 356, 363, 
    380, 395, 403, 411, 419, 427, 435, 448, 456, 463, 470, 477, 484, 491, 
    503, 510, 518, 526, 534, 542, 549, 556, 563, 570, 578, 586, 594, 602, 
    610, 618, 625, 632, 639, 646, 653, 660, 663, 666, 669, 675, 681, 687, 
    695, 703, 711, 719, 727, 734, 741, 748, 755, 762, 766, 770, 778, 786, 
    794, 802, 810, 823, 831, 838, 845, 852, 859, 866, 878, 885, 896, 907, 
    911, 918, 925, 932, 939, 946, 958, 965, 971, 977, 983, 989, 995, 1006, 
    1012, 1019, 1027, 1031, 1036, 1044, 1053, 1060, 1068, 1076, 1084, 1092, 1100, 1108, 
    1116, 1123, 1130, 1137, 1144, 1151, 1158, 1166, 1174, 1181, 1189, 1197, 1205, 1213, 
    1221, 1234, 1242, 1249, 1256, 1263, 1270, 1277, 1289, 1296, 1304, 1313, 1321, 1327, 
    1332, 1338, 1343, 1349, 1354, 1362, 1370, 1378, 1386, 1394, 1407, 1415, 1422, 1429, 
    1436, 1443, 1450, 1462, 1469, 0
  };

  const char *Strs =
    "PHI\000INLINEASM\000PROLOG_LABEL\000EH_LABEL\000GC_LABEL\000KILL\000EXT"
    "RACT_SUBREG\000INSERT_SUBREG\000IMPLICIT_DEF\000SUBREG_TO_REG\000COPY_T"
    "O_REGCLASS\000DBG_VALUE\000REG_SEQUENCE\000COPY\000BUNDLE\000ADC16mi\000"
    "ADC16mm\000ADC16mr\000ADC16ri\000ADC16rm\000ADC16rr\000ADC8mi\000ADC8mm"
    "\000ADC8mr\000ADC8ri\000ADC8rm\000ADC8rr\000ADD16mi\000ADD16mm\000ADD16"
    "mr\000ADD16ri\000ADD16rm\000ADD16rm_POST\000ADD16rr\000ADD8mi\000ADD8mm"
    "\000ADD8mr\000ADD8ri\000ADD8rm\000ADD8rm_POST\000ADD8rr\000ADJCALLSTACK"
    "DOWN\000ADJCALLSTACKUP\000AND16mi\000AND16mm\000AND16mr\000AND16ri\000A"
    "ND16rm\000AND16rm_POST\000AND16rr\000AND8mi\000AND8mm\000AND8mr\000AND8"
    "ri\000AND8rm\000AND8rm_POST\000AND8rr\000BIC16mm\000BIC16mr\000BIC16rm\000"
    "BIC16rr\000BIC8mm\000BIC8mr\000BIC8rm\000BIC8rr\000BIT16mi\000BIT16mm\000"
    "BIT16mr\000BIT16ri\000BIT16rm\000BIT16rr\000BIT8mi\000BIT8mm\000BIT8mr\000"
    "BIT8ri\000BIT8rm\000BIT8rr\000Bi\000Bm\000Br\000CALLi\000CALLm\000CALLr"
    "\000CMP16mi\000CMP16mr\000CMP16ri\000CMP16rm\000CMP16rr\000CMP8mi\000CM"
    "P8mr\000CMP8ri\000CMP8rm\000CMP8rr\000JCC\000JMP\000MOV16mi\000MOV16mm\000"
    "MOV16mr\000MOV16ri\000MOV16rm\000MOV16rm_POST\000MOV16rr\000MOV8mi\000M"
    "OV8mm\000MOV8mr\000MOV8ri\000MOV8rm\000MOV8rm_POST\000MOV8rr\000MOVZX16"
    "rm8\000MOVZX16rr8\000NOP\000OR16mi\000OR16mm\000OR16mr\000OR16ri\000OR1"
    "6rm\000OR16rm_POST\000OR16rr\000OR8mi\000OR8mm\000OR8mr\000OR8ri\000OR8"
    "rm\000OR8rm_POST\000OR8rr\000POP16r\000PUSH16r\000RET\000RETI\000SAR16r"
    "1\000SAR16r1c\000SAR8r1\000SAR8r1c\000SBC16mi\000SBC16mm\000SBC16mr\000"
    "SBC16ri\000SBC16rm\000SBC16rr\000SBC8mi\000SBC8mm\000SBC8mr\000SBC8ri\000"
    "SBC8rm\000SBC8rr\000SEXT16r\000SHL16r1\000SHL8r1\000SUB16mi\000SUB16mm\000"
    "SUB16mr\000SUB16ri\000SUB16rm\000SUB16rm_POST\000SUB16rr\000SUB8mi\000S"
    "UB8mm\000SUB8mr\000SUB8ri\000SUB8rm\000SUB8rm_POST\000SUB8rr\000SWPB16r"
    "\000Select16\000Select8\000Shl16\000Shl8\000Sra16\000Sra8\000Srl16\000S"
    "rl8\000XOR16mi\000XOR16mm\000XOR16mr\000XOR16ri\000XOR16rm\000XOR16rm_P"
    "OST\000XOR16rr\000XOR8mi\000XOR8mm\000XOR8mr\000XOR8ri\000XOR8rm\000XOR"
    "8rm_POST\000XOR8rr\000ZEXT16r\000";
  return Strs+InstAsmOffset[Opcode];
}

#endif

#ifdef PRINT_ALIAS_INSTR
#undef PRINT_ALIAS_INSTR

namespace { // Register classes
  enum RegClass {
    RC_GR8,
    RC_GR16
  };
} // end anonymous namespace

static bool regIsInRegisterClass(unsigned RegClass, unsigned Reg) {
  switch (RegClass) {
  default: break;
  case RC_GR8:
    switch (Reg) {
    default: break;
    case MSP430::R12B:
    case MSP430::R13B:
    case MSP430::R14B:
    case MSP430::R15B:
    case MSP430::R11B:
    case MSP430::R10B:
    case MSP430::R9B:
    case MSP430::R8B:
    case MSP430::R7B:
    case MSP430::R6B:
    case MSP430::R5B:
    case MSP430::FPB:
    case MSP430::PCB:
    case MSP430::SPB:
    case MSP430::SRB:
    case MSP430::CGB:
      return true;
    }
    break;
  case RC_GR16:
    switch (Reg) {
    default: break;
    case MSP430::R12W:
    case MSP430::R13W:
    case MSP430::R14W:
    case MSP430::R15W:
    case MSP430::R11W:
    case MSP430::R10W:
    case MSP430::R9W:
    case MSP430::R8W:
    case MSP430::R7W:
    case MSP430::R6W:
    case MSP430::R5W:
    case MSP430::FPW:
    case MSP430::PCW:
    case MSP430::SPW:
    case MSP430::SRW:
    case MSP430::CGW:
      return true;
    }
    break;
  }

  return false;
}

bool MSP430InstPrinter::printAliasInstr(const MCInst *MI, raw_ostream &OS) {
  return false;
}

#endif // PRINT_ALIAS_INSTR
