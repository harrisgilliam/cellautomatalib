//===- TableGen'erated file -------------------------------------*- C++ -*-===//
//
// Assembly Writer Source Fragment
//
// Automatically generated file, do not edit!
//
//===----------------------------------------------------------------------===//

/// printInstruction - This method is automatically generated by tablegen
/// from the instruction set description.
void MBlazeInstPrinter::printInstruction(const MCInst *MI, raw_ostream &O) {
  static const unsigned OpInfo[] = {
    0U,	// PHI
    0U,	// INLINEASM
    0U,	// PROLOG_LABEL
    0U,	// EH_LABEL
    0U,	// GC_LABEL
    0U,	// KILL
    0U,	// EXTRACT_SUBREG
    0U,	// INSERT_SUBREG
    0U,	// IMPLICIT_DEF
    0U,	// SUBREG_TO_REG
    0U,	// COPY_TO_REGCLASS
    1U,	// DBG_VALUE
    0U,	// REG_SEQUENCE
    0U,	// COPY
    11U,	// BUNDLE
    1073741842U,	// ADD
    1073741853U,	// ADDC
    1073741864U,	// ADDI
    1073741875U,	// ADDIC
    1073741886U,	// ADDIK
    1073741886U,	// ADDIK32
    1073741897U,	// ADDIKC
    1073741908U,	// ADDK
    1073741919U,	// ADDKC
    1610612842U,	// ADJCALLSTACKDOWN
    2147483773U,	// ADJCALLSTACKUP
    1207959694U,	// AGET
    1140850841U,	// AGETD
    1073741988U,	// AND
    1107296431U,	// ANDI
    1073742010U,	// ANDN
    1107296453U,	// ANDNI
    1207959760U,	// APUT
    1140850907U,	// APUTD
    1140850918U,	// BEQ
    1140850929U,	// BEQD
    1140850940U,	// BEQI
    1140850951U,	// BEQID
    1140850962U,	// BGE
    1140850973U,	// BGED
    1140850984U,	// BGEI
    1140850995U,	// BGEID
    1140851006U,	// BGT
    1140851017U,	// BGTD
    1140851028U,	// BGTI
    1140851039U,	// BGTID
    1140851050U,	// BLE
    1140851061U,	// BLED
    1140851072U,	// BLEI
    1140851083U,	// BLEID
    1140851094U,	// BLT
    1140851105U,	// BLTD
    1140851116U,	// BLTI
    1140851127U,	// BLTID
    1140851138U,	// BNE
    1140851149U,	// BNED
    1140851160U,	// BNEI
    1140851171U,	// BNEID
    1610613230U,	// BR
    1610613241U,	// BRA
    1610613252U,	// BRAD
    1610613263U,	// BRAI
    1610613274U,	// BRAID
    1140851237U,	// BRALD
    1140851248U,	// BRALID
    1610613307U,	// BRD
    1610613318U,	// BRI
    1610613329U,	// BRID
    1140851292U,	// BRK
    1140851303U,	// BRKI
    1140851314U,	// BRLD
    1140851325U,	// BRLID
    1140851325U,	// BRLID32
    1073742472U,	// BSLL
    1073742483U,	// BSLLI
    1073742494U,	// BSRA
    1073742505U,	// BSRAI
    1073742516U,	// BSRL
    1073742527U,	// BSRLI
    1207960266U,	// CAGET
    1140851413U,	// CAGETD
    1207960288U,	// CAPUT
    1140851435U,	// CAPUTD
    758U,	// CAS32
    1207960336U,	// CGET
    1140851483U,	// CGETD
    1140851494U,	// CLZ
    1073742638U,	// CMP
    1073742649U,	// CMPU
    1207960388U,	// CPUT
    1140851535U,	// CPUTD
    858U,	// DMEMBAR
    1207960419U,	// EAGET
    1140851566U,	// EAGETD
    1207960441U,	// ECAGET
    1140851588U,	// ECAGETD
    1207960463U,	// ECGET
    1140851610U,	// ECGETD
    1207960485U,	// EGET
    1140851632U,	// EGETD
    1073742779U,	// FADD
    1073742790U,	// FCMP_EQ
    1073742801U,	// FCMP_GE
    1073742812U,	// FCMP_GT
    1073742823U,	// FCMP_LE
    1073742834U,	// FCMP_LT
    1073742845U,	// FCMP_NE
    1073742856U,	// FCMP_UN
    1073742867U,	// FDIV
    1140851742U,	// FINT
    1140851753U,	// FLT
    1073742900U,	// FMUL
    1073742911U,	// FORI
    1342178378U,	// FRSUB
    1140851797U,	// FSQRT
    1207960672U,	// GET
    1140851819U,	// GETD
    1342178422U,	// IDIV
    1342178433U,	// IDIVU
    1164U,	// IDMEMBAR
    1173U,	// IMEMBAR
    1610613918U,	// IMM
    1193U,	// LAA32
    1215U,	// LAD32
    1237U,	// LAN32
    1260U,	// LAO32
    1281U,	// LAS32
    1303U,	// LAX32
    1476396333U,	// LBU
    1476396344U,	// LBUI
    1476396355U,	// LBUR
    1476396366U,	// LHU
    1476396377U,	// LHUI
    1476396388U,	// LHUR
    1476396399U,	// LW
    1476396410U,	// LWF
    1476396422U,	// LWFI
    1476396434U,	// LWI
    1476396445U,	// LWR
    1476396456U,	// LWX
    1459U,	// MEMBARRIER
    1140852164U,	// MFS
    1140852175U,	// MSRCLR
    1140852186U,	// MSRSET
    1140852197U,	// MTS
    1073743344U,	// MUL
    1073743355U,	// MULH
    1073743366U,	// MULHSU
    1073743377U,	// MULHU
    1073743388U,	// MULI
    1207961127U,	// NAGET
    1140852274U,	// NAGETD
    1207961149U,	// NAPUT
    1140852296U,	// NAPUTD
    1207961171U,	// NCAGET
    1140852318U,	// NCAGETD
    1207961193U,	// NCAPUT
    1140852340U,	// NCAPUTD
    1207961215U,	// NCGET
    1140852362U,	// NCGETD
    1207961237U,	// NCPUT
    1140852384U,	// NCPUTD
    1207961259U,	// NEAGET
    1140852406U,	// NEAGETD
    1207961281U,	// NECAGET
    1140852428U,	// NECAGETD
    1207961303U,	// NECGET
    1140852450U,	// NECGETD
    1207961325U,	// NEGET
    1140852472U,	// NEGETD
    1207961347U,	// NGET
    1140852494U,	// NGETD
    1817U,	// NOP
    1207961377U,	// NPUT
    1140852524U,	// NPUTD
    1073743671U,	// OR
    1107297343U,	// ORI
    1107297343U,	// ORI32
    1073743682U,	// PCMPBF
    1073743693U,	// PCMPEQ
    1073743704U,	// PCMPNE
    1207961443U,	// PUT
    1140852590U,	// PUTD
    1342179193U,	// RSUB
    1342179204U,	// RSUBC
    1342179215U,	// RSUBI
    1342179226U,	// RSUBIC
    1342179237U,	// RSUBIK
    1342179248U,	// RSUBIKC
    1342179259U,	// RSUBK
    1342179270U,	// RSUBKC
    1140852689U,	// RTBD
    1140852700U,	// RTED
    1140852711U,	// RTID
    1140852722U,	// RTSD
    1476397053U,	// SB
    1476397064U,	// SBI
    1476397075U,	// SBR
    1140852766U,	// SEXT16
    1140852777U,	// SEXT8
    1476397108U,	// SH
    1476397119U,	// SHI
    1476397130U,	// SHR
    1140852821U,	// SRA
    1140852832U,	// SRC
    1140852843U,	// SRL
    1476397174U,	// SW
    1476397185U,	// SWF
    1476397197U,	// SWFI
    1476397209U,	// SWI
    2212U,	// SWP32
    1476397234U,	// SWR
    1476397245U,	// SWX
    2248U,	// Select_CC
    2268U,	// Select_FCC
    2289U,	// ShiftL
    2306U,	// ShiftRA
    2324U,	// ShiftRL
    1207961894U,	// TAGET
    1140853041U,	// TAGETD
    3221227836U,	// TAPUT
    1610615111U,	// TAPUTD
    1207961938U,	// TCAGET
    1140853085U,	// TCAGETD
    3221227880U,	// TCAPUT
    1610615155U,	// TCAPUTD
    1207961982U,	// TCGET
    1140853129U,	// TCGETD
    3221227924U,	// TCPUT
    1610615199U,	// TCPUTD
    1207962026U,	// TEAGET
    1140853173U,	// TEAGETD
    1207962048U,	// TECAGET
    1140853195U,	// TECAGETD
    1207962070U,	// TECGET
    1140853217U,	// TECGETD
    1207962092U,	// TEGET
    1140853239U,	// TEGETD
    1207962114U,	// TGET
    1140853261U,	// TGETD
    1207962136U,	// TNAGET
    1140853283U,	// TNAGETD
    3221228078U,	// TNAPUT
    1610615353U,	// TNAPUTD
    1207962180U,	// TNCAGET
    1140853327U,	// TNCAGETD
    3221228122U,	// TNCAPUT
    1610615397U,	// TNCAPUTD
    1207962224U,	// TNCGET
    1140853371U,	// TNCGETD
    3221228166U,	// TNCPUT
    1610615441U,	// TNCPUTD
    1207962268U,	// TNEAGET
    1140853415U,	// TNEAGETD
    1207962290U,	// TNECAGET
    1140853437U,	// TNECAGETD
    1207962312U,	// TNECGET
    1140853459U,	// TNECGETD
    1207962334U,	// TNEGET
    1140853481U,	// TNEGETD
    1207962356U,	// TNGET
    1140853503U,	// TNGETD
    3221228298U,	// TNPUT
    1610615573U,	// TNPUTD
    3221228320U,	// TPUT
    1610615595U,	// TPUTD
    1140853558U,	// WDC
    1140853569U,	// WDCC
    1140853580U,	// WDCF
    1140853591U,	// WIC
    1073744738U,	// XOR
    1107299181U,	// XORI
    0U
  };

  const char *AsmStrs = 
    "DBG_VALUE\000BUNDLE\000add       \000addc      \000addi      \000addic "
    "    \000addik     \000addikc    \000addk      \000addkc     \000#ADJCAL"
    "LSTACKDOWN \000#ADJCALLSTACKUP \000aget      \000agetd     \000and     "
    "  \000andi      \000andn      \000andni     \000aput      \000aputd    "
    " \000beq       \000beqd      \000beqi      \000beqid     \000bge       "
    "\000bged      \000bgei      \000bgeid     \000bgt       \000bgtd      \000"
    "bgti      \000bgtid     \000ble       \000bled      \000blei      \000b"
    "leid     \000blt       \000bltd      \000blti      \000bltid     \000bn"
    "e       \000bned      \000bnei      \000bneid     \000br        \000bra"
    "       \000brad      \000brai      \000braid     \000brald     \000bral"
    "id    \000brd       \000bri       \000brid      \000brk       \000brki "
    "     \000brld      \000brlid     \000bsll      \000bslli     \000bsra  "
    "    \000bsrai     \000bsrl      \000bsrli     \000caget     \000cagetd "
    "   \000caput     \000caputd    \000# atomic compare and swap\000cget   "
    "   \000cgetd     \000clz    \000cmp       \000cmpu      \000cput      \000"
    "cputd     \000mbar   1\000eaget     \000eagetd    \000ecaget    \000eca"
    "getd   \000ecget     \000ecgetd    \000eget      \000egetd     \000fadd"
    "      \000fcmp.eq   \000fcmp.ge   \000fcmp.gt   \000fcmp.le   \000fcmp."
    "lt   \000fcmp.ne   \000fcmp.un   \000fdiv      \000fint      \000flt   "
    "    \000fmul      \000ori       \000frsub     \000fsqrt     \000get    "
    "   \000getd      \000idiv      \000idivu     \000mbar   0\000mbar   2\000"
    "imm       \000# atomic load and add\000# atomic load and and\000# atomi"
    "c load and nand\000# atomic load and or\000# atomic load and sub\000# a"
    "tomic load and xor\000lbu       \000lbui      \000lbur      \000lhu    "
    "   \000lhui      \000lhur      \000lw        \000lw         \000lwi    "
    "    \000lwi       \000lwr       \000lwx       \000# memory barrier\000m"
    "fs       \000msrclr    \000msrset    \000mts       \000mul       \000mu"
    "lh      \000mulhsu    \000mulhu     \000muli      \000naget     \000nag"
    "etd    \000naput     \000naputd    \000ncaget    \000ncagetd   \000ncap"
    "ut    \000ncaputd   \000ncget     \000ncgetd    \000ncput     \000ncput"
    "d    \000neaget    \000neagetd   \000necaget   \000necagetd  \000necget"
    "    \000necgetd   \000neget     \000negetd    \000nget      \000ngetd  "
    "   \000nop    \000nput      \000nputd     \000or        \000pcmpbf    \000"
    "pcmpeq    \000pcmpne    \000put       \000putd      \000rsub      \000r"
    "subc     \000rsubi     \000rsubic    \000rsubik    \000rsubikc   \000rs"
    "ubk     \000rsubkc    \000rtbd      \000rted      \000rtid      \000rts"
    "d      \000sb        \000sbi       \000sbr       \000sext16    \000sext"
    "8     \000sh        \000shi       \000shr       \000sra       \000src  "
    "     \000srl       \000sw        \000sw         \000swi        \000swi "
    "      \000# atomic swap\000swr       \000swx       \000; SELECT_CC PSEU"
    "DO!\000; SELECT_FCC PSEUDO!\000; ShiftL PSEUDO!\000; ShiftRA PSEUDO!\000"
    "; ShiftRL PSEUDO!\000taget     \000tagetd    \000taput     \000taputd  "
    "  \000tcaget    \000tcagetd   \000tcaput    \000tcaputd   \000tcget    "
    " \000tcgetd    \000tcput     \000tcputd    \000teaget    \000teagetd   "
    "\000tecaget   \000tecagetd  \000tecget    \000tecgetd   \000teget     \000"
    "tegetd    \000tget      \000tgetd     \000tnaget    \000tnagetd   \000t"
    "naput    \000tnaputd   \000tncaget   \000tncagetd  \000tncaput   \000tn"
    "caputd  \000tncget    \000tncgetd   \000tncput    \000tncputd   \000tne"
    "aget   \000tneagetd  \000tnecaget  \000tnecagetd \000tnecget   \000tnec"
    "getd  \000tneget    \000tnegetd   \000tnget     \000tngetd    \000tnput"
    "     \000tnputd    \000tput      \000tputd     \000wdc       \000wdc.cl"
    "ear \000wdc.flush \000wic       \000xor       \000xori      \000";

  O << "\t";

  // Emit the opcode for the instruction.
  unsigned Bits = OpInfo[MI->getOpcode()];
  assert(Bits != 0 && "Cannot print this instruction.");
  O << AsmStrs+(Bits & 4095)-1;


  // Fragment 0 encoded into 2 bits for 4 unique commands.
  switch ((Bits >> 30) & 3) {
  default:   // unreachable.
  case 0:
    // DBG_VALUE, BUNDLE, CAS32, DMEMBAR, IDMEMBAR, IMEMBAR, LAA32, LAD32, LA...
    return;
    break;
  case 1:
    // ADD, ADDC, ADDI, ADDIC, ADDIK, ADDIK32, ADDIKC, ADDK, ADDKC, ADJCALLST...
    printOperand(MI, 0, O); 
    break;
  case 2:
    // ADJCALLSTACKUP
    printUnsignedImm(MI, 0, O); 
    return;
    break;
  case 3:
    // TAPUT, TCAPUT, TCPUT, TNAPUT, TNCAPUT, TNCPUT, TNPUT, TPUT
    printFSLImm(MI, 0, O); 
    return;
    break;
  }


  // Fragment 1 encoded into 1 bits for 2 unique commands.
  if ((Bits >> 29) & 1) {
    // ADJCALLSTACKDOWN, BR, BRA, BRAD, BRAI, BRAID, BRD, BRI, BRID, IMM, TAP...
    return;
  } else {
    // ADD, ADDC, ADDI, ADDIC, ADDIK, ADDIK32, ADDIKC, ADDK, ADDKC, AGET, AGE...
    O << ", "; 
  }


  // Fragment 2 encoded into 2 bits for 4 unique commands.
  switch ((Bits >> 27) & 3) {
  default:   // unreachable.
  case 0:
    // ADD, ADDC, ADDI, ADDIC, ADDIK, ADDIK32, ADDIKC, ADDK, ADDKC, AGETD, AN...
    printOperand(MI, 1, O); 
    break;
  case 1:
    // AGET, APUT, CAGET, CAPUT, CGET, CPUT, EAGET, ECAGET, ECGET, EGET, GET,...
    printFSLImm(MI, 1, O); 
    return;
    break;
  case 2:
    // FRSUB, IDIV, IDIVU, RSUB, RSUBC, RSUBI, RSUBIC, RSUBIK, RSUBIKC, RSUBK...
    printOperand(MI, 2, O); 
    O << ", "; 
    printOperand(MI, 1, O); 
    return;
    break;
  case 3:
    // LBU, LBUI, LBUR, LHU, LHUI, LHUR, LW, LWF, LWFI, LWI, LWR, LWX, SB, SB...
    printMemOperand(MI, 1, O); 
    return;
    break;
  }


  // Fragment 3 encoded into 1 bits for 2 unique commands.
  if ((Bits >> 26) & 1) {
    // AGETD, APUTD, BEQ, BEQD, BEQI, BEQID, BGE, BGED, BGEI, BGEID, BGT, BGT...
    return;
  } else {
    // ADD, ADDC, ADDI, ADDIC, ADDIK, ADDIK32, ADDIKC, ADDK, ADDKC, AND, ANDI...
    O << ", "; 
  }


  // Fragment 4 encoded into 1 bits for 2 unique commands.
  if ((Bits >> 25) & 1) {
    // ANDI, ANDNI, ORI, ORI32, XORI
    printUnsignedImm(MI, 2, O); 
    return;
  } else {
    // ADD, ADDC, ADDI, ADDIC, ADDIK, ADDIK32, ADDIKC, ADDK, ADDKC, AND, ANDN...
    printOperand(MI, 2, O); 
    return;
  }

}


/// getRegisterName - This method is automatically generated by tblgen
/// from the register set description.  This returns the assembler name
/// for the specified register.
const char *MBlazeInstPrinter::getRegisterName(unsigned RegNo) {
  assert(RegNo && RegNo < 59 && "Invalid register number!");

  static const unsigned RegAsmOffset[] = {
    0, 8, 11, 14, 17, 20, 23, 26, 29, 32, 35, 38, 42, 46,
    50, 54, 58, 62, 66, 70, 74, 78, 82, 86, 90, 94, 98, 102,
    106, 110, 114, 118, 122, 126, 131, 136, 141, 146, 151, 156, 160, 165,
    171, 177, 183, 189, 195, 201, 207, 213, 219, 225, 232, 239, 246, 253,
    260, 266, 0
  };

  const char *AsmStrs =
    "rmsr[c]\000r0\000r1\000r2\000r3\000r4\000r5\000r6\000r7\000r8\000r9\000"
    "r10\000r11\000r12\000r13\000r14\000r15\000r16\000r17\000r18\000r19\000r"
    "20\000r21\000r22\000r23\000r24\000r25\000r26\000r27\000r28\000r29\000r3"
    "0\000r31\000rbtr\000rear\000redr\000resr\000rfsr\000rmsr\000rpc\000rpid"
    "\000rpvr0\000rpvr1\000rpvr2\000rpvr3\000rpvr4\000rpvr5\000rpvr6\000rpvr"
    "7\000rpvr8\000rpvr9\000rpvr10\000rpvr11\000rtlbhi\000rtlblo\000rtlbsx\000"
    "rtlbx\000rzpr\000";
  assert (*(AsmStrs+RegAsmOffset[RegNo-1]) &&
          "Invalid alt name index for register!");
  return AsmStrs+RegAsmOffset[RegNo-1];
}


#ifdef GET_INSTRUCTION_NAME
#undef GET_INSTRUCTION_NAME

/// getInstructionName: This method is automatically generated by tblgen
/// from the instruction set description.  This returns the enum name of the
/// specified instruction.
const char *MBlazeInstPrinter::getInstructionName(unsigned Opcode) {
  assert(Opcode < 272 && "Invalid instruction number!");

  static const unsigned InstAsmOffset[] = {
    0, 4, 14, 27, 36, 45, 50, 65, 79, 92, 106, 123, 133, 146, 
    151, 158, 162, 167, 172, 178, 184, 192, 199, 204, 210, 227, 242, 247, 
    253, 257, 262, 267, 273, 278, 284, 288, 293, 298, 304, 308, 313, 318, 
    324, 328, 333, 338, 344, 348, 353, 358, 364, 368, 373, 378, 384, 388, 
    393, 398, 404, 407, 411, 416, 421, 427, 433, 440, 444, 448, 453, 457, 
    462, 467, 473, 481, 486, 492, 497, 503, 508, 514, 520, 527, 533, 540, 
    546, 551, 557, 561, 565, 570, 575, 581, 589, 595, 602, 609, 617, 623, 
    630, 635, 641, 646, 654, 662, 670, 678, 686, 694, 702, 707, 712, 716, 
    721, 726, 732, 738, 742, 747, 752, 758, 767, 775, 779, 785, 791, 797, 
    803, 809, 815, 819, 824, 829, 833, 838, 843, 846, 850, 855, 859, 863, 
    867, 878, 882, 889, 896, 900, 904, 909, 916, 922, 927, 933, 940, 946, 
    953, 960, 968, 975, 983, 989, 996, 1002, 1009, 1016, 1024, 1032, 1041, 1048, 
    1056, 1062, 1069, 1074, 1080, 1084, 1089, 1095, 1098, 1102, 1108, 1115, 1122, 1129, 
    1133, 1138, 1143, 1149, 1155, 1162, 1169, 1177, 1183, 1190, 1195, 1200, 1205, 1210, 
    1213, 1217, 1221, 1228, 1234, 1237, 1241, 1245, 1249, 1253, 1257, 1260, 1264, 1269, 
    1273, 1279, 1283, 1287, 1297, 1308, 1315, 1323, 1331, 1337, 1344, 1350, 1357, 1364, 
    1372, 1379, 1387, 1393, 1400, 1406, 1413, 1420, 1428, 1436, 1445, 1452, 1460, 1466, 
    1473, 1478, 1484, 1491, 1499, 1506, 1514, 1522, 1531, 1539, 1548, 1555, 1563, 1570, 
    1578, 1586, 1595, 1604, 1614, 1622, 1631, 1638, 1646, 1652, 1659, 1665, 1672, 1677, 
    1683, 1687, 1692, 1697, 1701, 1705, 0
  };

  const char *Strs =
    "PHI\000INLINEASM\000PROLOG_LABEL\000EH_LABEL\000GC_LABEL\000KILL\000EXT"
    "RACT_SUBREG\000INSERT_SUBREG\000IMPLICIT_DEF\000SUBREG_TO_REG\000COPY_T"
    "O_REGCLASS\000DBG_VALUE\000REG_SEQUENCE\000COPY\000BUNDLE\000ADD\000ADD"
    "C\000ADDI\000ADDIC\000ADDIK\000ADDIK32\000ADDIKC\000ADDK\000ADDKC\000AD"
    "JCALLSTACKDOWN\000ADJCALLSTACKUP\000AGET\000AGETD\000AND\000ANDI\000AND"
    "N\000ANDNI\000APUT\000APUTD\000BEQ\000BEQD\000BEQI\000BEQID\000BGE\000B"
    "GED\000BGEI\000BGEID\000BGT\000BGTD\000BGTI\000BGTID\000BLE\000BLED\000"
    "BLEI\000BLEID\000BLT\000BLTD\000BLTI\000BLTID\000BNE\000BNED\000BNEI\000"
    "BNEID\000BR\000BRA\000BRAD\000BRAI\000BRAID\000BRALD\000BRALID\000BRD\000"
    "BRI\000BRID\000BRK\000BRKI\000BRLD\000BRLID\000BRLID32\000BSLL\000BSLLI"
    "\000BSRA\000BSRAI\000BSRL\000BSRLI\000CAGET\000CAGETD\000CAPUT\000CAPUT"
    "D\000CAS32\000CGET\000CGETD\000CLZ\000CMP\000CMPU\000CPUT\000CPUTD\000D"
    "MEMBAR\000EAGET\000EAGETD\000ECAGET\000ECAGETD\000ECGET\000ECGETD\000EG"
    "ET\000EGETD\000FADD\000FCMP_EQ\000FCMP_GE\000FCMP_GT\000FCMP_LE\000FCMP"
    "_LT\000FCMP_NE\000FCMP_UN\000FDIV\000FINT\000FLT\000FMUL\000FORI\000FRS"
    "UB\000FSQRT\000GET\000GETD\000IDIV\000IDIVU\000IDMEMBAR\000IMEMBAR\000I"
    "MM\000LAA32\000LAD32\000LAN32\000LAO32\000LAS32\000LAX32\000LBU\000LBUI"
    "\000LBUR\000LHU\000LHUI\000LHUR\000LW\000LWF\000LWFI\000LWI\000LWR\000L"
    "WX\000MEMBARRIER\000MFS\000MSRCLR\000MSRSET\000MTS\000MUL\000MULH\000MU"
    "LHSU\000MULHU\000MULI\000NAGET\000NAGETD\000NAPUT\000NAPUTD\000NCAGET\000"
    "NCAGETD\000NCAPUT\000NCAPUTD\000NCGET\000NCGETD\000NCPUT\000NCPUTD\000N"
    "EAGET\000NEAGETD\000NECAGET\000NECAGETD\000NECGET\000NECGETD\000NEGET\000"
    "NEGETD\000NGET\000NGETD\000NOP\000NPUT\000NPUTD\000OR\000ORI\000ORI32\000"
    "PCMPBF\000PCMPEQ\000PCMPNE\000PUT\000PUTD\000RSUB\000RSUBC\000RSUBI\000"
    "RSUBIC\000RSUBIK\000RSUBIKC\000RSUBK\000RSUBKC\000RTBD\000RTED\000RTID\000"
    "RTSD\000SB\000SBI\000SBR\000SEXT16\000SEXT8\000SH\000SHI\000SHR\000SRA\000"
    "SRC\000SRL\000SW\000SWF\000SWFI\000SWI\000SWP32\000SWR\000SWX\000Select"
    "_CC\000Select_FCC\000ShiftL\000ShiftRA\000ShiftRL\000TAGET\000TAGETD\000"
    "TAPUT\000TAPUTD\000TCAGET\000TCAGETD\000TCAPUT\000TCAPUTD\000TCGET\000T"
    "CGETD\000TCPUT\000TCPUTD\000TEAGET\000TEAGETD\000TECAGET\000TECAGETD\000"
    "TECGET\000TECGETD\000TEGET\000TEGETD\000TGET\000TGETD\000TNAGET\000TNAG"
    "ETD\000TNAPUT\000TNAPUTD\000TNCAGET\000TNCAGETD\000TNCAPUT\000TNCAPUTD\000"
    "TNCGET\000TNCGETD\000TNCPUT\000TNCPUTD\000TNEAGET\000TNEAGETD\000TNECAG"
    "ET\000TNECAGETD\000TNECGET\000TNECGETD\000TNEGET\000TNEGETD\000TNGET\000"
    "TNGETD\000TNPUT\000TNPUTD\000TPUT\000TPUTD\000WDC\000WDCC\000WDCF\000WI"
    "C\000XOR\000XORI\000";
  return Strs+InstAsmOffset[Opcode];
}

#endif

#ifdef PRINT_ALIAS_INSTR
#undef PRINT_ALIAS_INSTR

namespace { // Register classes
  enum RegClass {
    RC_GPR,
    RC_SPR,
    RC_CRC
  };
} // end anonymous namespace

static bool regIsInRegisterClass(unsigned RegClass, unsigned Reg) {
  switch (RegClass) {
  default: break;
  case RC_GPR:
    switch (Reg) {
    default: break;
    case MBlaze::R0:
    case MBlaze::R1:
    case MBlaze::R2:
    case MBlaze::R3:
    case MBlaze::R4:
    case MBlaze::R5:
    case MBlaze::R6:
    case MBlaze::R7:
    case MBlaze::R8:
    case MBlaze::R9:
    case MBlaze::R10:
    case MBlaze::R11:
    case MBlaze::R12:
    case MBlaze::R13:
    case MBlaze::R14:
    case MBlaze::R15:
    case MBlaze::R16:
    case MBlaze::R17:
    case MBlaze::R18:
    case MBlaze::R19:
    case MBlaze::R20:
    case MBlaze::R21:
    case MBlaze::R22:
    case MBlaze::R23:
    case MBlaze::R24:
    case MBlaze::R25:
    case MBlaze::R26:
    case MBlaze::R27:
    case MBlaze::R28:
    case MBlaze::R29:
    case MBlaze::R30:
    case MBlaze::R31:
      return true;
    }
    break;
  case RC_SPR:
    switch (Reg) {
    default: break;
    case MBlaze::RPC:
    case MBlaze::RMSR:
    case MBlaze::REAR:
    case MBlaze::RESR:
    case MBlaze::RFSR:
    case MBlaze::RBTR:
    case MBlaze::REDR:
    case MBlaze::RPID:
    case MBlaze::RZPR:
    case MBlaze::RTLBX:
    case MBlaze::RTLBLO:
    case MBlaze::RTLBHI:
    case MBlaze::RPVR0:
    case MBlaze::RPVR1:
    case MBlaze::RPVR2:
    case MBlaze::RPVR3:
    case MBlaze::RPVR4:
    case MBlaze::RPVR5:
    case MBlaze::RPVR6:
    case MBlaze::RPVR7:
    case MBlaze::RPVR8:
    case MBlaze::RPVR9:
    case MBlaze::RPVR10:
    case MBlaze::RPVR11:
      return true;
    }
    break;
  case RC_CRC:
    if (Reg == MBlaze::CARRY)
      return true;
    break;
  }

  return false;
}

bool MBlazeInstPrinter::printAliasInstr(const MCInst *MI, raw_ostream &OS) {
  return false;
}

#endif // PRINT_ALIAS_INSTR
