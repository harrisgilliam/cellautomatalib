//===- TableGen'erated file -------------------------------------*- C++ -*-===//
//
// Assembly Writer Source Fragment
//
// Automatically generated file, do not edit!
//
//===----------------------------------------------------------------------===//

/// printInstruction - This method is automatically generated by tablegen
/// from the instruction set description.
void SparcAsmPrinter::printInstruction(const MachineInstr *MI, raw_ostream &O) {
  static const unsigned OpInfo[] = {
    0U,	// PHI
    0U,	// INLINEASM
    0U,	// PROLOG_LABEL
    0U,	// EH_LABEL
    0U,	// GC_LABEL
    0U,	// KILL
    0U,	// EXTRACT_SUBREG
    0U,	// INSERT_SUBREG
    0U,	// IMPLICIT_DEF
    0U,	// SUBREG_TO_REG
    0U,	// COPY_TO_REGCLASS
    1U,	// DBG_VALUE
    0U,	// REG_SEQUENCE
    0U,	// COPY
    11U,	// BUNDLE
    268435474U,	// ADDCCri
    268435474U,	// ADDCCrr
    268435481U,	// ADDXri
    268435481U,	// ADDXrr
    268435487U,	// ADDri
    268435487U,	// ADDrr
    570425380U,	// ADJCALLSTACKDOWN
    570425399U,	// ADJCALLSTACKUP
    268435528U,	// ANDNri
    268435528U,	// ANDNrr
    268435534U,	// ANDri
    268435534U,	// ANDrr
    570425427U,	// BA
    805306455U,	// BCOND
    570425433U,	// CALL
    335544415U,	// FABSD
    335544422U,	// FABSS
    268435565U,	// FADDD
    268435572U,	// FADDS
    805306491U,	// FBCOND
    637534334U,	// FCMPD
    637534341U,	// FCMPS
    268435596U,	// FDIVD
    268435603U,	// FDIVS
    335544474U,	// FDTOI
    335544481U,	// FDTOS
    335544488U,	// FITOD
    335544495U,	// FITOS
    182U,	// FLUSHW
    335544509U,	// FMOVD
    1207959748U,	// FMOVD_FCC
    1241514180U,	// FMOVD_ICC
    335544522U,	// FMOVS
    1207959761U,	// FMOVS_FCC
    1241514193U,	// FMOVS_ICC
    268435671U,	// FMULD
    268435678U,	// FMULS
    335544549U,	// FNEGD
    335544556U,	// FNEGS
    268435699U,	// FSMULD
    335544571U,	// FSQRTD
    335544579U,	// FSQRTS
    335544587U,	// FSTOD
    335544594U,	// FSTOI
    268435737U,	// FSUBD
    268435744U,	// FSUBS
    335544615U,	// FpABSD
    335544624U,	// FpMOVD
    335544633U,	// FpNEGD
    1342177602U,	// GETPCX
    1610612825U,	// JMPLri
    1610612825U,	// JMPLrr
    1879048515U,	// LDDFri
    1879048515U,	// LDDFrr
    1879048521U,	// LDFri
    1879048521U,	// LDFrr
    1879048526U,	// LDSBri
    1879048526U,	// LDSBrr
    1879048533U,	// LDSHri
    1879048533U,	// LDSHrr
    1879048540U,	// LDUBri
    1879048540U,	// LDUBrr
    1879048547U,	// LDUHri
    1879048547U,	// LDUHrr
    1879048521U,	// LDri
    1879048521U,	// LDrr
    2147483679U,	// LEA_ADDri
    1207959914U,	// MOVFCCri
    1207959914U,	// MOVFCCrr
    1241514346U,	// MOVICCri
    1241514346U,	// MOVICCrr
    366U,	// NOP
    268435826U,	// ORNri
    268435826U,	// ORNrr
    268435831U,	// ORri
    268435831U,	// ORrr
    335544699U,	// POPCrr
    570425729U,	// RDY
    268435849U,	// RESTOREri
    268435849U,	// RESTORErr
    570425746U,	// RET
    570425755U,	// RETL
    268435876U,	// SAVEri
    268435876U,	// SAVErr
    268435882U,	// SDIVri
    268435882U,	// SDIVrr
    432U,	// SELECT_CC_DFP_FCC
    460U,	// SELECT_CC_DFP_ICC
    488U,	// SELECT_CC_FP_FCC
    515U,	// SELECT_CC_FP_ICC
    542U,	// SELECT_CC_Int_FCC
    570U,	// SELECT_CC_Int_ICC
    335544918U,	// SETHIi
    268436061U,	// SLLri
    268436061U,	// SLLrr
    268436066U,	// SMULri
    268436066U,	// SMULrr
    268436072U,	// SRAri
    268436072U,	// SRArr
    268436077U,	// SRLri
    268436077U,	// SRLrr
    2415919730U,	// STBri
    2415919730U,	// STBrr
    2415919735U,	// STDFri
    2415919740U,	// STDFrr
    2415919746U,	// STFri
    2415919746U,	// STFrr
    2415919750U,	// STHri
    2415919750U,	// STHrr
    2415919746U,	// STri
    2415919746U,	// STrr
    268436107U,	// SUBCCri
    268436107U,	// SUBCCrr
    268436114U,	// SUBXCCrr
    268436122U,	// SUBXri
    268436122U,	// SUBXrr
    268436128U,	// SUBri
    268436128U,	// SUBrr
    677U,	// TA3
    268436138U,	// UDIVri
    268436138U,	// UDIVrr
    268436144U,	// UMULri
    268436144U,	// UMULrr
    570426038U,	// UNIMP
    654312125U,	// WRYri
    654312125U,	// WRYrr
    268436161U,	// XNORri
    268436161U,	// XNORrr
    268436167U,	// XORri
    268436167U,	// XORrr
    0U
  };

  const char *AsmStrs = 
    "DBG_VALUE\000BUNDLE\000addcc \000addx \000add \000!ADJCALLSTACKDOWN \000"
    "!ADJCALLSTACKUP \000andn \000and \000ba \000b\000call \000fabsd \000fab"
    "ss \000faddd \000fadds \000fb\000fcmpd \000fcmps \000fdivd \000fdivs \000"
    "fdtoi \000fdtos \000fitod \000fitos \000flushw\000fmovd \000fmovd\000fm"
    "ovs \000fmovs\000fmuld \000fmuls \000fnegd \000fnegs \000fsmuld \000fsq"
    "rtd \000fsqrts \000fstod \000fstoi \000fsubd \000fsubs \000!FpABSD \000"
    "!FpMOVD \000!FpNEGD \000\000ldd [\000ld [\000ldsb [\000ldsh [\000ldub ["
    "\000lduh [\000mov\000nop\000orn \000or \000popc \000rd %y, \000restore "
    "\000jmp %i7+\000jmp %o7+\000save \000sdiv \000; SELECT_CC_DFP_FCC PSEUD"
    "O!\000; SELECT_CC_DFP_ICC PSEUDO!\000; SELECT_CC_FP_FCC PSEUDO!\000; SE"
    "LECT_CC_FP_ICC PSEUDO!\000; SELECT_CC_Int_FCC PSEUDO!\000; SELECT_CC_In"
    "t_ICC PSEUDO!\000sethi \000sll \000smul \000sra \000srl \000stb \000std"
    " \000std  \000st \000sth \000subcc \000subxcc \000subx \000sub \000ta 3"
    "\000udiv \000umul \000unimp \000wr \000xnor \000xor \000";

  O << "\t";

  // Emit the opcode for the instruction.
  unsigned Bits = OpInfo[MI->getOpcode()];
  assert(Bits != 0 && "Cannot print this instruction.");
  O << AsmStrs+(Bits & 1023)-1;


  // Fragment 0 encoded into 4 bits for 10 unique commands.
  switch ((Bits >> 28) & 15) {
  default:   // unreachable.
  case 0:
    // DBG_VALUE, BUNDLE, FLUSHW, NOP, SELECT_CC_DFP_FCC, SELECT_CC_DFP_ICC, ...
    return;
    break;
  case 1:
    // ADDCCri, ADDCCrr, ADDXri, ADDXrr, ADDri, ADDrr, ANDNri, ANDNrr, ANDri,...
    printOperand(MI, 1, O); 
    O << ", "; 
    break;
  case 2:
    // ADJCALLSTACKDOWN, ADJCALLSTACKUP, BA, CALL, FCMPD, FCMPS, RDY, RET, RE...
    printOperand(MI, 0, O); 
    break;
  case 3:
    // BCOND, FBCOND
    printCCOperand(MI, 1, O); 
    O << ' '; 
    printOperand(MI, 0, O); 
    return;
    break;
  case 4:
    // FMOVD_FCC, FMOVD_ICC, FMOVS_FCC, FMOVS_ICC, MOVFCCri, MOVFCCrr, MOVICC...
    printCCOperand(MI, 3, O); 
    break;
  case 5:
    // GETPCX
    printGetPCX(MI, 0, O); 
    return;
    break;
  case 6:
    // JMPLri, JMPLrr
    printMemOperand(MI, 0, O); 
    return;
    break;
  case 7:
    // LDDFri, LDDFrr, LDFri, LDFrr, LDSBri, LDSBrr, LDSHri, LDSHrr, LDUBri, ...
    printMemOperand(MI, 1, O); 
    O << "], "; 
    printOperand(MI, 0, O); 
    return;
    break;
  case 8:
    // LEA_ADDri
    printMemOperand(MI, 1, O, "arith"); 
    O << ", "; 
    printOperand(MI, 0, O); 
    return;
    break;
  case 9:
    // STBri, STBrr, STDFri, STDFrr, STFri, STFrr, STHri, STHrr, STri, STrr
    printOperand(MI, 2, O); 
    O << ", ["; 
    printMemOperand(MI, 0, O); 
    O << ']'; 
    return;
    break;
  }


  // Fragment 1 encoded into 3 bits for 6 unique commands.
  switch ((Bits >> 25) & 7) {
  default:   // unreachable.
  case 0:
    // ADDCCri, ADDCCrr, ADDXri, ADDXrr, ADDri, ADDrr, ANDNri, ANDNrr, ANDri,...
    printOperand(MI, 2, O); 
    O << ", "; 
    printOperand(MI, 0, O); 
    return;
    break;
  case 1:
    // ADJCALLSTACKDOWN, ADJCALLSTACKUP, BA, CALL, RDY, RET, RETL, UNIMP
    return;
    break;
  case 2:
    // FABSD, FABSS, FDTOI, FDTOS, FITOD, FITOS, FMOVD, FMOVS, FNEGD, FNEGS, ...
    printOperand(MI, 0, O); 
    return;
    break;
  case 3:
    // FCMPD, FCMPS, WRYri, WRYrr
    O << ", "; 
    printOperand(MI, 1, O); 
    break;
  case 4:
    // FMOVD_FCC, FMOVS_FCC, MOVFCCri, MOVFCCrr
    O << " %fcc0, "; 
    printOperand(MI, 2, O); 
    O << ", "; 
    printOperand(MI, 0, O); 
    return;
    break;
  case 5:
    // FMOVD_ICC, FMOVS_ICC, MOVICCri, MOVICCrr
    O << " %icc, "; 
    printOperand(MI, 2, O); 
    O << ", "; 
    printOperand(MI, 0, O); 
    return;
    break;
  }


  // Fragment 2 encoded into 1 bits for 2 unique commands.
  if ((Bits >> 24) & 1) {
    // WRYri, WRYrr
    O << ", %y"; 
    return;
  } else {
    // FCMPD, FCMPS
    O << "\n\tnop"; 
    return;
  }

}


/// getRegisterName - This method is automatically generated by tblgen
/// from the register set description.  This returns the assembler name
/// for the specified register.
const char *SparcAsmPrinter::getRegisterName(unsigned RegNo) {
  assert(RegNo && RegNo < 84 && "Invalid register number!");

  static const unsigned RegAsmOffset[] = {
    0, 3, 6, 9, 12, 15, 19, 23, 27, 31, 35, 39, 43, 47,
    51, 55, 59, 62, 3, 65, 6, 68, 9, 71, 12, 74, 15, 77,
    19, 81, 23, 85, 27, 89, 31, 93, 35, 97, 39, 101, 43, 105,
    47, 109, 51, 113, 55, 117, 121, 125, 128, 131, 134, 137, 140, 143,
    146, 149, 152, 155, 158, 161, 164, 167, 170, 173, 177, 180, 183, 186,
    189, 192, 195, 198, 201, 204, 207, 210, 213, 216, 219, 222, 225, 0
  };

  const char *AsmStrs =
    "F0\000F2\000F4\000F6\000F8\000F10\000F12\000F14\000F16\000F18\000F20\000"
    "F22\000F24\000F26\000F28\000F30\000F0\000F1\000F3\000F5\000F7\000F9\000"
    "F11\000F13\000F15\000F17\000F19\000F21\000F23\000F25\000F27\000F29\000F"
    "31\000FCC\000G0\000G1\000G2\000G3\000G4\000G5\000G6\000G7\000I0\000I1\000"
    "I2\000I3\000I4\000I5\000FP\000I7\000ICC\000L0\000L1\000L2\000L3\000L4\000"
    "L5\000L6\000L7\000O0\000O1\000O2\000O3\000O4\000O5\000SP\000O7\000Y\000";
  assert (*(AsmStrs+RegAsmOffset[RegNo-1]) &&
          "Invalid alt name index for register!");
  return AsmStrs+RegAsmOffset[RegNo-1];
}


#ifdef GET_INSTRUCTION_NAME
#undef GET_INSTRUCTION_NAME

/// getInstructionName: This method is automatically generated by tblgen
/// from the instruction set description.  This returns the enum name of the
/// specified instruction.
const char *SparcAsmPrinter::getInstructionName(unsigned Opcode) {
  assert(Opcode < 145 && "Invalid instruction number!");

  static const unsigned InstAsmOffset[] = {
    0, 4, 14, 27, 36, 45, 50, 65, 79, 92, 106, 123, 133, 146, 
    151, 158, 166, 174, 181, 188, 194, 200, 217, 232, 239, 246, 252, 258, 
    261, 267, 272, 278, 284, 290, 296, 303, 309, 315, 321, 327, 333, 339, 
    345, 351, 358, 364, 374, 384, 390, 400, 410, 416, 422, 428, 434, 441, 
    448, 455, 461, 467, 473, 479, 486, 493, 500, 507, 514, 521, 528, 535, 
    541, 547, 554, 561, 568, 575, 582, 589, 596, 603, 608, 613, 623, 632, 
    641, 650, 659, 663, 669, 675, 680, 685, 692, 696, 706, 716, 720, 725, 
    732, 739, 746, 753, 771, 789, 806, 823, 841, 859, 866, 872, 878, 885, 
    892, 898, 904, 910, 916, 922, 928, 935, 942, 948, 954, 960, 966, 971, 
    976, 984, 992, 1001, 1008, 1015, 1021, 1027, 1031, 1038, 1045, 1052, 1059, 1065, 
    1071, 1077, 1084, 1091, 1097, 0
  };

  const char *Strs =
    "PHI\000INLINEASM\000PROLOG_LABEL\000EH_LABEL\000GC_LABEL\000KILL\000EXT"
    "RACT_SUBREG\000INSERT_SUBREG\000IMPLICIT_DEF\000SUBREG_TO_REG\000COPY_T"
    "O_REGCLASS\000DBG_VALUE\000REG_SEQUENCE\000COPY\000BUNDLE\000ADDCCri\000"
    "ADDCCrr\000ADDXri\000ADDXrr\000ADDri\000ADDrr\000ADJCALLSTACKDOWN\000AD"
    "JCALLSTACKUP\000ANDNri\000ANDNrr\000ANDri\000ANDrr\000BA\000BCOND\000CA"
    "LL\000FABSD\000FABSS\000FADDD\000FADDS\000FBCOND\000FCMPD\000FCMPS\000F"
    "DIVD\000FDIVS\000FDTOI\000FDTOS\000FITOD\000FITOS\000FLUSHW\000FMOVD\000"
    "FMOVD_FCC\000FMOVD_ICC\000FMOVS\000FMOVS_FCC\000FMOVS_ICC\000FMULD\000F"
    "MULS\000FNEGD\000FNEGS\000FSMULD\000FSQRTD\000FSQRTS\000FSTOD\000FSTOI\000"
    "FSUBD\000FSUBS\000FpABSD\000FpMOVD\000FpNEGD\000GETPCX\000JMPLri\000JMP"
    "Lrr\000LDDFri\000LDDFrr\000LDFri\000LDFrr\000LDSBri\000LDSBrr\000LDSHri"
    "\000LDSHrr\000LDUBri\000LDUBrr\000LDUHri\000LDUHrr\000LDri\000LDrr\000L"
    "EA_ADDri\000MOVFCCri\000MOVFCCrr\000MOVICCri\000MOVICCrr\000NOP\000ORNr"
    "i\000ORNrr\000ORri\000ORrr\000POPCrr\000RDY\000RESTOREri\000RESTORErr\000"
    "RET\000RETL\000SAVEri\000SAVErr\000SDIVri\000SDIVrr\000SELECT_CC_DFP_FC"
    "C\000SELECT_CC_DFP_ICC\000SELECT_CC_FP_FCC\000SELECT_CC_FP_ICC\000SELEC"
    "T_CC_Int_FCC\000SELECT_CC_Int_ICC\000SETHIi\000SLLri\000SLLrr\000SMULri"
    "\000SMULrr\000SRAri\000SRArr\000SRLri\000SRLrr\000STBri\000STBrr\000STD"
    "Fri\000STDFrr\000STFri\000STFrr\000STHri\000STHrr\000STri\000STrr\000SU"
    "BCCri\000SUBCCrr\000SUBXCCrr\000SUBXri\000SUBXrr\000SUBri\000SUBrr\000T"
    "A3\000UDIVri\000UDIVrr\000UMULri\000UMULrr\000UNIMP\000WRYri\000WRYrr\000"
    "XNORri\000XNORrr\000XORri\000XORrr\000";
  return Strs+InstAsmOffset[Opcode];
}

#endif
